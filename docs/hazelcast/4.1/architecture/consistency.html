<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Hazelcast Documentation</title>
    <link rel="canonical" href="https://JakeSCahill.github.io/hazelcast/4.1/architecture/consistency.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-M267KFN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-M267KFN')</script>
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://JakeSCahill.github.io">Hazelcast Documentation</a>
        <div class="navbar-item">
          <input id="search-input" type="text" placeholder="Search docs">
        </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Hazelcast IMDG</a>
            <a class="navbar-item" href="#">Hazelcast Jet</a>
            <a class="navbar-item" href="#">Hazelcast Cloud</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Use cases</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Demos</a>
            <a class="navbar-item" href="#">GitHub</a>
            <a class="navbar-item" href="#">Community</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="hazelcast" data-version="4.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../hazelcast_overview.html">Hazelcast IMDG</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hazelcast_overview.html">Overview</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../get-started/getting_started.html">Get Started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started/glossary.html">Glossary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../develop/hazelcast_clients.html">Develop Solutions</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/jcache.html">JCache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/performance.html">Performance</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/serialization.html">Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/striim_cdc.html">Striim Hot Cache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/transactions.html">Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_query.html">Distributed Query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_sql.html">Distributed SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_events.html">Distributed Events</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_computing.html">Distributed Computing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../deploy/installing_upgrading.html">Deploy Clusters</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/starting_members_clients.html">Starting Members and Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/setting_up_clusters.html">Setting Up Clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/management.html">Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/simulator.html">Hazelcast Simulator</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/wan.html">WAN Replication</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/network_partitioning.html">Network Partitioning</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../migrate/migration_guides.html">Migrate</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../troubleshoot/common_exception_types.html">Troubleshooting</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../reference/faq.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/dds.html">Distributed data structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/system_properties.html">System properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/understanding_configuration.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/phone_homes.html">Phone homes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/hazelcast_plugins.html">Plugins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute/extending_hazelcast.html">Contribute</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/licenses.html">Licenses</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/revision_history.html">Documentation changes</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Hazelcast IMDG</span>
    <span class="version">4.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Hazelcast IMDG</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../hazelcast_overview.html">4.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../preface.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
  <div class="edit-this-page"><a class="git" href="https://github.com/JakeSCahill/docs-poc/edit/master/hazelcast-docs/modules/architecture/pages/consistency.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<div class="sect1">
<h2 id="_consistency_and_replication_model"><a class="anchor" href="#_consistency_and_replication_model"></a>Consistency and Replication Model</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_brief_overview_of_consistency_and_replication_in_distributed_systems"><a class="anchor" href="#_a_brief_overview_of_consistency_and_replication_in_distributed_systems"></a>A Brief Overview of Consistency and Replication in Distributed Systems</h3>
<div class="paragraph">
<p>Partitioning and replication are the two common techniques used together in
distributed databases to achieve scalable, available and transparent data distribution.
The data space is divided into partitions, each of which contains
a distinct portion of the overall data set. For these partitions, multiple copies called replicas
are created. Partition replicas are distributed among the cluster members.
Each member is assigned to at most a single replica for a partition.
In this setting, different replication techniques can be used to access the data and
keep the replicas in sync on updates. The technique being used directly affects
the guarantees and properties a distributed data store provides, due to
the CAP (<strong>C</strong>onsistency, <strong>A</strong>vailability and <strong>P</strong>artition Tolerance) principle.</p>
</div>
<div class="paragraph">
<p>One aspect of replication techniques is about where a replicated data set is
accessed and updated. For instance, primary-copy systems first elect
a replica, which can be called as primary, master, etc., and use that
replica to access the data. Changes in the data on the primary replica are
propagated to other replicas. This approach has different namings, such as
<em>primary-copy</em>, <em>single-master</em>, <em>passive replication</em>. The primary-copy technique is
a powerful model as it prevents conflicts, deadlocks among the replicas.
However, primary replicas can become bottlenecks.
On the other hand, we can have a different technique by eliminating
the primary-copy and treating each replica as equal. These systems can
achieve a higher level of availability as a data entry can be accessed and
updated using any replica. However, it can become more difficult to keep
the replicas in sync with each other.</p>
</div>
<div class="paragraph">
<p>Replication techniques also differ in how updates are propagated among replicas.
One option is to update each replica as part of a single atomic transaction, called as
<em>eager replication</em> or <em>synchronous replication</em>. Consensus algorithms apply
this approach to achieve strong consistency on a replicated data set.
The main drawback is the amount of coordination and communication required while
running the replication algorithm. CP systems implement consensus algorithms under the hood.
Another option is the <em>lazy replication</em> technique, which is also called as
<em>asynchronous replication</em>. Lazy replication algorithms execute updates on replicas with
separate transactions. They generally work with best-effort.
By this way, the amount of coordination among the replicas are degraded and
data can be accessed in a more performant manner. Yet, it can happen that
a particular update is executed on some replicas but not on others, which causes
replicas to diverge. Such problems can be resolved with different approaches, such as
<em>read-repair</em>, <em>write-repair</em>, <em>anti-entropy</em>. Lazy replication techniques are
popular among AP systems.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hazelcasts_replication_algorithm"><a class="anchor" href="#_hazelcasts_replication_algorithm"></a>Hazelcast&#8217;s Replication Algorithm</h3>
<div class="paragraph">
<p>The discussion here generally applies to any system that maintains multiple copies of
a data set. It applies to Hazelcast as well. In the context of CAP principle, <strong>Hazelcast offers
AP and CP functionality with different data structure implementations</strong>.
Data structures exposed under <code>HazelcastInstance</code> API are all <strong>AP</strong> data structures.
Hazelcast also contains a <strong>CP</strong> subsystem, built on the Raft consensus algorithm and
accessed via <code>HazelcastInstance.getCPSubsytem()</code> which provides <strong>CP</strong> data structures and APIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The replication algorithm and consistency model explained below apply
to AP data structures only. For CP subsystem and CP data structures,
see the <a href="#cp-subsystem">CP Subsystem</a> section.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For AP data structures, Hazelcast employs the combination of primary-copy and
configurable lazy replication techniques. As briefly described in
the <a href="#data-partitioning">Data Partitioning section</a>, each data entry is mapped to
a single Hazelcast partition and put into replicas of that partition. One of
the replicas is elected as the primary replica, which is responsible for
performing operations on that partition. When you read or
write a map entry, you transparently talk to the Hazelcast member to which
primary replica of the corresponding partition is assigned.
By this way, each request hits the most up-to-date version of
a particular data entry in a stable cluster. Backup replicas stay
in standby mode until the primary replica fails.
Upon failure of the primary replica, one of the backup replicas is promoted to the primary role.</p>
</div>
<div class="paragraph">
<p>With <em>lazy replication</em>, when the primary replica receives
an update operation for a key, it executes the update locally and
propagates it to backup replicas. It marks each update with
a logical timestamp so that backups apply them in the correct order and
converge to the same state with the primary. Backup replicas can be used to
scale reads (see the <a href="#enabling-backup-reads">Enabling Backup Reads section</a>) with
no strong consistency but monotonic reads guarantee.</p>
</div>
<div class="paragraph">
<p>Hazelcast offers features such as <em>SplitBrainProtection</em>, <em>ILock</em> and <em>AtomicLong</em>.
In the journey of being a highly elastic, dynamic and easy to
use product, Hazelcast tries to provide best-effort consistency guarantees without
being a complete CP solution. Therefore, we recommend these features to be used for
efficiency purposes in general, instead of correctness. For instance, they can be used to
prevent to run a resource-extensive computation multiple times, which would not
create any correctness problem if runs more than once. See the
<a href="#best-effort-consistency">Best-Effort Consistency</a> and <a href="#split-brain-syndrome">Network Partitioning</a> sections
for more information.</p>
</div>
<div class="sect3">
<h4 id="_best_effort_consistency"><a class="anchor" href="#_best_effort_consistency"></a>Best-Effort Consistency</h4>
<div class="paragraph">
<p>Hazelcast&#8217;s replication technique enables Hazelcast clusters to offer high throughput.
However, due to temporary situations in the system, such as
network interruption, backup replicas can miss some updates and
diverge from the primary. Backup replicas can also hit
VM or long GC pauses, and fall behind the primary, which is a situation called as
<em>replication lag</em>. If a Hazelcast partition primary replica member crashes while
there is a replication lag between itself and the backups, strong consistency of the data can be lost.</p>
</div>
<div class="paragraph">
<p>Please note that CP systems can have similar problems as well.
However, in a CP system, once a replica performs
an update locally (i.e., <em>commits</em> the update), the underlying consensus algorithm guarantees
durability of the update for the rest of the execution.</p>
</div>
<div class="paragraph">
<p>On the other hand, in AP systems like Hazelcast, a replica can perform
an update locally, even if the update is not to be performed on other replicas.
This is a fair trade-off to reduce amount of coordination among replicas and
maintain high throughput &amp; high availability of the system.
These systems employ additional measurements to maintain consistency in a
best-effort manner. In this regard, Hazelcast tries to minimize the effect of
such scenarios using an active anti-entropy solution as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each Hazelcast member runs a periodic task in the background.</p>
</li>
<li>
<p>For each primary replica it is assigned, it creates a summary information and
sends it to the backups.</p>
</li>
<li>
<p>Then, each backup member compares the summary information with its own data to
see if it is up-to-date with the primary.</p>
</li>
<li>
<p>If a backup member detects a missing update, it triggers
the synchronization process with the primary.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_invocation_lifecycle"><a class="anchor" href="#_invocation_lifecycle"></a>Invocation Lifecycle</h3>
<div class="paragraph">
<p>When a write is requested with the methods, such as
<code>map.put()</code> or <code>queue.offer()</code>, a write operation is submitted to
the Hazelcast member that owns the primary replica of the specific partition.
Partition of an operation is determined based on a parameter (key of an entry or
name of the data structure, etc.) related to that operation depending on
the data structure. Target Hazelcast member is figured out by looking up
a local partition assignment/ownership table, which is updated on
each partition migration and broadcasted to all cluster eventually.</p>
</div>
<div class="paragraph">
<p>When a Hazelcast member receives a partition specific operation,
it executes the operation and propagates it to backup replica(s) with
a logical timestamp. Number of backups for each operation depends on
the data structure and its configuration. See
<a href="#operation-threading">Threading Model - Operation Threading</a> for threading details.</p>
</div>
<div class="paragraph">
<p>Two types of backup replication are available: <em>sync</em> and <em>async</em>.
Despite what their names imply, both types are still implementations of
the lazy (async) replication model. The only difference between
<em>sync</em> and <em>async</em> is that, the former makes the caller block until
backup updates are applied by backup replicas and acknowledgments are sent back to
the caller, but the latter is just fire &amp; forget. Number of sync and
async backups are defined in the data structure configurations, and you can use
a combination of sync and async backups.</p>
</div>
<div class="paragraph">
<p>When backup updates are propagated, response of the execution including
number of sync backup updates is sent to the caller and after receiving
the response, caller waits to receive the specified number of
sync backup acknowledgements for a predefined timeout.
This timeout is 5 seconds by default and defined by
the system property <code>hazelcast.operation.backup.timeout.millis</code>
(see <a href="#system-properties">System Properties appendix</a>).</p>
</div>
<div class="paragraph">
<p>A backup update can be missed because of a few reasons, such as
a stale partition table information on a backup replica member,
network interruption, or a member crash. That&#8217;s why sync backup acks require
a timeout to give up. Regardless of being a sync or async backup, if a backup update is missed,
the periodically running anti-entropy mechanism detects the inconsistency and
synchronizes backup replicas with the primary. Also the graceful shutdown procedure ensures
that all backup replicas for partitions whose primary replicas are assigned to
the shutting down member will be consistent.</p>
</div>
<div class="paragraph">
<p>In some cases, although the target member of an invocation is assumed to be
alive by the failure detector, the target may not execute the operation or
send the response back in time. Network splits, long pauses caused by
high load, GC or I/O (disk, network) can be listed as a few possible reasons.
When an invocation doesn&#8217;t receive any response from the member that owns
primary replica, then invocation fails with an <code>OperationTimeoutException</code>.
This timeout is 2 minutes by default and defined by
the system property <code>hazelcast.operation.call.timeout.millis</code>
(see <a href="#system-properties">System Properties appendix</a>).
When timeout is passed, result of the invocation will be indeterminate.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exactly_once_at_least_once_or_at_most_once_execution"><a class="anchor" href="#_exactly_once_at_least_once_or_at_most_once_execution"></a>Exactly-once, At-least-once or At-most-once Execution</h3>
<div class="paragraph">
<p>Hazelcast, as an AP product, does not provide the exactly-once guarantee.
In general, Hazelcast tends to be an at-least-once solution.</p>
</div>
<div class="paragraph">
<p>In the following failure case, exactly-once guarantee can be broken:
When the target member of a pending invocation leaves the cluster while
the invocation is waiting for a response, that invocation is re-submitted to
its new target due to the new partition table. It can be that, it has
already been executed on the leaving member and backup updates are propagated to
the backup replicas, but the response is not received by the caller.
If that happens, the operation will be executed twice.</p>
</div>
<div class="paragraph">
<p>In the following failure case, invocation state becomes indeterminate:
As explained above, when an invocation does not receive a response in time,
invocation fails with an <code>OperationTimeoutException</code>. This exception does not
say anything about outcome of the operation, that means operation may not be
executed at all, it may be executed once or twice (due to member left case explained above).</p>
</div>
</div>
<div class="sect2">
<h3 id="_indeterminateoperationstateexception"><a class="anchor" href="#_indeterminateoperationstateexception"></a>IndeterminateOperationStateException</h3>
<div class="paragraph">
<p>As described in <a href="#invocation-lifecycle">Invocation Lifecycle</a> section,
for partition-based <strong>mutating</strong> invocations, such as <code>map.put()</code>,
a caller waits with a timeout for the operation that is executed on
corresponding partition&#8217;s primary replica and backup replicas, based on
the sync backup configuration of the distributed data structure.
Hazelcast 3.9 introduces a new mechanism to detect indeterminate situations while
making such invocations. If <code>hazelcast.operation.fail.on.indeterminate.state</code> system property is
enabled, a <strong>mutating</strong> invocation throws <code>IndeterminateOperationStateException</code> when
it encounters the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The operation fails on partition primary replica member with <code>MemberLeftException</code>.
In this case, the caller may not determine the status of the operation.
It could happen that the primary replica executes the operation, but fails before
replicating it to all the required backup replicas. Even if the caller receives
backup acks from some backup replicas, it cannot decide if it has received
all required ack responses, since it does not know how many acks it should wait for.</p>
</li>
<li>
<p>There is at least one missing ack from the backup replicas for the given timeout duration.
In this case, the caller knows that the operation is executed on the primary replica,
but some backup may have missed it. It could be also a false-positive,
if the backup timeout duration is configured with a very small value.
However, Hazelcast&#8217;s active anti-entropy mechanism eventually kicks in and
resolves durability of the write on all available backup replicas as long as
the primary replica member is alive.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an invocation fails with <code>IndeterminateOperationStateException</code>,
the system does not try to rollback the changes which are executed on healthy replicas.
Effect of a failed invocation may be even observed by another caller,
if the invocation has succeeded on the primary replica.
Hence, this new behavior does not guarantee linearizability.
However, if an invocation completes without <code>IndeterminateOperationStateException</code> when
the configuration is enabled, it is guaranteed that the operation has been
executed exactly-once on the primary replica and specified number of backup replicas of the partition.</p>
</div>
<div class="paragraph">
<p>Please note that <code>IndeterminateOperationStateException</code> does not apply to
read-only operations, such as <code>map.get()</code>. If a partition primary replica member crashes before
replying to a read-only operation, the operation is retried on the new owner of the primary replica.</p>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<link rel="shortcut icon" href="http://hazelcast.com/images/favicon.png">
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/vendor/search.js" id="search-script" data-base-path="../../.." data-page-path="/hazelcast/4.1/architecture/consistency.html"></script>
<script async src="../../../_/../search-index.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
