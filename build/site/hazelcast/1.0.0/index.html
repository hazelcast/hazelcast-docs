<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hazelcast IMDG :: Hazelcast Documentation</title>
    <link rel="canonical" href="http://localhost:5000/hazelcast/1.0.0/index.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../_/css/site.css">
<link rel="stylesheet" href="../../_/css/search.css">
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="http://localhost:5000">Hazelcast Documentation</a>
        <div class="navbar-item">
          <input id="search-input" type="text" placeholder="Search docs">
        </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="hazelcast" data-version="1.0.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Hazelcast IMDG</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-text">Get Started</span>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="deploy/cluster_utilities.html">Deploy</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="deploy/license_info.html">Installation Setup and Steps</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="deploy/cluster_utilities.html">Develop</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="deploy/license_info.html">Installation Setup and Steps</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Hazelcast IMDG</span>
    <span class="version">1.0.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Hazelcast IMDG</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">1.0.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Hazelcast IMDG</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///C:/Users/Jake%20Cahill/Documents/code-playground/docs/docs/modules/ROOT/pages/index.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Hazelcast IMDG</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Version 4.1</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://hazelcast.org/" target="_blank" rel="noopener"><img src="_images/logo_dark.png" alt="Hazelcast IMDG"></a>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset1_tab-1-title"></a>Tab 1 Title</p>
</li>
<li>
<p><a id="tabset1_tab-2-title"></a>Tab 2 Title</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset1_tab-1-title">
<div class="paragraph">
<p>This is the content of the first tab.</p>
</div>
<div class="paragraph">
<p>Another paragraph in the first tab.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">$ a code block</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_tab-2-title">
<div class="paragraph">
<p>This is the content of the second tab.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Welcome to the Hazelcast IMDG (In-Memory Data Grid) Reference Manual.
This manual includes concepts, instructions and examples to guide you on
how to use Hazelcast and build Hazelcast IMDG applications.</p>
</div>
<div class="paragraph">
<p>This reference manual mostly talks about the Hazelcast member and clients
in Java language. Although, the core of Hazelcast IMDG is based on the Java
programming language, it has the following clients and programming language APIs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java</p>
</li>
<li>
<p>.NET</p>
</li>
<li>
<p>C++</p>
</li>
<li>
<p>Node.js</p>
</li>
<li>
<p>Python</p>
</li>
<li>
<p>Go</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We recommend you to learn the basics of Hazelcast IMDG using this manual first. Then,
you can always get the client related resources/links in the <a href="#hazelcast-clients">Clients chapter</a>.</p>
</div>
<div class="sect2">
<h3 id="hazelcast-imdg-editions"><a class="anchor" href="#hazelcast-imdg-editions"></a>Editions</h3>
<div class="paragraph">
<p>This Reference Manual covers all editions of Hazelcast IMDG. Throughout
this manual:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Hazelcast</strong> or <strong>Hazelcast IMDG</strong> refers to the open source edition
of Hazelcast in-memory data grid middleware. <strong>Hazelcast</strong> is also the
name of the company (Hazelcast, Inc.) providing the Hazelcast product.</p>
</li>
<li>
<p><strong class="navy">Hazelcast IMDG Pro</strong> is a commercially licensed edition of
Hazelcast IMDG which provides various cloud and Management Center plugins
in addition to Hazelcast IMDG.</p>
</li>
<li>
<p><strong class="blue">Hazelcast IMDG Enterprise</strong> is a commercially licensed edition of
Hazelcast IMDG which provides High-Density Memory Store, Hot Restart
Persistence features and Security suite in addition to Hazelcast IMDG Pro.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Pro and Enterprise editions offer all the features of the open source edition.</p>
</div>
</div>
<div class="sect2">
<h3 id="licensing"><a class="anchor" href="#licensing"></a>Licensing</h3>
<div class="paragraph">
<p>Hazelcast IMDG and Hazelcast Reference Manual are free and provided under the Apache License,
Version 2.0. Hazelcast IMDG Pro and Enterprise are commercially
licensed by Hazelcast, Inc.</p>
</div>
<div class="paragraph">
<p>For more detailed information on licensing, see the <a href="#license-questions">License Questions appendix</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="trademarks"><a class="anchor" href="#trademarks"></a>Trademarks</h3>
<div class="paragraph">
<p>Hazelcast is a registered trademark of Hazelcast, Inc. All other trademarks in this manual
are held by their respective owners.</p>
</div>
</div>
<div class="sect2">
<h3 id="customer-support"><a class="anchor" href="#customer-support"></a>Customer Support</h3>
<div class="paragraph">
<p>Support for Hazelcast is provided via <a href="https://github.com/hazelcast/hazelcast/issues" target="_blank" rel="noopener">GitHub</a>,
<a href="https://groups.google.com/forum/#!forum/hazelcast" target="_blank" rel="noopener">Mail Group</a> and <a href="http://www.stackoverflow.com" target="_blank" rel="noopener">StackOverflow</a>.</p>
</div>
<div class="paragraph">
<p>For information on the commercial support for Hazelcast IMDG and Hazelcast IMDG Enterprise, see
<a href="https://hazelcast.com/pricing/" target="_blank" rel="noopener">hazelcast.com</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_release_notes"><a class="anchor" href="#_release_notes"></a>Release Notes</h3>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/release-notes/" target="_blank" rel="noopener">Release Notes document</a> for the new
features, enhancements and fixes performed for each Hazelcast IMDG release.</p>
</div>
</div>
<div class="sect2">
<h3 id="contributing-to-hazelcast-imdg"><a class="anchor" href="#contributing-to-hazelcast-imdg"></a>Contributing</h3>
<div class="paragraph">
<p>You can contribute to the Hazelcast IMDG code, report a bug, or request an enhancement.
See the following resources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://hazelcast.atlassian.net/wiki/display/COM/Developing+with+Git" target="_blank" rel="noopener">Developing with Git</a>:
Document that explains the branch mechanism of Hazelcast and how to request changes.</p>
</li>
<li>
<p><a href="https://hazelcast.atlassian.net/wiki/display/COM/Hazelcast+Contributor+Agreement" target="_blank" rel="noopener">Hazelcast
Contributor Agreement form</a>: Form that each contributing developer needs to fill and send back
to Hazelcast.</p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast" target="_blank" rel="noopener">Hazelcast on GitHub</a>: Hazelcast repository where the
code is developed, issues and pull requests are managed.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="partners"><a class="anchor" href="#partners"></a>Partners</h3>
<div class="paragraph">
<p>Hazelcast partners with leading hardware and software technologies, system integrators, resellers
and OEMs including Amazon Web Services, Vert.x, Azul Systems, C2B2. See the
<a href="https://hazelcast.com/partners/" target="_blank" rel="noopener">Partners</a> page for the full list of and information on our partners.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>1. Quick Start</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter intends to get you started in 5 minutes. The quick start shows how to
start Hazelcast members, form a cluster, connect it with
a client application in your preferred language and monitor
the cluster using Hazelcast Management Center.</p>
</div>
<div class="paragraph">
<p>For a comprehensive overview of what Hazelcast IMDG actually is
see <a href="#what-is-hazelcast-imdg">What is Hazelcast IMDG?</a>.</p>
</div>
<div class="sect2">
<h3 id="_installing"><a class="anchor" href="#_installing"></a>1.1. Installing</h3>
<div class="paragraph">
<p>You can use the Hazelcast
<a href="https://github.com/hazelcast/hazelcast-command-line" target="_blank" rel="noopener">Command Line Interface (CLI)</a>
to install and start Hazelcast IMDG.</p>
</div>
<div class="paragraph">
<p>Assuming you have the <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> package manager, run the following commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ brew tap hazelcast/hz
$ brew install hazelcast</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently, the CLI way is meant for development purposes, not for a production usage.
For production or if you prefer other ways, take a look at <a href="#installing-hazelcast-imdg">Installing and Upgrading</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_cluster"><a class="anchor" href="#_creating_a_cluster"></a>1.2. Creating a Cluster</h3>
<div class="paragraph">
<p>Use the following command on your terminal/command line
to start a standalone Hazelcast member:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ hz start</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you have a 1-member cluster. To add one more member to the cluster,
open another terminal/command line and rerun the above command. The members
discover each other automatically and form a 2-member cluster. You should see
happening it with log output in the command line like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">Members {size:2, ver:2} [
    Member [127.0.0.1]:5701 - e40081de-056a-4ae5-8ffe-632caf8a6cf1 this
    Member [127.0.0.1]:5702 - 93e82109-16bf-4b16-9c87-f4a6d0873080
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that these members are started with the default configuration.
The location of the <code>hazelcast.xml</code> is printed on the first line of
the output of the above command.</p>
</div>
</div>
<div class="sect2">
<h3 id="_your_first_client_application"><a class="anchor" href="#_your_first_client_application"></a>1.3. Your First Client Application</h3>
<div class="paragraph">
<p>Having a running cluster as started in the above section, let&#8217;s
create a client application that connects to this cluster,
creates a map and populates it. Below, we first briefly give
how to install a client of your preference and then an example code
for each. We are assuming that the members and clients are on the
same machine for simplicity.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Installation notes: You have to have Hazelcast Java Client on the classpath.
// The simplest way of doing it is to put `hazelcast-all` JAR
// on the classpath, e.g. via Maven. See "Installation" chapter for details.

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;

public class MapSample {
    public static void main(String[] args) {
        // Start the client and connect to the cluster
        HazelcastInstance hz = HazelcastClient.newHazelcastClient();
        // Create a Distributed Map in the cluster
        IMap map = hz.getMap("my-distributed-map");
        //Standard Put and Get
        map.put("1", "John");
        map.put("2", "Mary");
        map.put("3", "Jane");
        // Shutdown the client
        hz.shutdown();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">C++</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">//Installation notes: Download the latest C++ library from
//https://hazelcast.org/imdg/clients-languages/cplusplus/
//and see https://github.com/hazelcast/hazelcast-cpp-client#13-downloading-and-installing]
//for installation instructions.

#include

using namespace hazelcast::client;
int main() {
    // Start the client and connect to the cluster
    HazelcastClient hz;
    // Create a Distributed Map in the cluster
    IMap map = hz.getMap("my-distributed-map");
    //Standard Put and Get
    map.put("1", "John");
    map.put("2", "Mary");
    map.put("3", "Jane");
    // Shutdown the client
    hz.shutdown();

    return 0;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">C#</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//Installation notes: Run the following command at the NuGet package manager console
//Install-Package Hazelcast.Net -Pre

using Hazelcast.Client;

namespace Hazelcast.Examples.Org.Website.Samples
{
    public class MapSample
    {
        public static void Run(string[] args)
        {
            // Start the client and connect to the cluster
            var hz = HazelcastClient.NewHazelcastClient();
            // Create a Distributed Map in the cluster
            var map = hz.GetMap("my-distributed-map");
            //Standard Put and Get
            map.put("1", "John");
            map.put("2", "Mary");
            map.put("3", "Jane");
            // Shutdown the client
            hz.Shutdown();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Node.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">//Installation notes: Run the following command
//npm install hazelcast-client

var Client = require('hazelcast-client').Client;
// Start the client and connect to the cluster
Client.newHazelcastClient().then(function (hz) {
    var map;
    // Create a Distributed Map in the cluster
    hz.getMap('my-distributed-map').then(function (mp) {
        map = mp;
        // Standard Put and Get
        return map.put('1', 'John');
    });
        // Shutdown the client
        hz.shutdown();
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Python</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python"># Installation notes: Run the following command
# pip install hazelcast-python-client

import hazelcast

if __name__ == "__main__":
    # Start the client and connect to the cluster
    hz = hazelcast.HazelcastClient()
    # Create a Distributed Map in the cluster
    map = hz.get_map("my-distributed-map").blocking()
    # Standard Put and Get
    map.put("1", "John")
    map.put("2", "Mary")
    map.put("3", "Jane")
    # Shutdown the client
    hz.shutdown()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Go</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go">//Installation notes: Run the following command
//go get github.com/hazelcast/hazelcast-go-client

import "github.com/hazelcast/hazelcast-go-client"

func mapSampleRun() {
	// Start the client and connect to the cluster
	hz, _ := hazelcast.NewClient()
	// Create a Distributed Map in the cluster
	mp, _ := hz.GetMap("myDistributedMap")
	//Standard Put and Get
	mp.Put("1", "John")
	mp.Put("2", "Mary")
	mp.Put("3", "Jane")
	// Shutdown the client
	hz.Shutdown()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For comprehensive information on the clients, see the following sections:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#java-client">Java client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-cpp-client">C++ client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-csharp-client">C# client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-nodejs-client">Node.js client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-python-client">Python client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-go-client">Go client</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_connecting_management_center_to_the_cluster"><a class="anchor" href="#_connecting_management_center_to_the_cluster"></a>1.4. Connecting Management Center to the Cluster</h3>
<div class="paragraph">
<p>Hazelcast Management Center helps you to monitor and manage your IMDG cluster.
After you created your cluster and client application as depicted in the above sections,
let&#8217;s connect Management Center to the cluster. Note that having client applications
is not a must to use the Management Center; you can connect it to your cluster that
does not have any clients.</p>
</div>
<div class="paragraph">
<p>Use the following command to start the Management Center:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">hz mc start</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, open your preferred web browser to <code>http://localhost:8080</code> and
select the <code>default</code> security provider to provide a username and password.
Log in to Management Center using those credentials and create a cluster connection;
the defaults should work fine. If using Docker for members, find out the Docker IP address
of cluster rather than the default of localhost.</p>
</div>
<div class="paragraph">
<p>For comprehensive information on Management Center, see its
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html" target="_blank" rel="noopener">documentation</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_whats_next"><a class="anchor" href="#_whats_next"></a>1.5. What&#8217;s Next?</h3>
<div class="paragraph">
<p>In this chapter, you have learnt starting a Hazelcast IMDG cluster,
inserting data to it via clients and monitoring
it through Management Center. Now, you may want to perform the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Form a cluster not just on your local machine: see <a href="#setting-up-clusters">Setting Up Clusters</a>.</p>
</li>
<li>
<p>Start using our distributed data structures: see <a href="#distributed-data-structures">Distributed Data Structures</a>.</p>
</li>
<li>
<p>Learn how to configure Hazelcast IMDG: see <a href="#understanding-configuration">Understanding Configuration</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can always reach out via <a href="https://slack.hazelcast.com/" target="_blank" rel="noopener">Slack</a>,
<a href="https://groups.google.com/forum/#!forum/hazelcast" target="_blank" rel="noopener">Mail Group</a> or <a href="http://www.stackoverflow.com" target="_blank" rel="noopener">StackOverflow</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hazelcast-overview"><a class="anchor" href="#hazelcast-overview"></a>2. Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter introduces Hazelcast IMDG, describes Hazelcast&#8217;s architecture along with its
partitioning mechanism, use cases and topology.</p>
</div>
<div class="sect2">
<h3 id="what-is-hazelcast-imdg"><a class="anchor" href="#what-is-hazelcast-imdg"></a>2.1. What is Hazelcast IMDG?</h3>
<div class="paragraph">
<p>Hazelcast IMDG is an open-source distributed in-memory
object store supporting a wide variety of data structures.</p>
</div>
<div class="paragraph">
<p>You can use Hazelcast IMDG to store your data in RAM, spread
and replicate it across your cluster of machines, and perform computations on it.
Replication gives you the resilience to failures of cluster members.</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG is highly scalable and available. Distributed applications can use
it for distributed caching, synchronization, clustering, processing,
pub/sub messaging, etc.</p>
</div>
<div class="paragraph">
<p>It is implemented in Java language and has clients for Java, C++, .NET, REST, Python,
Go and Node.js. Hazelcast IMDG also speaks Memcached and REST protocols. It plugs into
Hibernate and can easily be used with any existing database system.</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG makes distributed computing simple by
offering distributed implementations of many developer-friendly interfaces.
For example, the Map interface provides an In-Memory Key Value store which confers many
of the advantages of NoSQL in terms of developer friendliness and developer productivity.</p>
</div>
<div class="paragraph">
<p>Your cloud-native applications can easily use Hazelcast IMDG.
It is flexible enough to use as a data and computing platform out-of-the-box
or as a framework for your own cloud-native applications and microservices.</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG is designed to be lightweight and easy to use. Since it
is delivered as a compact library (JAR) and
has no external dependencies other than Java, it easily
plugs into your software solution and provides
distributed data structures and computing utilities.</p>
</div>
<div class="paragraph">
<p>It is designed to scale up to hundreds of members and thousands of clients.
When you add new members, they automatically discover the cluster
and linearly increase both the memory and
processing capacity. The members maintain a TCP connection between
each other and all communication is performed through
this layer. Each cluster member is configured to be the same in terms
of functionality. The oldest member (the first member created
in the cluster) automatically performs the data assignment to cluster members.
If the oldest member dies, the second oldest member takes over.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can come across with the term "master" or "master member" in some
sections of this manual. They are used for contextual clarification purposes;
please remember that they refer to the "oldest member" which is explained in
the above paragraph.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast IMDG offers simple scalability, partitioning (sharding), and re-balancing
out-of-the-box. It does not require any extra coordination processes. NoSQL and
traditional databases are difficult to scale out and manage. They require additional
processes for coordination and high availability. With Hazelcast IMDG, when you start
another process to add more capacity, data and backups are automatically and evenly balanced.</p>
</div>
<div class="paragraph">
<p><strong>Hazelcast&#8217;s Distinctive Strengths</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is open source.</p>
</li>
<li>
<p>It is only a JAR file. You do not need to install software other than Java.</p>
</li>
<li>
<p>Hazelcast IMDG stores everything in-memory (RAM). It is designed to perform fast reads
and updates.</p>
</li>
<li>
<p>Hazelcast IMDG is peer-to-peer; there is no single point of failure in a Hazelcast IMDG cluster;
each member in the cluster is configured to be functionally the same. They all store equal amounts
of data and do equal amounts of processing. You can embed Hazelcast IMDG in your
existing application or use it in client and server mode where your application is a
client to Hazelcast members.</p>
</li>
<li>
<p>When the size of your memory and compute requirements increase, new members can
be dynamically joined to the Hazelcast IMDG cluster to scale elastically.</p>
</li>
<li>
<p>Data is resilient to member failure. Data backups are distributed across the cluster.
This is a big benefit when a member in the cluster crashes as data is not lost.
Hazelcast keeps the backup of each data entry on multiple members. On a member
failure, the data is restored from the backup and the cluster continues to operate without downtime.</p>
</li>
<li>
<p>Members are always aware of each other unlike in traditional key-value caching solutions.</p>
</li>
<li>
<p>Hazelcast provides out-of-the-box distributed data structures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, Hazelcast has a vibrant open source community enabling it to be continuously developed.</p>
</div>
<div class="paragraph">
<p>Hazelcast is a fit when you need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>analytic applications requiring big data processing by partitioning the data</p>
</li>
<li>
<p>to retain frequently accessed data in the grid</p>
</li>
<li>
<p>a cache, particularly an open source JCache provider with elastic distributed
scalability</p>
</li>
<li>
<p>a primary data store for applications with utmost performance, scalability and
low-latency requirements</p>
</li>
<li>
<p>an In-Memory NoSQL Key Value Store</p>
</li>
<li>
<p>publish/subscribe communication at highest speed and scalability between applications</p>
</li>
<li>
<p>applications that need to scale elastically in distributed and cloud environments</p>
</li>
<li>
<p>a highly available distributed cache for applications</p>
</li>
<li>
<p>an alternative to Coherence and Terracotta.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="hazelcast-imdg-architecture"><a class="anchor" href="#hazelcast-imdg-architecture"></a>2.2. Architecture</h3>
<div class="paragraph">
<p>You can see the features for all Hazelcast IMDG editions in the following
architecture diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/HazelcastArchitecture.png" alt="Hazelcast Architecture">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can see small "HD" boxes for some features in the above diagram.
Those features can use High-Density (HD) Memory Store when it is available.
It means if you have Hazelcast IMDG Enterprise HD, you can use those features with HD Memory Store.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information on Hazelcast IMDG&#8217;s Architecture, see the white paper
<a href="https://hazelcast.com/resources/architects-view-hazelcast/" target="_blank" rel="noopener">An Architect&#8217;s View of Hazelcast</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="hazelcast-topology"><a class="anchor" href="#hazelcast-topology"></a>2.3. Topology</h3>
<div class="paragraph">
<p>You can deploy a Hazelcast cluster in two ways: Embedded or Client/Server.</p>
</div>
<div class="paragraph">
<p>If you have an application whose main focal point is asynchronous or high performance
computing and lots of task
executions, then Embedded deployment is the preferred way. In Embedded deployment,
members include both the application and Hazelcast data and services. The advantage
of the Embedded deployment is having a low-latency data access.</p>
</div>
<div class="paragraph">
<p>See the below illustration.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/Embedded.png" alt="Embedded Deployment">
</div>
</div>
<div class="paragraph">
<p>In the Client/Server deployment, Hazelcast data and services are centralized in one or
more server members and they are accessed by the application through clients.
You can have a cluster of server members that can be independently created and scaled.
Your clients communicate with
these members to reach to Hazelcast data and services on them.</p>
</div>
<div class="paragraph">
<p>See the below illustration.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/ClientServer.png" alt="Client/Server Deployment">
</div>
</div>
<div class="paragraph">
<p>Hazelcast provides native clients (Java, .NET and C++), Memcache and REST clients,
Python and Node.js client implementations.</p>
</div>
<div class="paragraph">
<p>Client/Server deployment has advantages including more predictable and reliable Hazelcast
performance, easier identification of problem causes and, most importantly, better scalability.
When you need to scale in this deployment type, just add more Hazelcast server members. You
can address client and server scalability concerns separately.</p>
</div>
<div class="paragraph">
<p>Note that Hazelcast <strong>member</strong> libraries are available only in Java. Therefore, embedding a
member to a business service, it is only possible with Java. Applications written in other
languages (.NET, C++, Node.js, etc.) can use Hazelcast client libraries to access the cluster.
See the <a href="#hazelcast-clients">Hazelcast Clients chapter</a> for information on the clients and other language implementations.</p>
</div>
<div class="paragraph">
<p>If you want low-latency data access, as in the Embedded deployment, and you also want the
scalability advantages of the Client/Server deployment, you can consider defining Near Caches
for your clients. This enables the frequently used data to be kept in the client&#8217;s local memory.
See the <a href="#configuring-client-near-cache">Configuring Client Near Cache section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="data-partitioning"><a class="anchor" href="#data-partitioning"></a>2.4. Data Partitioning</h3>
<div class="paragraph">
<p>The memory segments in Hazelcast IMDG are called partitions. They can contain hundreds
or thousands of data entries each, depending on the memory capacity of your system.</p>
</div>
<div class="paragraph">
<p>The partitions are distributed equally among the members of the cluster. Hazelcast
also creates backups of these partitions which are also distributed in the cluster.</p>
</div>
<div class="paragraph">
<p>By default, Hazelcast creates a single copy/replica of each partition. You can configure Hazelcast so that
each partition can have multiple replicas. One of these replicas is called "primary"
and others are called "backups". The cluster member which owns the "primary" replica of a partition
is called the "partition owner". When you read or write a particular data entry, you transparently
talk to the partition owner that contains the data entry.</p>
</div>
<div class="paragraph">
<p>By default, Hazelcast offers 271 partitions. When you start a cluster with a single member,
it owns all of 271 partitions (i.e., it keeps primary replicas for 271 partitions). The following
illustration shows the partitions in a Hazelcast cluster with single member.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/NodePartition.jpg" alt="Single Member with Partitions">
</div>
</div>
<div class="paragraph">
<p>When you start a second member on that cluster (creating a Hazelcast cluster with two members),
the partition replicas are distributed as shown in the illustration here.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Partition distributions in the below illustrations are shown for the sake of simplicity and
for descriptive purposes. Normally, the partitions are not distributed in any order, as they are
shown in these illustrations, but are distributed randomly (they do not have to be sequentially
distributed to each member). The important point here is that Hazelcast equally distributes the
partition primaries and their backup replicas among the members.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/BackupPartitions.jpg" alt="Cluster with Two Members - Backups are Created">
</div>
</div>
<div class="paragraph">
<p>In the illustration, the partition replicas with black text are primaries and the partition replicas
with blue text are backups. The first member has primary replicas of 135 partitions (black) and
each of these partitions are backed up in the second member (i.e., the second member owns the
backup replicas) (blue). At the same time, the first member also has the backup replicas of
the second member&#8217;s primary partition replicas.</p>
</div>
<div class="paragraph">
<p>As you add more members, Hazelcast moves some of the primary and backup partition replicas to
the new members one by one, making all members equal and redundant. Thanks to the consistent
hashing algorithm, only the minimum amount of partitions are moved to scale out Hazelcast. The
following is an illustration of the partition replica distributions in a Hazelcast cluster with four members.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/4NodeCluster.jpg" alt="Cluster with Four Members">
</div>
</div>
<div class="paragraph">
<p>Hazelcast distributes partitions' primary and backup replicas equally among the members of the
cluster. Backup replicas of the partitions are maintained for redundancy.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Your data can have multiple copies on partition primaries and backups, depending on your
backup count. See the <a href="#backing-up-maps">Backing Up Maps section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast also offers lite members. These members do not own any partition. Lite members are
intended for use in computationally-heavy task executions and listener registrations. Although
they do not own any partitions,
they can access partitions that are owned by other members in the cluster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#enabling-lite-members">Enabling Lite Members section</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="how-the-data-is-partitioned"><a class="anchor" href="#how-the-data-is-partitioned"></a>2.4.1. How the Data is Partitioned</h4>
<div class="paragraph">
<p>Hazelcast distributes data entries into the partitions using a hashing algorithm. Given an object
key (for example, for a map) or an object name (for example, for a topic or list):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the key or name is serialized (converted into a byte array)</p>
</li>
<li>
<p>this byte array is hashed</p>
</li>
<li>
<p>the result of the hash is mod by the number of partitions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The result of this modulo - <strong>MOD(hash result, partition count)</strong> - is the partition in which the
data will be stored, that is the <strong>partition ID</strong>. For ALL members you have in your cluster, the
partition ID for a given key is always the same.</p>
</div>
</div>
<div class="sect3">
<h4 id="partition-table"><a class="anchor" href="#partition-table"></a>2.4.2. Partition Table</h4>
<div class="paragraph">
<p>When you start a member, a partition table is created within it. This table stores the partition
IDs and the cluster members to which they belong. The purpose of this table is to make all members
(including lite members) in the cluster aware of this information, making sure that each member
knows where the data is.</p>
</div>
<div class="paragraph">
<p>The oldest member in the cluster (the one that started first) periodically sends the partition
table to all members. In this way each member in the cluster is informed about any changes to
partition ownership. The ownerships may be changed when, for example, a new member joins the
cluster, or when a member leaves the cluster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the oldest member of the cluster goes down, the next oldest member sends the partition
table information to the other ones.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can configure the frequency (how often) that the member sends the partition table the information
by using the <code>hazelcast.partition.table.send.interval</code> system property. The property is set to every
15 seconds by default.</p>
</div>
</div>
<div class="sect3">
<h4 id="repartitioning"><a class="anchor" href="#repartitioning"></a>2.4.3. Repartitioning</h4>
<div class="paragraph">
<p>Repartitioning is the process of redistribution of partition ownerships. Hazelcast performs the
repartitioning when a member joins or leaves the cluster.</p>
</div>
<div class="paragraph">
<p>In these cases, the partition table in the oldest member is updated with the new partition
ownerships. Note that if a lite member joins or leaves a cluster, repartitioning is not triggered
since lite members do not own any partitions.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="use-cases"><a class="anchor" href="#use-cases"></a>2.5. Use Cases</h3>
<div class="paragraph">
<p>Hazelcast can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to cluster highly changing data with event notifications, e.g., user based events, and
to queue and distribute background tasks</p>
</li>
<li>
<p>as a simple Memcache with Near Cache</p>
</li>
<li>
<p>as a cloud-wide scheduler of certain processes that need to be performed on some members</p>
</li>
<li>
<p>to share information (user information, queues, maps, etc.) on the fly with multiple
members in different installations under OSGI environments</p>
</li>
<li>
<p>to share keys in a cluster where there is a web service interface on an
application server and some validation</p>
</li>
<li>
<p>as a distributed topic (publish/subscribe server) to build scalable chat servers for smartphones</p>
</li>
<li>
<p>as a strongly consistent layer for its concurrency API which is Hazelcast&#8217;s CP
(CP with respect the CAP principle) subsystem built on top of the Raft consensus algorithm</p>
</li>
<li>
<p>as a front layer for a Cassandra back-end</p>
</li>
<li>
<p>to distribute user object states across the cluster, to pass messages between objects
and to share system data structures (static initialization state, mirrored objects, object
identity generators)</p>
</li>
<li>
<p>as a multi-tenancy cache where each tenant has its own map</p>
</li>
<li>
<p>to share datasets, e.g., table-like data structure, to be used by applications</p>
</li>
<li>
<p>to distribute the load and collect status from Amazon EC2 servers where the front-end is
developed using, for example, Spring framework</p>
</li>
<li>
<p>as a real-time streamer for performance detection</p>
</li>
<li>
<p>as storage for session data in web applications (enables horizontal scalability of the web application).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="resources"><a class="anchor" href="#resources"></a>2.6. Resources</h3>
<div class="ulist">
<ul>
<li>
<p>Hazelcast source code can be found at <a href="https://github.com/hazelcast/hazelcast" target="_blank" rel="noopener">GitHub/Hazelcast</a>.
This is also where you can contribute and report issues.</p>
</li>
<li>
<p>Hazelcast API can be found at <a href="https://docs.hazelcast.org/docs/latest-dev/javadoc/" target="_blank" rel="noopener">Hazelcast.org/docs/Javadoc</a>.</p>
</li>
<li>
<p>Code samples can be downloaded from <a href="https://hazelcast.org/imdg/download/" target="_blank" rel="noopener">Hazelcast.org/download</a>.</p>
</li>
<li>
<p>More use cases and resources can be found at <a href="http://www.hazelcast.com" target="_blank" rel="noopener">Hazelcast.com</a>.</p>
</li>
<li>
<p>Questions and discussions can be posted at the <a href="https://groups.google.com/forum/#!forum/hazelcast" target="_blank" rel="noopener">Hazelcast mail group</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="installing-hazelcast-imdg"><a class="anchor" href="#installing-hazelcast-imdg"></a>3. Installing and Upgrading</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides pre- and post-installation
details, and deployment options of Hazelcast IMDG.</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG provides a number of options on how to install it.
Here&#8217;s a brief overview of them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#installing-using-cli">CLI</a>: Fastest way of getting Hazelcast IMDG running (in the client/server mode).
Currently not suitable for production usage, but rather for development purposes.</p>
</li>
<li>
<p><a href="#installing-using-maven">Maven</a>: Easiest way for Maven users (typically Java developers), especially appropriate
for the embedded mode when Hazelcast IMDG is tightly coupled with the application.</p>
</li>
<li>
<p><a href="#installing-using-docker">Docker</a>: One line Docker based setup.</p>
</li>
<li>
<p><a href="#installing-using-download-archives">Download Archives</a>: Provides the most flexibility and all the tooling, but takes a little longer time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A separate section is dedicated for
<a href="#deploying-in-cloud">deployments into cloud</a>, which includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#deploying-hazelcast-cloud">Hazelcast Cloud</a></p>
</li>
<li>
<p><a href="#deploying-on-amazon-ec2">Amazon Web Services</a></p>
</li>
<li>
<p><a href="#deploying-on-microsoft-azure">Microsoft Azure</a></p>
</li>
<li>
<p><a href="#deploying-on-gcp">Google Cloud Platform</a></p>
</li>
<li>
<p><a href="#deploying-on-pivotal-cloud-foundry">Deploying in VMware Tanzu</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="installing-using-cli"><a class="anchor" href="#installing-using-cli"></a>3.1. CLI</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, installation using CLI is intended for development purposes.
For production setups please use the other installation options explained later in this chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To install Hazelcast via command line interface, run the following commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">$ brew tap hazelcast/hz
$ brew install hazelcast</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information visit the GitHub repository
of the <a href="https://github.com/hazelcast/hazelcast-command-line" target="_blank" rel="noopener">Command Line Interface (CLI)</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="installing-using-maven"><a class="anchor" href="#installing-using-maven"></a>3.2. Maven</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As a prerequisite, make sure you have Java installed on your system.
If you&#8217;re using JDK 9 and newer, see <a href="#running-in-modular-java">Running in Modular Java</a>.
For the list of supported Java versions, see <a href="#supported-jvms">Supported Java Virtual Machines</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can find Hazelcast in standard Maven repositories. If your
project uses Maven, you do not need to add
additional repositories to your <code>pom.xml</code> or add
<code>hazelcast-4.1.jar</code> file into your
classpath (Maven does that for you). Just add the following
lines to your <code>pom.xml</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Hazelcast Open Source Edition</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
        &lt;artifactId&gt;hazelcast-all&lt;/artifactId&gt;
        &lt;version&gt;4.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Hazelcast Enterprise Edition</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- You need to define following repository: --&gt;
&lt;repository&gt;
    &lt;id&gt;Hazelcast Private Release Repository&lt;/id&gt;
    &lt;url&gt;https://repository.hazelcast.com/release/&lt;/url&gt;
&lt;/repository&gt;
&lt;!-- Optional repository if you want to use latest snapshots --&gt;
&lt;repository&gt;
    &lt;id&gt;Hazelcast Private Snapshot Repository&lt;/id&gt;
    &lt;url&gt;https://repository.hazelcast.com/snapshot/&lt;/url&gt;
&lt;/repository&gt;


&lt;!-- You also need to define following dependencies: --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast-enterprise-all&lt;/artifactId&gt;
    &lt;version&gt;4.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Optional dependency for including JavaDoc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast-enterprise-all&lt;/artifactId&gt;
    &lt;version&gt;4.1&lt;/version&gt;
    &lt;classifier&gt;javadoc&lt;/classifier&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Above dependency (<code>hazelcast-all</code>) includes both member and Java
client libraries of Hazelcast IMDG. A separate Java client module
and dependency do not exist. See <a href="#removal-of-hazelcast-client-module">here</a>
for the details.</p>
</div>
</div>
<div class="sect2">
<h3 id="installing-using-docker"><a class="anchor" href="#installing-using-docker"></a>3.3. Docker</h3>
<div class="paragraph">
<p>Hazelcast is distributed in a form of Docker images.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://hub.docker.com/r/hazelcast/hazelcast" target="_blank" rel="noopener">hazelcast/hazelcast</a>: Hazelcast Docker image hosted on Docker Hub</p>
</li>
<li>
<p><a href="https://hub.docker.com/r/hazelcast/hazelcast-enterprise" target="_blank" rel="noopener">hazelcast/hazelcast-enterprise</a>: Hazelcast Enterprise Docker image hosted on Docker Hub</p>
</li>
<li>
<p><a href="https://catalog.redhat.com/software/containers/hazelcast/hazelcast-enterprise-4-rhel8/5ee38856ecb5246c090412bd" target="_blank" rel="noopener">registry.connect.redhat.com/hazelcast/hazelcast-enterprise-4-rhel8</a>: Red Hat certified Docker image hosted on Red Hat Container Catalog</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can run the following command to launch the Hazelcast Docker container:</p>
</div>
<div class="listingblock primary">
<div class="title">hazelcast</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">$ docker run hazelcast/hazelcast:$HAZELCAST_VERSION</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">hazelcast-enterprise</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">$ docker run -e HZ_LICENSE_KEY=&lt;Your Enterprise License Key&gt; hazelcast/hazelcast-enterprise:$HAZELCAST_VERSION</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">hazelcast-enterprise-4-rhel8</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell"># You must be logged into Red Hat Container Registry

$ docker run -e HZ_LICENSE_KEY=&lt;Your Enterprise License Key&gt; registry.connect.redhat.com/hazelcast/hazelcast-enterprise-4-rhel8:$HAZELCAST_VERSION</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command will pull Hazelcast Docker image and run a new Hazelcast instance.</p>
</div>
<div class="paragraph">
<p>See the following for more details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-docker" target="_blank" rel="noopener">Hazelcast and Hazelcast Enterprise Docker image documentation</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-openshift" target="_blank" rel="noopener">Red Hat Hazelcast Enterprise Docker image documentation</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="installing-using-download-archives"><a class="anchor" href="#installing-using-download-archives"></a>3.4. Download Archives</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As a prerequisite, make sure you have Java installed on your system.
If you&#8217;re using JDK 9 and newer, see <a href="#running-in-modular-java">Running in Modular Java</a>.
For the list of supported Java versions, see <a href="#supported-jvms">Supported Java Virtual Machines</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can download and install Hazelcast IMDG yourself. You only need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>download the package <code>hazelcast-4.1.zip</code> or <code>hazelcast-4.1.tar.gz</code>
from <a href="https://hazelcast.org/download" target="_blank" rel="noopener">hazelcast.org</a></p>
</li>
<li>
<p>extract the downloaded <code>hazelcast-4.1.zip</code> or <code>hazelcast-4.1.tar.gz</code></p>
</li>
<li>
<p>and add the file <code>hazelcast-4.1.jar</code> to your classpath.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When you download and extract the Hazelcast ZIP or TAR.GZ package, you will
see the <code>start/stop.sh</code> (for Linux) and <code>start/stop.bat</code> (for Windows) scripts under the <code>/bin</code> folder.
These scripts start/stop a Hazelcast member. See the <a href="#creating-a-cluster">Quick Start chapter</a>
to see the start scripts in action.</p>
</div>
<div class="paragraph">
<p>There are also some other scripts in the download archive whose usage descriptions
are given in their related sections including the <a href="#using-the-script-cluster-sh">Using the Script cluster.sh</a>,
<a href="#cp-subsystem-management-apis">CP Subsystem Management APIs section</a> and
<a href="#health-check-script">Using the healthcheck.sh Script</a> sections. You can also check the full list
of scripts in the <code>readme.html</code> of your download archive.</p>
</div>
</div>
<div class="sect2">
<h3 id="deploying-hazelcast-cloud"><a class="anchor" href="#deploying-hazelcast-cloud"></a>3.5. Hazelcast Cloud</h3>
<div class="paragraph">
<p>A simple option for deploying Hazelcast is <a href="https://cloud.hazelcast.com/sign-up" target="_blank" rel="noopener">Hazelcast Cloud</a>. It delivers
enterprise-grade Hazelcast software in the cloud. You can deploy, scale
and update your Hazelcast easily using Hazelcast Cloud; it maintains the
clusters for you. You can use Hazelcast Cloud as a low-latency high-performance
caching or data layer for your microservices, and it is also a nice solution
for state management of serverless functions (AWS Lambda).</p>
</div>
<div class="paragraph">
<p>Hazelcast Cloud uses Docker and Kubernetes, and is powered by Hazelcast IMDG
Enterprise HD. It is initially available on Amazon Web Services (AWS), to be
followed by Microsoft Azure and Google Cloud Platform (GCP). Since it is based
on Hazelcast IMDG Enterprise HD, it features advanced functionality such as
TLS, multi-region, persistence, and high availability.</p>
</div>
</div>
<div class="sect2">
<h3 id="deploying-in-kubernetes"><a class="anchor" href="#deploying-in-kubernetes"></a>3.6. Kubernetes/OpenShift Deployment</h3>
<div class="paragraph">
<p>Hazelcast provides a few methods to simplify deploying Hazelcast cluster into Kubernetes-based environments.</p>
</div>
<div class="sect3">
<h4 id="_quick_start"><a class="anchor" href="#_quick_start"></a>3.6.1. Quick Start</h4>
<div class="paragraph">
<p>If you just want to play with Hazelcast on Kubernetes, execute the following commands to create Hazelcast cluster
with 3 members into <code>default</code> namespace using the <code>default</code> Service Account.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">kubectl apply -f https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml
kubectl run hazelcast-1 --image=hazelcast/hazelcast:$HAZELCAST_VERSION
kubectl run hazelcast-2 --image=hazelcast/hazelcast:$HAZELCAST_VERSION
kubectl run hazelcast-3 --image=hazelcast/hazelcast:$HAZELCAST_VERSION</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast members automatically discovers themselves using the
<a href="https://github.com/hazelcast/hazelcast-kubernetes" target="_blank" rel="noopener">Hazelcast Kubernetes Discovery plugin</a>
and therefore form one Hazelcast cluster.</p>
</div>
</div>
<div class="sect3">
<h4 id="_helm_chart"><a class="anchor" href="#_helm_chart"></a>3.6.2. Helm Chart</h4>
<div class="paragraph">
<p><a href="https://helm.sh/" target="_blank" rel="noopener">Helm</a> is a package manager for Kubernetes. Hazelcast is distributed in a form of Helm Charts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/charts/tree/master/stable/hazelcast" target="_blank" rel="noopener">hazelcast/hazelcast</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/charts/tree/master/stable/hazelcast-enterprise" target="_blank" rel="noopener">hazelcast/hazelcast-enterprise</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://github.com/hazelcast/charts" target="_blank" rel="noopener">Hazelcast Helm Charts documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_kubernetesopenshift_operator"><a class="anchor" href="#_kubernetesopenshift_operator"></a>3.6.3. Kubernetes/OpenShift Operator</h4>
<div class="paragraph">
<p>Kubernetes Operators are software extensions to Kubernetes which help you create and manage your applications.
You can deploy and manage Hazelcast using the following Operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://hub.docker.com/r/hazelcast/hazelcast-operator" target="_blank" rel="noopener">hazelcast/hazelcast-operator</a>: Hazelcast Operator hosted on Docker Hub</p>
</li>
<li>
<p><a href="https://hub.docker.com/r/hazelcast/hazelcast-enterprise-operator" target="_blank" rel="noopener">hazelcast/hazelcast-enterprise-operator</a>: Red Hat certified Hazelcast Enterprise Operator hosted on Docker Hub</p>
</li>
<li>
<p><a href="https://catalog.redhat.com/software/containers/hazelcast/hazelcast-enterprise-operator/5eb3bf9bac3db90370945f59" target="_blank" rel="noopener">registry.connect.redhat.com/hazelcast/hazelcast-enterprise-operator</a>: Hazelcast Enterprise Operator hosted on Red Hat Container Catalog</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are a few different ways in using Hazelcast Operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>kubectl/oc instructions: See the <a href="https://github.com/hazelcast/hazelcast-operator" target="_blank" rel="noopener">Hazelcast Operator documentation</a>.</p>
</li>
<li>
<p>OpenShift Web Console: OpenShift provides a way to deploy operators from its UI.</p>
</li>
<li>
<p>OperatorHub instructions: Check Operator Hub for <a href="https://operatorhub.io/operator/hazelcast-operator" target="_blank" rel="noopener">Hazelcast</a> and <a href="https://operatorhub.io/operator/hazelcast-enterprise-operator" target="_blank" rel="noopener">Hazelcast Enterprise</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="deploying-on-pivotal-cloud-foundry"><a class="anchor" href="#deploying-on-pivotal-cloud-foundry"></a>3.7. Deploying in VMware Tanzu</h3>
<div class="paragraph">
<p>You can deploy your Hazelcast Enterprise cluster in VMware Tanzu (former Pivotal Cloud Foundry).
See the following for details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://network.pivotal.io/products/hazelcast-pcf/" target="_blank" rel="noopener">Hazelcast Enterprise Product Page</a></p>
</li>
<li>
<p><a href="https://docs.pivotal.io/partners/hazelcast/index.html" target="_blank" rel="noopener">Hazelcast Enterprise Usage Instructions and Release Notes</a></p>
</li>
<li>
<p><a href="https://guides.hazelcast.org/vmware-tanzu/" target="_blank" rel="noopener">Hazelcast Guides: Hazelcast Enterprise IMDG for VMware Tanzu</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="deploying-in-cloud"><a class="anchor" href="#deploying-in-cloud"></a>3.8. Deploying in Cloud Providers</h3>
<div class="paragraph">
<p>Hazelcast can be deployed into different cloud providers. Thanks to dedicated
<a href="#hazelcast-cloud-discovery-plugins">Hazelcast Cloud Discovery plugins</a> there is no static IP configuration needed and
Hazelcast cluster is resilient to availability zone failures.</p>
</div>
<div class="sect3">
<h4 id="deploying-on-amazon-ec2"><a class="anchor" href="#deploying-on-amazon-ec2"></a>3.8.1. Amazon Web Services</h4>
<div class="paragraph">
<p>You can easily deploy your Hazelcast projects on AWS EC2 instances and ECS clusters. See the
information about <a href="#hazelcast-cloud-discovery-plugins-aws">Hazelcast AWS Discovery plugin</a>
for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="deploying-on-microsoft-azure"><a class="anchor" href="#deploying-on-microsoft-azure"></a>3.8.2. Microsoft Azure</h4>
<div class="paragraph">
<p>You can easily deploy your Hazelcast projects on the Azure VM Instances and AKS clusters. See the
information about <a href="#hazelcast-cloud-discovery-plugins-azure">Hazelcast Azure Discovery plugin</a>
for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="deploying-on-gcp"><a class="anchor" href="#deploying-on-gcp"></a>3.8.3. Google Cloud Platform</h4>
<div class="paragraph">
<p>You can easily deploy your Hazelcast projects on the Google Compute VM Instances and GKE clusters. See the
information about <a href="#hazelcast-cloud-discovery-plugins-gcp">Hazelcast GCP Discovery plugin</a>
for details.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="setting-the-license-key"><a class="anchor" href="#setting-the-license-key"></a>3.9. Using Pro and Enterprise editions</h3>
<div class="paragraph">
<p>Hazelcast IMDG offers two commercially licensed editions: <strong>Pro</strong> and <strong>Enterprise</strong>.
The supported features differ in your Hazelcast
setup according to the license type you own.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pro license</strong>: In addition to the open source edition of Hazelcast,
Pro features are the following:</p>
<div class="ulist">
<ul>
<li>
<p><a href="#cp-subsystem-persistence">[cp-subsystem-persistence]</a></p>
</li>
<li>
<p><a href="#deploying-on-pivotal-cloud-foundry">Deploying in VMware Tanzu</a></p>
</li>
<li>
<p><a href="#deploying-in-kubernetes">Deploying in Openshift container platform</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Enterprise license</strong>: In addition to the open source and Pro editions of
Hazelcast, Enterprise features are the following:</p>
<div class="ulist">
<ul>
<li>
<p><a href="#security">Security suite</a></p>
</li>
<li>
<p><a href="#wan-replication">[wan-replication]</a></p>
</li>
<li>
<p><a href="#clustered-jmx-and-rest-via-management-center">Clustered REST</a></p>
</li>
<li>
<p><a href="#clustered-jmx-and-rest-via-management-center">Clustered JMX</a></p>
</li>
<li>
<p><a href="#hazelcast-striim-hot-cache">Striim Hot Cache</a></p>
</li>
<li>
<p><a href="#rolling-member-upgrades">Rolling Upgrades</a></p>
</li>
<li>
<p><a href="#high-density-memory-store">[high-density-memory-store]</a></p>
</li>
<li>
<p><a href="#hot-restart-persistence">[hot-restart-persistence]</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>See also <a href="https://hazelcast.com/product-features/imdg-comparison/" target="_blank" rel="noopener">here</a> for a
more detailed feature comparison between the editions.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_license_key"><a class="anchor" href="#_setting_up_license_key"></a>3.9.1. Setting Up License Key</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hazelcast IMDG Pro and Enterprise license keys are required only for members.
You do not need to set a license key for your Java clients for which you
want to use the Pro and Enterprise features.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use Hazelcast IMDG Pro or Enterprise, you need to set the provided license
key using one of the configuration methods shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- Add the below line to any place you like in the file `hazelcast-default.xml`. --&gt;

&lt;hazelcast&gt;
    ...
    &lt;license-key&gt;Your Enterprise License Key&lt;/license-key&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml"># Add the below line to any place you like in the file `hazelcast-default.yaml`.

hazelcast:
  ...
  license-key: Your Hazelcast Enterprise or Enterprise HD License Key
  ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Programmatic configuration.

Config config = new Config();
config.setLicenseKey( "Your Enterprise License Key" );</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:config&gt;
    ...
    &lt;hz:license-key&gt;Your Enterprise License Key&lt;/hz:license-key&gt;
    ...
&lt;/hz:config&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JVM System Property</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">-Dhazelcast.enterprise.license.key=Your Enterprise License Key</code></pre>
</div>
</div>
<div class="paragraph">
<p>For monitoring information such as expiration date of your license key see <a href="#license-info">[license-info]</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="license-key-format"><a class="anchor" href="#license-key-format"></a>3.9.2. License Key Format</h4>
<div class="paragraph">
<p>License keys have the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;Name of the Hazelcast edition&gt;#&lt;Count of the Members&gt;#&lt;License key&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The strings before the <code>&lt;License key&gt;</code> is the human readable part. You
can use your license key with or without this human readable part. So,
both the following example license keys are valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>HazelcastEnterpriseHD#2Nodes#1q2w3e4r5t</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>1q2w3e4r5t</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rolling-member-upgrades"><a class="anchor" href="#rolling-member-upgrades"></a>3.10. Rolling Member Upgrades</h3>
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise</strong></p>
</div>
<div class="paragraph">
<p>This chapter explains the procedure of upgrading the version of Hazelcast members in a running cluster without interrupting the operation of the cluster.</p>
</div>
<div class="sect3">
<h4 id="terminology"><a class="anchor" href="#terminology"></a>3.10.1. Terminology</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Minor version</strong>: A version change after the decimal point, e.g.,
3.12 and 3.13.</p>
</li>
<li>
<p><strong>Patch version</strong>: A version change after the second decimal point,
e.g., 3.12.1 and 3.12.2.</p>
</li>
<li>
<p><strong>Member codebase version</strong>: The <code>major.minor.patch</code> version of the
Hazelcast binary on which the member executes. For example, when running
on <code>hazelcast-3.12.jar</code>, your member&#8217;s codebase version is <code>3.12.0</code>.</p>
</li>
<li>
<p><strong>Cluster version</strong>: The <code>major.minor</code> version at which the cluster
operates. This ensures that cluster members are able to communicate using
the same cluster protocol and
determines the feature set exposed by the cluster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="hazelcast-members-compatibility-guarantees"><a class="anchor" href="#hazelcast-members-compatibility-guarantees"></a>3.10.2. Hazelcast Members Compatibility Guarantees</h4>
<div class="paragraph">
<p>Hazelcast members operating on binaries of the same major and minor
version numbers are compatible regardless of patch version.
For example, in a cluster with members running on version 3.11.1,
it is possible to perform a rolling upgrade to 3.11.2 by shutting
down, upgrading to <code>hazelcast-3.11.2.jar</code> binary and starting each
member one by one. <em>Patch level compatibility applies to both Hazelcast
IMDG and Hazelcast IMDG Enterprise</em>.</p>
</div>
<div class="paragraph">
<p>Also, each minor version is compatible with the previous one (back until
Hazelcast IMDG 3.8). For example, it is possible to perform a rolling
upgrade on a cluster running Hazelcast IMDG Enterprise 3.11 to Hazelcast
IMDG Enterprise 3.12. <em>Rolling upgrades across minor versions is a Hazelcast
IMDG Enterprise feature</em>.</p>
</div>
<div class="paragraph">
<p>The compatibility guarantees described above are given in the context of
rolling member upgrades and only apply to GA (general availability) releases.
It is never advisable to run a cluster with members running on different
patch or minor versions for prolonged periods of time.</p>
</div>
</div>
<div class="sect3">
<h4 id="rolling-upgrade-procedure"><a class="anchor" href="#rolling-upgrade-procedure"></a>3.10.3. Rolling Upgrade Procedure</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The version numbers used in this chapter are examples.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s assume a cluster with four members running on codebase version <code>3.12.0</code> with cluster version <code>3.12</code>, that should be upgraded to codebase version
<code>3.13.0</code> and cluster version <code>3.13</code>. The rolling upgrade process for this cluster, i.e., replacing existing <code>3.12.0</code> members one by one with an upgraded
one at version <code>3.13.0</code>, includes the following steps which should be repeated for each member:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gracefully shut down an existing <code>3.12.0</code> member.</p>
</li>
<li>
<p>Wait until all partition migrations are completed; during migrations,
membership changes (member joins or removals) are not allowed.</p>
</li>
<li>
<p>Update the member with the new <code>3.13.0</code> Hazelcast binaries.</p>
</li>
<li>
<p>Start the member and wait until it joins the cluster. You should
see something like the following in your logs:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code> ...
 INFO: [192.168.2.2]:5701 [cluster] [3.13] Hazelcast 3.9 (20170630 - a67dc3a) starting at [192.168.2.2]:5701
 ...
 INFO: [192.168.2.2]:5701 [cluster] [3.13] Cluster version set to 3.12</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The version in brackets (<code>[3.13]</code>) still denotes the member&#8217;s codebase version (running on the hypothetical <code>hazelcast-3.13.jar</code> binary). Once the member locates the existing cluster members, it sends its join request to the master. The master validates that the new member is allowed to join the cluster and lets the new member know that the cluster is currently operating at <code>3.12</code> cluster version. The new member sets <code>3.12</code> as its cluster version and starts operating normally.</p>
</div>
<div class="paragraph">
<p>At this point all members of the cluster have been upgraded to codebase version <code>3.13.0</code> but the cluster still operates at cluster version <code>3.12</code>. In order to use <code>3.13</code> features the cluster version must be changed to <code>3.13</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Rolling upgrade can be used for one version at a time, e.g., 3.n to 3.n+1. You cannot upgrade
your members, for example, from 3.13 to 3.15 in a single rolling upgrade session.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="upgrading-cluster-version"><a class="anchor" href="#upgrading-cluster-version"></a>3.10.4. Upgrading Cluster Version</h4>
<div class="paragraph">
<p>You have the following options to upgrade the cluster version:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using <a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#rolling-upgrade">Management Center</a>.</p>
</li>
<li>
<p>Using the <a href="#using-the-script-cluster-sh">cluster.sh</a> script.</p>
</li>
<li>
<p>Allow the cluster to <a href="#enabling-auto-upgrading">auto-upgrade</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that you need to enable the REST API to use either of the above methods
to upgrade your cluster version. For this, enable the <code>CLUSTER_WRITE</code>
REST endpoint group (its default is disabled). See the
<a href="#using-the-rest-endpoint-groups">[using-the-rest-endpoint-groups]</a> section on how to enable them.</p>
</div>
<div class="paragraph">
<p>Also note that you need to upgrade your Management Center version <strong>before</strong> upgrading the member version if you want to
change the cluster version using Management Center. Management Center is compatible with the previous minor version of
Hazelcast. For example, Management Center 3.12 works with both Hazelcast IMDG
3.11 and 3.12. To change your cluster version to 3.12, you need Management Center 3.12.</p>
</div>
</div>
<div class="sect3">
<h4 id="_enabling_auto_upgrading"><a class="anchor" href="#_enabling_auto_upgrading"></a>3.10.5. Enabling Auto-Upgrading</h4>
<div class="paragraph">
<p>The cluster can automatically upgrade its version. As soon as it detects
that all its members have a version higher than the current cluster
version, it upgrades the cluster version to match it. This feature is
disabled by default. To enable it, set the system property
<code>hazelcast.cluster.version.auto.upgrade.enabled</code> to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>There is one tricky detail here: as you are shutting down and upgrading
the members one by one, when you shut down the last one, all the members
in the remaining cluster have the newer version, but you don&#8217;t want the
auto-upgrade to kick in before you have successfully upgraded the last
member as well. To avoid this, you can use the
<code>hazelcast.cluster.version.auto.upgrade.min.cluster.size</code> system
property. You should
set it to the size of your cluster, and then Hazelcast will wait for the
last member to join before it can proceed with the auto-upgrade.</p>
</div>
</div>
<div class="sect3">
<h4 id="network-partitions-and-rolling-upgrades"><a class="anchor" href="#network-partitions-and-rolling-upgrades"></a>3.10.6. Network Partitions and Rolling Upgrades</h4>
<div class="paragraph">
<p>In the event of network partitions which split your cluster into two subclusters, split-brain handling works as explained in the <a href="#network-partitioning">Network Partitioning chapter</a>, with the
additional constraint that two subclusters only merge as long as they operate on the same cluster version. This is a requirement to ensure that all members participating
in each one of the subclusters are able to operate as members of the merged cluster at the same cluster version.</p>
</div>
<div class="paragraph">
<p>With regards to rolling upgrades, the above constraint implies that if a network partition occurs while a change of cluster version is in progress, then with some unlucky timing, one subcluster may be upgraded to the new cluster version and another subcluster may have upgraded members but still operate at the old cluster version.</p>
</div>
<div class="paragraph">
<p>In order for the two subclusters to merge, it is necessary to change the cluster version of the subcluster that still operates on the old cluster version, so that both subclusters
will be operating at the same, upgraded cluster version and able to merge as soon as the network partition is fixed.</p>
</div>
</div>
<div class="sect3">
<h4 id="rolling-upgrade-faq"><a class="anchor" href="#rolling-upgrade-faq"></a>3.10.7. Rolling Upgrade FAQ</h4>
<div class="paragraph">
<p>The following provide answers to the frequently asked questions related to rolling member upgrades.</p>
</div>
<div class="paragraph">
<p><strong>How is the cluster version set?</strong></p>
</div>
<div class="paragraph">
<p>When a new member starts, it is not yet joined to a cluster; therefore its cluster version is still undetermined. In order for the cluster version to be
set, one of the following must happen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the member cannot locate any members of the cluster to join or is configured without a joiner: in this case, the member appoints itself as the master of a new single-member cluster and its cluster version is set to the <code>major.minor</code> version of its own codebase version. So a standalone member running on codebase version <code>3.12.0</code> sets its own cluster version to <code>3.12</code>.</p>
</li>
<li>
<p>the member that is starting locates members of the cluster and identifies which is the master: in this case, the master validates that the joining member&#8217;s codebase version is compatible with the current cluster version. If it is found to be compatible, then the member joins and the master sends the cluster version, which is set on the joining member. Otherwise, the starting member fails to join and shuts down.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>What if a new Hazelcast minor version changes fundamental cluster protocol communication, like join messages?</strong></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The version numbers used in the paragraph below are only used as an example.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On startup, as answered in the above question (How is the cluster version set?), the cluster version is not yet known to a member that has not joined any cluster.
By default the newly started member uses the cluster protocol that corresponds to its codebase version until this member joins a cluster
(so for codebase <code>3.12.0</code> this means implicitly assuming cluster version <code>3.12</code>). If, hypothetically, major changes in discovery &amp; join operations
have been introduced which do not allow the member to join a <code>3.11</code> cluster, then the member should be explicitly configured to start
assuming a <code>3.11</code> cluster version.</p>
</div>
<div class="paragraph">
<p><strong>Do I have to upgrade clients to work with rolling upgrades?</strong></p>
</div>
<div class="paragraph">
<p>Clients which implement the Open Binary Client Protocol
are compatible with Hazelcast version 3.6 and newer minor versions. Thus older client versions are compatible with next minor versions. Newer clients
connected to a cluster operate at the lower version of capabilities until all members are upgraded and the cluster version upgrade occurs.</p>
</div>
<div class="paragraph">
<p><strong>Can I stop and start multiple members at once during a rolling member upgrade?</strong></p>
</div>
<div class="paragraph">
<p>It is not recommended due to potential network partitions. It is advised to always stop and start one member in each upgrade step.</p>
</div>
<div class="paragraph">
<p><strong>Can I upgrade my business app together with Hazelcast while doing a rolling member upgrade?</strong></p>
</div>
<div class="paragraph">
<p>Yes, but make sure to make the new version of your app compatible with the old one since there will be a timespan when both versions interoperate. Checking if two versions of your app are compatible includes verifying binary and algorithmic compatibility and some other steps.</p>
</div>
<div class="paragraph">
<p>It is worth mentioning that a business app upgrade is orthogonal to a rolling member upgrade. A rolling business app upgrade may be done without upgrading the members.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-in-modular-java"><a class="anchor" href="#running-in-modular-java"></a>3.11. Running in Modular Java</h3>
<div class="paragraph">
<p>Java <a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">project Jigsaw</a> brought
a new Module System into Java 9 and newer. Hazelcast supports running in
the modular environment. If you want to run your application with Hazelcast
libraries on the modulepath, use the following module name:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.core</code> for <code>hazelcast-4.1.jar</code> and
<code>hazelcast-enterprise-4.1.jar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Don&#8217;t use <code>hazelcast-all-4.1.jar</code> or
<code>hazelcast-enterprise-all-4.1.jar</code> on the modulepath as it could
lead to problems in module dependencies for your application. You can
still use them on the classpath.</p>
</div>
<div class="paragraph">
<p>The Java Module System comes with stricter visibility rules. It affects
Hazelcast which uses internal Java API to reach the best performance results.</p>
</div>
<div class="paragraph">
<p>Hazelcast needs the <code>java.se</code> module and access to the following Java
packages for a proper work:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.base/jdk.internal.ref</code></p>
</li>
<li>
<p><code>java.base/java.nio</code> <em>(reflective access)</em></p>
</li>
<li>
<p><code>java.base/sun.nio.ch</code> <em>(reflective access)</em></p>
</li>
<li>
<p><code>java.base/java.lang</code> <em>(reflective access)</em></p>
</li>
<li>
<p><code>jdk.management/com.ibm.lang.management.internal</code> <em>(reflective access)</em></p>
</li>
<li>
<p><code>jdk.management/com.sun.management.internal</code> <em>(reflective access)</em></p>
</li>
<li>
<p><code>java.management/sun.management</code> <em>(reflective access)</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can provide the access to the above mentioned packages by using
<code>--add-exports</code> and <code>--add-opens</code> (for the reflective access) Java arguments.</p>
</div>
<div class="paragraph">
<p><strong>Example: Running a member on the classpath</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java --add-modules java.se \
  --add-exports java.base/jdk.internal.ref=ALL-UNNAMED \
  --add-opens java.base/java.lang=ALL-UNNAMED \
  --add-opens java.base/java.nio=ALL-UNNAMED \
  --add-opens java.base/sun.nio.ch=ALL-UNNAMED \
  --add-opens java.management/sun.management=ALL-UNNAMED \
  --add-opens jdk.management/com.ibm.lang.management.internal=ALL-UNNAMED \
  --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED \
  -jar hazelcast-4.1.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example: Running a member on the modulepath</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java --add-modules java.se \
  --add-exports java.base/jdk.internal.ref=com.hazelcast.core \
  --add-opens java.base/java.lang=com.hazelcast.core \
  --add-opens java.base/java.nio=com.hazelcast.core \
  --add-opens java.base/sun.nio.ch=com.hazelcast.core \
  --add-opens java.management/sun.management=com.hazelcast.core \
  --add-opens jdk.management/com.ibm.lang.management.internal=com.hazelcast.core \
  --add-opens jdk.management/com.sun.management.internal=com.hazelcast.core \
  --module-path lib \
  --module com.hazelcast.core/com.hazelcast.core.server.HazelcastMemberStarter</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>This example expects <code>hazelcast-4.1.jar</code> placed in the <code>lib</code> directory.</em></p>
</div>
</div>
<div class="sect2">
<h3 id="supported-jvms"><a class="anchor" href="#supported-jvms"></a>3.12. Supported Java Virtual Machines</h3>
<div class="paragraph">
<p>Following table summarizes the version compatibility between Hazelcast IMDG
and various vendors' Java Virtual Machines (JVMs).</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Supported JVMs</caption>
<colgroup>
<col style="width: 35%;">
<col style="width: 10%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 10%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Hazelcast IMDG Version</th>
<th class="tableblock halign-left valign-top">JDK Version</th>
<th class="tableblock halign-left valign-top">Oracle JDK</th>
<th class="tableblock halign-left valign-top">IBM SDK, Java Technology Edition</th>
<th class="tableblock halign-left valign-top">Azul Zing JDK</th>
<th class="tableblock halign-left valign-top">OpenJDK</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Up to 3.11</p>
<p class="tableblock">(<em>JDK 6 support is dropped with the release of Hazelcast IMDG 3.12</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Up to 3.11</p>
<p class="tableblock">(<em>JDK 7 support is dropped with the release of Hazelcast IMDG 3.12</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Up to current</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>3.11 and newer:  Fully supported.</p>
</li>
<li>
<p>3.10 and older: Partially supported.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-times"></i></span></p>
<p class="tableblock">(JDK not available yet)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hazelcast IMDG 3.10 and older releases are not fully tested on JDK 9
and newer, so there may be some features that are not working properly.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>See the following sections for the details of Hazelcast IMDG supporting
JDK 9 and newer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#running-in-modular-java">Running in Modular Java</a>: Talks about the
new module system present in Java 9 and newer and how you can run a Hazelcast
application on it.</p>
</li>
<li>
<p><a href="#tls-ssl-for-hazelcast-members">TLS/SSL for Hazelcast Members</a>: Lists
<code>TLSv1.3</code>, which comes with Java 11, as a supported TLS version.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="starting-the-member-and-client"><a class="anchor" href="#starting-the-member-and-client"></a>4. Starting the Members and Clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Having installed Hazelcast and assuming you have the required
libraries of your preferred client language, let&#8217;s see how we can start the
members and clients.</p>
</div>
<div class="paragraph">
<p><strong>Members:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">Shell</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Starts a standalone member:

sh bin/start.sh</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Docker</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">docker run hazelcast/hazelcast:$HAZELCAST_VERSION</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config cfg = new Config();
HazelcastInstance instance = Hazelcast.newHazelcastInstance(cfg);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>start.sh</code> / <code>start.bat</code> scripts lets you start one Hazelcast instance
per directory. To start a new instance, please unzip Hazelcast ZIP or TAR.GZ
package in a new directory.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use the start scripts to deploy your own library to a
Hazelcast member. See the <a href="#adding-user-library-to-classpath">Adding User
Library to CLASSPATH section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Clients:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
HazelcastInstance hzclient = HazelcastClient.newHazelcastClient();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">C++</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">hazelcast::client::ClientConfig config;
hazelcast::client::HazelcastClient hzclient(config);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">C#</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">var cfg = new ClientConfig();
var hzclient = HazelcastClient.NewHazelcastClient(cfg);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Node.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">const { Client } = require('hazelcast-client');
const hzclient = await Client.newHazelcastClient();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Python</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">config = hazelcast.ClientConfig()
hzclient = hazelcast.HazelcastClient(config)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Go</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go">config := hazelcast.NewConfig()
hzclient , _ := hazelcast.NewClientWithConfig(config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast also offers a tool, <strong>Management Center</strong>, that enables you to monitor your cluster.
It is included in your Hazelcast IMDG download package and can also be downloaded
from the Hazelcast website&#8217;s <a href="https://hazelcast.org/download/#management-center" target="_blank" rel="noopener">download page</a>.
You can use this tool to monitor your cluster, cluster members, clients, data structures
and WAN replications. See the <a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html" target="_blank" rel="noopener">documentation</a> for details on Hazelcast Management Center.</p>
</div>
<div class="paragraph">
<p>By default, Hazelcast uses multicast to discover other members that can form a cluster.  If you are
working with other Hazelcast developers on the same network, you may find yourself joining their
clusters under the default settings.  Hazelcast provides a way to segregate clusters within the same
network when using multicast. See the <a href="#creating-cluster">Creating Clusters section</a>
for more information.  Alternatively, if you do not wish to use the default multicast mechanism,
you can provide a fixed list of IP addresses that are allowed to join. See
the <a href="#join">Join configuration section</a> for more information.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Multicast mechanism is not recommended for production since UDP
is often blocked in production environments and other discovery mechanisms
are more definite. See the <a href="#discovery-mechanisms">Discovery Mechanisms section</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also check the video tutorials <a href="https://hazelcast.org/getting-started-with-hazelcast" target="_blank" rel="noopener">here</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_example_application"><a class="anchor" href="#_example_application"></a>4.1. Example Application</h3>
<div class="paragraph">
<p>In this short tutorial, you perform the following activities:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a simple Java application using the Hazelcast distributed map and queue.</p>
</li>
<li>
<p>Run our application twice to have a cluster with two members (JVMs).</p>
</li>
<li>
<p>Connect to our cluster from another Java application by using the
Hazelcast Native Java Client API.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s begin.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The following code starts the first Hazelcast member and
creates and uses the <code>customers</code> map and queue.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config cfg = new Config();
        HazelcastInstance instance = Hazelcast.newHazelcastInstance(cfg);
        Map&lt;Integer, String&gt; mapCustomers = instance.getMap("customers");
        mapCustomers.put(1, "Joe");
        mapCustomers.put(2, "Ali");
        mapCustomers.put(3, "Avi");

        System.out.println("Customer with key 1: "+ mapCustomers.get(1));
        System.out.println("Map Size:" + mapCustomers.size());

        Queue&lt;String&gt; queueCustomers = instance.getQueue("customers");
        queueCustomers.offer("Tom");
        queueCustomers.offer("Mary");
        queueCustomers.offer("Jane");
        System.out.println("First customer: " + queueCustomers.poll());
        System.out.println("Second customer: "+ queueCustomers.peek());
        System.out.println("Queue size: " + queueCustomers.size());</code></pre>
</div>
</div>
</li>
<li>
<p>Run this <code>GettingStarted</code> class a second time to get the second member
started. The members form a cluster and the output is similar to the following.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Members {size:2, ver:2} [
    Member [127.0.0.1]:5701 - e40081de-056a-4ae5-8ffe-632caf8a6cf1 this
    Member [127.0.0.1]:5702 - 93e82109-16bf-4b16-9c87-f4a6d0873080
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, you can see the size of your cluster (<code>size</code>) and member list
version (<code>ver</code>). The member list version is incremented when changes
happen to the cluster, e.g., a member leaving from or joining to the cluster.</p>
</div>
</li>
<li>
<p>Now, add the <code>hazelcast-client-</code><strong><code>4.1</code></strong><code>.jar</code> library to your classpath.
This is required to use a Hazelcast client.</p>
</li>
<li>
<p>The following code starts a Hazelcast Client, connects to our cluster,
and prints the size of the <code>customers</code> map.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class GettingStartedClient {
    public static void main( String[] args ) {
        ClientConfig clientConfig = new ClientConfig();
        HazelcastInstance client = HazelcastClient.newHazelcastClient( clientConfig );
        IMap map = client.getMap( "customers" );
        System.out.println( "Map Size:" + map.size() );
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>When you run it, you see the client properly connecting to the cluster
and printing the map size as <strong>3</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="understanding-configuration"><a class="anchor" href="#understanding-configuration"></a>5. Understanding Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes the options to configure your Hazelcast applications
and explains the utilities which you can make use of while configuring.
You can configure Hazelcast using one or mix of the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Declarative way</p>
</li>
<li>
<p>Programmatic way</p>
</li>
<li>
<p>Using Hazelcast system properties</p>
</li>
<li>
<p>Within the Spring context</p>
</li>
<li>
<p>Overriding configuration with environment variables or system properties</p>
</li>
<li>
<p>Dynamically adding configuration on a running cluster</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="configuring-declaratively"><a class="anchor" href="#configuring-declaratively"></a>5.1. Configuring Declaratively</h3>
<div class="paragraph">
<p>This is the configuration option where you use an XML or a YAML configuration
file. When you download and unzip <code>hazelcast-4.1
.zip</code>, you see the following files present in the  <code>/bin</code> folder, which are
standard configuration files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast-default.xml</code>: Default declarative XML configuration file for Hazelcast.
The configuration for the distributed data structures in this XML file should
be fine for most of the Hazelcast users. If not, you can tailor this XML file according
to your needs by adding/removing/modifying properties. Also see the <a href="#setting-up-clusters">Setting Up Clusters chapter</a> for the network related configurations.</p>
</li>
<li>
<p><code>hazelcast-default.yaml</code>: Default YAML configuration file identical to <code>hazelcast.xml</code> in content.</p>
</li>
<li>
<p><code>hazelcast-full-example.xml</code>: Configuration file which includes all Hazelcast configuration
elements and attributes with their descriptions. It is the "superset" of <code>hazelcast.xml</code>.
You can use <code>hazelcast-full-example.xml</code> as a reference document to learn about any element
or attribute, or you can change its name to <code>hazelcast.xml</code> and start to use it as your
Hazelcast configuration file.</p>
</li>
<li>
<p><code>hazelcast-full-example.yaml</code>: YAML configuration file identical to
<code>hazelcast-full-example.xml</code> in content.</p>
</li>
<li>
<p><code>hazelcast-client-full-example.xml</code>: Complete Hazelcast Java client example configuration
file which includes all configuration elements and attributes with their descriptions. Read
more about Java client configuration <a href="#configuring-java-client">here</a>.</p>
</li>
<li>
<p><code>hazelcast-client-full-example.yaml</code>: YAML configuration file identical to
<code>hazelcast-client-full-example.xml</code> in content.</p>
</li>
<li>
<p><code>hazelcast-client-failover-full-example.xml</code>: Complete Hazelcast client failover example
configuration file which includes all Hazelcast client failover configuration elements and
attributes with their descriptions. Read about Blue-Green Deployment and Disaster Recovery
<a href="#blue-green-deployment-and-disaster-recovery">here</a>.</p>
</li>
<li>
<p><code>hazelcast-client-failover-full-example.yaml</code>: YAML configuration file identical to
<code>hazelcast-client-failover-full-example.xml</code> in content.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A part of the default XML/YAML configurations is shown as an example below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cluster-name&gt;dev&lt;/cluster-name&gt;
    &lt;management-center scripting-enabled="false" /&gt;
    &lt;network&gt;
        &lt;port auto-increment="true" port-count="100"&gt;5701&lt;/port&gt;
        &lt;outbound-ports&gt;
        &lt;!--
        Allowed port range when connecting to other members.
        0 or * means the port provided by the system.
        --&gt;
            &lt;ports&gt;0&lt;/ports&gt;
        &lt;/outbound-ports&gt;
        &lt;join&gt;
            &lt;multicast enabled="true"&gt;
                &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;
                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
	    &lt;/multicast&gt;
	    &lt;tcp-ip enabled="false"&gt;
	        &lt;interface&gt;127.0.0.1&lt;/interface&gt;
                &lt;member-list&gt;
                    &lt;member&gt;127.0.0.1&lt;/member&gt;
                &lt;/member-list&gt;
            &lt;/tcp-ip&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    &lt;map name="default"&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  cluster-name: dev
  management-center:
    scripting-enabled: false
  network:
    port:
      auto-increment: true
      port-count: 100
      port: 5701
    outbound-ports:
      # Allowed port range when connecting to other nodes.
      # 0 or * means use system provided port.
      - 0
    join:
      multicast:
        enabled: true
        multicast-group: 224.2.2.3
        multicast-port: 54327
      tcp-ip:
        enabled: false
        interface: 127.0.0.1
        member-list:
          - 127.0.0.1
  map:
    default:
      time-to-live-seconds: 0
    ...</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="composing-declarative-configuration"><a class="anchor" href="#composing-declarative-configuration"></a>5.1.1. Composing Declarative Configuration</h4>
<div class="paragraph">
<p>You can compose the declarative configuration of your Hazelcast member or
Hazelcast client from multiple declarative
configuration snippets. In order to compose a declarative configuration, you
can <code>import</code> different
declarative configuration files. Composing configuration files is supported both
in XML and YAML configurations with the
limitation that only configuration files written in the same language can be composed.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you want to compose the declarative configuration for Hazelcast out of two
XML configurations: <code>development-cluster-config.xml</code> and <code>development-network-config.xml</code>.
These two configurations are shown below.</p>
</div>
<div class="paragraph">
<p><code>development-cluster-config.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name&gt;dev&lt;/cluster-name&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>development-network-config.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;network&gt;
        &lt;port auto-increment="true" port-count="100"&gt;5701&lt;/port&gt;
        &lt;join&gt;
            &lt;multicast enabled="true"&gt;
                &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;
                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
            &lt;/multicast&gt;
        &lt;/join&gt;
    &lt;/network&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get your example Hazelcast declarative configuration out of the above two,
use the <code>&lt;import/&gt;</code> element as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;import resource="development-group-config.xml"/&gt;
    &lt;import resource="development-network-config.xml"/&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example using the YAML configuration files looks like the following:</p>
</div>
<div class="paragraph">
<p><code>development-cluster-config.yaml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  cluster-name: dev</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>development-network-config.yaml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  network:
    port:
      auto-increment: true
      port-count: 100
      port: 5701
    join:
      multicast:
        enabled: true
        multicast-group: 224.2.2.3
        multicast-port: 54327</code></pre>
</div>
</div>
<div class="paragraph">
<p>Composing the above two YAML configuration files needs them to be imported as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  import:
    - development-group-config.yaml
    - development-network-config.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>This feature also applies to the declarative configuration of Hazelcast client.
See the following examples.</p>
</div>
<div class="paragraph">
<p><code>client-cluster-config.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    &lt;cluster-name&gt;dev&lt;/cluster-name&gt;
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>client-network-config.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    &lt;network&gt;
        &lt;cluster-members&gt;
            &lt;address&gt;127.0.0.1:7000&lt;/address&gt;
        &lt;/cluster-members&gt;
    &lt;/network&gt;
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get a Hazelcast client declarative configuration from the above two examples,
use the <code>&lt;import/&gt;</code> element as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    &lt;import resource="client-cluster-config.xml"/&gt;
    &lt;import resource="client-network-config.xml"/&gt;
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same client configuration using the YAML language is shown below.</p>
</div>
<div class="paragraph">
<p><code>client-cluster-config.yaml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast-client:
  cluster-name: dev</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>client-network-config.yaml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast-client:
  network:
    cluster-members:
      - 127.0.0.1:7000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Composing a Hazelcast client declarative configuration by importing the above two examples is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast-client:
  import:
    - client-cluster-config.yaml
    - client-network-config.yaml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Use <code>&lt;import/&gt;</code> element on top level of the XML hierarchy.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Use the <code>import</code> mapping on top level of the YAML hierarchy.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Resources from the classpath and file system may also be used to compose a declarative configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;import resource="file:///etc/hazelcast/development-cluster-config.xml"/&gt; &lt;!-- loaded from filesystem --&gt;
    &lt;import resource="classpath:development-network-config.xml"/&gt;  &lt;!-- loaded from classpath --&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  import:
    # loaded from filesystem
    - file:///etc/hazelcast/development-cluster-config.yaml
    # loaded from classpath
    - classpath:development-network-config.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Importing resources with variables in their names is also supported. See the following example snippets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;import resource="${environment}-cluster-config.xml"/&gt;
    &lt;import resource="${environment}-network-config.xml"/&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  import:
    - ${environment}-cluster-config.yaml
    - ${environment}-network-config.yaml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#using-variables">Using Variables section</a> to learn how you can set
the configuration elements with variables.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="configuring-declaratively-yaml"><a class="anchor" href="#configuring-declaratively-yaml"></a>5.1.2. Configuring Declaratively with YAML</h4>
<div class="paragraph">
<p>You can configure the Hazelcast members and Java clients declaratively with YAML configuration files in
installations of Hazelcast running on Java runtime version 8 or above.</p>
</div>
<div class="paragraph">
<p>The structure of the YAML configuration follows the structure of the XML configuration.
Therefore, you can rewrite the existing XML
configurations in YAML easily. There are some differences between the XML and YAML languages
that make the two declarative configurations to slightly derive as the the following examples show.</p>
</div>
<div class="paragraph">
<p>In the YAML declarative configuration, mappings are used in which the name of the mapping node
needs to be unique within its enclosing mapping. See the following example with
configuring two maps in the same configuration file.</p>
</div>
<div class="paragraph">
<p>In the XML configuration files, we have two <code>&lt;map&gt;</code> elements as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="map1"&gt;
        &lt;!-- map1 configuration --&gt;
    &lt;/map&gt;
    &lt;map name="map2"&gt;
        &lt;!-- map2 configuration --&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the YAML configuration, the map can be configured under a mapping <code>map</code> as shown in
the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
    ...
    map:
        map1:
          # map1 configuration
        map2:
          # map2 configuration
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The XML and YAML configurations above define the same maps <code>map1</code> and <code>map2</code>.
Please note that in the YAML configuration file
there is no <code>name</code> node, instead, the name of the map is used as the name of the
mapping for configuring the given map.</p>
</div>
<div class="paragraph">
<p>There are other configuration entries that have no unique names and are listed in the
same enclosing entry. Examples to this
kind of configurations are listing the member addresses, interfaces in the networking
configurations and defining listeners. The
following example configures listeners to illustrate this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;com.hazelcast.examples.MembershipListener&lt;/listener&gt;
        &lt;listener&gt;com.hazelcast.examples.MigrationListener&lt;/listener&gt;
        &lt;listener&gt;com.hazelcast.examples.PartitionLostListener&lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the YAML configuration, the listeners are defined as a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  ...
  listeners:
    - com.hazelcast.examples.MembershipListener
    - com.hazelcast.examples.MigrationListener
    - com.hazelcast.examples.PartitionLostListener
  ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another notable difference between XML and YAML is the lack of the attributes in the
case of YAML. Everything that can be
configured with an attribute in the XML configuration is a scalar node in the YAML
configuration with the same name. See the
following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;multicast enabled="true"&gt;
                &lt;multicast-group&gt;1.2.3.4&lt;/multicast-group&gt;
                &lt;!-- other multicast configuration options --&gt;
            &lt;/multicast&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the identical YAML configuration, the <code>enabled</code> attribute of the XML
configuration is a scalar node on the same level with
the other items of the multicast configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  ...
  network:
    join:
      multicast:
        enabled: true
        multicast-group: 1.2.3.4
        # other multicast configuration options
  ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can refer to the full example YAML configuration files placed in the <code>/bin</code> folder
of the downloadable <code>hazelcast-4.1.zip</code> after unzipping it. Please see the
complete list of the full example YAML configurations <a href="#configuring-declaratively">here</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-programmatically"><a class="anchor" href="#configuring-programmatically"></a>5.2. Configuring Programmatically</h3>
<div class="paragraph">
<p>Besides declarative configuration, you can configure your cluster programmatically.
For this you can create a <code>Config</code> object, set/change its properties and attributes
and use this <code>Config</code> object to create a new Hazelcast member. Following is an example
code which configures some network and Hazelcast Map properties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        config.getNetworkConfig().setPort( 5900 )
                .setPortAutoIncrement( false );

        MapConfig mapConfig = new MapConfig();
        mapConfig.setName( "testMap" )
                .setBackupCount( 2 )
                .setTimeToLiveSeconds( 300 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create a Hazelcast member with the above example configuration, pass the
configuration object as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance( config );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>Config</code> must not be modified after the Hazelcast instance is started.
In other words, all configuration must be completed before creating the <code>HazelcastInstance</code>.
Certain additional configuration elements can be added at runtime as described in the
<a href="#dynamically-adding-data-structure-configuration-on-a-cluster">Dynamically Adding Data Structure Configuration on a Cluster section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also create a named Hazelcast member. In this case, you should set <code>instanceName</code>
of <code>Config</code> object as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.setInstanceName( "my-instance" );
Hazelcast.newHazelcastInstance( config );</code></pre>
</div>
</div>
<div class="paragraph">
<p>To retrieve an existing Hazelcast member by its name, use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Hazelcast.getHazelcastInstanceByName( "my-instance" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>To retrieve all existing Hazelcast members, use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Hazelcast.getAllHazelcastInstances();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hazelcast performs schema validation through the file <code>hazelcast-config-4.1.xsd</code>
which comes with your Hazelcast libraries. Hazelcast throws a meaningful exception if there
is an error in the declarative or programmatic configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to specify your own configuration file to create <code>Config</code>, Hazelcast supports
several ways including filesystem,
classpath, InputStream and URL.</p>
</div>
<div class="paragraph">
<p>Building <code>Config</code> from the XML declarative configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Config cfg = new XmlConfigBuilder(xmlFileName).build();</code></p>
</li>
<li>
<p><code>Config cfg = new XmlConfigBuilder(inputStream).build();</code></p>
</li>
<li>
<p><code>Config cfg = new ClasspathXmlConfig(xmlFileName);</code></p>
</li>
<li>
<p><code>Config cfg = new FileSystemXmlConfig(configFilename);</code></p>
</li>
<li>
<p><code>Config cfg = new UrlXmlConfig(url);</code></p>
</li>
<li>
<p><code>Config cfg = new InMemoryXmlConfig(xml);</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Building <code>Config</code> from the YAML declarative configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Config cfg = new YamlConfigBuilder(yamlFileName).build();</code></p>
</li>
<li>
<p><code>Config cfg = new YamlConfigBuilder(inputStream).build();</code></p>
</li>
<li>
<p><code>Config cfg = new ClasspathYamlConfig(yamlFileName);</code></p>
</li>
<li>
<p><code>Config cfg = new FileSystemYamlConfig(configFilename);</code></p>
</li>
<li>
<p><code>Config cfg = new UrlYamlConfig(url);</code></p>
</li>
<li>
<p><code>Config cfg = new InMemoryYamlConfig(yaml);</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="configuring-with-system-properties"><a class="anchor" href="#configuring-with-system-properties"></a>5.3. Configuring with System Properties</h3>
<div class="paragraph">
<p>You can use system properties to configure some aspects of Hazelcast. You set
these properties as name and value pairs through declarative configuration,
programmatic configuration or JVM system property. Following are examples for
each option.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.property.foo"&gt;value&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
    ...
    properties:
      hazelcast.property.foo: value
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config() ;
config.setProperty( "hazelcast.property.foo", "value" );</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Using JVM&#8217;s <code>System</code> class or <code>-D</code> argument:</strong></p>
</div>
<div class="paragraph">
<p><code>System.setProperty( "hazelcast.property.foo", "value" );</code></p>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="paragraph">
<p><code>java -Dhazelcast.property.foo=value</code></p>
</div>
<div class="paragraph">
<p>You will see Hazelcast system properties mentioned throughout this Reference Manual
as required in some of the chapters and sections. All Hazelcast system properties
are listed in the <a href="#system-properties">System Properties appendix</a> with their
descriptions, default values and property types as a reference for you.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-within-spring-context"><a class="anchor" href="#configuring-within-spring-context"></a>5.4. Configuring within Spring Context</h3>
<div class="paragraph">
<p>If you use Hazelcast with <a href="https://spring.io/" target="_blank" rel="noopener">Spring</a> you can declare beans
using the namespace <code>hazelcast</code>. When you add the namespace declaration to
the element <code>beans</code> in the Spring context file, you can start to use the
namespace shortcut <code>hz</code> to be used as a bean declaration. Following is an
example Hazelcast configuration when integrated with Spring:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:hazelcast id="instance"&gt;
    &lt;hz:config&gt;
        &lt;hz:cluster-name name="dev"/&gt;
        &lt;hz:network port="5701" port-auto-increment="false"&gt;
            &lt;hz:join&gt;
                &lt;hz:multicast enabled="false"/&gt;
                &lt;hz:tcp-ip enabled="true"&gt;
                    &lt;hz:members&gt;10.10.1.2, 10.10.1.3&lt;/hz:members&gt;
                &lt;/hz:tcp-ip&gt;
            &lt;/hz:join&gt;
        &lt;/hz:network&gt;
    &lt;/hz:config&gt;
&lt;/hz:hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#integration-with-spring">Integration with Spring section</a> for
more information on Hazelcast-Spring integration.</p>
</div>
</div>
<div class="sect2">
<h3 id="overriding-configuration"><a class="anchor" href="#overriding-configuration"></a>5.5. Overriding Configuration</h3>
<div class="paragraph">
<p>You can override your clusters' configurations
without having to modify the XML or YAML configuration files.
Hazelcast makes this possible using the system properties or
environment variables.</p>
</div>
<div class="paragraph">
<p>For example, if you just want to override <code>cluster-name</code>,
you would need to craft a declarative configuration as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name name="dev"/&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cluster-name: dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of the above, you can achieve the same purpose using
the following on the command line:</p>
</div>
<div class="listingblock primary">
<div class="title">Using Environment Variable</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">export HZ_CLUSTERNAME=dev</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Using System Property</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">java -Dhz.cluster-name=value</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recognized and unrecognized configuration entries will be logged when Hazelcast starts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The above mechanism exists mostly for the sake of trivial
environment specific configuration changes, and should not be treated
as a replacement for complex XML/YAML configuration files.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_conversion_rules"><a class="anchor" href="#_conversion_rules"></a>5.5.1. Conversion Rules</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All entries need to mirror YAML configuration structure which differs slightly from XML&#8217;s.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to make Hazelcast recognize environment variables
as valid configuration entries, they need to obey the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each configuration entry needs to start with <code>HZ_</code> or <code>HZ_CLIENT_</code>.</p>
</li>
<li>
<p>A new configuration level should be introduced with an underscore (<code>_</code>).</p>
</li>
<li>
<p>Dashes (<code>-</code>) should be removed.</p>
</li>
<li>
<p>Variable names should be in upper case.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Assume that you want to have the following configuration for
your cluster, represented as YAML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  cluster-name: dev
  network:
    port:
      auto-increment: true
      port-count: 100
      port: 5701
    join:
      auto-detection:
        enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to use the environment variables, the above
would be represented as a set of the following environment variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">HZ_CLUSTERNAME=dev
HZ_NETWORK_PORT_AUTOINCREMENT=true
HZ_NETWORK_PORT_PORTCOUNT=100
HZ_NETWORK_PORT_PORT=5701
HZ_NETWORK_JOIN_AUTODETECTION_ENABLED=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to make Hazelcast recognize system properties
as valid configuration entries, they need to obey the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each configuration entry needs to start with <code>hz.</code> or <code>hz-client.</code>.</p>
</li>
<li>
<p>A new configuration level should be introduced with an underscore (<code>_</code>).</p>
</li>
<li>
<p>Variable names should be in lower case.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to use the environment variables, the above YAML
configuration would be represented as a set of the following system
properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">hz.cluster-name=dev
hz.network.port.auto-increment=true
hz.network.port_port-count=100
hz.network.port_port=5701
hz.network.join-auto-detection-enabled=true</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Keep in mind that it&#8217;s not possible to override
configuration entries using YAML sequences.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamically-adding-data-structure-configuration-on-a-cluster"><a class="anchor" href="#dynamically-adding-data-structure-configuration-on-a-cluster"></a>5.6. Dynamically Adding Data Structure Configuration on a Cluster</h3>
<div class="paragraph">
<p>As described above, Hazelcast can be configured in a declarative or
programmatic way; configuration must be completed before starting a
Hazelcast member and this configuration cannot be altered at runtime,
thus we refer to this as <em>static</em> configuration.</p>
</div>
<div class="paragraph">
<p>It is possible to dynamically add configuration for certain data structures at
runtime; these can be added by invoking one of the <code>Config.add*Config</code> methods on
the <code>Config</code> object obtained from a running member&#8217;s <code>HazelcastInstance.getConfig()</code> method.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        MapConfig mapConfig = new MapConfig("sessions");
        config.addMapConfig(mapConfig);
        HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);
        MapConfig noBackupsMap = new MapConfig("dont-backup").setBackupCount(0);
        instance.getConfig().addMapConfig(noBackupsMap);</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
You must invoke the <code>add*Config</code> method on the Hazelcast instance&#8217;s configuration object to
add a configuration dynamically. In the above example, this is done with the
<code>instance.getConfig().addMapConfig(noBackupsMap);</code> line. This submits the map configuration dynamically
to all cluster members and also to members which join the cluster later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Dynamic configuration elements must be fully configured before the invocation
of <code>add*Config</code> method: at that point, the configuration object is delivered
to every member of the cluster and added to each member&#8217;s dynamic configuration,
so mutating the configuration object after the <code>add*Config</code> invocation does not have
an effect.</p>
</div>
<div class="paragraph">
<p>As dynamically added data structure configuration is propagated across all cluster
members, failures may occur due to conditions such as timeout and network partition.
The configuration propagation mechanism internally retries adding the configuration
whenever a membership change is detected. However if an exception is thrown from
<code>add*Config</code> method, the configuration may have been partially propagated to some
cluster members and adding the configuration should be retried by the user.</p>
</div>
<div class="paragraph">
<p>Adding a new dynamic configuration is supported for all <code>add*Config</code> methods except the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SplitBrainProtectionConfig</code>: A new split-brain protection configuration cannot be dynamically added but other
configuration can reference split-brain protections configured in the existing static configuration.</p>
</li>
<li>
<p><code>WanReplicationConfig</code>: A new WAN replication configuration cannot be dynamically
added, however existing static ones can be referenced from other configurations,
e.g., a new dynamic <code>MapConfig</code> may include a <code>WanReplicationRef</code> to a statically
configured WAN replication.</p>
</li>
<li>
<p><code>ListenerConfig</code>: Listeners can be instead added at runtime via other API such as
<code>HazelcastInstance.getCluster().addMembershipListener</code> and
<code>HazelcastInstance.getPartitionService().addMigrationListener</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Keep in mind that this feature also works for Hazelcast Java clients.
See the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance client = HazelcastClient.newHazelcastClient();
MapConfig mCfg = new MapConfig("test");
mCfg.setTimeToLiveSeconds(15);
client.getConfig().addMapConfig(mCfg);
HazelcastClient.shutdownAll();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If your cluster has data structures with configurations added during runtime,
those configurations are lost when a cluster restart occurs due to any reason since
they are not persisted. This will be improved in future Hazelcast IMDG releases.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="handling-configuration-conflicts"><a class="anchor" href="#handling-configuration-conflicts"></a>5.6.1. Handling Configuration Conflicts</h4>
<div class="paragraph">
<p>Attempting to add a dynamic configuration, when a static configuration for
the same element already exists, throws <code>InvalidConfigurationException</code>. For example,
assuming we start a member with the following fragment in <code>hazelcast.xml</code> configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="sessions"&gt;
        ...
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then adding a dynamic configuration for a map with the name <code>sessions</code> throws
a <code>InvalidConfigurationException</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance instance = Hazelcast.newHazelcastInstance();

MapConfig sessionsMapConfig = new MapConfig("sessions");

// this will throw ConfigurationException:
instance.getConfig().addMapConfig(sessionsMapConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When attempting to add dynamic configuration for an element for which dynamic
configuration has already been added, then if a configuration conflict is detected
a <code>InvalidConfigurationException</code> is thrown. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance instance = Hazelcast.newHazelcastInstance();

MapConfig sessionsMapConfig = new MapConfig("sessions").setBackupCount(0);
instance.getConfig().addMapConfig(sessionsMapConfig);

MapConfig sessionsWithBackup = new MapConfig("sessions").setBackupCount(1);
// throws ConfigurationException because the new MapConfig conflicts with existing one
instance.getConfig().addMapConfig(sessionsWithBackup);

MapConfig sessionsWithoutBackup = new MapConfig("sessions").setBackupCount(0);
// does not throw exception: new dynamic config is equal to existing dynamic config of same name
instance.getConfig().addMapConfig(sessionsWithoutBackup);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dynamic_data_structure_configuration_and_user_customizations"><a class="anchor" href="#_dynamic_data_structure_configuration_and_user_customizations"></a>5.6.2. Dynamic Data Structure Configuration and User Customizations</h4>
<div class="paragraph">
<p>Dynamically added data structure configuration may reference
user customizations, such as a user-provided <code>MapLoader</code> implementation referenced
by a <code>MapConfig</code>. User customizations can be usually configured using either of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by specifying a class or factory class name, e.g., <code>MapStoreConfig.setClassName</code>, and letting the
Hazelcast members instantiate the object</p>
</li>
<li>
<p>by providing an existing instance, e.g., <code>MapStoreConfig.setImplementation</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When dynamically adding new a data structure configuration with user customizations,
take the following considerations into account:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For the user customizations submitted as a class name or factory class name, the referenced
classes are resolved  lazily. Therefore, they should be either already on each member&#8217;s local
classpath or resolvable via <a href="#member-user-code-deployment">user code deployment</a>.</p>
</li>
<li>
<p>When the user customizations are submitted as instances (or similarly factory instances),
the instances themselves have to be serializable. This is because the entire configuration needs
to be sent over the network to all cluster members, and their classes have to be available
on each member&#8217;s local classpath.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="checking-configuration"><a class="anchor" href="#checking-configuration"></a>5.7. Checking Configuration</h3>
<div class="paragraph">
<p>When you start a Hazelcast member without passing a <code>Config</code> object, as explained
in the <a href="#configuring-programmatically">Configuring Programmatically section</a>,
Hazelcast checks the member&#8217;s configuration as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, it looks for the <code>hazelcast.config</code> system property. If it is set, its
value is used as the path. This is useful if you want to be able to change your
Hazelcast configuration; you can do this because it is not embedded within the
application. You can set the <code>config</code> option with the following command:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.config=`*`&lt;path to the hazelcast.xml or hazelcast.yaml&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The suffix of the filename is used to determine the language of the configuration.
If the suffix is <code>.xml</code> the
configuration file is parsed as an
XML configuration file. If it is <code>.yaml</code>, the configuration file is parsed as a
YAML configuration file.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The path can be a regular one or a classpath reference with the prefix <code>classpath:</code>.</p>
</div>
</li>
<li>
<p>If the above system property is not set, Hazelcast then checks whether there is
a <code>hazelcast.xml</code> file in the working directory.</p>
</li>
<li>
<p>If not, it then checks whether <code>hazelcast.xml</code> exists on the classpath.</p>
</li>
<li>
<p>If not, it then checks whether <code>hazelcast.yaml</code> (or <code>.yml</code>) exists in the working directory.</p>
</li>
<li>
<p>If not, it then checks whether <code>hazelcast.yaml</code> (or <code>.yml</code>) exists on the classpath.</p>
</li>
<li>
<p>If none of the above works, Hazelcast loads the default configuration
(<code>hazelcast.xml</code>) that comes with your Hazelcast package.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before configuring Hazelcast, please try to work with the default configuration
to see if it works for you. This default configuration should be fine for most of
the users. If not, you can consider to modify the configuration to be more suitable
for your environment.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-pattern-matcher"><a class="anchor" href="#configuration-pattern-matcher"></a>5.8. Configuration Pattern Matcher</h3>
<div class="paragraph">
<p>You can give a custom strategy to match an item name to a configuration pattern. By
default Hazelcast uses a simplified wildcard matching. See <a href="#using-wildcards">Using Wildcards section</a>
for this.
A custom configuration pattern matcher can be given by using either member or client <code>config</code>
objects, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Setting a custom config pattern matcher via member config object
Config config = new Config();
config.setConfigPatternMatcher(new ExampleConfigPatternMatcher());</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following is an example pattern matcher:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ExampleConfigPatternMatcher extends MatchingPointConfigPatternMatcher {

    @Override
    public String matches(Iterable&lt;String&gt; configPatterns, String itemName) throws InvalidConfigurationException {
        String matches = super.matches(configPatterns, itemName);
        if (matches == null) throw new InvalidConfigurationException("No config found for " + itemName);
        return matches;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-wildcards"><a class="anchor" href="#using-wildcards"></a>5.9. Using Wildcards</h3>
<div class="paragraph">
<p>Hazelcast supports wildcard configuration for all distributed data structures that
can be configured using <code>Config</code>, that is, for all except <code>IAtomicLong</code>,
<code>IAtomicReference</code>. Using an asterisk (*) character in the name, different
instances of maps, queues, topics, semaphores, etc. can be configured by a
single configuration.</p>
</div>
<div class="paragraph">
<p>A single asterisk (*) can be placed anywhere inside the configuration name.</p>
</div>
<div class="paragraph">
<p>For instance, a map named <code>com.hazelcast.test.mymap</code> can be configured using
one of the following configurations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="com.hazelcast.test.*"&gt;
        ...
    &lt;/map&gt;

    &lt;!-- OR --&gt;

    &lt;map name="com.hazel*"&gt;
        ...
    &lt;/map&gt;

    &lt;!-- OR --&gt;

    &lt;map name="*.test.mymap"&gt;
        ...
    &lt;/map&gt;

    &lt;!-- OR --&gt;

    &lt;map name="com.*test.mymap"&gt;
        ...
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A queue named <code>com.hazelcast.test.myqueue</code> can be configured using one
of the following configurations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;queue name="*hazelcast.test.myqueue"&gt;
        ...
    &lt;/queue&gt;

    &lt;!-- OR --&gt;

    &lt;queue name="com.hazelcast.*.myqueue"&gt;
        ...
    &lt;/queue&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>You can use only a single asterisk as a wildcard for each data
structure configuration.</p>
</li>
<li>
<p>If you have matching wildcard configurations for a data structure,
the most specific (longest) one is used when configuring it. Let&#8217;s say
you have a map named <code>mymap.customer.name</code> and you have map configurations
<code>mymap.*</code> and <code>mymap.customer.*</code>. Hazelcast uses <code>mymap.customer.*</code> to
configure this map.</p>
<div class="paragraph">
<p>As another example, assume that you have a map named <code>mymap.customer.name</code>, and
map configurations <code>mymap.*.name</code> and <code>mymap.customer.*</code>. Hazelcast uses <code>mymap.customer.*</code>
to configure this map. As you see, the longest character length before the asterisk makes
it the most specific, so it wins the configuration.</p>
</div>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="using-variables"><a class="anchor" href="#using-variables"></a>5.10. Using Variables</h3>
<div class="paragraph">
<p>In your Hazelcast and/or Hazelcast Client declarative configuration, you can use
variables to set the values of the elements. This is valid when you set a system
property programmatically or you use the command line interface. You can use a variable
in the declarative configuration to access the values of the system properties you set.</p>
</div>
<div class="paragraph">
<p>For example, see the following command that sets two system properties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dcluster.name=dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s get the values of these system properties in the declarative
configuration (XML/YAML) of Hazelcast, as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name&gt;${cluster.name}&lt;/cluster-name&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cluster-name: ${cluster.name}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This also applies to the declarative configuration of Hazelcast Java Client,
as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    &lt;cluster-name&gt;${cluster.name}&lt;/cluster-name&gt;
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  cluster-name: ${cluster.name}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not want to rely on the system properties, you can use the
<code>XmlConfigBuilder</code> or <code>YamlConfigBuilder</code> and explicitly
set a <code>Properties</code> instance, as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Properties properties = new Properties();

// fill the properties, e.g., from database/LDAP, etc.

XmlConfigBuilder builder = new XmlConfigBuilder();
builder.setProperties(properties);
Config config = builder.build();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="variable-replacers"><a class="anchor" href="#variable-replacers"></a>5.11. Variable Replacers</h3>
<div class="paragraph">
<p>Variable replacers are used to replace custom strings during loading the configuration,
e.g., they can be used to mask sensitive information such as usernames and passwords.
Of course their usage is not limited to security related information.</p>
</div>
<div class="paragraph">
<p>Variable replacers implement the interface <code>com.hazelcast.config.replacer.spi.ConfigReplacer</code>
and they are configured only
declaratively: in the Hazelcast&#8217;s declarative configuration files, i.e.,
<code>hazelcast.xml</code>, <code>hazelcast.yaml</code> and <code>hazelcast-client
.xml</code>, <code>hazelcast-client.yaml</code>. See the <code>ConfigReplacer</code>s
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/replacer/spi/ConfigReplacer.html" target="_blank" rel="noopener">Javadoc</a>
for basic information on how a replacer works.</p>
</div>
<div class="paragraph">
<p>Variable replacers are configured within the element <code>&lt;config-replacers&gt;</code> under <code>&lt;hazelcast&gt;</code>,
as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;config-replacers fail-if-value-missing="false"&gt;
        &lt;replacer class-name="com.acme.MyReplacer"&gt;
            &lt;properties&gt;
                &lt;property name="propName"&gt;value&lt;/property&gt;
                ...
            &lt;/properties&gt;
        &lt;/replacer&gt;
        &lt;replacer class-name="example.AnotherReplacer"/&gt;
    &lt;/config-replacers&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
    ...
    config-replacers:
      fail-if-value-missing: false
      replacers:
        - class-name: com.acme.MyReplacer
          properties:
            propName: value
            ...
        - class-name: example.AnotherReplacer
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, <code>&lt;config-replacers&gt;</code> is the parent element for your replacers,
which are declared using the <code>&lt;replacer&gt;</code> sub-elements. You can define multiple
replacers under the <code>&lt;config-replacers&gt;.</code> Here are the descriptions of elements
and attributes used for the replacer configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fail-if-value-missing</code>: Specifies whether the loading configuration process
stops when a replacement value is missing. It is an optional attribute and its default value is true.</p>
</li>
<li>
<p><code>class-name</code>: Full class name of the replacer.</p>
</li>
<li>
<p><code>&lt;properties&gt;</code>: Contains names and values of the properties used to configure a replacer.
Each property is defined using the <code>&lt;property&gt;</code> sub-element. All of the properties are
explained in the upcoming sections.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following replacer classes are provided by Hazelcast as example implementations of
the <code>ConfigReplacer</code> interface. Note that you can also implement your own replacers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EncryptionReplacer</code></p>
</li>
<li>
<p><code>PropertyReplacer</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is also a <code>ExecReplacer</code> which runs an external command and uses its
standard output as the value for the variable. See its
<a href="https://github.com/hazelcast/hazelcast-code-samples/blob/master/variable-replacers/src/main/java/com/hazelcast/sample/replacer/ExecReplacer.java" target="_blank" rel="noopener">code sample</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each example replacer is explained in the below sections.</p>
</div>
<div class="sect3">
<h4 id="_encryptionreplacer"><a class="anchor" href="#_encryptionreplacer"></a>5.11.1. EncryptionReplacer</h4>
<div class="paragraph">
<p>This example <code>EncryptionReplacer</code> replaces encrypted variables by its plain
form. The secret key for encryption/decryption is generated from a password
which can be a value in a file and/or environment specific values, such as MAC
address and actual user data.</p>
</div>
<div class="paragraph">
<p>Its full class name is <code>com.hazelcast.config.replacer.EncryptionReplacer</code> and
the replacer prefix is <code>ENC</code>. The following are the properties used to
configure this example replacer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cipherAlgorithm</code>: Cipher algorithm used for the encryption/decryption.
Its default value is AES.</p>
</li>
<li>
<p><code>keyLengthBits</code>: Length of the secret key to be generated in bits. Its default value is 128 bits.</p>
</li>
<li>
<p><code>passwordFile</code>: Path to a file whose content should be used as a part
of the encryption password. When the property is not provided no file is
used as a part of the password. Its default value is null.</p>
</li>
<li>
<p><code>passwordNetworkInterface</code>: Name of network interface whose MAC address
should be used as a part of the encryption password. When the property is
not provided no network interface property is used as a part of the password.
Its default value is null.</p>
</li>
<li>
<p><code>passwordUserProperties</code>: Specifies whether the current user properties
(<code>user.name</code> and <code>user.home</code>) should be used as a part of the encryption
password. Its default value is true.</p>
</li>
<li>
<p><code>saltLengthBytes</code>: Length of a random password salt in bytes. Its default
value is 8 bytes.</p>
</li>
<li>
<p><code>secretKeyAlgorithm</code>:  Name of the secret-key algorithm to be associated
with the generated secret key. Its default value is AES.</p>
</li>
<li>
<p><code>secretKeyFactoryAlgorithm</code>: Algorithm used to generate a secret key from
a password. Its default value is PBKDF2WithHmacSHA256.</p>
</li>
<li>
<p><code>securityProvider</code>: Name of a Java Security Provider to be used for retrieving
the configured secret key factory and the cipher. Its default value is null.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Older Java versions may not support all the algorithms used as defaults.
Please use the property values supported your Java version.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As a usage example, let&#8217;s create a password file and generate the encrypted
string out of this file as instructed below:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create the password file: <code>echo '/Za-uG3dDfpd,5.-' &gt; /opt/master-password</code></p>
</li>
<li>
<p>Define the encrypted variables:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>java -cp hazelcast-*.jar \
    -DpasswordFile=/opt/master-password \
    -DpasswordUserProperties=false \
    com.hazelcast.config.replacer.EncryptionReplacer \
    "aCluster"
$ENC{Gw45stIlan0=:531:yVN9/xQpJ/Ww3EYkAPvHdA==}</code></pre>
</div>
</div>
</li>
<li>
<p>Configure the replacer and put the encrypted variables into the configuration:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;config-replacers&gt;
        &lt;replacer class-name="com.hazelcast.config.replacer.EncryptionReplacer"&gt;
            &lt;properties&gt;
                &lt;property name="passwordFile"&gt;/opt/master-password&lt;/property&gt;
                &lt;property name="passwordUserProperties"&gt;false&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/replacer&gt;
    &lt;/config-replacers&gt;
    &lt;cluster-name&gt;$ENC{Gw45stIlan0=:531:yVN9/xQpJ/Ww3EYkAPvHdA==}&lt;/cluster-name&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>Check if the decryption works:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>java -jar hazelcast-*.jar
Apr 06, 2018 10:15:43 AM com.hazelcast.config.XmlConfigLocator
INFO: Loading 'hazelcast.xml' from working directory.
Apr 06, 2018 10:15:44 AM com.hazelcast.instance.AddressPicker
INFO: [LOCAL] [aCluster] [3.10-SNAPSHOT] Prefer IPv4 stack is true.</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see in the logs, the correctly decrypted cluster name value
("aCluster") is used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_propertyreplacer"><a class="anchor" href="#_propertyreplacer"></a>5.11.2. PropertyReplacer</h4>
<div class="paragraph">
<p>The <code>PropertyReplacer</code> replaces variables by properties with the given
name. Usually the system properties are used, e.g., <code>${user.name}</code>.
There is no need to define it in the declarative configuration files.</p>
</div>
<div class="paragraph">
<p>Its full class name is <code>com.hazelcast.config.replacer.PropertyReplacer</code>
and the replacer prefix is empty string ("").</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_custom_replacers"><a class="anchor" href="#_implementing_custom_replacers"></a>5.11.3. Implementing Custom Replacers</h4>
<div class="paragraph">
<p>You can also provide your own replacer implementations. All replacers
have to implement the interface <code>com.hazelcast.config.replacer.spi.ConfigReplacer</code>.
A simple snippet is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ConfigReplacer {
    void init(Properties properties);
    String getPrefix();
    String getReplacement(String maskedValue);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-up-clusters"><a class="anchor" href="#setting-up-clusters"></a>6. Setting Up Clusters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes Hazelcast clusters and the methods
cluster members and native clients use to form a Hazelcast cluster.</p>
</div>
<div class="sect2">
<h3 id="discovery-mechanisms"><a class="anchor" href="#discovery-mechanisms"></a>6.1. Discovery Mechanisms</h3>
<div class="paragraph">
<p>A Hazelcast cluster is a network of cluster members that run Hazelcast.
Cluster members  automatically join together to form a cluster. This automatic
joining takes place with various discovery mechanisms that the cluster members
use to find each other.</p>
</div>
<div class="paragraph">
<p>Please note that, after a cluster is formed, communication between cluster members
is always via TCP/IP, regardless of the discovery mechanism used.</p>
</div>
<div class="paragraph">
<p>Hazelcast uses the following discovery mechanisms.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="https://hazelcast.com/resources/hazelcast-deployment-operations-guide/" target="_blank" rel="noopener">Hazelcast IMDG Deployment and Operations Guide</a>
for advices on the best discovery mechanism to use.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="auto-detection"><a class="anchor" href="#auto-detection"></a>6.1.1. Auto Detection</h4>
<div class="paragraph">
<p>By default, Hazelcast tries to automatically detect the applicable discovery mechanism based on the runtime environment.</p>
</div>
<div class="paragraph">
<p>Note that using Auto Detection is not recommended for production. Note also that if Hazelcast finds no applicable
discovery mechanism, then it falls back to <a href="#multicast">Multicast</a>.</p>
</div>
<div class="paragraph">
<p>See the <a href="#discovering-members-auto-detection">Discovering Members by Auto Detection section</a> for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="tcp"><a class="anchor" href="#tcp"></a>6.1.2. TCP</h4>
<div class="paragraph">
<p>You can configure Hazelcast to be a full TCP/IP cluster. See the
<a href="#discovering-members-by-tcp">Discovering Members by TCP section</a> for configuration details.</p>
</div>
</div>
<div class="sect3">
<h4 id="multicast"><a class="anchor" href="#multicast"></a>6.1.3. Multicast</h4>
<div class="paragraph">
<p>Multicast mechanism is not recommended for production since UDP is often
blocked in production environments and other discovery mechanisms are more definite.</p>
</div>
<div class="paragraph">
<p>With this mechanism, Hazelcast allows cluster members to find each other
using multicast communication. See the
<a href="#discovering-members-by-multicast">Discovering Members by Multicast section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="aws-cloud-discovery"><a class="anchor" href="#aws-cloud-discovery"></a>6.1.4. AWS Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast supports EC2/ECS auto-discovery. It is useful when you
do not want to provide or you cannot provide the list of possible
IP addresses. See the <a href="#hazelcast-cloud-discovery-plugins-aws">Cloud Discovery Plugins: Hazelcast AWS section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="azure-cloud-discovery"><a class="anchor" href="#azure-cloud-discovery"></a>6.1.5. Azure Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast offers a discovery strategy for your Hazelcast applications
running on Azure. See the <a href="#hazelcast-cloud-discovery-plugins-azure">Cloud Discovery Plugins: Hazelcast Azure section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gcp-cloud-discovery"><a class="anchor" href="#gcp-cloud-discovery"></a>6.1.6. GCP Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast supports discovering members in the <a href="https://cloud.google.com/compute/" target="_blank" rel="noopener">GCP Compute Engine</a>
environment. You can easily configure Hazelcast members discovery, WAN replication,
and Hazelcast Client to work seamlessly on the native GCP VM Instances.
This discovery feature is provided as a Hazelcast plugin.
See the <a href="#hazelcast-cloud-discovery-plugins-gcp">Cloud Discovery Plugins: Hazelcast GCP section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="kubernetes-cloud-discovery"><a class="anchor" href="#kubernetes-cloud-discovery"></a>6.1.7. Kubernetes Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast provides Kubernetes discovery mechanism that looks for IP addresses of members.
See the <a href="#hazelcast-cloud-discovery-plugins-kubernetes">Cloud Discovery Plugins: Hazelcast Kubernetes section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="eureka-cloud-discovery"><a class="anchor" href="#eureka-cloud-discovery"></a>6.1.8. Eureka Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast supports the Eureka V1 discovery.
See the <a href="#hazelcast-cloud-discovery-plugins-eureka">Cloud Discovery Plugins: Hazelcast Eureka section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="zookeeper-cloud-discovery"><a class="anchor" href="#zookeeper-cloud-discovery"></a>6.1.9. Zookeeper Cloud Discovery</h4>
<div class="paragraph">
<p>This discovery mechanism provides a service based discovery strategy by using
Apache Curator to communicate with your Zookeeper server.
See the <a href="#hazelcast-cloud-discovery-plugins-zookeeper">Cloud Discovery Plugins: Hazelcast Zookeeper section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="hazelcast-for-pcf"><a class="anchor" href="#hazelcast-for-pcf"></a>6.1.10. Hazelcast for Tanzu VMware</h4>
<div class="paragraph">
<p>Using a clickable Hazelcast Tile for VMWare (former Pivotal Cloud Foundry), you can
deploy your Hazelcast cluster on PCF. This feature is provided as a Hazelcast
plugin.
See the <a href="#deploying-on-pivotal-cloud-foundry">Deploying in VMware Tanzu section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="discovering-members-auto-detection"><a class="anchor" href="#discovering-members-auto-detection"></a>6.2. Discovering Members by Auto Detection</h3>
<div class="paragraph">
<p>Auto Detection is a good way to start playing with Hazelcast. It tries to automatically detect the appropriate
discovery plugin and apply it to your Hazelcast configuration. Assuming you have <code>hazelcast-all</code>
on your classpath and your runtime is Kubernetes, Hazelcast automatically applies
the <a href="#kubernetes-cloud-discovery">Kubernetes discovery mechanism</a>.</p>
</div>
<div class="paragraph">
<p>Below is a table with minimal requirements for each environment.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Environment Requirements</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 71.4286%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Environment</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Requirements</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-cloud-discovery-plugins-aws">AWS</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>AWS EC2 requires the following points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Security Group with the port 5701 open</p>
</li>
<li>
<p>IAM role with the <code>ec2:DescribeInstances</code> permission attached to the EC2 Instance</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-cloud-discovery-plugins-azure">Azure</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Azure requires having Azure managed identity with the <code>READ</code> role attached to your Azure Virtual Machine.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-cloud-discovery-plugins-gcp">GCP</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>GCP requires having Cloud API (at minimum Read Only to Compute Engine API) access attached to your VM Instance.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-cloud-discovery-plugins-kubernetes">Kubernetes</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Kubernetes requires applying the
<a href="https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml" target="_blank" rel="noopener">RBAC permissions</a>.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="discovering-members-by-tcp"><a class="anchor" href="#discovering-members-by-tcp"></a>6.3. Discovering Members by TCP</h3>
<div class="paragraph">
<p>If multicast is not the preferred way of discovery for your environment,
then you can configure Hazelcast to be a full TCP/IP cluster. When you configure
Hazelcast to discover members by TCP/IP, you must list all or a subset of the members'
host names and/or IP addresses as cluster members. You do not have to list all of these
cluster members, but at least one of the listed members has to be active in the cluster
when a new member joins.</p>
</div>
<div class="paragraph">
<p>To configure your Hazelcast to be a full TCP/IP cluster, set the following
configuration elements. See the <a href="#tcp-ip-element">tcp-ip element section</a> for the
full descriptions of the TCP/IP discovery configuration elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set the <code>enabled</code> attribute of the <code>tcp-ip</code> element to <code>true</code>.</p>
</li>
<li>
<p>Provide your <code>member</code> elements within the <code>tcp-ip</code> element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;tcp-ip enabled="true"&gt;
                &lt;member&gt;machine1&lt;/member&gt;
                &lt;member&gt;machine2&lt;/member&gt;
                &lt;member&gt;machine3:5799&lt;/member&gt;
                &lt;member&gt;192.168.1.0-7&lt;/member&gt;
                &lt;member&gt;192.168.1.21&lt;/member&gt;
            &lt;/tcp-ip&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    join:
      tcp-ip:
        enabled: true
        member-list:
          - machine1
          - machine2
          - machine3:5799
          - 192.168.1.0-7
          - 192.168.1.21</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown above, you can provide IP addresses or host names for <code>member</code> elements.
You can also give a range of IP addresses, such as <code>192.168.1.0-7</code>.</p>
</div>
<div class="paragraph">
<p>Instead of providing members line-by-line as shown above, you also have the option
to use the <code>members</code> element and write comma-separated IP addresses, as shown below.</p>
</div>
<div class="paragraph">
<p><code>&lt;members&gt;192.168.1.0-7,192.168.1.21&lt;/members&gt;</code></p>
</div>
<div class="paragraph">
<p>If you do not provide ports for the members, Hazelcast automatically tries the
ports 5701, 5702 and so on.</p>
</div>
<div class="paragraph">
<p>By default, Hazelcast binds to all local network interfaces to accept incoming
traffic. You can change this behavior using the system property <code>hazelcast.socket.bind.any</code>.
If you set this property to <code>false</code>, Hazelcast uses the interfaces specified in the <code>interfaces</code>
element (see the <a href="#interfaces">Interfaces Configuration section</a>). If no interfaces are
provided, then it tries to resolve one interface to bind from the <code>member</code> elements.</p>
</div>
</div>
<div class="sect2">
<h3 id="discovering-members-by-multicast"><a class="anchor" href="#discovering-members-by-multicast"></a>6.4. Discovering Members by Multicast</h3>
<div class="paragraph">
<p>With the multicast auto-discovery mechanism, Hazelcast allows cluster members to find
each other using multicast communication. The cluster members do not need to know the
concrete addresses of the other members, as they just multicast to all the other members
for listening. Whether multicast is possible or allowed depends on your environment.</p>
</div>
<div class="paragraph">
<p>To set your Hazelcast to multicast auto-discovery, set the following configuration
elements. See the <a href="#multicast-element">multicast element section</a> for the full
description of the multicast discovery configuration elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set the <code>enabled</code> attribute of the <code>multicast</code> element to <code>true</code>.</p>
</li>
<li>
<p>Set <code>multicast-group</code>, <code>multicast-port</code>, <code>multicast-time-to-live</code>, etc. to your
multicast values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;multicast enabled="true"&gt;
                &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;
                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
                &lt;multicast-time-to-live&gt;32&lt;/multicast-time-to-live&gt;
                &lt;multicast-timeout-seconds&gt;2&lt;/multicast-timeout-seconds&gt;
                &lt;trusted-interfaces&gt;
                    &lt;interface&gt;192.168.1.102&lt;/interface&gt;
                &lt;/trusted-interfaces&gt;
            &lt;/multicast&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    join:
      multicast:
        enabled: true
        multicast-group: 224.2.2.3
        multicast-port: 54327
        multicast-time-to-live: 32
        multicast-timeout-seconds: 2
        trusted-interfaces:
          - 192.168.1.102</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pay attention to the <code>multicast-timeout-seconds</code> element. <code>multicast-timeout-seconds</code>
specifies the time in seconds that a member should wait for a valid multicast
response from another member running in the network before declaring itself the
leader member (the first member joined to the cluster) and creating its own cluster.
This only applies to the startup of members where no leader has been assigned yet. If
you specify a high value to <code>multicast-timeout-seconds</code>, such as 60 seconds, it means
that until a leader is selected, each member waits 60 seconds before moving on. Be careful
when providing a high value. Also, be careful not to set the value too low, or the members
might give up too early and create their own cluster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Multicast auto-discovery is not supported for Hazelcast native clients yet.
However, we offer Multicast Discovery Plugin for this purpose. See the
<a href="#discovering-native-clients">Discovering Native Clients section</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="discovering-native-clients"><a class="anchor" href="#discovering-native-clients"></a>6.5. Discovering Native Clients</h3>
<div class="paragraph">
<p>Hazelcast members and native Java clients can find each other with multicast
discovery plugin. This plugin is implemented using <a href="#discovery-spi">Hazelcast Discovery SPI</a>.
You should configure the plugin both at Hazelcast members and Java clients in order to
use multicast discovery.</p>
</div>
<div class="paragraph">
<p>To configure your cluster to have the multicast discovery plugin, follow
these steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set the <code>enabled</code> attribute of the <code>hazelcast.discovery.enabled</code>
property to <code>true</code>.</p>
</li>
<li>
<p>Add multicast discovery strategy configuration to your XML file,
i.e., <code>&lt;discovery-strategies&gt;</code> element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.discovery.enabled"&gt;true&lt;/property&gt;
    &lt;/properties&gt;
    &lt;network&gt;
        &lt;join&gt;
            &lt;discovery-strategies&gt;
                &lt;discovery-strategy class="com.hazelcast.spi.discovery.multicast.MulticastDiscoveryStrategy" enabled="true"&gt;
                    &lt;properties&gt;
                        &lt;property name="group"&gt;224.2.2.3&lt;/property&gt;
                        &lt;property name="port"&gt;54327&lt;/property&gt;
                    &lt;/properties&gt;
                &lt;/discovery-strategy&gt;
            &lt;/discovery-strategies&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.discovery.enabled: true
  network:
    join:
      discovery-strategies:
        discovery-strategy:
          enabled: true
          class: com.hazelcast.spi.discovery.multicast.MulticastDiscoveryStrategy
          properties:
            group: 224.2.2.3
            port: 54327</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the multicast discovery plugin configuration
properties with their descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>group</code>: String value that is used to set the multicast group,
so that you can isolate your clusters.</p>
</li>
<li>
<p><code>port</code>: Integer value that is used to set the multicast port.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="creating-cluster"><a class="anchor" href="#creating-cluster"></a>6.6. Creating Clusters</h3>
<div class="paragraph">
<p>You can create clusters using the <code>cluster-name</code> configuration
element.</p>
</div>
<div class="paragraph">
<p>You can separate and group your clusters in a simple way by specifying cluster names.
Example groupings can be by <strong>development</strong>, <strong>production</strong>, <strong>test</strong>, <strong>app</strong>, etc.
The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name&gt;production&lt;/cluster-name&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cluster-name: production</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also define the cluster configuration programmatically.
A JVM can host multiple Hazelcast instances. Each Hazelcast instance can only
participate in one group. Each Hazelcast instance only joins to its own group
and does not interact with other groups. The following code example creates
three separate Hazelcast instances--<code>h1</code> belongs to the <code>production</code> cluster,
while <code>h2</code> and <code>h3</code> belong to the <code>development</code> cluster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config configProd = new Config();
        configProd.setClusterName( "production" );

        Config configDev = new Config();
        configDev.setClusterName( "development" );

        HazelcastInstance h1 = Hazelcast.newHazelcastInstance( configProd );
        HazelcastInstance h2 = Hazelcast.newHazelcastInstance( configDev );
        HazelcastInstance h3 = Hazelcast.newHazelcastInstance( configDev );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="member-user-code-deployment"><a class="anchor" href="#member-user-code-deployment"></a>6.7. Deploying User Code on the Member</h3>
<div class="paragraph">
<p>Hazelcast can dynamically load your custom classes or domain classes from other
members. A <a href="#enabling-lite-members">lite member</a> can be designated as a <em>class
repository</em>, but any member can <em>provide</em> classes to other members. For this
purpose Hazelcast offers a distributed dynamic class loader.</p>
</div>
<div class="paragraph">
<p>The following is a brief working mechanism of the User Code Deployment feature:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A new dynamic class loader is created to handle each operation.</p>
</li>
<li>
<p>It first checks locally available classes, i.e. the member&#8217;s classpath. If
the class is found, it is used.</p>
</li>
<li>
<p>Then it checks the <em>cache</em> of classes loaded from remote members or clients
(if caching is enabled on your local member, see the
<a href="#configuring-user-code-deployment">Configuring User Code Deployment</a> section). If your class is found there, it
is used.</p>
</li>
<li>
<p>Finally, the dynamic class loader checks configured remote members, one by
one. If some member returns the class, it will be used. It can also put this
class into the local class cache as mentioned in the previous step.</p>
</li>
<li>
<p>If the class is not found, <code>ClassNotFoundException</code> is thrown.</p>
</li>
<li>
<p>The dynamic class loader is released after the operation is handled. A next
operation will load the class from the cache or re-fetch it.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using the user code deployment feature is a fit for your functional objects
like <code>Runnable</code>, <code>Callable</code> and <code>EntryProcessor</code>.
For the domain objects, we recommend you to use the
<a href="#accessing-domain-objects-without-domain-classes">generic object interface</a> (<code>GenericRecord</code>).
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-user-code-deployment"><a class="anchor" href="#configuring-user-code-deployment"></a>6.7.1. Configuring User Code Deployment</h4>
<div class="paragraph">
<p>User Code Deployment feature is not enabled by default. You can control local
caching of the classes loaded from other members, control classes to be
provided to other members and create blacklists and whitelists of classes and
packages.</p>
</div>
<div class="paragraph">
<p>Following are example configuration snippets:</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;user-code-deployment enabled="true"&gt;
        &lt;class-cache-mode&gt;ETERNAL&lt;/class-cache-mode&gt;
        &lt;provider-mode&gt;LOCAL_AND_CACHED_CLASSES&lt;/provider-mode&gt;
        &lt;blacklist-prefixes&gt;com.foo,com.bar&lt;/blacklist-prefixes&gt;
        &lt;whitelist-prefixes&gt;com.bar.MyClass&lt;/whitelist-prefixes&gt;
        &lt;provider-filter&gt;HAS_ATTRIBUTE:lite&lt;/provider-filter&gt;
    &lt;/user-code-deployment&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  user-code-deployment:
    enabled: true
    class-cache-mode: ETERNAL
    provider-mode: LOCAL_AND_CACHED_CLASSES
    blacklist-prefixes: com.foo,com.bar
    whitelist-prefixes: com.bar.MyClass
    provider-filter: HAS_ATTRIBUTE:lite</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        UserCodeDeploymentConfig distCLConfig = config.getUserCodeDeploymentConfig();
        distCLConfig.setEnabled( true )
                .setClassCacheMode( UserCodeDeploymentConfig.ClassCacheMode.ETERNAL )
                .setProviderMode( UserCodeDeploymentConfig.ProviderMode.LOCAL_AND_CACHED_CLASSES )
                .setBlacklistedPrefixes( "com.foo,com.bar" )
                .setWhitelistedPrefixes( "com.bar.MyClass" )
                .setProviderFilter( "HAS_ATTRIBUTE:lite" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>User Code Deployment on the member has the following configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether dynamic class loading is enabled or not. Its
default value is "false" and it&#8217;s a mandatory attribute. If feature is
disabled, the member will never load classes from other members or clients.</p>
</li>
<li>
<p><code>&lt;class-cache-mode&gt;</code>: Controls the local caching behavior for the classes
loaded from remote members (classes loaded from clients are always cached).
Available values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>ETERNAL</code>: Cache the loaded classes locally. This is the default value and
suitable when you load long-living objects, such as domain objects stored in a map.</p>
</li>
<li>
<p><code>OFF</code>: Do not cache the loaded classes locally. It is suitable for loading
runnables, callables, entry processors, etc.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>&lt;provider-mode&gt;</code>: Controls which classes are served to other cluster
members. Available values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>LOCAL_AND_CACHED_CLASSES</code>: Serve classes loaded from both local classpath
and from other members. This is the default value.</p>
</li>
<li>
<p><code>LOCAL_CLASSES_ONLY</code>: Serve classes from the local classpath only. Classes
loaded from other members are used locally, but they are not served to other members.</p>
</li>
<li>
<p><code>OFF</code>: Never serve classes to other members.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>&lt;blacklist-prefixes&gt;</code>: Comma separated class/package name prefixes that
the member will never attempt to load from other members and that the client
won&#8217;t be allowed to upload. For example, if you set it to "com.foo", remote
loading of all classes from the "com.foo" package is prevented, including the
classes from all its sub-packages. If you set it to "com.foo.Class", then
"Class" and all classes starting with "Class" in the "com.foo" package are
blacklisted. There are built-in prefixes which are always blacklisted.
These are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>javax.</code></p>
</li>
<li>
<p><code>java.</code></p>
</li>
<li>
<p><code>sun.</code></p>
</li>
<li>
<p><code>com.hazelcast.</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>&lt;whitelist-prefixes&gt;</code>: Comma separated name prefixes of classes/packages
only from which the classes are allowed to be loaded. It allows to quickly
configure remote loading only for classes from selected packages. It can be
used together with blacklisting. For example, you can whitelist the prefix
"com.foo" and blacklist the prefix "com.foo.secret". If the list is empty, all
classes are allowed.</p>
</li>
<li>
<p><code>&lt;provider-filter&gt;</code>: Filter to constrain members that can be used for a class
loading request when a class is not available locally. The value is in the
format "HAS_ATTRIBUTE:foo". When it is set to "HAS_ATTRIBUTE:foo", the class
loading request is only sent to the members which have "foo" as a
<a href="#defining-member-attributes">member attribute</a>. Setting this to null allows
loading of classes from all members. See an example in the next section.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="example-for-filtering-members"><a class="anchor" href="#example-for-filtering-members"></a>6.7.2. Example for Filtering of Members</h4>
<div class="paragraph">
<p>As described above, the configuration element <code>provider-filter</code> is used to
limit members that can be used to load classes. The attribute required in the
<code>provider-filter</code> must be set as a member attribute on the members from which
the classes are to be loaded. See the following examples provided as
programmatic configurations.</p>
</div>
<div class="paragraph">
<p>The example configuration below allows the Hazelcast member to load classes
only from members with the <code>class-provider</code> attribute set. It prevents from
asking any other member to provide a locally unavailable class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config hazelcastConfig = new Config();
        UserCodeDeploymentConfig ucdConfig = hazelcastConfig.getUserCodeDeploymentConfig();
        ucdConfig.setProviderFilter("HAS_ATTRIBUTE:class-provider");

        HazelcastInstance instance = Hazelcast.newHazelcastInstance(hazelcastConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example configuration below sets the attribute <code>class-provider</code> for a
member. Therefore the above member will be able to load classes from this
member:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config hazelcastConfig = new Config();
        MemberAttributeConfig memberAttributes = hazelcastConfig.getMemberAttributeConfig();
        memberAttributes.setAttribute("class-provider", "true");

        HazelcastInstance instance = Hazelcast.newHazelcastInstance(hazelcastConfig);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client-user-code-deployment"><a class="anchor" href="#client-user-code-deployment"></a>6.8. Deploying User Code from Clients</h3>
<div class="paragraph">
<p>You can also deploy your code from the client side for the following
situations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You have objects that run on the cluster via the clients such as
<code>Runnable</code>, <code>Callable</code> and <code>EntryProcessor</code>.</p>
</li>
<li>
<p>You have new user domain objects which need to be deployed into the cluster.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When this feature is enabled on the client, the client will deploy the classes
to the members when connecting. This way, when a client adds a new class, the
members do not require a restart to include it in their classpath.</p>
</div>
<div class="paragraph">
<p>You can also use the client permission policy to specify which clients
are permitted to use User Code Deployment. See the <a href="#permissions">Permissions section</a>.</p>
</div>
<div class="paragraph">
<p>NOTE:</p>
</div>
<div class="sect3">
<h4 id="configuring-client-user-code-deployment"><a class="anchor" href="#configuring-client-user-code-deployment"></a>6.8.1. Configuring Client User Code Deployment</h4>
<div class="paragraph">
<p>Client User Code Deployment feature is not enabled by default. You can
configure this feature declaratively or programmatically.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using the user code deployment feature is a fit for your functional objects
like <code>Runnable</code>, <code>Callable</code> and <code>EntryProcessor</code>.
For the domain objects, we recommend you to use the
<a href="#accessing-domain-objects-without-domain-classes">generic object interface</a> (<code>GenericRecord</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Following are example configuration snippets:</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="paragraph">
<p>In your <code>hazelcast-client.xml/yaml</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;user-code-deployment enabled="true"&gt;
        &lt;jarPaths&gt;
            &lt;jarPath&gt;/User/example/example.jar&lt;/jarPath&gt;
            &lt;jarPath&gt;example.jar&lt;/jarPath&gt; &lt;!--from class path --&gt;
            &lt;jarPath&gt;https://com.example.com/example.jar&lt;/jarPath&gt;
            &lt;jarPath&gt;file://Users/example/example.jar&lt;/jarPath&gt;
        &lt;/jarPaths&gt;
        &lt;classNames&gt;
            &lt;!-- for classes available in client's class path --&gt;
            &lt;className&gt;example.ClassName&lt;/className&gt;
            &lt;className&gt;example.ClassName2&lt;/className&gt;
        &lt;/classNames&gt;
    &lt;/user-code-deployment&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  user-code-deployment
    enabled: true
    jarPaths:
      - /User/example/example.jar
      - example.jar
      - https://com.example.com/example.jar
      - file://Users/example/example.jar
    classNames:
      - example.ClassName
      - example.ClassName2</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        ClientConfig clientConfig = new ClientConfig();
        ClientUserCodeDeploymentConfig clientUserCodeDeploymentConfig = new ClientUserCodeDeploymentConfig();

        clientUserCodeDeploymentConfig.addJar("/User/example/example.jar");
        clientUserCodeDeploymentConfig.addJar("https://com.example.com/example.jar");
        clientUserCodeDeploymentConfig.addClass("example.ClassName");
        clientUserCodeDeploymentConfig.addClass("example.ClassName2");

        clientUserCodeDeploymentConfig.setEnabled(true);
        clientConfig.setUserCodeDeploymentConfig(clientUserCodeDeploymentConfig);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="client-user-code-deployment-note"><a class="anchor" href="#client-user-code-deployment-note"></a>Important to Know</h5>
<div class="paragraph">
<p>The members have to be configured in a specific way for the feature to work
correctly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>User Code Deployment must be enabled on the members. Otherwise, the classes
from the client will be ignored. Also blacklisted and non-whitelisted classes
will be ignored.</p>
</li>
<li>
<p>All members must be providers, <code>provider-mode</code> must be set to
<code>LOCAL_AND_CACHED_CLASSES</code> on all members.</p>
</li>
<li>
<p>No <code>provider-filter</code> must be configured.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The client uploads the classes only to one member. If the members don&#8217;t load
classes from each other, other members won&#8217;t see the class.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a programmatic configuration of the members that will work with client
user code deployment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        UserCodeDeploymentConfig ucdConfig = config.getUserCodeDeploymentConfig();
        ucdConfig.setEnabled(true);
        // following two configs are defaults, we show them for clarity
        ucdConfig.setProviderMode(ProviderMode.LOCAL_AND_CACHED_CLASSES);
        ucdConfig.setProviderFilter(null);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#member-user-code-deployment">Member User Code Deployment section</a>
for more information on enabling it on the member side and the configuration properties.</p>
</div>
<div class="paragraph">
<p>Classes deployed from clients are always cached on the members, no matter
whether <code>ETERNAL</code> or <code>OFF</code> is configured on the members.</p>
</div>
</div>
<div class="sect4">
<h5 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a>Performance Considerations</h5>
<div class="paragraph">
<p>The client always uploads all added classes and jars to one of the members,
whether it has them or not. So avoid adding large jar files for each connection
- if configured properly, the member will have the class the next time the
client connects.</p>
</div>
</div>
<div class="sect4">
<h5 id="_two_versions_of_a_class"><a class="anchor" href="#_two_versions_of_a_class"></a>Two Versions of a Class</h5>
<div class="paragraph">
<p>If the client uploads a class and the member already has that class, an
exception is thrown if the byte code is different. If byte code is same, it is
ignored. Therefore classes uploaded from the client can&#8217;t be updated with a new
version.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adding_user_library_to_classpath"><a class="anchor" href="#_adding_user_library_to_classpath"></a>6.8.2. Adding User Library to CLASSPATH</h4>
<div class="paragraph">
<p>When you want to use a Hazelcast feature in a non-Java client, you need to make
sure that the Hazelcast member recognizes it. For this, you can use the <code>/user-lib</code>
directory that comes with the Hazelcast package and deploy your own library to the member.
Let&#8217;s say you use Hazelcast Node.js client and want to use an entry processor.
This processor should be <code>IdentifiedDataSerializable</code> or <code>Portable</code> in the Node.js client.
You need to implement the Java equivalents of the processor and its factory on the member side,
and put these compiled class or JAR files into the <code>/user-lib</code> directory. Then you can run
the <code>start.sh</code> script which adds them to the classpath.</p>
</div>
<div class="paragraph">
<p>The following is an example code which can be the Java equivalent of
entry processor in the Node.js client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IdentifiedEntryProcessor implements EntryProcessor&lt;String, String, String&gt;, IdentifiedDataSerializable {
    static final int CLASS_ID = 1;
    private String value;
    public IdentifiedEntryProcessor() {
    }
    @Override
    public int getFactoryId() {
        return IdentifiedFactory.FACTORY_ID;
    }
    @Override
    public int getClassId() {
        return CLASS_ID;
    }
    @Override
    public void writeData(ObjectDataOutput out) throws IOException {
        out.writeUTF(value);
    }
    @Override
    public void readData(ObjectDataInput in) throws IOException {
        value = in.readUTF();
    }
    @Override
    public String process(Map.Entry&lt;String, String&gt; entry) {
        entry.setValue(value);
        return value;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can implement the above processor&#8217;s factory as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IdentifiedFactory implements DataSerializableFactory {
    public static final int FACTORY_ID = 5;
    @Override
    public IdentifiedDataSerializable create(int typeId) {
        if (typeId == IdentifiedEntryProcessor.CLASS_ID) {
            return new IdentifiedEntryProcessor();
        }
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following is the configuration for the above factory:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;serialization&gt;
        &lt;data-serializable-factories&gt;
            &lt;data-serializable-factory factory-id="5"&gt;
                IdentifiedFactory
            &lt;/data-serializable-factory&gt;
        &lt;/data-serializable-factories&gt;
    &lt;/serialization&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    data-serializable-factories:
      - factory-id: 5
        class-name: IdentifiedFactory</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can start your Hazelcast member by using the start scripts
(<code>start.sh</code> or <code>start.bat</code>) in the <code>/bin</code> directory. The start scripts
automatically adds your class and JAR files to the classpath.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="accessing-domain-objects-without-domain-classes"><a class="anchor" href="#accessing-domain-objects-without-domain-classes"></a>6.9. Accessing Domain Objects without Domain Classes - BETA</h3>
<div class="paragraph">
<p>Hazelcast offers a generic object interface (<code>GenericRecord</code>) that is returned to the user
when the domain class is missing on the classpath.
For example, if <code>PortableFactory</code> is not given in the serialization configuration for a
portable object, the user domain class cannot be created, and Hazelcast returns <code>GenericRecord</code> instead.
In the previous Hazelcast IMDG releases, we were throwing <code>HazelcastSerializationException("Could not create Portable for class-id: " + classId)</code>
for the same situation.</p>
</div>
<div class="paragraph">
<p><code>GenericRecord</code> is an immutable object. It allows you to read the field of objects via the related field names.
<code>GenericRecord</code> is applicable only to <code>Portable</code> objects.</p>
</div>
<div class="paragraph">
<p>You can use this feature when the cluster does not have the domain classes of the clients in a
client-server architecture. On remote calls like distributed executor service or entry processors,
you may need to access the domain object. In case the class of the domain object is not available on the cluster,
<code>GenericRecord</code> allows to access, read and write the objects
back without the class of the domain object on the classpath. Here is a read example with entry processor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    map.executeOnKey(key, (EntryProcessor&lt;Object, Object, Object&gt;) entry -&gt; {
             Object value = entry.getValue();
             GenericRecord genericRecord = (GenericRecord) value;

             int id = genericRecord.readInt("id");

             return null;
         });</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative approach introduced in the previous Hazelcast IMDG releases is the <a href="#member-user-code-deployment">User Code Deployment</a>
feature to deploy the classes from the client to the cluster.
However, it has a restriction: you can not upload
a new version of your class to the cluster if you use the portable versioning support.
Loading two different versions of the same class on the JVM is not a problem that we want to solve: using <code>GenericRecord</code>,
you can easily write different versions of your classes
from the clients and access them without using the User Code Deployment feature.</p>
</div>
<div class="paragraph">
<p>With the introduction of <code>GenericRecord</code>, User Code Deployment should be used only for functional objects like <code>Runnable</code>,
<code>Callable</code> and <code>EntryProcessor</code>.</p>
</div>
<div class="paragraph">
<p>You can also create a <code>GenericRecord</code> in portable format with <code>GenericRecord.Builder</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClassDefinition classDefinition = new ClassDefinitionBuilder(PORTABLE_FACTORY_ID, EMPLOYEE_CLASS_ID)
                        .addUTFField("name").addIntField("id").build();

GenericRecord namedRecord = GenericRecord.Builder.portable(classDefinition)
                .writeUTF("name", "foo")
                .writeInt("id", 123).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the class definitions are better to be created once and
used when creating different instances of the same type <code>GenericRecord</code>.</p>
</div>
<div class="paragraph">
<p>We have also added two convenience methods in <code>GenericRecord</code> for you to
avoid passing a class definition. For example, if you want to modify a value and
put it back using an entry processor, you don&#8217;t need to create a class definition.
Instead you can create a builder from <code>GenericRecord</code> which carries the same class definition as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">map.executeOnKey("key", (EntryProcessor&lt;Object, Object, Object&gt;) entry -&gt; {
            GenericRecord genericRecord = (GenericRecord) entry.getValue();
            GenericRecord modifiedGenericRecord = genericRecord.newBuilder()
                    .writeUTF("name","Kermit")
                    .writeLong("id", 4)
                    .writeInt("age",20)
                    .writeUTF("surname", "The Frog").build();
            entry.setValue(modifiedGenericRecord);
            return null;
        });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another convenience method is <code>cloneWithBuilder</code>. This is useful if you want to update only
a couple of fields from the original <code>genericRecord</code>. In that case, the new builder carries
both <code>classDefinition</code> and values from the original
<code>genericRecord</code>. Here is the same example where we just update the age:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">map.executeOnKey("key", (EntryProcessor&lt;Object, Object, Object&gt;) entry -&gt; {
            GenericRecord genericRecord = (GenericRecord) entry.getValue();
            GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder()
                    .writeInt("age",22).build();
            entry.setValue(modifiedGenericRecord);
            return null;
        });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another use case of this feature is on the client side (could also be a member):
<code>GenericRecord</code> allows to read from/write to a cluster without having the related classes on the classpath.
A client could work with the cluster without introducing the <code>PortableFactory</code> at the start.
In this case, the client works with <code>GenericRecord</code>s instead of domain classes.
An example code snippet on the client side with a map is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        GenericRecord record = (GenericRecord) map.get("key1");
        String name = record.readUTF("name");
        int id = record.readInt("id");

        GenericRecord newGenericRecord = genericRecord.cloneWithBuilder()
                .writeInt("age",22).build();

        map.put("key2", newGenericRecord);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="partition-group-configuration"><a class="anchor" href="#partition-group-configuration"></a>6.10. Partition Group Configuration</h3>
<div class="paragraph">
<p>Hazelcast distributes key objects into partitions using the consistent
hashing algorithm. Multiple replicas are created for each partition and
those partition replicas are distributed among Hazelcast members. An entry
is stored in the members that own replicas of the partition to which the entry&#8217;s
key is assigned. The total partition count is 271 by default; you can change it
with the configuration property <code>hazelcast.partition.count</code>. See the
<a href="#system-properties">System Properties appendix</a>.</p>
</div>
<div class="paragraph">
<p>Hazelcast member that owns the primary replica of a partition is called as
the partition owner. Other replicas are called backups. Based on the configuration,
a key object can be kept in multiple replicas of a partition. A member can hold at
most one replica of a partition (ownership or backup).</p>
</div>
<div class="paragraph">
<p>By default, Hazelcast distributes partition replicas randomly and equally among
the cluster members, assuming all members in the cluster are identical. But what
if some members share the same JVM or physical machine or chassis and you want
backups of these members to be assigned to members in another machine or chassis?
What if processing or memory capacities of some members are different and you
do not want an equal number of partitions to be assigned to all members?</p>
</div>
<div class="paragraph">
<p>To deal with such scenarios, you can group members in the same JVM (or physical machine)
or members located in the same chassis. Or you can group members to create identical
capacity. We call these groups <strong>partition groups</strong>. Partitions are assigned to those
partition groups instead of individual members. Backup replicas of a partition which is
owned by a partition group are located in other partition groups.</p>
</div>
<div class="sect3">
<h4 id="grouping-types"><a class="anchor" href="#grouping-types"></a>6.10.1. Grouping Types</h4>
<div class="paragraph">
<p>When you enable partition grouping, Hazelcast presents the following choices
for you to configure partition groups.</p>
</div>
<div class="sect4">
<h5 id="_host_aware"><a class="anchor" href="#_host_aware"></a>HOST_AWARE</h5>
<div class="paragraph">
<p>You can group members automatically using the IP addresses of members, so members
sharing the same network interface are grouped together. All members on the same
host (IP address or domain name) form a single partition group. This helps to avoid
data loss when a physical server crashes, because multiple replicas of the same
partition are not stored on the same host. But if there are multiple network
interfaces or domain names per physical machine, this assumption is invalid.</p>
</div>
<div class="paragraph">
<p>The following are declarative and programmatic configuration snippets that
show how to enable <code>HOST_AWARE</code> grouping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;partition-group enabled="true" group-type="HOST_AWARE" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.HOST_AWARE );</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_custom"><a class="anchor" href="#_custom"></a>CUSTOM</h5>
<div class="paragraph">
<p>You can do custom grouping using Hazelcast&#8217;s interface matching configuration.
This way, you can add different and multiple interfaces to a group. You can also
use wildcards in the interface addresses. For example, the users can create rack-aware
or data warehouse partition groups using custom partition grouping.</p>
</div>
<div class="paragraph">
<p>The following are declarative and programmatic configuration examples that show
how to enable and use <code>CUSTOM</code> grouping:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;partition-group enabled="true" group-type="CUSTOM"&gt;
        &lt;member-group&gt;
            &lt;interface&gt;10.10.0.*&lt;/interface&gt;
            &lt;interface&gt;10.10.3.*&lt;/interface&gt;
            &lt;interface&gt;10.10.5.*&lt;/interface&gt;
        &lt;/member-group&gt;
        &lt;member-group&gt;
            &lt;interface&gt;10.10.10.10-100&lt;/interface&gt;
            &lt;interface&gt;10.10.1.*&lt;/interface&gt;
            &lt;interface&gt;10.10.2.*&lt;/interface&gt;
        &lt;/member-group&gt;
    &lt;/partition-group&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  partition-group:
    enabled: true
    group-type: CUSTOM
    member-group:
      - - 10.10.0.*
        - 10.10.3.*
        - 10.10.5.*
      - - 10.10.10.10-100
        - 10.10.1.*
        - 10.10.2.*</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
        partitionGroupConfig.setEnabled( true )
                .setGroupType( PartitionGroupConfig.MemberGroupType.CUSTOM );

        MemberGroupConfig memberGroupConfig = new MemberGroupConfig();
        memberGroupConfig.addInterface( "10.10.0.*" )
                .addInterface( "10.10.3.*" ).addInterface("10.10.5.*" );

        MemberGroupConfig memberGroupConfig2 = new MemberGroupConfig();
        memberGroupConfig2.addInterface( "10.10.10.10-100" )
                .addInterface( "10.10.1.*").addInterface( "10.10.2.*" );

        partitionGroupConfig.addMemberGroupConfig( memberGroupConfig );
        partitionGroupConfig.addMemberGroupConfig( memberGroupConfig2 );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While your cluster was forming, if you configured your members to
discover each other by their IP addresses, you should use the IP addresses
for the <code>&lt;interface&gt;</code> element. If your members discovered each other by their
host names, you should use host names.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_per_member"><a class="anchor" href="#_per_member"></a>PER_MEMBER</h5>
<div class="paragraph">
<p>You can give every member its own group. Each member is a group of its own
and primary and backup partitions are distributed randomly (not on the same
physical member). This gives the least amount of protection and is the default
configuration for a Hazelcast cluster. This grouping type provides good redundancy
when Hazelcast members are on separate hosts. However, if multiple instances
run on the same host, this type is not a good option.</p>
</div>
<div class="paragraph">
<p>The following are declarative and programmatic configuration snippets that
show how to enable <code>PER_MEMBER</code> grouping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;partition-group enabled="true" group-type="PER_MEMBER" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.PER_MEMBER );</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_zone_aware"><a class="anchor" href="#_zone_aware"></a>ZONE_AWARE</h5>
<div class="paragraph">
<p>You can use ZONE_AWARE configuration with <a href="https://github.com/hazelcast/hazelcast-kubernetes" target="_blank" rel="noopener">Hazelcast Kubernetes</a>,
<a href="https://github.com/hazelcast/hazelcast-aws" target="_blank" rel="noopener">Hazelcast AWS</a>,
<a href="https://github.com/hazelcast/hazelcast-gcp" target="_blank" rel="noopener">Hazelcast GCP</a>,
<a href="https://github.com/hazelcast/hazelcast-jclouds" target="_blank" rel="noopener">Hazelcast jclouds</a> or
<a href="https://github.com/hazelcast/hazelcast-azure" target="_blank" rel="noopener">Hazelcast Azure</a> Discovery Service plugins.</p>
</div>
<div class="paragraph">
<p>As discovery services, these plugins put zone information to the Hazelcast
<a href="#defining-member-attributes">member attributes</a> map during the discovery process.
When ZONE_AWARE is configured as partition group type, Hazelcast creates the partition
groups with respect to member attributes map entries that include zone information.
That means backups are created in the other zones and each zone is accepted as one partition group.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the ZONE_AWARE partition grouping, a Hazelcast cluster spanning
multiple AZs should have an equal number of members in each AZ. Otherwise,
it results in uneven partition distribution among the members.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is the list of supported attributes which is set by the
Discovery Service plugins during a Hazelcast member start-up:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.partition.group.zone</code>: For the zones in the same area.</p>
</li>
<li>
<p><code>hazelcast.partition.group.rack</code>: For different racks in the same zone.</p>
</li>
<li>
<p><code>hazelcast.partition.group.host</code>: For a shared physical member if virtualization is used.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hazelcast jclouds plugin offers rack or host information in addition to
zone information based on the cloud provider. In such cases, Hazelcast looks for zone,
rack and host information in the given order and create partition groups with available information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following are declarative and programmatic configuration snippets
that show how to enable <code>ZONE_AWARE</code> grouping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;partition-group enabled="true" group-type="ZONE_AWARE" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.ZONE_AWARE );</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_spi"><a class="anchor" href="#_spi"></a>SPI</h5>
<div class="paragraph">
<p>You can provide your own partition group implementation using the SPI configuration.
To create your partition group implementation, you need to first extend the
<code>DiscoveryStrategy</code> class of the discovery service plugin, override the method
<code>public PartitionGroupStrategy getPartitionGroupStrategy()</code> and return the <code>PartitionGroupStrategy</code>
configuration in that overridden method.</p>
</div>
<div class="paragraph">
<p>The following code covers the implementation steps mentioned in the above paragraph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomDiscovery extends AbstractDiscoveryStrategy {

    public CustomDiscovery(ILogger logger, Map&lt;String, Comparable&gt; properties) {
        super(logger, properties);
    }

    @Override
    public Iterable&lt;DiscoveryNode&gt; discoverNodes() {
        Iterable&lt;DiscoveryNode&gt; iterable = //your implementation
        return iterable;
    }

    @Override
    public PartitionGroupStrategy getPartitionGroupStrategy() {
        return new CustomPartitionGroupStrategy();
    }

    private class CustomPartitionGroupStrategy implements PartitionGroupStrategy {
        @Override
        public Iterable&lt;MemberGroup&gt; getMemberGroups() {
            Iterable&lt;MemberGroup&gt; iterable = //your implementation
            return iterable;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="logging-configuration"><a class="anchor" href="#logging-configuration"></a>6.11. Logging Configuration</h3>
<div class="paragraph">
<p>Hazelcast has a flexible logging configuration and does not depend on
any logging framework except JDK logging. It has built-in adapters
for a number of logging frameworks and it also supports custom loggers
by providing logging interfaces.</p>
</div>
<div class="paragraph">
<p>To use the built-in adapters, set the <code>hazelcast.logging.type</code> property
to one of the predefined types below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>jdk</strong>: JDK logging (default)</p>
</li>
<li>
<p><strong>log4j</strong>: Log4j</p>
</li>
<li>
<p><strong>log4j2</strong>: Log4j2</p>
</li>
<li>
<p><strong>slf4j</strong>: Slf4j</p>
</li>
<li>
<p><strong>none</strong>: disable logging</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can set <code>hazelcast.logging.type</code> through declarative configuration,
programmatic configuration or JVM system property.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you choose to use <code>log4j</code>, <code>log4j2</code>, or <code>slf4j</code>, you should include
the proper dependencies in the classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.logging.type"&gt;log4j&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.logging.type: log4j</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config() ;
config.setProperty( "hazelcast.logging.type", "log4j" );</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>System Property</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>using the <code>java -Dhazelcast.logging.type=slf4j</code> JVM parameter</p>
</li>
<li>
<p>using <code>System.setProperty( "hazelcast.logging.type", "none" );</code> System class</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the provided logging mechanisms are not satisfactory, you can implement
your own using the custom logging feature. To use it, implement the
<code>com.hazelcast.logging.LoggerFactory</code> and <code>com.hazelcast.logging.ILogger</code>
interfaces and set the system property <code>hazelcast.logging.class</code> as your
custom <code>LoggerFactory</code> class name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.logging.class=foo.bar.MyLoggingFactory</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also listen to logging events generated by Hazelcast runtime
by registering <code>LogListener</code>s to <code>LoggingService</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">LogListener listener = new LogListener() {
  public void log( LogEvent logEvent ) {
    // do something
  }
};
HazelcastInstance instance = Hazelcast.newHazelcastInstance();
LoggingService loggingService = instance.getLoggingService();
loggingService.addLogListener( Level.INFO, listener );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Through the <code>LoggingService</code>, you can get the currently used
ILogger implementation and log your own messages too.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are not using command line for configuring logging, you should be careful
about Hazelcast classes. They may be defaulted to <code>jdk</code> logging before newly configured
logging is read. When logging mechanism is selected, it will not change.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Below are example configurations for Log4j2 and Log4j. Note that Hazelcast does not
recommend any specific logging library, these examples are provided only to demonstrate
how to configure the logging. You can use your custom logging as explained above.</p>
</div>
<div class="sect3">
<h4 id="_example_log4j2_configuration"><a class="anchor" href="#_example_log4j2_configuration"></a>6.11.1. Example Log4j2 Configuration</h4>
<div class="paragraph">
<p>Specify the logging type as Log4j2 and a separate logging configuration file as shown below.</p>
</div>
<div class="paragraph">
<p>Using JVM arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.logging.type=log4j2
-Dlog4j.configurationFile=/path/to/properties/log4j2.properties</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using declarative configuration (<code>hazelcast.xml/yaml</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.logging.type"&gt;log4j2&lt;/property&gt;
        &lt;property name="log4j2.configuration"&gt;/path/to/properties/log4j2.properties&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.logging.type: log4j2
    log4j2.configuration: /path/to/properties/log4j2.properties</code></pre>
</div>
</div>
<div class="paragraph">
<p>Following is an example <code>log4j2.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">rootLogger=file
rootLogger.level=info
property.filepath=/path/to/log/files
property.filename=hazelcast

appender.file.type=RollingFile
appender.file.name=RollingFile
appender.file.fileName=${filepath}/${filename}.log
appender.file.filePattern=${filepath}/${filename}-%d{yyyy-MM-dd}-%i.log.gz
appender.file.layout.type=PatternLayout
appender.file.layout.pattern = %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
appender.file.policies.type=Policies
appender.file.policies.time.type=TimeBasedTriggeringPolicy
appender.file.policies.time.interval=1
appender.file.policies.time.modulate=true
appender.file.policies.size.type=SizeBasedTriggeringPolicy
appender.file.policies.size.size=50MB
appender.file.strategy.type=DefaultRolloverStrategy
appender.file.strategy.max=100

rootLogger.appenderRefs=file
rootLogger.appenderRef.file.ref=RollingFile

#Hazelcast specific logs.

#log4j.logger.com.hazelcast=debug

#log4j.logger.com.hazelcast.cluster=debug
#log4j.logger.com.hazelcast.partition=debug
#log4j.logger.com.hazelcast.partition.InternalPartitionService=debug
#log4j.logger.com.hazelcast.nio=debug
#log4j.logger.com.hazelcast.hibernate=debug</code></pre>
</div>
</div>
<div class="paragraph">
<p>To enable the debug logs for all Hazelcast operations uncomment the below line
in the above configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>log4j.logger.com.hazelcast=debug</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not need detailed logs, the default settings are enough.
Using the Hazelcast specific lines in the above configuration file,
you can select to see specific logs (cluster, partition, hibernate, etc.) in desired levels.</p>
</div>
<div class="paragraph">
<p>You can also use the <code>hazelcast.logging.details.enabled</code> property to
specify whether the name, IP address and version of the cluster are included
in the logs. When there are lots of log lines, it may be hard to follow.
When set to <code>false</code>, those information will not appear.</p>
</div>
</div>
<div class="sect3">
<h4 id="_example_log4j_configuration"><a class="anchor" href="#_example_log4j_configuration"></a>6.11.2. Example Log4j Configuration</h4>
<div class="paragraph">
<p>Its configuration is similar to that of Log4j2. Below is the JVM argument way of
specifying the logging type and configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.logging.type=log4j
-Dlog4j.configuration=file:/path/to/properties/log4j.properties</code></pre>
</div>
</div>
<div class="paragraph">
<p>Following is an example <code>log4j.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">log4j.rootLogger=INFO,file

log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.File=/path/to/log/files/hazelcast.log
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %p [%c{1}] - %m%n
log4j.appender.file.maxFileSize=50MB
log4j.appender.file.maxBackupIndex=100
log4j.appender.file.threshold=DEBUG

#log4j.logger.com.hazelcast=debug

#log4j.logger.com.hazelcast.cluster=debug
#log4j.logger.com.hazelcast.partition=debug
#log4j.logger.com.hazelcast.partition.InternalPartitionService=debug
#log4j.logger.com.hazelcast.nio=debug
#log4j.logger.com.hazelcast.hibernate=debug</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="other-network-configurations"><a class="anchor" href="#other-network-configurations"></a>6.12. Other Network Configurations</h3>
<div class="paragraph">
<p>All network related configurations are performed via the <code>network</code> element
in the Hazelcast XML configuration file or the class <code>NetworkConfig</code>
when using programmatic configuration. Following subsections describe the
available configurations that you can perform under the <code>network</code> element.</p>
</div>
<div class="sect3">
<h4 id="public-address"><a class="anchor" href="#public-address"></a>6.12.1. Public Address</h4>
<div class="paragraph">
<p><code>public-address</code> overrides the public address of a member. By default, a member
selects its socket address as its public address. But behind a network address translation (NAT),
two endpoints (members) may not be able to see/access each other.
If both members set their public addresses to their defined addresses on NAT,
then that way they can communicate with each other. In this case, their public addresses
are not an address of a local network interface but a virtual address defined by NAT.
It is optional to set and useful when you have a private cloud.
Note that, the value for this element should be given in the format <strong><code>host IP address:port number</code></strong>.
See the following examples.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;public-address&gt;11.22.33.44:5555&lt;/public-address&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    public-address: 11.22.33.44:5555</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.getNetworkConfig()
    .setPublicAddress( "11.22.33.44:5555" );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="port"><a class="anchor" href="#port"></a>6.12.2. Port</h4>
<div class="paragraph">
<p>You can specify the ports that Hazelcast uses to communicate between cluster members.
Its default value is <code>5701</code>. The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;port port-count="20" auto-increment="true"&gt;5701&lt;/port&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    port:
      auto-increment: true
      port-count: 20
      port: 5701</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.getNetworkConfig().setPort( 5701 )
    .setPortAutoIncrement( true ).setPortCount( 20 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>According to the above example, Hazelcast tries to find free ports between 5701 and 5720.</p>
</div>
<div class="paragraph">
<p><code>port</code> has the following attributes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>port-count</code>: By default, Hazelcast tries 100 ports to bind. Meaning that,
if you set the value of port as 5701, as members are joining to the cluster,
Hazelcast tries to find ports between 5701 and 5801. You can choose to change the
port count in the cases like having large instances on a single machine or
willing to have only a few ports to be assigned. The parameter <code>port-count</code>
is used for this purpose, whose default value is 100.</p>
</li>
<li>
<p><code>auto-increment</code>:  In some cases you may want to choose to use only one port.
In that case, you can disable the auto-increment feature of <code>port</code> by setting
<code>auto-increment</code> to <code>false</code>. The <code>port-count</code> attribute is not used when
auto-increment feature is disabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="outbound-ports"><a class="anchor" href="#outbound-ports"></a>6.12.3. Outbound Ports</h4>
<div class="paragraph">
<p>By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation.
But security policies/firewalls may require you to restrict outbound ports to be
used by Hazelcast-enabled applications. To fulfill this requirement, you can configure
Hazelcast to use only defined outbound ports. The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;outbound-ports&gt;
            &lt;!-- ports between 33000 and 35000 --&gt;
            &lt;ports&gt;33000-35000&lt;/ports&gt;
            &lt;!-- comma separated ports --&gt;
            &lt;ports&gt;37000,37001,37002,37003&lt;/ports&gt;
            &lt;ports&gt;38000,38500-38600&lt;/ports&gt;
        &lt;/outbound-ports&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    outbound-ports:
      - 33000-35000
      - 37000,37001,37002,37003
      - 38000,38500-38600</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
NetworkConfig networkConfig = config.getNetworkConfig();
// ports between 35000 and 35100
networkConfig.addOutboundPortDefinition("35000-35100");
// comma separated ports
networkConfig.addOutboundPortDefinition("36001, 36002, 36003");
networkConfig.addOutboundPort(37000);
networkConfig.addOutboundPort(37001);
...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can use port ranges and/or comma separated ports.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As shown in the programmatic configuration, you use the method <code>addOutboundPort</code>
to add only one port. If you need to add a group of ports, then use the method <code>addOutboundPortDefinition</code>.</p>
</div>
<div class="paragraph">
<p>In the declarative configuration, the element <code>ports</code> can be used for both single and
multiple port definitions. When you set this element to  <code>0</code> or  <code>*</code>,
your operating system (not Hazelcast) selects a free port from the ephemeral range.</p>
</div>
</div>
<div class="sect3">
<h4 id="reuse-address"><a class="anchor" href="#reuse-address"></a>6.12.4. Reuse Address</h4>
<div class="paragraph">
<p>When you shutdown a cluster member, the server socket port goes into the
<code>TIME_WAIT</code> state for the next couple of minutes. If you start the member right after
shutting it down, you may not be able to bind it to the same port because it is in the
<code>TIME_WAIT</code> state. If you set the <code>reuse-address</code> element to <code>true</code>, the <code>TIME_WAIT</code> state
is ignored and you can bind the member to the same port again.</p>
</div>
<div class="paragraph">
<p>The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;reuse-address&gt;true&lt;/reuse-address&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    reuse-address: true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
NetworkConfig networkConfig = config.getNetworkConfig();

networkConfig.setReuseAddress( true );
...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="join"><a class="anchor" href="#join"></a>6.12.5. Join</h4>
<div class="paragraph">
<p>The <code>join</code> configuration element is used to discover Hazelcast members and enable them
to form a cluster. Hazelcast provides Auto Detection, Multicast, TCP/IP, AWS, Kubernetes, Azure, GCP, Eureka, and more.
These mechanisms are explained the <a href="#discovery-mechanisms">Discovery Mechanisms section</a>.
This section describes all the sub-elements and attributes of <code>join</code> element.
The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;auto-detection enabled="true" /&gt;
            &lt;multicast enabled="false"&gt;
                &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;
                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
                &lt;multicast-time-to-live&gt;32&lt;/multicast-time-to-live&gt;
                &lt;multicast-timeout-seconds&gt;2&lt;/multicast-timeout-seconds&gt;
                &lt;trusted-interfaces&gt;
                    &lt;interface&gt;192.168.1.102&lt;/interface&gt;
                &lt;/trusted-interfaces&gt;
            &lt;/multicast&gt;
            &lt;tcp-ip enabled="false"&gt;
                &lt;required-member&gt;192.168.1.104&lt;/required-member&gt;
                &lt;member&gt;192.168.1.104&lt;/member&gt;
                &lt;members&gt;192.168.1.105,192.168.1.106&lt;/members&gt;
            &lt;/tcp-ip&gt;
            &lt;aws enabled="false"&gt;
                &lt;access-key&gt;my-access-key&lt;/access-key&gt;
                &lt;secret-key&gt;my-secret-key&lt;/secret-key&gt;
                &lt;region&gt;us-west-1&lt;/region&gt;
                &lt;host-header&gt;ec2.amazonaws.com&lt;/host-header&gt;
                &lt;security-group-name&gt;hazelcast-sg&lt;/security-group-name&gt;
                &lt;tag-key&gt;type&lt;/tag-key&gt;
                &lt;tag-value&gt;hz-members&lt;/tag-value&gt;
            &lt;/aws&gt;
            &lt;discovery-strategies&gt;
                &lt;discovery-strategy ... /&gt;
            &lt;/discovery-strategies&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    join:
      auto-detection:
        enabled: true
      multicast:
        enabled: false
        multicast-group: 224.2.2.3
        multicast-port: 54327
        multicast-time-to-live: 32
        multicast-timeout-seconds: 2
        trusted-interfaces:
          - 192.168.1.102
      tcp-ip:
        enabled: false
        required-member: 192.168.1.104
        member-list:
          - 192.168.1.104
          - 192.168.1.105,192.168.1.106
      aws:
        enabled: false
        access-key: my-access-key
        secret-key: my-secret-key
        region: us-west-1
        host-header: ec2.amazonaws.com
        security-group-name: hazelcast-sg
        tag-key: type
        tag-value: hz-nodes
      discovery-strategies:
        discovery-strategy:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
NetworkConfig network = config.getNetworkConfig();
JoinConfig join = network.getJoin();
join.getTcpIpConfig().addMember( "10.45.67.32" ).addMember( "10.45.67.100" )
            .setRequiredMember( "192.168.10.100" ).setEnabled( true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>join</code> element has the following sub-elements and attributes.</p>
</div>
<div class="sect4">
<h5 id="auto-detection-element"><a class="anchor" href="#auto-detection-element"></a>auto-detection element</h5>
<div class="paragraph">
<p>The <code>auto-detection</code> element includes the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Enables Hazelcast Auto Detection, <code>true</code> by default.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="multicast-element"><a class="anchor" href="#multicast-element"></a>multicast element</h5>
<div class="paragraph">
<p>The <code>multicast</code> element includes parameters to fine tune the multicast join mechanism.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether the multicast discovery is enabled or not, <code>true</code> or <code>false</code>.</p>
</li>
<li>
<p><code>multicast-group</code>: The multicast group IP address. Specify it when you want to create
clusters within the same network. Values can be between 224.0.0.0 and 239.255.255.255.
Its default value is 224.2.2.3.</p>
</li>
<li>
<p><code>multicast-port</code>: The multicast socket port that the Hazelcast member listens to and
sends discovery messages through. Its default value is 54327.</p>
</li>
<li>
<p><code>multicast-time-to-live</code>: Time-to-live value for multicast packets sent out to control
the scope of multicasts. See more information <a href="http://www.tldp.org/HOWTO/Multicast-HOWTO-2.html">here</a>.</p>
</li>
<li>
<p><code>multicast-timeout-seconds</code>: Only when the members are starting up, this timeout (in seconds)
specifies the period during which a member waits for a multicast response from another member.
For example, if you set it as 60 seconds, each member waits for 60 seconds until a leader
member is selected. Its default value is 2 seconds.</p>
</li>
<li>
<p><code>trusted-interfaces</code>: Includes IP addresses of trusted members. When a member wants to
join to the cluster, its join request is rejected if it is not a trusted member. You can
give an IP addresses range using the wildcard (*) on the last digit of IP address,
e.g., 192.168.1.* or 192.168.1.100-110.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Multicast mechanism is not recommended for production since UDP is often blocked
in production environments and other join mechanisms are more definite.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="tcp-ip-element"><a class="anchor" href="#tcp-ip-element"></a>tcp-ip element</h5>
<div class="paragraph">
<p>The <code>tcp-ip</code> element includes parameters to fine tune the TCP/IP join mechanism.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether the TCP/IP discovery is enabled or not.
Values can be <code>true</code> or <code>false</code>.</p>
</li>
<li>
<p><code>required-member</code>: IP address of the required member. Cluster is only
formed if the member with this IP address is found.</p>
</li>
<li>
<p><code>member</code>: IP address(es) of one or more well known members. Once members
are connected to these well known ones, all member addresses are communicated
with each other. You can also give comma separated IP addresses using the <code>members</code> element.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>tcp-ip</code> element also accepts the <code>interface</code> parameter. See the
<a href="#interfaces">Interfaces element description</a>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>connection-timeout-seconds</code>: Defines the connection timeout in seconds.
This is the maximum amount of time Hazelcast is going to try to connect to a well
known member before giving up. Setting it to a too low value could mean that a
member is not able to connect to a cluster. Setting it to a too high value means
that member startup could slow down because of longer timeouts, for example when
a well known member is not up. Increasing this value is recommended if you have many
IPs listed and the members cannot properly build up the cluster. Its default value is 5 seconds.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aws-element"><a class="anchor" href="#aws-element"></a>aws element</h5>
<div class="paragraph">
<p>The <code>aws</code> element includes parameters to allow the members to form a cluster
on the Amazon EC2 and ECS environments.</p>
</div>
<div class="paragraph">
<p>For details, please check the
<a href="https://github.com/hazelcast/hazelcast-aws">Hazelcast AWS Discovery plugin documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="azure-element"><a class="anchor" href="#azure-element"></a>azure element</h5>
<div class="paragraph">
<p>The <code>azure</code> element includes parameters to allow the members to form a cluster on the Azure VM machines.</p>
</div>
<div class="paragraph">
<p>For details, please check the
<a href="https://github.com/hazelcast/hazelcast-azure">Hazelcast Azure Discovery plugin documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="gcp-element"><a class="anchor" href="#gcp-element"></a>gcp element</h5>
<div class="paragraph">
<p>The <code>gcp</code> element includes parameters to allow the members to form a cluster on the GCP Compute VM instances.</p>
</div>
<div class="paragraph">
<p>For details, please check the
<a href="https://github.com/hazelcast/hazelcast-gcp">Hazelcast GCP Discovery plugin documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="kubernetes-element"><a class="anchor" href="#kubernetes-element"></a>kubernetes element</h5>
<div class="paragraph">
<p>The <code>kubernetes</code> element includes parameters to allow the members to form a cluster on the Kubernetes environment.</p>
</div>
<div class="paragraph">
<p>For details, please check the
<a href="https://github.com/hazelcast/hazelcast-kubernetes">Hazelcast Kubernetes Discovery plugin documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="discovery-strategies-element"><a class="anchor" href="#discovery-strategies-element"></a>discovery-strategies element</h5>
<div class="paragraph">
<p>The <code>discovery-strategies</code> element configures internal or external discovery
strategies based on the Hazelcast Discovery SPI. For further information, see
the <a href="#discovery-spi">Discovery SPI section</a> and the vendor documentation of
the used discovery strategy.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="interfaces"><a class="anchor" href="#interfaces"></a>6.12.6. Interfaces</h4>
<div class="paragraph">
<p>You can specify which network interfaces that Hazelcast should use.
Servers mostly have more than one network interface, so you may want to list
the valid IPs. <strong>Range characters <code>"*"</code> and <code>"-"</code></strong> can be used for simplicity.
For instance, 10.3.10.* refers to IPs between 10.3.10.0 and 10.3.10.255.
Interface 10.3.10.4-18 refers to IPs between 10.3.10.4 and 10.3.10.18
(4 and 18 included). If network interface configuration is enabled
(it is disabled by default) and if Hazelcast cannot find a matching interface,
then it prints a message on the console and does not start on that member.</p>
</div>
<div class="paragraph">
<p>The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;interfaces enabled="true"&gt;
            &lt;interface&gt;10.3.16.*&lt;/interface&gt;
            &lt;interface&gt;10.3.10.4-18&lt;/interface&gt;
            &lt;interface&gt;192.168.1.3&lt;/interface&gt;
        &lt;/interfaces&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    interfaces:
      enabled: true
      interfaces:
        - 10.3.16.*
        - 10.3.10.4-18
        - 192.168.1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
NetworkConfig network = config.getNetworkConfig();
InterfacesConfig interfaceConfig = network.getInterfaces();
interfaceConfig.setEnabled( true )
            .addInterface( "192.168.1.3" );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ipv6-support"><a class="anchor" href="#ipv6-support"></a>6.12.7. IPv6 Support</h4>
<div class="paragraph">
<p>Hazelcast supports IPv6 addresses seamlessly (This support is switched
off by default, see the note at the end of this section).</p>
</div>
<div class="paragraph">
<p>All you need is to define IPv6 addresses or interfaces in the network
configuration. The only current limitation is that you cannot define
wildcard IPv6 addresses in the TCP/IP join configuration (<code>tcp-ip</code> element).
<a href="#interfaces">Interfaces</a> configuration does not have this limitation,
you can configure wildcard IPv6 interfaces in the same way as IPv4 interfaces.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;port auto-increment="true"&gt;5701&lt;/port&gt;
        &lt;join&gt;
            &lt;multicast enabled="false"&gt;
                &lt;multicast-group&gt;FF02:0:0:0:0:0:0:1&lt;/multicast-group&gt;
                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
            &lt;/multicast&gt;
            &lt;tcp-ip enabled="true"&gt;
                &lt;member&gt;[fe80::223:6cff:fe93:7c7e]:5701&lt;/member&gt;
                &lt;interface&gt;192.168.1.0-7&lt;/interface&gt;
                &lt;interface&gt;192.168.1.*&lt;/interface&gt;
                &lt;interface&gt;fe80:0:0:0:45c5:47ee:fe15:493a&lt;/interface&gt;
            &lt;/tcp-ip&gt;
        &lt;/join&gt;
        &lt;interfaces enabled="true"&gt;
            &lt;interface&gt;10.3.16.*&lt;/interface&gt;
            &lt;interface&gt;10.3.10.4-18&lt;/interface&gt;
            &lt;interface&gt;fe80:0:0:0:45c5:47ee:fe15:*&lt;/interface&gt;
            &lt;interface&gt;fe80::223:6cff:fe93:0-5555&lt;/interface&gt;
        &lt;/interfaces&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    port:
      auto-increment: true
      port: 5701
    join:
      multicast:
        enabled: false
        multicast-group: FF02:0:0:0:0:0:0:1
        multicast-port: 54327
      tcp-ip:
        enabled: true
        member: [fe80::223:6cff:fe93:7c7e]:5701
        interface: 192.168.1.0-7
        interface: 192.168.1.*
        interface: fe80:0:0:0:45c5:47ee:fe15:493a
    interfaces:
      enabled: true
      interfaces:
        - 10.3.16.*
        - 10.3.10.4-18
        - fe80:0:0:0:45c5:47ee:fe15:*
        - fe80::223:6cff:fe93:0-5555</code></pre>
</div>
</div>
<div class="paragraph">
<p>JVM has two system properties for setting the preferred protocol stack
(IPv4 or IPv6) as well as the preferred address family types (inet4 or inet6).
On a dual stack machine, IPv6 stack is preferred by default, you can change this
through the <code>java.net.preferIPv4Stack=&lt;true|false&gt;</code> system property. When querying
name services, JVM prefers IPv4 addresses over IPv6 addresses and returns an IPv4
address if possible. You can change this through <code>java.net.preferIPv6Addresses=&lt;true|false&gt;</code>
system property.</p>
</div>
<div class="paragraph">
<p>See also additional <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/net/ipv6_guide/" target="_blank" rel="noopener">details on IPv6 support in Java</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
IPv6 support has been switched off by default, since some platforms have issues
using the IPv6 stack. Some other platforms such as Amazon AWS have no support at all.
To enable IPv6 support, just set configuration property <code>hazelcast.prefer.ipv4.stack</code>
to <strong>false</strong>. See the <a href="#system-properties">System Properties appendix</a> for details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="member-address-provides-spi"><a class="anchor" href="#member-address-provides-spi"></a>6.12.8. Member Address Provider SPI</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This SPI is not intended to provide addresses of other cluster members with
which the Hazelcast instance forms a cluster. To do that, see the
<a href="#other-network-configurations">previous sections</a> above.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, Hazelcast chooses the public and bind address. You can influence on the
choice by defining a <code>public-address</code> in the configuration or by using other
properties mentioned above. In some cases, though, these properties are not
enough and the default address picking strategy chooses wrong addresses.
This may be the case when deploying Hazelcast in some cloud environments,
such as AWS, when using Docker or when the instance is deployed behind a NAT
and the <code>public-address</code> property is not enough (see the <a href="#public-address">Public Address section</a>).</p>
</div>
<div class="paragraph">
<p>In these cases, it is possible to configure the bind and public address
in a more advanced way. You can provide an implementation of the
<code>com.hazelcast.spi.MemberAddressProvider</code> interface which provides
the bind and public address. The implementation may then choose these
addresses in any way - it may read from a system property or file or
even invoke a web service to retrieve the public and private address.</p>
</div>
<div class="paragraph">
<p>The details of the implementation depend heavily on the environment in which
Hazelcast is deployed. As such, we now demonstrate how to configure Hazelcast
to use a simplified custom member address provider SPI implementation.
An example implementation is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static final class SimpleMemberAddressProvider implements MemberAddressProvider {
    @Override
    public InetSocketAddress getBindAddress() {
        // determine the address using some configuration, calling an API, ...
        return new InetSocketAddress(hostname, port);
    }

    @Override
    public InetSocketAddress getPublicAddress() {
        // determine the address using some configuration, calling an API, ...
        return new InetSocketAddress(hostname, port);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if the bind address port is <code>0</code> then it uses a port as configured
in the Hazelcast network configuration (see the <a href="#port">Port section</a>).
If the public address port is set to <code>0</code> then it broadcasts the same port that
it is bound to. If you wish to bind to any local interface, you may return
<code>new InetSocketAddress((InetAddress) null, port)</code> from the <code>getBindAddress()</code> address.</p>
</div>
<div class="paragraph">
<p>The following configuration examples contain properties that are provided to the
constructor of the provider class. If you do not provide any properties, the class
may have either a no-arg constructor or a constructor accepting a single
<code>java.util.Properties</code> instance. On the other hand, if you do provide properties
in the configuration, the class must have a constructor accepting a single
<code>java.util.Properties</code> instance.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;member-address-provider enabled="true"&gt;
            &lt;class-name&gt;SimpleMemberAddressProvider&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="prop1"&gt;prop1-value&lt;/property&gt;
                &lt;property name="prop2"&gt;prop2-value&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/member-address-provider&gt;
        &lt;!-- other network configurations --&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    member-address-provider:
      enabled: true
      class-name: SimpleMemberAddressProvider
      properties:
        prop1: prop1-value
        prop2: prop2-value
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
MemberAddressProviderConfig memberAddressProviderConfig = config.getNetworkConfig().getMemberAddressProviderConfig();
memberAddressProviderConfig
      .setEnabled(true)
      .setClassName(MemberAddressProviderWithStaticProperties.class.getName());
Properties properties = memberAddressProviderConfig.getProperties();
properties.setProperty("prop1", "prop1-value");
properties.setProperty("prop2", "prop2-value");

config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);

// perform other configuration

Hazelcast.newHazelcastInstance(config);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="failure-detector-configuration"><a class="anchor" href="#failure-detector-configuration"></a>6.13. Failure Detector Configuration</h3>
<div class="paragraph">
<p>A failure detector is responsible to determine if a member in the cluster is
unreachable or crashed. The most important problem in failure detection is to
distinguish whether a member is still alive but slow or has crashed. But according
to the famous <a href="http://dl.acm.org/citation.cfm?doid=3149.214121" target="_blank" rel="noopener">FLP result</a>,
it is impossible to distinguish a crashed member from a slow one in an asynchronous
system. A workaround to this limitation is to use unreliable failure detectors.
An unreliable failure detector allows a member to suspect that others have failed,
usually based on liveness criteria but it can make mistakes to a certain degree.</p>
</div>
<div class="paragraph">
<p>Hazelcast has the following built-in failure detectors: Deadline Failure Detector
and Phi Accrual Failure Detector.</p>
</div>
<div class="paragraph">
<p>There is also a Ping Failure Detector, that, if enabled, works in parallel with
the above ones, but identifies
the failures on OSI Layer 3 (Network Layer). This detector is by default disabled.</p>
</div>
<div class="paragraph">
<p>Note that, Hazelcast also offers failure detectors for its Java client.
See the <a href="#java-client-failure-detectors">Client Failure Detectors section</a> for more information.</p>
</div>
<div class="sect3">
<h4 id="_deadline_failure_detector"><a class="anchor" href="#_deadline_failure_detector"></a>6.13.1. Deadline Failure Detector</h4>
<div class="paragraph">
<p><em>Deadline Failure Detector</em> uses an absolute timeout for missing/lost
heartbeats. After timeout, a member is considered as crashed/unavailable
and marked as suspected.</p>
</div>
<div class="paragraph">
<p><em>Deadline Failure Detector</em> has the following configuration properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.heartbeat.interval.seconds</code>: This is the interval at which
member heartbeat messages are sent to each other.</p>
</li>
<li>
<p><code>hazelcast.max.no.heartbeat.seconds</code>: This is the timeout which defines
when a cluster member is suspected because it has not sent any heartbeats.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use <em>Deadline Failure Detector</em>, the configuration property
<code>hazelcast.heartbeat.failuredetector.type</code> should be set to <code>"deadline"</code>.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.heartbeat.failuredetector.type"&gt;deadline&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.interval.seconds"&gt;5&lt;/property&gt;
        &lt;property name="hazelcast.max.no.heartbeat.seconds"&gt;120&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.heartbeat.failuredetector.type: deadline
    hazelcast.heartbeat.interval.seconds: 5
    hazelcast.max.no.heartbeat.seconds: 120</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
config.setProperty("hazelcast.heartbeat.failuredetector.type", "deadline");
config.setProperty("hazelcast.heartbeat.interval.seconds", "5");
config.setProperty("hazelcast.max.no.heartbeat.seconds", "120");
[...]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<em>Deadline Failure Detector</em> is the default failure detector in Hazelcast.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="phi-accrual-failure-detector"><a class="anchor" href="#phi-accrual-failure-detector"></a>6.13.2. Phi Accrual Failure Detector</h4>
<div class="paragraph">
<p>This is the failure detector based on
<a href="https://www.computer.org/csdl/proceedings/srds/2004/2239/00/22390066-abs.html" target="_blank" rel="noopener">The Phi Accrual Failure Detector' by Hayashibara et al.</a></p>
</div>
<div class="paragraph">
<p>Phi Accrual Failure Detectorkeeps track of the intervals between heartbeats
in a sliding window of time andmeasures the mean and variance of these
samples and calculates a value of suspicion level (Phi). The value ofphi
increases when the period since the last heartbeat gets longer.If the network
becomes slow or unreliable, the resulting mean and variance increase, there needs
to be a longer period for which no heartbeat is received before the member is suspected.</p>
</div>
<div class="paragraph">
<p>The <code>hazelcast.heartbeat.interval.seconds</code>and <code>hazelcast.max.no.heartbeat.seconds</code>
propertiesstill can be used as period of heartbeat messages and deadline of
heartbeat messages. Since <em>Phi Accrual Failure Detector</em> is adaptive to network
conditions, a much lower <code>hazelcast.max.no.heartbeat.seconds</code> can be defined than
<em>Deadline Failure Detector</em>'s timeout.</p>
</div>
<div class="paragraph">
<p>In addition to the above two properties, <em>Phi Accrual Failure Detector</em> has the
following configuration properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.heartbeat.phiaccrual.failuredetector.threshold</code>: This is the phi
threshold for suspicion. After calculated phi exceeds this threshold, a member
is considered as unreachable and marked as suspected. A low threshold allows to
detect member crashes/failures faster but can generate more mistakes and cause
wrong member suspicions. A high threshold generates fewer mistakes but is slower
to detect actual crashes/failures.</p>
<div class="paragraph">
<p><code>phi = 1</code> means likeliness that we will make a mistake is about <code>10%</code>. The likeliness
is about <code>1%</code> with <code>phi = 2</code>, <code>0.1%</code> with <code>phi = 3</code> and so on. Default phi threshold is 10.</p>
</div>
</li>
<li>
<p><code>hazelcast.heartbeat.phiaccrual.failuredetector.sample.size</code>: Number of samples
to keep for history. Its default value is 200.</p>
</li>
<li>
<p><code>hazelcast.heartbeat.phiaccrual.failuredetector.min.std.dev.millis</code>: Minimum
standard deviation to use for the normal distribution used when calculating phi.
Too low standard deviation might result in too much sensitivity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use <em>Phi Accrual Failure Detector</em>, configuration property
<code>hazelcast.heartbeat.failuredetector.type</code> should be set to <code>"phi-accrual"</code>.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.heartbeat.failuredetector.type"&gt;phi-accrual&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.interval.seconds"&gt;1&lt;/property&gt;
        &lt;property name="hazelcast.max.no.heartbeat.seconds"&gt;60&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.phiaccrual.failuredetector.threshold"&gt;10&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.phiaccrual.failuredetector.sample.size"&gt;200&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.phiaccrual.failuredetector.min.std.dev.millis"&gt;100&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.heartbeat.failuredetector.type: phi-accrual
    hazelcast.heartbeat.interval.seconds: 1
    hazelcast.max.no.heartbeat.seconds: 60
    hazelcast.heartbeat.phiaccrual.failuredetector.sample.size: 200
    hazelcast.heartbeat.phiaccrual.failuredetector.min.std.dev.millis: 100</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
config.setProperty("hazelcast.heartbeat.failuredetector.type", "phi-accrual");
config.setProperty("hazelcast.heartbeat.interval.seconds", "1");
config.setProperty("hazelcast.max.no.heartbeat.seconds", "60");
config.setProperty("hazelcast.heartbeat.phiaccrual.failuredetector.threshold", "10");
config.setProperty("hazelcast.heartbeat.phiaccrual.failuredetector.sample.size", "200");
config.setProperty("hazelcast.heartbeat.phiaccrual.failuredetector.min.std.dev.millis", "100");
[...]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ping-failure-detector"><a class="anchor" href="#ping-failure-detector"></a>6.13.3. Ping Failure Detector</h4>
<div class="paragraph">
<p>The Ping Failure Detector may be configured in addition to one of Deadline and
Phi Accrual Failure Detectors. It operates at Layer 3 of the OSI protocol and
provides much quicker and more deterministic detection of hardware and other
lower level events. This detector may be configured to perform an extra check
after a member is suspected by one of the other detectors, or it can work in
parallel, which is the default. This way hardware and network level issues are
detected more quickly.</p>
</div>
<div class="paragraph">
<p>This failure detector is based on <code>InetAddress.isReachable()</code>.
When the JVM process has enough permissions to create RAW sockets, the
implementation chooses to rely on ICMP Echo requests. This is preferred.</p>
</div>
<div class="paragraph">
<p>If there are not enough permissions, it can be configured to fallback on
attempting a TCP Echo on port 7. In the latter case, both a successful
connection or an explicit rejection is treated as "Host is Reachable".
Or, it can be forced to use only RAW sockets. This is not preferred as
each call creates a heavy weight socket and moreover the Echo service is
typically disabled.</p>
</div>
<div class="paragraph">
<p>For the Ping Failure Detector to rely <strong>only</strong> on ICMP Echo requests,
there are some criteria that need to be met.</p>
</div>
<div class="sect4">
<h5 id="requirements-and-linuxunix-configuration"><a class="anchor" href="#requirements-and-linuxunix-configuration"></a>Requirements and Linux/Unix Configuration</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Supported OS: as of Java 1.8 only Linux/Unix environments are supported</strong>.
This detector relies on ICMP, i.e., the protocol behind the <code>ping</code> command.
It tries to issue the ping attempts periodically, and their responses are used
to determine the reachability of the remote member. However, you cannot simply
create an ICMP Echo Request because these type of packets do not rely on any of
the preexisting transport protocols such as TCP. In order to create such a request,
you must have the privileges to create RAW sockets (see <a href="https://linux.die.net/man/7/raw" target="_blank" rel="noopener">https://linux.die.net/man/7/raw</a>).
Most operating systems allow this to the root users, however Unix based ones
are more flexible and allow the use of custom privileges per process
instead of requiring root access. Therefore, this detector is supported only on Linux.</p>
</li>
<li>
<p><strong>The Java executable must have the <code>cap_net_raw</code> capability.</strong> As described in
the above requirement, on Linux, you have the ability to define extra capabilities
to a single process, which would allow the process to interact with the RAW sockets.
This interaction is achieved via the capability <code>cap_net_raw</code>
(see <a href="https://linux.die.net/man/7/capabilities" target="_blank" rel="noopener">https://linux.die.net/man/7/capabilities</a>).
To enable this capability run the following command:</p>
<div class="paragraph">
<p><code>sudo setcap cap_net_raw=+ep &lt;JDK_HOME&gt;/jre/bin/java</code></p>
</div>
</li>
<li>
<p><strong>When running with custom capabilities, the dynamic linker on Linux rejects
loading the libs from untrusted paths.</strong> Since you have now <code>cap_net_raw</code> as a
custom capability for a process, it becomes suspicious to the dynamic linker
and throws an error: <code>java: error while loading shared libraries: libjli.so:
cannot open shared object file: No such file or directory</code></p>
<div class="ulist">
<ul>
<li>
<p>To overcome this rejection, the <code>&lt;JDK_HOME&gt;/jre/lib/amd64/jli/</code> path needs
to be added in the <code>ld.conf</code>. Run the following command to do this:
<code>echo "&lt;JDK_HOME&gt;/jre/lib/amd64/jli/" &gt;&gt; /etc/ld.so.conf.d/java.conf &amp;&amp; sudo ldconfig</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>ICMP Echo Requests must not be blocked by the receiving hosts.</strong>
<code>/proc/sys/net/ipv4/icmp_echo_ignore_all</code> set to <code>0</code>.
Run the following command:</p>
<div class="paragraph">
<p><code>echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If any of the above criteria isn&#8217;t met, then the <code>isReachable</code>
always falls back on TCP Echo attempts on port 7.</p>
</div>
<div class="paragraph">
<p>To be able to use the Ping Failure Detector, you can configure it
using the <code>icmp</code> element in your Hazelcast IMDG declarative configuration
file, e.g., <code>hazelcast.xml</code>. An example is shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;network&gt;
    ...
        &lt;failure-detector&gt;
            &lt;icmp enabled="true"&gt;
                &lt;timeout-milliseconds&gt;1000&lt;/timeout-milliseconds&gt;
                &lt;fail-fast-on-startup&gt;true&lt;/fail-fast-on-startup&gt;
                &lt;interval-milliseconds&gt;1000&lt;/interval-milliseconds&gt;
                &lt;max-attempts&gt;3&lt;/max-attempts&gt;
                &lt;parallel-mode&gt;true&lt;/parallel-mode&gt;
                &lt;ttl&gt;0&lt;/ttl&gt;
            &lt;/icmp&gt;
        &lt;/failure-detector&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    failure-detector:
      icmp:
        enabled: true
        timeout-milliseconds: 1000
        fail-fast-on-startup: true
        interval-milliseconds: 1000
        max-attempts: 3
        parallel-mode: true
        ttl: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the element and attribute descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether the legacy ICMP detection mode is enabled; works
cooperatively with the existing failure detector and only kicks-in after
a pre-defined period has passed with no heartbeats from a member.
Its default value is <code>false</code>.</p>
</li>
<li>
<p><code>parallel-mode</code>: Specifies whether the parallel ping detector is enabled;
works separately from the other detectors. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>timeout-milliseconds</code>: Number of milliseconds until a ping attempt
is considered failed if there was no reply. Its default value is <code>1000</code> milliseconds.</p>
</li>
<li>
<p><code>max-attempts</code>: Maximum number of ping attempts before
the member/node gets suspected by the detector. Its default value is <code>2</code>.</p>
</li>
<li>
<p><code>interval-milliseconds</code>: Interval, in milliseconds, between each ping
attempt. 1000ms (1 sec) is also the minimum interval allowed.
Its default value is <code>1000</code> milliseconds.</p>
</li>
<li>
<p><code>ttl</code>: Maximum number of hops the packets should
go through. Its default value is <code>0</code>.</p>
</li>
<li>
<p><code>fail-fast-on-startup</code>: Specifies whether the cluster member fails to start
if it is unable to action an ICMP ping command when ICMP is enabled. Failure
is usually due to OS level restrictions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the above example configuration, the Ping detector attempts 3 pings, one every second and
waits up to 1 second for each to complete. If after 3 seconds, there was no successful
ping, the member gets suspected.</p>
</div>
<div class="paragraph">
<p>To enforce the <a href="#requirements-and-linuxunix-configuration">Requirements</a>, the property
<code>hazelcast.icmp.echo.fail.fast.on.startup</code> can also be set to <code>true</code>, in which case,
if any of the requirements isn&#8217;t met, Hazelcast fails to start.</p>
</div>
<div class="paragraph">
<p>Below is a summary table of all possible configuration combinations
of the ping failure detector.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Ping Failure Detector Possible Configuration Combinations</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 30%;">
<col style="width: 20%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ICMP</th>
<th class="tableblock halign-left valign-top">Parallel</th>
<th class="tableblock halign-left valign-top">Fail-Fast</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Linux</th>
<th class="tableblock halign-left valign-top">Windows</th>
<th class="tableblock halign-left valign-top">macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completely disabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Legacy ping mode. This works hand-to-hand with the OSI Layer 7 failure
detector (see. phi or deadline in the sections above). Ping in this mode
only kicks in after a period when there are no heartbeats received, in which
case the remote Hazelcast member is pinged up to a configurable count of attempts.
If all those attempts fail, the member gets suspected. You can configure this
attempt count using the <code>max-attempts</code> configuration element listed above.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parallel ping detector, works in parallel with the configured failure detector.
Checks periodically if members are live (OSI Layer 3) and suspects them immediately,
regardless of the other detectors.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parallel ping detector, works in parallel with the configured failure detector.
Checks periodically if members are live (OSI Layer 3) and suspects them immediately,
regardless of the other detectors.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported - Requires OS Configuration  Enforcing ICMP Echo if available -
No start up if not available</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not Supported</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not Supported - Requires root privileges</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_network_configuration"><a class="anchor" href="#_advanced_network_configuration"></a>6.14. Advanced Network Configuration</h3>
<div class="paragraph">
<p>With the default configuration, Hazelcast members use a single server socket for all kinds
of connections: cluster members, Hazelcast clients implementing the Open Binary Client
Protocol and HTTP protocol clients connect to a single server socket that handles all the protocols.</p>
</div>
<div class="paragraph">
<p>You can also configure the Hazelcast members with
separate server sockets using a different network configuration for different protocols.
This configuration scheme allows more flexibility when deploying Hazelcast as described
in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For security, it is possible to bind the member protocol server socket on a protected
internal network interface, while the client connections can be established on another
network interface accessible by the Hazelcast clients.</p>
</li>
<li>
<p>Different kinds of network connections can be established with different socket options.
For example varying send/receive window size to optimize the network usage, TLS for
connections over WAN while member-to-member connections may remain unencrypted, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the following example we introduce the advanced network configuration for a
member to listen for member-to-member connections on the default port <code>5701</code> while
listening for client connections on the port <code>9090</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        config.getAdvancedNetworkConfig().setEnabled(true);
        config.getAdvancedNetworkConfig().setClientEndpointConfig(
                new ServerSocketEndpointConfig().setPort(9090)
        );
        HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);
        System.out.println(instance.getCluster().getLocalMember().getAddressMap());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running this example prints something similar to the following output,
indicating that the member listens for the specified protocols on the respective configured ports:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{EndpointQualifier{type='CLIENT'}=[10.212.134.156]:9090, EndpointQualifier{type='MEMBER'}=[10.212.134.156]:5701}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network enabled="true"&gt;
        &lt;member-server-socket-endpoint-config&gt;
            &lt;port&gt;5701&lt;/port&gt;
        &lt;/member-server-socket-endpoint-config&gt;
        &lt;client-server-socket-endpoint-config&gt;
            &lt;port&gt;9090&lt;/port&gt;
        &lt;/client-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    enabled: true
    member-server-socket-endpoint-config:
      port:
        - 5701
    client-server-socket-endpoint-config:
      port:
        - 9090</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_cluster_members_for_advanced_network_configuration"><a class="anchor" href="#_setting_up_cluster_members_for_advanced_network_configuration"></a>6.14.1. Setting Up Cluster Members for Advanced Network Configuration</h4>
<div class="paragraph">
<p>Advanced network configuration and single-socket network configuration are
mutually exclusive: either an enabled <code>AdvancedNetworkConfig</code> or the <code>NetworkConfig</code>
object is used to configure a member&#8217;s networking, including the joiner, discovery,
failure detectors, etc. as described in the previous sections of this chapter.</p>
</div>
<div class="paragraph">
<p>You cannot define both elements in the declarative configuration, i.e., the <code>network</code>
and <code>advanced-network</code> elements cannot be configured at the same time. In the
programmatic configuration, an enabled <code>AdvancedNetworkConfig</code> takes precedence over
the <code>NetworkConfig</code>. <code>AdvancedNetworkConfig</code> is disabled by default, therefore the
unisocket member configuration under <code>NetworkConfig</code> is used in the default case.</p>
</div>
<div class="paragraph">
<p>When using the advanced network configuration, the following configurations are defined
member-wide:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Joiner and cluster discovery (Multicast, TCP/IP, AWS, Azure, GCP, Kubernetes, Eureka, etc.)</p>
</li>
<li>
<p><code>MemberAddressProvider</code> configuration</p>
</li>
<li>
<p>Failure detector configuration</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition to the above, the advanced network configuration allows the
configuration of multiple endpoints: each endpoint configuration applies for a
specific protocol, e.g., <code>MEMBER</code> and <code>CLIENT</code>. An additional optional identifier
can be configured to separate the configuration of multiple <code>WAN</code> protocol endpoints.</p>
</div>
<div class="paragraph">
<p>The supported protocols are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MEMBER</code>: A member server socket is required for Hazelcast to operate. The default
advanced network configuration defines a member endpoint configuration listening on
port 5701 (same as the single-socket Hazelcast member configuration).</p>
</li>
<li>
<p><code>CLIENT</code>: A single server socket handling the Hazelcast Open Binary Client Protocol
can be optionally configured. If no such endpoint is configured, then the clients will
not be able to connect to the Hazelcast member.</p>
</li>
<li>
<p><code>REST</code>: A REST server socket is optional.</p>
</li>
<li>
<p><code>MEMCACHE</code>: When accessing a Hazelcast cluster over the Memcache text protocol, an
endpoint listening to <code>MEMCACHE</code> protocol must be defined.</p>
</li>
<li>
<p><code>WAN</code>: Multiple WAN endpoint configurations can be defined to determine the network
settings of outgoing connections (from the members of a source cluster to the target
WAN cluster members) or to establish server sockets on which a target WAN member can
listen for the incoming connections from the source cluster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_server_socket_endpoint_configuration"><a class="anchor" href="#_server_socket_endpoint_configuration"></a>6.14.2. Server Socket Endpoint Configuration</h4>
<div class="paragraph">
<p>The server socket endpoint configuration is common for all protocols. The elements
comprising a server socket endpoint configuration are identical to their single-socket
network configuration counterparts.</p>
</div>
<div class="paragraph">
<p>The following declarative configuration example includes all the common server
socket endpoint elements:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
   ...
   &lt;advanced-network enabled="true"&gt;
       &lt;member-server-socket-endpoint-config&gt;
           &lt;port auto-increment="true" port-count="100"&gt;5701&lt;/port&gt;
           &lt;outbound-ports&gt;
               &lt;ports&gt;33000-35000&lt;/ports&gt;
               &lt;ports&gt;37000,37001,37002,37003&lt;/ports&gt;
               &lt;ports&gt;38000,38500-38600&lt;/ports&gt;
           &lt;/outbound-ports&gt;
           &lt;interfaces enabled="true"&gt;
               &lt;interface&gt;10.10.1.*&lt;/interface&gt;
           &lt;/interfaces&gt;
           &lt;ssl enabled="true"&gt;
               &lt;factory-class-name&gt;com.hazelcast.examples.MySSLContextFactory&lt;/factory-class-name&gt;
               &lt;properties&gt;
                   &lt;property name="foo"&gt;bar&lt;/property&gt;
               &lt;/properties&gt;
           &lt;/ssl&gt;
           &lt;symmetric-encryption&gt;
               &lt;algorithm&gt;ALGO&lt;/algorithm&gt;
               &lt;salt&gt;SALT&lt;/salt&gt;
               &lt;password&gt;PASS&lt;/password&gt;
               &lt;iteration-count&gt;10000&lt;/iteration-count&gt;
           &lt;/symmetric-encryption&gt;
           &lt;socket-interceptor enabled="true"&gt;
               &lt;class-name&gt;com.hazelcast.examples.MySocketInterceptor&lt;/class-name&gt;
               &lt;properties&gt;
                   &lt;property name="foo"&gt;bar&lt;/property&gt;
               &lt;/properties&gt;
           &lt;/socket-interceptor&gt;
           &lt;socket-options&gt;
               &lt;buffer-direct&gt;true&lt;/buffer-direct&gt;
               &lt;tcp-no-delay&gt;true&lt;/tcp-no-delay&gt;
               &lt;keep-alive&gt;true&lt;/keep-alive&gt;
               &lt;connect-timeout-seconds&gt;64&lt;/connect-timeout-seconds&gt;
               &lt;send-buffer-size-kb&gt;25&lt;/send-buffer-size-kb&gt;
               &lt;receive-buffer-size-kb&gt;33&lt;/receive-buffer-size-kb&gt;
               &lt;linger-seconds&gt;99&lt;/linger-seconds&gt;
           &lt;/socket-options&gt;
           &lt;public-address&gt;dummy&lt;/public-address&gt;
           &lt;reuse-address&gt;true&lt;/reuse-address&gt;
        &lt;/member-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network
    enabled: true
    member-server-socket-endpoint-config:
    port:
      auto-increment: true
      port-count: 100
      port: 5701
    outbound-ports:
      - 33000-35000
      - 37000,37001,37002,37003
      - 38000,38500-38600
    interfaces:
      enabled: true
      interfaces:
        - 10.10.1.*
    ssl:
      enabled: true
      factory-class-name: com.hazelcast.examples.MySSLContextFactory
      properties:
        foo: bar
    symmetric-encryption:
      algorithm: ALGO
      salt: SALT
      password: PASS
      iteration-count: 10000
    socket-interceptor:
      enabled: true
      class-name: com.hazelcast.examples.MySocketInterceptor
      properties:
        foo: bar
    socket-options:
      buffer-direct: true
      tcp-no-delay: true
      keep-alive: true
      connect-timeout-seconds: 64
      send-buffer-size-kb: 25
      receive-buffer-size-kb: 33
      linger-seconds: 99
    public-address: dummy
    reuse-address: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the declarative configuration, specific element names introduce the
server socket endpoint configuration for each protocol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>member-server-socket-endpoint-config</code> for <code>MEMBER</code> protocol</p>
</li>
<li>
<p><code>client-server-socket-endpoint-config</code> for <code>CLIENT</code> protocol</p>
</li>
<li>
<p><code>rest-server-socket-endpoint-config</code> for <code>REST</code> endpoint</p>
</li>
<li>
<p><code>memcache-server-socket-endpoint-config</code> for <code>MEMCACHE</code> endpoint</p>
</li>
<li>
<p><code>wan-server-socket-endpoint-config</code> for <code>WAN</code> endpoints</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using the programmatic configuration, corresponding methods set the
respective server socket endpoint configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getAdvancedNetworkConfig().setMemberEndpointConfig(
                new ServerSocketEndpointConfig()
                    .setPort(5701)
                    .setPortAutoIncrement(false)
                    .setSSLConfig(new SSLConfig())
                    .setReuseAddress(true)
                    .setSocketTcpNoDelay(true)
        );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_rest_server_socket_endpoint_configuration"><a class="anchor" href="#_setting_up_rest_server_socket_endpoint_configuration"></a>6.14.3. Setting Up REST Server Socket Endpoint Configuration</h4>
<div class="paragraph">
<p>In addition to the common server socket configuration described above, the REST
endpoint configuration includes certain additional elements which are used to
enable/disable the REST functionality groups.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getAdvancedNetworkConfig().setRestEndpointConfig(
                new RestServerEndpointConfig()
                    .setPort(8080)
                    .setPortAutoIncrement(false)
                    .enableGroups(WAN, CLUSTER_READ, HEALTH_CHECK)
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network enabled="true"&gt;
        &lt;rest-server-socket-endpoint-config&gt;
            &lt;port auto-increment="false"&gt;8080&lt;/port&gt;
            &lt;endpoint-groups&gt;
                &lt;endpoint-group name="WAN" enabled="true"/&gt;
                &lt;endpoint-group name="CLUSTER_READ" enabled="true"/&gt;
                &lt;endpoint-group name="HEALTH_CHECK" enabled="true"/&gt;
            &lt;/endpoint-groups&gt;
        &lt;/rest-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    enabled: true
    rest-server-socket-endpoint-config:
      port:
        auto-increment: false
        port: 8080
      endpoint-groups:
        WAN:
          enabled: true
        CLUSTER_READ:
          enabled: true
        HEALTH_CHECK:
          enabled: true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_wan_endpoints_configuration"><a class="anchor" href="#_setting_up_wan_endpoints_configuration"></a>6.14.4. Setting Up WAN Endpoints Configuration</h4>
<div class="paragraph">
<p>Multiple WAN endpoint configurations can be defined to configure the outgoing
connections and server sockets, depending on the role of the member in the WAN
replication. The configuration examples are provided in the following sections for
both active and passive side of the WAN replication.</p>
</div>
<div class="sect4">
<h5 id="_configuring_the_wan_active_side"><a class="anchor" href="#_configuring_the_wan_active_side"></a>Configuring the WAN Active Side</h5>
<div class="paragraph">
<p>The members on the active cluster initiate connections to the target cluster members,
so there is no need to create a server socket. A plain <code>EndpointConfig</code> is created that
supplies the configuration for the client side of connections that the active members
will create:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getAdvancedNetworkConfig().addWanEndpointConfig(
                new EndpointConfig().setName("tokyo")
                        .setSSLConfig(new SSLConfig()
                                            .setEnabled(true)
                                            .setFactoryClassName("com.hazelcast.examples.MySSLContextFactory")
                                            .setProperty("foo", "bar"))
        );
        WanReplicationConfig wanReplicationConfig = new WanReplicationConfig();
        WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        			.setEndpoint("tokyo")
        			.setTargetEndpoints("tokyo.hazelcast.com:8765");
        wanReplicationConfig.addBatchReplicationPublisherConfig(publisherConfig);
        config.addWanReplicationConfig(wanReplicationConfig);

        config.getMapConfig("customers").setWanReplicationRef(
                new WanReplicationRef("replicate-to-tokyo", "com.company.MergePolicy", emptyList(), false)
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network enabled="true"&gt;
        &lt;wan-endpoint-config name="tokyo"&gt;
            &lt;ssl enabled="true"&gt;
                &lt;factory-class-name&gt;com.hazelcast.examples.MySSLContextFactory&lt;/factory-class-name&gt;
                &lt;properties&gt;
                    &lt;property name="endpoints"&gt;tokyo.example.com:11010&lt;/property&gt;
                &lt;/properties&gt;
            &lt;/ssl&gt;
        &lt;/wan-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
    &lt;wan-replication name="replicate-to-tokyo"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;clusterB&lt;/cluster-name&gt;
            &lt;target-endpoints&gt;...&lt;/target-endpoints&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
    &lt;map name="customer"&gt;
        &lt;wan-replication-ref name="replicate-to-tokyo"&gt;
            &lt;merge-policy&gt;...&lt;/merge-policy&gt;
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    enabled: true
    wan-endpoint-config:
      endpoint-tokyo:
        ssl:
          enabled: true
          factory-class-name: com.hazelcast.examples.MySSLContextFactory
          properties:
            endpoints: tokyo.example.com:11010
    wan-replication:
      replicate-to-tokyo:
        batch-publisher:
          cluster-name: clusterB&lt;
          target-endpoints: ...
    map:
      customer:
        wan-replication-ref:
          replicate-to-tokyo:
            merge-policy-class-name: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wan-endpoint-config</code> element contains the same sub-elements as the
<code>member-server-socket-endpoint-config</code> element described above except <code>port</code>,
<code>public-address</code> and <code>reuse-address</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_the_wan_passive_side"><a class="anchor" href="#_configuring_the_wan_passive_side"></a>Configuring the WAN Passive Side</h5>
<div class="paragraph">
<p>On the passive cluster, a server socket is configured on the members to listen
for the incoming WAN connections, matching the network configuration (SSL configuration,
etc.) configured on the active side of the WAN replication.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getAdvancedNetworkConfig().addWanEndpointConfig(
                new ServerSocketEndpointConfig()
                        .setName("tokyo")
                        .setPort(11010)
                        .setPortAutoIncrement(false)
                        .setSSLConfig(new SSLConfig()
                                .setEnabled(true)
                                .setFactoryClassName("com.hazelcast.examples.MySSLContextFactory")
                                .setProperty("foo", "bar")
                        ));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network enabled="true"&gt;
        &lt;wan-server-socket-endpoint-config name="tokyo"&gt;
            &lt;port auto-increment="false"&gt;11010&lt;/port&gt;
            &lt;ssl enabled="true"&gt;
                &lt;factory-class-name&gt;com.hazelcast.examples.MySSLContextFactory&lt;/factory-class-name&gt;
                &lt;properties&gt;
                    &lt;property name="foo"&gt;bar&lt;/property&gt;
                &lt;/properties&gt;
            &lt;/ssl&gt;
        &lt;/wan-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    enabled: true
    wan-server-socket-endpoint-config:
      tokyo:
        port:
          auto-increment: false
          port: 11010
        ssl:
          enabled: true
          factory-class-name: com.hazelcast.examples.MySSLContextFactory
        properties:
          foo: bar</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_advanced_network_configuration_faq"><a class="anchor" href="#_advanced_network_configuration_faq"></a>6.14.5. Advanced Network Configuration FAQ</h4>
<div class="qlist qanda">
<ol>
<li>
<p><em>Can I multiplex protocols on a single advanced network endpoint? For example, can I use a single server socket to listen for <code>MEMBER</code> and <code>CLIENT</code> protocols?</em></p>
<p>No, each endpoint configuration that defines a server socket must bind to a different socket address.</p>
</li>
<li>
<p><em>Can I mix unisocket and advanced network members in the same cluster?</em></p>
<p>No, the results will be undefined.</p>
</li>
<li>
<p><em>Can I configure multiple server socket endpoints for the same protocol?</em></p>
<p>You can only configure multiple server socket endpoints for <code>WAN</code> protocol. For other protocols (<code>MEMBER</code>, <code>CLIENT</code>, <code>REST</code>, <code>MEMCACHE</code>), a single server socket can be configured.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distributed-data-structures"><a class="anchor" href="#distributed-data-structures"></a>7. Distributed Data Structures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As mentioned in the <a href="#hazelcast-overview">Overview section</a>, Hazelcast offers
distributed implementations of many common data structures. For each of the client
languages, Hazelcast mimics as closely as possible the natural interface of the
structure. So, for example in Java, the map follows <code>java.util.Map</code> semantics.
In the descriptions below, we mention each structure&#8217;s Java equivalent interface.  All of
these structures are usable from Java, .NET, C++, Node.js, Python, and Go.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Standard utility collections</strong></p>
<div class="ulist">
<ul>
<li>
<p><a href="#map">Map</a> is the distributed implementation of <code>java.util.Map</code>.
It lets you read from and write to a Hazelcast map with methods such as
<code>get</code> and <code>put</code>.</p>
</li>
<li>
<p><a href="#queue">Queue</a> is the distributed implementation of <code>java.util.concurrent.BlockingQueue</code>.
You can add an item in one member and remove it from another one.</p>
</li>
<li>
<p><a href="#ringbuffer">Ringbuffer</a> is implemented for reliable eventing system.</p>
</li>
<li>
<p><a href="#set">Set</a> is the distributed and concurrent implementation of <code>java.util.Set</code>.
It does not allow duplicate elements and does not preserve their order.</p>
</li>
<li>
<p><a href="#list">List</a> is similar to Hazelcast Set. The only difference is that it allows
duplicate elements and preserves their order.</p>
</li>
<li>
<p><a href="#multimap">Multimap</a> is a specialized Hazelcast map. It is a distributed data
structure where you can store multiple values for a single key.</p>
</li>
<li>
<p><a href="#replicated-map">Replicated Map</a> does not partition data. It does not spread
data to different cluster members. Instead, it replicates the data to all members.</p>
</li>
<li>
<p><a href="#cardinality-estimator">Cardinality Estimator</a> is a data structure which implements
Flajolet&#8217;s HyperLogLog algorithm.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Topic</strong> is the distributed mechanism for publishing messages that are delivered to
multiple subscribers. It is also known as the publish/subscribe (pub/sub) messaging model.
See the <a href="#topic">Topic section</a> for more information. Hazelcast also has a structure called
Reliable Topic which uses the same interface of Hazelcast Topic. The difference is that it is
backed up by the Ringbuffer data structure. See the <a href="#reliable-topic">Reliable Topic section</a>.</p>
</li>
<li>
<p><strong>Concurrency utilities</strong></p>
<div class="ulist">
<ul>
<li>
<p><a href="#lock">FencedLock</a> is the distributed implementation of <code>java.util.concurrent.locks.Lock</code>.
When you use lock, the critical section that Hazelcast Lock guards is guaranteed to be
executed by only one thread in the entire cluster.</p>
</li>
<li>
<p><a href="#isemaphore">ISemaphore</a> is the distributed implementation of <code>java.util.concurrent.Semaphore</code>.
When performing concurrent activities, semaphores offer permits to control the thread counts.</p>
</li>
<li>
<p><a href="#iatomiclong">IAtomicLong</a> is the distributed implementation of
<code>java.util.concurrent.atomic.AtomicLong</code>. Most of AtomicLong&#8217;s operations are available.
However, these operations involve remote calls and hence their performances differ from
AtomicLong, due to being distributed.</p>
</li>
<li>
<p><a href="#iatomicreference">IAtomicReference</a> is the distributed implementation of
<code>java.util.concurrent.atomic.AtomicReference</code>. When you need to deal with a reference
in a distributed environment, you can use Hazelcast IAtomicReference.</p>
</li>
<li>
<p><a href="#flakeidgenerator">FlakeIdGenerator</a> is used to generate cluster-wide unique identifiers.</p>
</li>
<li>
<p><a href="#icountdownlatch">ICountdownLatch</a> is the distributed implementation of
<code>java.util.concurrent.CountDownLatch</code>. Hazelcast CountDownLatch is a gate keeper for
concurrent activities. It enables the threads to wait for other threads to complete
their operations.</p>
</li>
<li>
<p><a href="#pn-counter">PN counter</a> is a distributed data structure where each Hazelcast instance
can increment and decrement the counter value and these updates are propagated to all replicas.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#event-journal">Event Journal</a> is a distributed data structure that stores the history
of mutation actions on map or cache.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="overview-of-hazelcast-distributed-objects"><a class="anchor" href="#overview-of-hazelcast-distributed-objects"></a>7.1. Overview of Hazelcast Distributed Objects</h3>
<div class="paragraph">
<p>Hazelcast has two types of distributed objects in terms of their partitioning strategies:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Data structures where each partition stores a part of the instance,
namely partitioned data structures.</p>
</li>
<li>
<p>Data structures where a single partition stores the whole instance,
namely non-partitioned data structures.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following are the partitioned Hazelcast data structures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Map</p>
</li>
<li>
<p>MultiMap</p>
</li>
<li>
<p>Cache (Hazelcast JCache implementation)</p>
</li>
<li>
<p>Event Journal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following are the non-partitioned Hazelcast data structures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Queue</p>
</li>
<li>
<p>Set</p>
</li>
<li>
<p>List</p>
</li>
<li>
<p>Ringbuffer</p>
</li>
<li>
<p>FencedLock</p>
</li>
<li>
<p>ISemaphore</p>
</li>
<li>
<p>IAtomicLong</p>
</li>
<li>
<p>IAtomicReference</p>
</li>
<li>
<p>FlakeIdGenerator</p>
</li>
<li>
<p>ICountdownLatch</p>
</li>
<li>
<p>Cardinality Estimator</p>
</li>
<li>
<p>PN Counter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Besides these, Hazelcast also offers the Replicated Map structure as
explained in the above <strong>Standard utility collections</strong> list.</p>
</div>
<div class="sect3">
<h4 id="loading-and-destroying-a-distributed-object"><a class="anchor" href="#loading-and-destroying-a-distributed-object"></a>7.1.1. Loading and Destroying a Distributed Object</h4>
<div class="paragraph">
<p>Hazelcast offers a <code>get</code> method for most of its distributed objects. To load an object,
first create a Hazelcast instance and then use the related <code>get</code> method on this instance.
Following example code snippet creates an Hazelcast instance and a map on this instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Map&lt;Integer, String&gt; customers = hazelcastInstance.getMap( "customers" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>As to the configuration of distributed object, Hazelcast uses the default settings
from the file <code>hazelcast.xml</code> that comes with your Hazelcast download. Of course,
you can provide an explicit configuration in this XML or programmatically according
to your needs. See the <a href="#understanding-configuration">Understanding Configuration section</a>.</p>
</div>
<div class="paragraph">
<p>Note that, most of Hazelcast&#8217;s distributed objects are created lazily, i.e., a distributed object
is created once the first operation accesses it.</p>
</div>
<div class="paragraph">
<p>If you want to use an object you loaded in other places, you can safely reload it using its
reference without creating a new Hazelcast instance (<code>customers</code> in the above example).</p>
</div>
<div class="paragraph">
<p>To destroy a Hazelcast distributed object, you can use the method <code>destroy</code>. This method clears
and releases all resources of the object. Therefore, you must use it with care since a reload
with the same object reference after the object is destroyed creates a new data structure without
an error. See the following example code where one of the queues are destroyed and the other
one is accessed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz1 = Hazelcast.newHazelcastInstance();
        HazelcastInstance hz2 = Hazelcast.newHazelcastInstance();
        IQueue&lt;String&gt; q1 = hz1.getQueue("q");
        IQueue&lt;String&gt; q2 = hz2.getQueue("q");
        q1.add("foo");
        System.out.println("q1.size: "+q1.size()+ " q2.size:"+q2.size());
        q1.destroy();
        System.out.println("q1.size: " + q1.size() + " q2.size:" + q2.size());</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you start the <code>Member</code> above, the output is as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">q1.size: 1 q2.size:1
q1.size: 0 q2.size:0</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see, no error is generated and a new queue resource is created.</p>
</div>
<div class="paragraph">
<p>Hazelcast is designed to create any distributed data structure whenever it is accessed,
i.e., whenever a call is made to the data structure. Therefore, keep in mind that a
data structure is recreated when you perform an operation on it even after you have destroyed it.</p>
</div>
</div>
<div class="sect3">
<h4 id="controlling-partitions"><a class="anchor" href="#controlling-partitions"></a>7.1.2. Controlling Partitions</h4>
<div class="paragraph">
<p>Hazelcast uses the name of a distributed object to determine which partition it will be put.
Let&#8217;s load two queues as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
IQueue q1 = hazelcastInstance.getQueue("q1");
IQueue q2 = hazelcastInstance.getQueue("q2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since these queues have different names, they will be placed into different partitions.
If you want to put these two into the same partition, you use the <code>@</code> symbol as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
IQueue q1 = hazelcastInstance.getQueue("q1@foo");
IQueue q2 = hazelcastInstance.getQueue("q2@foo");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, these two queues will be put into the same partition whose partition key is <code>foo</code>.
Note that you can use the method <code>getPartitionKey</code> to learn the partition key of a distributed object.
It may be useful when you want to create an object in the same partition of an existing object.
See its usage as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String partitionKey = q1.getPartitionKey();
IQueue q3 = hazelcastInstance.getQueue("q3@"+partitionKey);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="common-features-of-all-hazelcast-data-structures"><a class="anchor" href="#common-features-of-all-hazelcast-data-structures"></a>7.1.3. Common Features of all Hazelcast Data Structures</h4>
<div class="ulist">
<ul>
<li>
<p>If a member goes down, its backup replica (which holds the same data) dynamically
redistributes the data, including the ownership and locks on them, to the remaining
live members. As a result, there will not be any data loss.</p>
</li>
<li>
<p>There is no single cluster master that can be a single point of failure.
Every member in the cluster has equal rights and responsibilities. No single member is
superior. There is no dependency on an external 'server' or 'master'.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="example-distributed-object-code"><a class="anchor" href="#example-distributed-object-code"></a>7.1.4. Example Distributed Object Code</h4>
<div class="paragraph">
<p>Here is an example of how you can retrieve existing data structure instances
(map, queue, set, topic, etc.) and how you can listen for instance events,
such as an instance being created or destroyed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        ExampleDOL example = new ExampleDOL();
        Config config = new Config();

        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config);
        hazelcastInstance.addDistributedObjectListener(example);

        Collection&lt;DistributedObject&gt; distributedObjects = hazelcastInstance.getDistributedObjects();
        for (DistributedObject distributedObject : distributedObjects) {
            System.out.println(distributedObject.getName());
        }
    }

    @Override
    public void distributedObjectCreated(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println("Created " + instance.getName());
    }

    @Override
    public void distributedObjectDestroyed(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println("Destroyed " + instance.getName());
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="map"><a class="anchor" href="#map"></a>7.2. Map</h3>
<div class="paragraph">
<p>Hazelcast Map (<code>IMap</code>) extends the interface <code>java.util.concurrent.ConcurrentMap</code>
and hence <code>java.util.Map</code>. It is the distributed implementation of Java map. You can
perform operations like reading and writing from/to a Hazelcast map with the well
known get and put methods.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
IMap data structure can also be used by <a href="https://jet.hazelcast.org/" target="_blank" rel="noopener">Hazelcast Jet</a>
for Real-Time Stream Processing (by enabling the Event Journal on your map) and
Fast Batch Processing. Hazelcast Jet uses IMap as a source (reads data from IMap) and as a sink
(writes data to IMap). See the <a href="https://jet.hazelcast.org/use-cases/fast-batch-processing/" target="_blank" rel="noopener">Fast Batch Processing</a>
and <a href="https://jet.hazelcast.org/use-cases/real-time-stream-processing/" target="_blank" rel="noopener">Real-Time Stream Processing</a>
use cases for Hazelcast Jet. See also <a href="https://jet-start.sh/docs/api/sources-sinks#imap" target="_blank" rel="noopener">here</a>
in the Hazelcast Jet Programming Guide to learn how Jet uses IMap, i.e., how it can read from and write to IMap.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="getting-a-map-and-putting-an-entry"><a class="anchor" href="#getting-a-map-and-putting-an-entry"></a>7.2.1. Getting a Map and Putting an Entry</h4>
<div class="paragraph">
<p>Hazelcast partitions your map entries and their backups, and almost evenly distribute
them onto all Hazelcast members. Each member carries approximately
"number of map entries * 2 * 1/n" entries, where <strong>n</strong> is the number of members in the cluster.
For example, if you have a member with 1000 objects to be stored in the cluster and then you
start a second member, each member will both store 500 objects and back up the 500 objects
in the other member.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create a Hazelcast instance and fill a map named <code>Capitals</code> with key-value pairs
using the following code. Use the HazelcastInstance <code>getMap</code> method to get the map,
then use the map <code>put</code> method to put an entry into the map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance();
Map&lt;String, String&gt; capitalcities = hzInstance.getMap( "capitals" );
    capitalcities.put( "1", "Tokyo" );
    capitalcities.put( "2", "Paris" );
    capitalcities.put( "3", "Washington" );
    capitalcities.put( "4", "Ankara" );
    capitalcities.put( "5", "Brussels" );
    capitalcities.put( "6", "Amsterdam" );
    capitalcities.put( "7", "New Delhi" );
    capitalcities.put( "8", "London" );
    capitalcities.put( "9", "Berlin" );
    capitalcities.put( "10", "Oslo" );
    capitalcities.put( "11", "Moscow" );
    ...
    capitalcities.put( "120", "Stockholm" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run this code, a cluster member is created with a map whose entries are
distributed across the members' partitions. See the below illustration. For now,
this is a single member cluster.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/1Node.png" alt="Map Entries in a Single Member">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please note that some of the partitions do not contain any data entries since
we only have 120 objects and the partition count is 271 by default. This count is
configurable and can be changed using the system property <code>hazelcast.partition.count</code>.
See the <a href="#system-properties">System Properties appendix</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="creating-a-member-for-map-backup"><a class="anchor" href="#creating-a-member-for-map-backup"></a>7.2.2. Creating A Member for Map Backup</h4>
<div class="paragraph">
<p>Now let&#8217;s create a second member by running the above code again. This creates a
cluster with two members. This is also where backups of entries are created - remember
the backup partitions mentioned in the <a href="#hazelcast-overview">Hazelcast Overview section</a>.
The following illustration shows two members and how the data and its backup is distributed.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/2Nodes.png" alt="Map Entries with Backups in Two Members">
</div>
</div>
<div class="paragraph">
<p>As you see, when a new member joins the cluster, it takes ownership and loads some of the
data in the cluster. Eventually, it will carry almost "(1/n <code>*</code> total-data) + backups" of the data,
reducing the load on other members.</p>
</div>
<div class="paragraph">
<p><code>HazelcastInstance.getMap()</code> returns an instance of <code>com.hazelcast.map.IMap</code> which extends
the <code>java.util.concurrent.ConcurrentMap</code> interface. Methods like
<code>ConcurrentMap.putIfAbsent(key,value)</code> and <code>ConcurrentMap.replace(key,value)</code> can be used
on the distributed map, as shown in the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class BasicMapOperations {

    private HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

    public Customer getCustomer(String id) {
        ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap("customers");
        Customer customer = customers.get(id);
        if (customer == null) {
            customer = new Customer(id);
            customer = customers.putIfAbsent(id, customer);
        }
        return customer;
    }

    public boolean updateCustomer(Customer customer) {
        ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap("customers");
        return (customers.replace(customer.getId(), customer) != null);
    }

    public boolean removeCustomer(Customer customer) {
        ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap("customers");
        return customers.remove(customer.getId(), customer);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All <code>ConcurrentMap</code> operations such as <code>put</code> and <code>remove</code> might wait if the key is locked
by another thread in the local or remote JVM. But, they will eventually return with success.
<code>ConcurrentMap</code> operations never throw a <code>java.util.ConcurrentModificationException</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="backing-up-maps"><a class="anchor" href="#backing-up-maps"></a>7.2.3. Backing Up Maps</h4>
<div class="paragraph">
<p>Hazelcast distributes map entries onto multiple cluster members (JVMs). Each member
holds some portion of the data.</p>
</div>
<div class="paragraph">
<p>Distributed maps have one backup by default. If a member goes down, your data is recovered
using the backups in the cluster. There are two types of backups as described below: <em>sync</em> and <em>async</em>.</p>
</div>
<div class="sect4">
<h5 id="creating-sync-backups"><a class="anchor" href="#creating-sync-backups"></a>Creating Sync Backups</h5>
<div class="paragraph">
<p>To provide data safety, Hazelcast allows you to specify the number of backup copies you
want to have. That way, data on a cluster member is copied onto other member(s).</p>
</div>
<div class="paragraph">
<p>To create synchronous backups, select the number of backup copies using the <code>backup-count</code> property.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      backup-count: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>When this count is 1, a map entry will have its backup on one other member in the cluster.
If you set it to 2, then a map entry will have its backup on two other members.
You can set it to 0 if you do not want your entries to be backed up, e.g., if performance
is more important than backing up. The maximum value for the backup count is 6.</p>
</div>
<div class="paragraph">
<p>Hazelcast supports both synchronous and asynchronous backups. By default, backup operations
are synchronous and configured with <code>backup-count</code>. In this case, backup operations block
operations until backups are successfully copied to backup members (or deleted from backup
members in case of remove) and acknowledgements are received. Therefore, backups are updated
before a <code>write</code>(put, set, remove and their async counterparts) operation is completed,
provided that the cluster is stable. Sync backup operations have a blocking cost which may
lead to latency issues.</p>
</div>
</div>
<div class="sect4">
<h5 id="creating-async-backups"><a class="anchor" href="#creating-async-backups"></a>Creating Async Backups</h5>
<div class="paragraph">
<p>Asynchronous backups, on the other hand, do not block operations. They are fire &amp; forget and
do not require acknowledgements; the backup operations are performed at some point in time.</p>
</div>
<div class="paragraph">
<p>To create asynchronous backups, select the number of async backups with the <code>async-backup-count</code>
property. An example is shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;backup-count&gt;0&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      backup-count: 0
      async-backup-count: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#consistency-and-replication-model">Consistency and Replication Model</a> for more detail.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Backups increase memory usage since they are also kept in memory.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A map can have both sync and async backups at the same time.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="enabling-backup-reads"><a class="anchor" href="#enabling-backup-reads"></a>Enabling Backup Reads</h5>
<div class="paragraph">
<p>By default, Hazelcast has one sync backup copy. If <code>backup-count</code> is set to more than 1, then
each member will carry both owned entries and backup copies of other members. So for the <code>map.get(key)</code>
call, it is possible that the calling member has a backup copy of that key. By default, <code>map.get(key)</code>
always reads the value from the actual owner of the key for consistency.</p>
</div>
<div class="paragraph">
<p>To enable backup reads (read local backup entries), set the value of the <code>read-backup-data</code> property
to <strong>true</strong>. Its default value is <strong>false</strong> for consistency. Enabling backup reads can improve
performance but on the other hand it can cause stale reads while still preserving monotonic-reads property.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;backup-count&gt;0&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
        &lt;read-backup-data&gt;true&lt;/read-backup-data&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      backup-count: 0
      async-backup-count: 1
      read-backup-data: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>This feature is available when there is at least one sync or async backup.</p>
</div>
<div class="paragraph">
<p>Please note that if you are performing a read from a backup, you should take into account that
your hits to the keys in the backups are not reflected as hits to the original keys on the primary
members. This has an impact on IMap&#8217;s maximum idle seconds or time-to-live seconds expiration.
Therefore, even though there is a hit on a key in backups, your original key on the primary member may expire.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Backup reads that are requested by Hazelcast clients are ignored since this operation
is performed on the local entries.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="map-eviction"><a class="anchor" href="#map-eviction"></a>7.2.4. Map Eviction</h4>
<div class="paragraph">
<p>Unless you delete the map entries manually or use an eviction policy, they will remain in the map.
Hazelcast supports policy-based eviction for distributed maps. Currently supported policies are
LRU (Least Recently Used) and LFU (Least Frequently Used).</p>
</div>
<div class="paragraph">
<p>Hazelcast Map uses the same eviction mechanism as the JCache implementation.
See the <a href="#eviction-algorithm">Eviction Algorithm section</a> for details.</p>
</div>
<div class="sect4">
<h5 id="understanding-map-eviction"><a class="anchor" href="#understanding-map-eviction"></a>Understanding Map Eviction</h5>
<div class="paragraph">
<p>Hazelcast Map performs eviction based on partitions. For example, when you specify a size using
the <code>PER_NODE</code> attribute for <code>max-size</code> (see the <a href="#configuring-map-eviction">Configuring Map Eviction section</a>),
Hazelcast internally calculates the maximum size for every partition. Hazelcast uses the following
equation to calculate the maximum size of a partition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>partition-maximum-size = max-size * member-count / partition-count</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the <code>partition-maximum-size</code> is less than 1 in the equation above, it will be set to 1
(otherwise, the partitions would be emptied immediately by eviction due to the exceedance of
<code>max-size</code> being less than 1).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The eviction process starts according to this calculated partition maximum size when you try
to put an entry. When entry count in that partition exceeds partition maximum size, eviction
starts on that partition.</p>
</div>
<div class="paragraph">
<p>Assume that you have the following figures as examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>partition count: 200</p>
</li>
<li>
<p>entry count for each partition: 100</p>
</li>
<li>
<p><code>max-size</code> (PER_NODE): 20000</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The total number of entries here is 20000 (partition count * entry count for each partition).
This means you are at the eviction threshold since you set the <code>max-size</code> to 20000. When you
try to put an entry:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the entry goes to the relevant partition</p>
</li>
<li>
<p>the partition checks whether the eviction threshold is reached (<code>max-size</code>)</p>
</li>
<li>
<p>only one entry will be evicted.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As a result of this eviction process, when you check the size of your map, it is 19999. After
this eviction, subsequent put operations do not trigger the next eviction until the map size
is again close to the <code>max-size</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The above scenario is simply an example that describes how the eviction process works.
Hazelcast finds the most optimum number of entries to be evicted according to your cluster
size and selected policy.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="configuring-map-eviction"><a class="anchor" href="#configuring-map-eviction"></a>Configuring Map Eviction</h5>
<div class="paragraph">
<p>The following is an example declarative configuration for map eviction.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;max-idle-seconds&gt;0&lt;/max-idle-seconds&gt;
        &lt;eviction eviction-policy="LRU" max-size-policy="PER_NODE" size="5000"/&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      time-to-live-seconds: 0
      max-idle-seconds: 0
      eviction:
        eviction-policy: LRU
        max-size-policy: PER_NODE
        size: 5000</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the configuration element descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>time-to-live-seconds</code>: Maximum time in seconds for each entry to stay in the map (TTL).
It limits the lifetime of the entries relative to the time of the last write access
performed on them. If it is not 0, the entries whose lifetime exceeds this period
(without any write access performed on them during this period) are expired and
evicted automatically. An individual entry may have its own lifetime limit by
using one of the methods accepting a TTL; see <a href="#evicting-specific-entries">Evicting Specific Entries section</a>.
If there is no TTL value provided for the individual entry, it inherits the value
set for this element. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>.
Its default value is 0, which means infinite (no expiration and eviction). If it is not 0,
entries are evicted regardless of the set <code>eviction-policy</code> described below.</p>
</li>
<li>
<p><code>max-idle-seconds</code>: Maximum time in seconds for each entry to stay idle in
the map. It limits the lifetime of the entries relative to the time of the
last read or write access performed on them. The entries whose idle period
exceeds this limit are expired and evicted automatically. An entry is idle
if no <code>get</code>, <code>put</code>, <code>EntryProcessor.process</code> or <code>containsKey</code> is called on
it. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>.
Its default value is 0, which means infinite.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Setting this property to 1 second expires the entry after 1 second, regardless of
the operations done on that entry in-between, due to the loss of millisecond
resolution on the entry timestamps. Assume that you create a record at time = 1 second
(1000 milliseconds) and access it at wall clock time 1100 milliseconds and
then again at 1400 milliseconds. In this case, the entry is deemed as not touched.
So, setting this property to 1 second is not supported.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Both <code>time-to-live-seconds</code> and <code>max-idle-seconds</code> may be used simultaneously on
the map entries. In that case, the entry is considered expired if at least one of the
policies marks it as expired.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>eviction-policy</code>: Eviction policy to be applied when the size of map grows larger than
the value specified by the <code>size</code> element described below.  Valid values are:</p>
<div class="ulist">
<ul>
<li>
<p>NONE: Default policy. If set, no items are evicted and the property <code>size</code> described
below is ignored. You still can combine it with <code>time-to-live-seconds</code> and <code>max-idle-seconds</code>.</p>
</li>
<li>
<p>LRU: Least Recently Used.</p>
</li>
<li>
<p>LFU: Least Frequently Used.</p>
<div class="paragraph">
<p>Apart from the above values, you can also develop and use your own eviction policy.
See the <a href="#custom-eviction-policy">Custom Eviction Policy section</a>.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>size</code>: Maximum size of the map. When maximum size is reached, the map is evicted
based on the policy defined. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>.
Its default value is 0, which means infinite. If you want <code>size</code> to work, set the
<code>eviction-policy</code> property to a value other than NONE. Its attributes are described below.</p>
<div class="ulist">
<ul>
<li>
<p><code>PER_NODE</code>: Maximum number of map entries in each cluster member. This is the default policy.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="PER_NODE" size="5000"/&gt;</code></p>
</div>
</li>
<li>
<p><code>PER_PARTITION</code>: Maximum number of map entries within each partition. Storage size depends
on the partition count in a cluster member. This attribute should not be used often. For instance,
avoid using this attribute with a small cluster. If the cluster is small, it hosts more partitions,
and therefore map entries, than that of a larger cluster. Thus, for a small cluster, eviction of
the entries decreases performance (the number of entries is large).</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="PER_PARTITION" size="27100" /&gt;</code></p>
</div>
</li>
<li>
<p><code>USED_HEAP_SIZE</code>: Maximum used heap size in megabytes per map for each Hazelcast instance.
Please note that this policy does not work when <a href="#setting-in-memory-format">in-memory format</a>
is set to <code>OBJECT</code>, since the memory footprint cannot be determined when data is put as <code>OBJECT</code>.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="USED_HEAP_SIZE" size="4096" /&gt;</code></p>
</div>
</li>
<li>
<p><code>USED_HEAP_PERCENTAGE</code>: Maximum used heap size percentage per map for each Hazelcast instance.
If, for example, a JVM is configured to have 1000 MB and this value is 10, then the map entries
will be evicted when used heap size exceeds 100 MB. Please note that this policy does not work
when <a href="#setting-in-memory-format">in-memory format</a> is set to <code>OBJECT</code>, since the memory footprint
cannot be determined when data is put as <code>OBJECT</code>.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="USED_HEAP_PERCENTAGE" size="10" /&gt;</code></p>
</div>
</li>
<li>
<p><code>FREE_HEAP_SIZE</code>: Minimum free heap size in megabytes for each JVM.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="FREE_HEAP_SIZE" size="512" /&gt;</code></p>
</div>
</li>
<li>
<p><code>FREE_HEAP_PERCENTAGE</code>: Minimum free heap size percentage for each JVM. If, for example, a JVM
is configured to have 1000 MB and this value is 10, then the map entries will be evicted when
free heap size is below 100 MB.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="FREE_HEAP_PERCENTAGE" size="10" /&gt;</code></p>
</div>
</li>
<li>
<p><code>USED_NATIVE_MEMORY_SIZE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) Maximum used native memory
size in megabytes per map for each Hazelcast instance.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="USED_NATIVE_MEMORY_SIZE" size="1024" /&gt;</code></p>
</div>
</li>
<li>
<p><code>USED_NATIVE_MEMORY_PERCENTAGE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) Maximum used native
memory size percentage per map for each Hazelcast instance.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="USED_NATIVE_MEMORY_PERCENTAGE" size="65" /&gt;</code></p>
</div>
</li>
<li>
<p><code>FREE_NATIVE_MEMORY_SIZE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) Minimum free native memory
size in megabytes for each Hazelcast instance.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="FREE_NATIVE_MEMORY_SIZE" size="256" /&gt;</code></p>
</div>
</li>
<li>
<p><code>FREE_NATIVE_MEMORY_PERCENTAGE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) Minimum free native
memory size percentage for each Hazelcast instance.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="FREE_NATIVE_MEMORY_PERCENTAGE" size="5" /&gt;</code></p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>To put it briefly, Hazelcast maps have no restrictions on the size and may grow arbitrarily
large, by default. When it comes to reducing the size of a map, there are two concepts:
expiration and eviction.</p>
</div>
<div class="paragraph">
<p>Expiration puts a limit on the maximum lifetime of an entry stored inside the map.
When the entry expires it cannot be retrieved from the map any longer and at some point
in time it will be cleaned out from the map to free up the memory. Expiration, and hence
the eviction based on the expiration, can be configured using the element <code>time-to-live-seconds</code>
and <code>max-idle-seconds</code> as described above.</p>
</div>
<div class="paragraph">
<p>Eviction puts a limit on the maximum size of the map. If the size of the map grows larger than
the maximum allowed size, an eviction policy decides which item to evict from the map to reduce
its size. The maximum allowed size can be configured using the element <code>size</code> and the
eviction policy can be configured using the element <code>eviction-policy</code> as described above.</p>
</div>
<div class="paragraph">
<p>Eviction and expiration can be used together. In this case, the expiration configurations
(<code>time-to-live-seconds</code> and <code>max-idle-seconds</code>) continue to work as usual cleaning out the
expired entries regardless of the map size. Note that locked map entries are not the subjects
for eviction and expiration.</p>
</div>
</div>
<div class="sect4">
<h5 id="example-eviction-configurations"><a class="anchor" href="#example-eviction-configurations"></a>Example Eviction Configurations</h5>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="documents"&gt;
        &lt;eviction eviction-policy="LRU" max-size-policy="PER_NODE" size="10000"/&gt;
        &lt;max-idle-seconds&gt;60&lt;/max-idle-seconds&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    documents:
      eviction:
        eviction-policy: LRU
        max-size-policy: PER_NODE
        size: 10000
      max-idle-seconds: 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, <code>documents</code> map starts to evict its entries from a member when the
map size exceeds 10000 in that member. Then the entries least recently used will be evicted.
The entries not used for more than 60 seconds will be evicted as well.</p>
</div>
<div class="paragraph">
<p>And the following is an example eviction configuration for a map having <code>NATIVE</code> as the
in-memory format:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="nativeMap"&gt;
        &lt;in-memory-format&gt;NATIVE&lt;/in-memory-format&gt;
        &lt;eviction max-size-policy="USED_NATIVE_MEMORY_PERCENTAGE" eviction-policy="LFU" size="99"/&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    nativeMap:
      in-memory-format: NATIVE
      eviction:
        eviction-policy: LFU
        max-size-policy: USED_NATIVE_MEMORY_PERCENTAGE
        size: 99</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="evicting-specific-entries"><a class="anchor" href="#evicting-specific-entries"></a>Evicting Specific Entries</h5>
<div class="paragraph">
<p>The eviction policies and configurations explained above apply to all the entries of a map.
The entries that meet the specified eviction conditions are evicted.</p>
</div>
<div class="paragraph">
<p>If you want to evict some specific map entries, you can use the <code>ttl</code> and <code>ttlUnit</code> parameters of
the method <code>map.put()</code>. An example code line is given below.</p>
</div>
<div class="paragraph">
<p><code>myMap.put( "1", "John", 50, TimeUnit.SECONDS )</code></p>
</div>
<div class="paragraph">
<p>The map entry with the key "1" will be evicted 50 seconds after it is put into <code>myMap</code>.</p>
</div>
<div class="paragraph">
<p>You may also use <code>map.setTTL</code> method to alter the time-to-live value of an existing entry.
It is done as follows:</p>
</div>
<div class="paragraph">
<p><code>myMap.setTTL( "1", 50, TimeUnit.SECONDS )</code></p>
</div>
<div class="paragraph">
<p>In addition to the <code>ttl</code>, you may also specify a maximum idle timeout for specific map entries
using the <code>maxIdle</code> and <code>maxIdleUnit</code> parameters:</p>
</div>
<div class="paragraph">
<p><code>myMap.put( "1", "John", 50, TimeUnit.SECONDS, 40, TimeUnit.SECONDS )</code></p>
</div>
<div class="paragraph">
<p>Here <code>ttl</code> is set as 50 seconds and <code>maxIdle</code> is set as 40 seconds. The entry is considered to
be evicted if at least one of these policies marks it as expired. If you want to specify only
the <code>maxIdle</code> parameter, you need to set <code>ttl</code> as 0 seconds.</p>
</div>
</div>
<div class="sect4">
<h5 id="evicting-all-entries"><a class="anchor" href="#evicting-all-entries"></a>Evicting All Entries</h5>
<div class="paragraph">
<p>To evict all keys from the map except the locked ones, use the method <code>evictAll()</code>.
If a MapStore is defined for the map, <code>deleteAll</code> is not called by <code>evictAll</code>. If
you want to call the method <code>deleteAll</code>, use <code>clear()</code>.</p>
</div>
<div class="paragraph">
<p>An example is given below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        final int numberOfKeysToLock = 4;
        final int numberOfEntriesToAdd = 1000;

        HazelcastInstance node1 = Hazelcast.newHazelcastInstance();
        HazelcastInstance node2 = Hazelcast.newHazelcastInstance();

        IMap&lt;Integer, Integer&gt; map = node1.getMap( "map" );
        for (int i = 0; i &lt; numberOfEntriesToAdd; i++) {
            map.put(i, i);
        }

        for (int i = 0; i &lt; numberOfKeysToLock; i++) {
            map.lock(i);
        }

        // should keep locked keys and evict all others.
        map.evictAll();

        System.out.printf("# After calling evictAll...\n");
        System.out.printf("# Expected map size\t: %d\n", numberOfKeysToLock);
        System.out.printf("# Actual map size\t: %d\n", map.size());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Only EVICT_ALL event is fired for any registered listeners.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="forced-eviction"><a class="anchor" href="#forced-eviction"></a>Forced Eviction</h5>
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast may use forced eviction in the cases when the eviction
explained in <a href="#understanding-map-eviction">Understanding Map Eviction</a>
is not enough to free up your memory. Note that this is valid if
you are using <strong class="blue">Hazelcast IMDG Enterprise</strong> and you set your
in-memory format to <code>NATIVE</code>.</p>
</div>
<div class="paragraph">
<p>The forced eviction mechanism is explained below as steps in the
given order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the normal eviction is not enough, forced eviction is
triggered and first it tries to evict approx. 20% of the entries
from the current partition. It retries this five times.</p>
</li>
<li>
<p>If the result of above step is still not enough, forced eviction
applies the above step to all maps. This time it might perform eviction
from some other partitions too, provided that they are owned by the same
thread.</p>
</li>
<li>
<p>If that is still not enough to free up your memory, it evicts not the
20% but all the entries from the current partition.</p>
</li>
<li>
<p>If that is not enough, it will evict all the entries from the other
data structures; from the partitions owned by the local thread.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, when all the above steps are not enough, Hazelcast throws
a native <code>OutOfMemoryException</code>.</p>
</div>
<div class="paragraph">
<p>When you have an evictable cache/map, you should safely put
entries to it without facing with any memory shortages.
Forced eviction helps to achieve this. Regular eviction
removes one entry at a time while forced eviction can remove
multiple entries, which can even be owned by another caches/maps.</p>
</div>
</div>
<div class="sect4">
<h5 id="custom-eviction-policy"><a class="anchor" href="#custom-eviction-policy"></a>Custom Eviction Policy</h5>
<div class="paragraph">
<p>Apart from the policies such as LRU and LFU, which Hazelcast provides out-of-the-box,
you can develop and use your own eviction policy.</p>
</div>
<div class="paragraph">
<p>To achieve this, you need to provide an implementation of <code>MapEvictionPolicyComparator</code> as in
the following <code>OddEvictor</code> example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MapCustomEvictionPolicyComparator {

    public static void main(String[] args) {
        Config config = new Config();
        config.getMapConfig("test")
                .getEvictionConfig()
                .setComparator(new OddEvictor())
                .setMaxSizePolicy(PER_NODE)
                .setSize(10000);

        HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);
        IMap&lt;Integer, Integer&gt; map = instance.getMap("test");

        final Queue&lt;Integer&gt; oddKeys = new ConcurrentLinkedQueue&lt;Integer&gt;();
        final Queue&lt;Integer&gt; evenKeys = new ConcurrentLinkedQueue&lt;Integer&gt;();

        map.addEntryListener((EntryEvictedListener&lt;Integer, Integer&gt;) event -&gt; {
            Integer key = event.getKey();
            if (key % 2 == 0) {
                evenKeys.add(key);
            } else {
                oddKeys.add(key);
            }
        }, false);

        // wait some more time to receive evicted-events
        parkNanos(SECONDS.toNanos(5));

        for (int i = 0; i &lt; 15000; i++) {
            map.put(i, i);
        }

        String msg = "IMap uses sampling based eviction. After eviction"
                + " is completed, we are expecting number of evicted-odd-keys"
                + " should be greater than number of evicted-even-keys. \nNumber"
                + " of evicted-odd-keys = %d, number of evicted-even-keys = %d";
        out.println(format(msg, oddKeys.size(), evenKeys.size()));

        instance.shutdown();
    }

    /**
     * Odd evictor tries to evict odd keys first.
     */
    private static class OddEvictor
            implements MapEvictionPolicyComparator&lt;Integer, Integer&gt; {

        @Override
        public int compare(EntryView&lt;Integer, Integer&gt; e1,
                           EntryView&lt;Integer, Integer&gt; e2) {

            Integer key1 = e1.getKey();
            if (key1 % 2 != 0) {
                return -1;
            }

            Integer key2 = e2.getKey();
            if (key2 % 2 != 0) {
                return 1;
            }

            return 0;
        }

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can enable your policy by setting it via the method
<code>MapConfig.getEvictionConfig().setComparatorClassName()</code>
programmatically or via XML declaratively. Following is the example
declarative configuration for the eviction policy <code>OddEvictor</code> implemented above:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="test"&gt;
        ...
        &lt;eviction comparator-class-name="com.mycompany.OddEvictor"/&gt;
        ...
    &lt;/map&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    test:
      eviction:
        comparator-class-name: com.mycompany.OddEvictor</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you Hazelcast with Spring, you can enable your policy as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:map name="test"&gt;
    &lt;hz:map-eviction comparator-class-name="com.package.OddEvictor"/&gt;
&lt;/hz:map&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setting-in-memory-format"><a class="anchor" href="#setting-in-memory-format"></a>7.2.5. Setting In-Memory Format</h4>
<div class="paragraph">
<p>IMap (and a few other Hazelcast data structures, such as ICache)
has an <code>in-memory-format</code> configuration option. By default, Hazelcast
stores data into memory in binary (serialized) format. Sometimes it can
be efficient to store the entries in their object form, especially in cases
of local processing, such as entry processor and queries.</p>
</div>
<div class="paragraph">
<p>Specify the <code>in-memory-format</code> element in the configuration to set how the
data will be stored in the memory. You have the following format options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BINARY</code> (default): The data (both the key and value) is stored in serialized
binary format. You can use this option if you mostly perform regular map
operations, such as <code>put</code> and <code>get</code>.</p>
</li>
<li>
<p><code>OBJECT</code>: The data is stored in deserialized form. This configuration is
good for maps where <a href="#entry-processor">entry processing</a> and <a href="#how-distributed-query-works">queries</a> form the majority of all
operations and the objects are complex, making the serialization cost comparatively
high. By storing objects, entry processing does not contain the deserialization
cost. Note that when you use <code>OBJECT</code> as the in-memory format, the key is still
stored in binary format and the value is stored in object format.</p>
</li>
<li>
<p><code>NATIVE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) This format behaves the same as
BINARY, however, instead of heap memory, key and value are stored in the off-heap
memory.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Regular operations like <code>get</code> rely on the object instance. When the <code>OBJECT</code> format
is used and a <code>get</code> is performed, the map does not return the stored instance,
but creates a clone. Therefore, this whole <code>get</code> operation first includes a
serialization on the member owning the instance and then a deserialization on
the member calling the instance. When the <code>BINARY</code> format is used, only a
deserialization is required; <code>BINARY</code> is faster.</p>
</div>
<div class="paragraph">
<p>Similarly, a <code>put</code> operation is faster when the <code>BINARY</code> format is used. If the
format was <code>OBJECT</code>, the map would create a clone of the instance, and there would
first be a serialization and then a deserialization. When BINARY is used, only a
deserialization is needed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a value is stored in <code>OBJECT</code> format, a change on a returned value does not
affect the stored instance. In this case, the returned instance is not the actual one
but a clone. Therefore, changes made on an object after it is returned will not reflect
on the actual stored data. Similarly, when a value is written to a map and the value is
stored in <code>OBJECT</code> format, it will be a copy of the <code>put</code> value. Therefore, changes made
on the object after it is stored will not reflect on the stored data.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-high-density-memory-store-with-map"><a class="anchor" href="#using-high-density-memory-store-with-map"></a>7.2.6. Using High-Density Memory Store with Map</h4>
<div class="paragraph">
<p><strong class="navy">Hazelcast IMDG Enterprise HD</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast instances are Java programs. In case of <code>BINARY</code> and <code>OBJECT</code> in-memory
formats, Hazelcast stores your distributed data into the heap of its server instances.
Java heap is subject to garbage collection (GC). In case of larger heaps, garbage
collection might cause your application to pause for tens of seconds (even minutes
for really large heaps), badly affecting your application performance and response times.</p>
</div>
<div class="paragraph">
<p>As the data gets bigger, you either run the application with larger heap, which would
result in longer GC pauses or run multiple instances with smaller heap which can turn
into an operational nightmare if the number of such instances becomes very high.</p>
</div>
<div class="paragraph">
<p>To overcome this challenge, Hazelcast offers High-Density Memory Store for your maps.
You can configure your map to use High-Density Memory Store by setting the in-memory
format to <code>NATIVE</code>. The following snippet is the declarative configuration example.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="nativeMap"&gt;
        &lt;in-memory-format&gt;NATIVE&lt;/in-memory-format&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    nativeMap:
      in-memory-format: NATIVE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that you should have already enabled the High-Density Memory Store
usage for your cluster. See the <a href="#configuring-high-density-memory-store">Configuring High-Density Memory Store section</a>.</p>
</div>
<div class="paragraph">
<p>You can also benefit from the persistent memory technologies such as
Intel&#174; Optane&#8482; DC to be used by the High-Density Memory Store. See the
<a href="#using-persistent-memory">Using Persistent Memory section</a>.</p>
</div>
<div class="sect4">
<h5 id="required-configuration-changes-when-using-native"><a class="anchor" href="#required-configuration-changes-when-using-native"></a>Required Configuration Changes When Using NATIVE</h5>
<div class="paragraph">
<p>Note that the eviction mechanism is different for <code>NATIVE</code> in-memory format.
The new eviction algorithm for map with High-Density Memory Store is similar
to that of JCache with High-Density Memory Store and is described <a href="#eviction-algorithm">here</a>.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="nativeMap"&gt;
        &lt;in-memory-format&gt;NATIVE&lt;/in-memory-format&gt;
        &lt;eviction-percentage&gt;25&lt;/eviction-percentage&gt; &lt;--! NO IMPACT with NATIVE --&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    nativeMap:
      in-memory-format: NATIVE
      eviction-percentage: 25 # NO IMPACT with NATIVE</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>These IMap eviction policies for <code>size</code> cannot be used: <code>FREE_HEAP_PERCENTAGE</code>,
<code>FREE_HEAP_SIZE</code>, <code>USED_HEAP_PERCENTAGE</code>, <code>USED_HEAP_SIZE</code>.</p>
</li>
<li>
<p>Near Cache eviction policy <code>ENTRY_COUNT</code> cannot be used for
<code>max-size-policy</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#high-density-memory-store">High-Density Memory Store section</a>
for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_metadata_policy"><a class="anchor" href="#_metadata_policy"></a>7.2.7. Metadata Policy</h4>
<div class="paragraph">
<p>Hazelcast IMap offers automatic preprocessing of various data types on the
update time to make queries faster. It is currently supported only by the
<a href="#querying-json-strings">HazelcastJsonValue</a> type. When metadata creation
is on, IMap creates additional metadata about the objects of supported types
and uses this metadata during the querying. It does not affect the latency
and throughput of the object of any type except the supported types.</p>
</div>
<div class="paragraph">
<p>This feature is on by default. You can configure it using the <code>metadata-policy</code>
configuration element.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="map-a"&gt;
        &lt;!--
        valid values for metadata-policy are:
          - OFF
          - CREATE_ON_UPDATE (default)
        --&gt;
        &lt;metadata-policy&gt;OFF&lt;/metadata-policy&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    map-a:
    # valid values for metadata-policy are:
    # - OFF
    # - CREATE_ON_UPDATE (default)
      metadata-policy: OFF</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MapConfig mapConfig = new MapConfig();
mapConfig.setMetadataPolicy(MetadataPolicy.OFF);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="loading-and-storing-persistent-data"><a class="anchor" href="#loading-and-storing-persistent-data"></a>7.2.8. Loading and Storing Persistent Data</h4>
<div class="paragraph">
<p>Hazelcast allows you to load and store the distributed map entries
from/to a persistent data store such as a relational database. To do this,
you can use Hazelcast&#8217;s <code>MapStore</code> and <code>MapLoader</code> interfaces.</p>
</div>
<div class="paragraph">
<p>When you provide a <code>MapLoader</code> implementation and request an entry
(<code>IMap.get()</code>) that does not exist in memory, <code>MapLoader</code>'s <code>load</code>
method loads that entry from the data store. This loaded entry is placed
into the map and will stay there until it is removed or evicted.</p>
</div>
<div class="paragraph">
<p>All loads can be listened via <code>EntryLoadedListener</code>. See the
<a href="#listening-for-map-events">Listening for Map Events section</a>
to learn how you can catch entry-based events.</p>
</div>
<div class="paragraph">
<p>When a <code>MapStore</code> implementation is provided, an entry is also put into a
user defined data store.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Data store needs to be a centralized system that is
accessible from all Hazelcast members. Persistence to a local file system
is not supported.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Also note that the <code>MapStore</code> interface extends the <code>MapLoader</code> interface
as you can see in the interface <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/MapStore.html" target="_blank" rel="noopener">code</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Following is a <code>MapStore</code> example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonMapStore implements MapStore&lt;Long, Person&gt; {

    private final Connection con;
    private final PreparedStatement allKeysStatement;

    public PersonMapStore() {
        try {
            con = DriverManager.getConnection("jdbc:hsqldb:mydatabase", "SA", "");
            con.createStatement().executeUpdate(
                    "create table if not exists person (id bigint not null, name varchar(45), primary key (id))");
            allKeysStatement = con.prepareStatement("select id from person");
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void delete(Long key) {
        System.out.println("Delete:" + key);
        try {
            con.createStatement().executeUpdate(
                    format("delete from person where id = %s", key));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void store(Long key, Person value) {
        try {
            con.createStatement().executeUpdate(
                    format("insert into person values(%s,'%s')", key, value.getName()));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void storeAll(Map&lt;Long, Person&gt; map) {
        for (Map.Entry&lt;Long, Person&gt; entry : map.entrySet()) {
            store(entry.getKey(), entry.getValue());
        }
    }

    public synchronized void deleteAll(Collection&lt;Long&gt; keys) {
        for (Long key : keys) {
            delete(key);
        }
    }

    public synchronized Person load(Long key) {
        try {
            ResultSet resultSet = con.createStatement().executeQuery(
                    format("select name from person where id =%s", key));
            try {
                if (!resultSet.next()) {
                    return null;
                }
                String name = resultSet.getString(1);
                return new Person(key, name);
            } finally {
                resultSet.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized Map&lt;Long, Person&gt; loadAll(Collection&lt;Long&gt; keys) {
        Map&lt;Long, Person&gt; result = new HashMap&lt;Long, Person&gt;();
        for (Long key : keys) {
            result.put(key, load(key));
        }
        return result;
    }

    public Iterable&lt;Long&gt; loadAllKeys() {
        return new StatementIterable&lt;Long&gt;(allKeysStatement);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
During the initial loading process, MapStore uses a thread different from the
partition threads that are used by the ExecutorService. After the initialization is
completed, the <code>map.get</code> method looks up any nonexistent value from the database in
a partition thread, or the <code>map.put</code> method looks up the database to return the previously
associated value for a key also in a partition thread.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Entries loaded by <code>MapLoader</code> do not have a set time-to-live property. Therefore,
they live until evicted or explicitly removed. It is possible to enforce time-to-live
on the entries by using <code>EntryLoader</code>. <code>EntryLoader</code> allows you to set
time-to-live values per key before handing the values to Hazelcast. Therefore, you can store and
load key specific time-to-live values in the external storage.</p>
</div>
<div class="paragraph">
<p>Similar to <code>EntryLoader</code>, in order to store custom expiration times associated
with the entries, you may use <code>EntryStore</code>. <code>EntryStore</code> allows you to
retrieve associated expiration date for each entry. The expiration date is an offset
from an epoch in milliseconds. Epoch is January 1, 1970 UTC which is used by
<code>System.currentTimeMillis()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although the expiration date is expressed in milliseconds, IMap has second granularity
when it comes to expiration. Therefore, the expiration date is rounded to the nearest lower
whole second.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>EntryLoader</code> and <code>EntryStore</code> extend from <code>MapLoader</code> and <code>MapStore</code>, respectively.
Therefore, all features and configuration parameters of <code>MapLoader</code> and <code>MapStore</code> apply
to them, too.</p>
</div>
<div class="paragraph">
<p>Following is an <code>EntryStore</code> example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonEntryStore implements EntryStore&lt;Long, Person&gt; {

    private final Connection con;
    private final PreparedStatement allKeysStatement;

    public PersonEntryStore() {
        try {
            con = DriverManager.getConnection("jdbc:hsqldb:mydatabase", "SA", "");
            con.createStatement().executeUpdate(
                    "create table if not exists person (id bigint not null, name varchar(45), expiration-date bigint, primary key (id))");
            allKeysStatement = con.prepareStatement("select id from person");
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public synchronized void delete(Long key) {
        System.out.println("Delete:" + key);
        try {
            con.createStatement().executeUpdate(
                    format("delete from person where id = %s", key));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public synchronized void store(Long key, MetadataAwareValue&lt;Person&gt; value) {
        try {
            con.createStatement().executeUpdate(
                    format("insert into person values(%s,'%s', %d)", key, value.getValue().getName(), value.getExpirationTime()));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void storeAll(Map&lt;Long, MetadataAwareValue&lt;Person&gt;&gt; map) {
        for (Map.Entry&lt;Long, MetadataAwareValue&lt;Person&gt;&gt; entry : map.entrySet()) {
            store(entry.getKey(), entry.getValue());
        }
    }

    @Override
    public synchronized void deleteAll(Collection&lt;Long&gt; keys) {
        for (Long key : keys) {
            delete(key);
        }
    }

    @Override
    public synchronized MetadataAwareValue&lt;Person&gt; load(Long key) {
        try {
            ResultSet resultSet = con.createStatement().executeQuery(
                    format("select name,expiration-date from person where id =%s", key));
            try {
                if (!resultSet.next()) {
                    return null;
                }
                String name = resultSet.getString(1);
                Long expirationDate = resultSet.getLong(2);
                return new MetadataAwareValue&lt;&gt;(new Person(key, name), expirationDate);
            } finally {
                resultSet.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public synchronized Map&lt;Long, MetadataAwareValue&lt;Person&gt;&gt; loadAll(Collection&lt;Long&gt; keys) {
        Map&lt;Long, MetadataAwareValue&lt;Person&gt;&gt; result = new HashMap&lt;&gt;();
        for (Long key : keys) {
            result.put(key, load(key));
        }
        return result;
    }

    public Iterable&lt;Long&gt; loadAllKeys() {
        return new StatementIterable&lt;Long&gt;(allKeysStatement);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more MapStore/MapLoader code samples,
see <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/distributed-map/mapstore/src/main/java" target="_blank" rel="noopener">here</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast supports read-through, write-through and write-behind persistence
modes, which are explained in the subsections below.</p>
</div>
<div class="sect4">
<h5 id="using-read-through-persistence"><a class="anchor" href="#using-read-through-persistence"></a>Using Read-Through Persistence</h5>
<div class="paragraph">
<p>If an entry does not exist in memory when an application asks for it,
Hazelcast asks the loader implementation to load that entry from the
data store.  If the entry exists there, the loader implementation gets it,
hands it to Hazelcast, and Hazelcast puts it into memory. This is read-through
persistence mode.</p>
</div>
<div class="paragraph">
<p>As you can remember from the introduction of this section, the <code>IMap.get()</code> method
triggers the <code>load()</code> method in your MapLoader implementation if an entry does not
exist in the memory. In this case, note that the <code>IMap.get()</code> method does not create
backup copies for such entries, when the mode is read-through persistence: there is no
need for backups for these entries since if the primary entry is lost, then a read for
the key triggers the <code>load()</code> method and loads the entry from the persistence layer.</p>
</div>
</div>
<div class="sect4">
<h5 id="setting-write-through-persistence"><a class="anchor" href="#setting-write-through-persistence"></a>Setting Write-Through Persistence</h5>
<div class="paragraph">
<p><code>MapStore</code> can be configured to be write-through by setting the <code>write-delay-seconds</code>
property to <strong>0</strong>. This means the entries are put to the data store synchronously.</p>
</div>
<div class="paragraph">
<p>In this mode, when the <code>map.put(key,value)</code> call returns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MapStore.store(key,value)</code> is successfully called so the entry is persisted.</p>
</li>
<li>
<p>In-Memory entry is updated.</p>
</li>
<li>
<p>In-Memory backup copies are successfully created on other cluster members
(if <code>backup-count</code> is greater than 0).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>MapStore</code> throws an exception then the exception is propagated to the original
<code>put</code> or <code>remove</code> call in the form of <code>RuntimeException</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a key difference in the behaviors of <code>map.remove(key)</code> and
<code>map.delete(key)</code>, i.e., the latter results in <code>MapStore.delete(key)</code> to be invoked
whereas the former only removes the entry from IMap.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="setting-write-behind-persistence"><a class="anchor" href="#setting-write-behind-persistence"></a>Setting Write-Behind Persistence</h5>
<div class="paragraph">
<p>You can configure <code>MapStore</code> as write-behind by setting the <code>write-delay-seconds</code>
property to a value bigger than <strong>0</strong>. This means the modified entries will be
put to the data store asynchronously after a configured delay.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In write-behind mode, Hazelcast coalesces updates on a specific key by
default, which means it applies only the last update on that key. However,
you can set <code>MapStoreConfig.setWriteCoalescing()</code> to <code>FALSE</code> and you can store
all updates performed on a key to the data store.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you set <code>MapStoreConfig.setWriteCoalescing()</code> to <code>FALSE</code>, after you
reached per-node maximum write-behind-queue capacity, subsequent put operations
will fail with <code>ReachedMaxSizeException</code>. This exception is thrown to prevent
uncontrolled grow of write-behind queues. You can set per-node maximum capacity
using the system property <code>hazelcast.map.write.behind.queue.capacity</code>. See the
<a href="#system-properties">System Properties appendix</a> for information on this property
and how to set the system properties.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In write-behind mode, when the <code>map.put(key,value)</code> call returns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>in-memory entry is updated</p>
</li>
<li>
<p>in-memory backup copies are successfully created on the other cluster members
(if <code>backup-count</code> is greater than 0)</p>
</li>
<li>
<p>the entry is marked as dirty so that after <code>write-delay-seconds</code>, it can be
persisted with <code>MapStore.store(key,value)</code> call</p>
</li>
<li>
<p>and for fault tolerance, dirty entries are stored in a queue on the primary
member and also on a back-up member.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The same behavior goes for the <code>map.remove(key)</code>, the only difference is that
<code>MapStore.delete(key)</code> is called when the entry will be deleted.</p>
</div>
<div class="paragraph">
<p>If <code>MapStore</code> throws an exception, then Hazelcast tries to store the entry again.
If the entry still cannot be stored, a log message is printed and the entry is re-queued.</p>
</div>
<div class="paragraph">
<p>For batch write operations, which are only allowed in write-behind mode,
Hazelcast calls the <code>MapStore.storeAll(map)</code> and <code>MapStore.deleteAll(collection)</code>
methods to do all writes in a single call.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a map entry is marked as dirty, meaning that it is waiting to be
persisted to the <code>MapStore</code> in a write-behind scenario, the eviction process
forces the entry to be stored. This way you have control over the number of
entries waiting to be stored, and thus you can prevent a possible OutOfMemory
exception.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>MapStore</code> or <code>MapLoader</code> implementations should not use
Hazelcast Map/Queue/MultiMap/List/Set operations. Your implementation should
only work with your data store. Otherwise, you may get into deadlock situations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;map-store enabled="true" initial-mode="LAZY"&gt;
            &lt;class-name&gt;com.hazelcast.examples.DummyStore&lt;/class-name&gt;
            &lt;write-delay-seconds&gt;60&lt;/write-delay-seconds&gt;
            &lt;write-batch-size&gt;1000&lt;/write-batch-size&gt;
            &lt;write-coalescing&gt;true&lt;/write-coalescing&gt;
        &lt;/map-store&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      map-store:
        enabled: true
        initial-mode: LAZY
        class-name: com.hazelcast.examples.DummyStore
        write-delay-seconds: 60
        write-batch-size: 1000
        write-coalescing: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions of MapStore configuration elements and attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>class-name</code>: Name of the class implementing MapLoader and/or MapStore.</p>
</li>
<li>
<p><code>write-delay-seconds</code>: Number of seconds to delay to call the
MapStore.store(key, value). If the value is zero then it is write-through,
so the <code>MapStore.store(key,value)</code> method is called as soon as the entry is
updated. Otherwise, it is write-behind; so the updates will be stored after
the <code>write-delay-seconds</code> value by calling the <code>Hazelcast.storeAll(map)</code> method.
Its default value is 0.</p>
</li>
<li>
<p><code>write-batch-size</code>: Used to create batch chunks when writing map store. In
default mode, all map entries are tried to be written in one go. To create
batch chunks, the minimum meaningful value for write-batch-size is 2. For values
smaller than 2, it works as in default mode.</p>
</li>
<li>
<p><code>write-coalescing</code>: In write-behind mode, Hazelcast coalesces updates on a
specific key by default; it applies only the last update on it. You can set this
element to <code>false</code> to store all updates performed on a key to the data store.</p>
</li>
<li>
<p><code>enabled</code>: True to enable this map-store, false to disable. Its default value
is true.</p>
</li>
<li>
<p><code>initial-mode</code>: Sets the initial load mode. LAZY is the default load mode, where
load is asynchronous. EAGER means load is blocked till all partitions are loaded.
See the <a href="#initializing-map-on-startup">Initializing Map on Startup section</a> for
more details.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_managing_the_lifecycle_of_a_maploader"><a class="anchor" href="#_managing_the_lifecycle_of_a_maploader"></a>Managing the Lifecycle of a MapLoader</h5>
<div class="paragraph">
<p>With <code>MapLoader</code> (and <code>MapStore</code> which extends it), you can do the regular store and load operations.
If you need to perform other operations on create or on destroy of a <code>MapLoader</code>,
such as establishing a connection to a database or accessing to other Hazelcast maps,
you need to implement the <code>MapLoaderLifeCycleSupport</code> interface. By implementing
it, you will have the <code>init()</code> and <code>destroy()</code> methods.</p>
</div>
<div class="paragraph">
<p>The <code>init()</code> method initializes the <code>MapLoader</code> implementation. Hazelcast calls
this method when the map is first created on a Hazelcast instance. The <code>MapLoader</code>
implementation can initialize the required resources
such as reading a configuration file or creating a database connection
or accessing a Hazelcast instance.</p>
</div>
<div class="paragraph">
<p>The <code>destroy()</code> method is called during the graceful shutdown of a Hazelcast instance.
You can override this method  to cleanup the resources held by the <code>MapLoader</code> implementation, such as
closing the database connections.</p>
</div>
<div class="paragraph">
<p>In summary, you need <code>MapLoaderLifecycleSupport</code> to perform actions
on create and on destroy of a <code>MapLoader</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="https://github.com/hazelcast/hazelcast-code-samples/blob/master/hazelcast-integration/mongodb/src/main/java/com/hazelcast/loader/MongoMapStore.java" target="_blank" rel="noopener">here</a> to see this interface in action.</p>
</div>
</div>
<div class="sect4">
<h5 id="storing-entries-to-multiple-maps"><a class="anchor" href="#storing-entries-to-multiple-maps"></a>Storing Entries to Multiple Maps</h5>
<div class="paragraph">
<p>A configuration can be applied to more than one map using wildcards
(see <a href="#using-wildcards">Using Wildcards</a>), meaning that the configuration is
shared among the maps. But <code>MapStore</code> does not know which entries to store
when there is one configuration applied to multiple maps.</p>
</div>
<div class="paragraph">
<p>To store entries when there is one configuration applied to multiple maps,
use Hazelcast&#8217;s <code>MapStoreFactory</code> interface. Using the <code>MapStoreFactory</code> interface,
<code>MapStore</code>s for each map can be created when a wildcard configuration is used.
Example code is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
MapConfig mapConfig = config.getMapConfig( "*" );
MapStoreConfig mapStoreConfig = mapConfig.getMapStoreConfig();
mapStoreConfig.setFactoryImplementation( new MapStoreFactory&lt;Object, Object&gt;() {
    @Override
    public MapLoader&lt;Object, Object&gt; newMapStore( String mapName, Properties properties ) {
        return null;
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>To initialize the <code>MapLoader</code> implementation with the given map name, configuration
properties and the Hazelcast instance, implement the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/MapLoaderLifecycleSupport.html" target="_blank" rel="noopener"><code>MapLoaderLifecycleSupport</code> interface</a>
which is described in the previous section.</p>
</div>
</div>
<div class="sect4">
<h5 id="initializing-map-on-startup"><a class="anchor" href="#initializing-map-on-startup"></a>Initializing Map on Startup</h5>
<div class="paragraph">
<p>To pre-populate the in-memory map when the map is first touched/used,
use the <code>MapLoader.loadAllKeys</code> API.</p>
</div>
<div class="paragraph">
<p>If <code>MapLoader.loadAllKeys</code> returns NULL, then nothing will be loaded.
Your <code>MapLoader.loadAllKeys</code> implementation can return all or some of the
keys. For example, you may select and return only the keys which are most
important to you that you want to load them while initializing the map.
<code>MapLoader.loadAllKeys</code> is the fastest way of pre-populating the map since
Hazelcast optimizes the loading process by having each cluster member load
its owned portion of the entries.</p>
</div>
<div class="paragraph">
<p>The <code>InitialLoadMode</code> configuration parameter in the class
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/MapStoreConfig.html" target="_blank" rel="noopener">MapStoreConfig</a>
has two values: <code>LAZY</code> and <code>EAGER</code>. If <code>InitialLoadMode</code> is set to
<code>LAZY</code>, data is not loaded during the map creation. If it is set to
<code>EAGER</code>, all the data is loaded while the map is created and everything becomes
ready to use. Also, if you add indices to your map with the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/IndexConfig.html" target="_blank" rel="noopener">IndexConfig</a>
class or the <a href="#indexing-queries"><code>addIndex</code></a> method, then
<code>InitialLoadMode</code> is overridden and <code>MapStoreConfig</code> behaves as if <code>EAGER</code> mode is on.</p>
</div>
<div class="paragraph">
<p>Here is the <code>MapLoader</code> initialization flow:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When <code>getMap()</code> is first called from any member, initialization starts
depending on the value of <code>InitialLoadMode</code>. If it is set to <code>EAGER</code>,
initialization starts on all partitions as soon as the map is touched,
i.e., all partitions are loaded when <code>getMap</code> is called.  If it is set to
<code>LAZY</code>, data is loaded partition by partition, i.e., each partition is
loaded with its first touch.</p>
</li>
<li>
<p>Hazelcast calls <code>MapLoader.loadAllKeys()</code> to get all your
keys on one of the members.</p>
</li>
<li>
<p>That member distributes keys to all other members in batches.</p>
</li>
<li>
<p>Each member loads values of all its owned keys by calling
<code>MapLoader.loadAll(keys)</code>.</p>
</li>
<li>
<p>Each member puts its owned entries into the map by calling
<code>IMap.putTransient(key,value)</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the load mode is <code>LAZY</code> and the <code>clear()</code> method is called
(which triggers <code>MapStore.deleteAll()</code>), Hazelcast removes <strong>ONLY</strong> the
loaded entries from your map and datastore. Since all the data is not loaded
in this case (<code>LAZY</code> mode), please note that there may still be entries
in your datastore.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not want the MapStore start to load as soon as the
first cluster member starts, you can use the system property <code>hazelcast.initial.min.cluster.size</code>.
For example, if you set its value as <code>3</code>, loading process will be
blocked until all three members are completely up.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The return type of <code>loadAllKeys()</code> is changed from <code>Set</code> to <code>Iterable</code>
with the release of Hazelcast 3.5. MapLoader implementations from previous
releases are also supported and do not need to be adapted.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="loading-keys-incrementally"><a class="anchor" href="#loading-keys-incrementally"></a>Loading Keys Incrementally</h5>
<div class="paragraph">
<p>If the number of keys to load is large, it is more efficient to
load them incrementally rather than loading them all at once. To support
incremental loading, the <code>MapLoader.loadAllKeys()</code> method returns an <code>Iterable</code>
which can be lazily populated with the results of a database query.</p>
</div>
<div class="paragraph">
<p>Hazelcast iterates over the <code>Iterable</code> and, while doing so, sends out the keys
to their respective owner members. The <code>Iterator</code> obtained from <code>MapLoader.loadAllKeys()</code>
may also implement the <code>Closeable</code> interface, in which case <code>Iterator</code> is closed
once the iteration is over. This is intended for releasing resources such as
closing a JDBC result set.</p>
</div>
</div>
<div class="sect4">
<h5 id="forcing-all-keys-to-be-loaded"><a class="anchor" href="#forcing-all-keys-to-be-loaded"></a>Forcing All Keys To Be Loaded</h5>
<div class="paragraph">
<p>The method <code>loadAll</code> loads some or all keys into a data store in order to
optimize the multiple load operations. The method has two signatures; the
same method can take two different parameter lists. One signature loads the
given keys and the other loads all keys. See the example code below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        final int numberOfEntriesToAdd = 1000;
        final String mapName = LoadAll.class.getCanonicalName();
        final Config config = createNewConfig(mapName);
        final HazelcastInstance node = Hazelcast.newHazelcastInstance(config);
        final IMap&lt;Integer, Integer&gt; map = node.getMap(mapName);

        populateMap(map, numberOfEntriesToAdd);
        System.out.printf("# Map store has %d elements\n", numberOfEntriesToAdd);

        map.evictAll();
        System.out.printf("# After evictAll map size\t: %d\n", map.size());

        map.loadAll(true);
        System.out.printf("# After loadAll map size\t: %d\n", map.size());</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="post-processing-objects-in-map-store"><a class="anchor" href="#post-processing-objects-in-map-store"></a>Post-Processing Objects in Map Store</h5>
<div class="paragraph">
<p>In some scenarios, you may need to modify the object after storing it into
the map store.
For example, you can get an ID or version auto-generated by your database and
then need to modify your object stored in the distributed map, but not to break
the synchronization between the database and the data grid.</p>
</div>
<div class="paragraph">
<p>To post-process an object in the map store, implement the <code>PostProcessingMapStore</code>
interface to put the modified object into the distributed map. This triggers an
extra step of <code>Serialization</code>, so use it only when needed. (This is only valid
when using the <code>write-through</code> map store configuration.)</p>
</div>
<div class="paragraph">
<p>Here is an example of post processing map store:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ProcessingStore implements MapStore&lt;Integer, Employee&gt;, PostProcessingMapStore {
    @Override
    public void store( Integer key, Employee employee ) {
        EmployeeId id = saveEmployee();
        employee.setId( id.getId() );
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please note that if you are using a post-processing map store in
combination with the entry processors, post-processed values will not be
carried to backups.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="accessing-a-database-using-properties"><a class="anchor" href="#accessing-a-database-using-properties"></a>Accessing a Database Using <code>Properties</code></h5>
<div class="paragraph">
<p>You can prepare your own <code>MapLoader</code> to access a database such as Cassandra
and MongoDB. For this, you can first declaratively specify the database properties
in your <code>hazelcast.xml</code> configuration file and then implement the
<code>MapLoaderLifecycleSupport</code> interface to pass those properties.</p>
</div>
<div class="paragraph">
<p>You can define the database properties, such as its URL and name, using the
<code>properties</code> configuration element. The following is a configuration example
for MongoDB:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="supplements"&gt;
        &lt;map-store enabled="true" initial-mode="LAZY"&gt;
            &lt;class-name&gt;com.hazelcast.loader.YourMapStoreImplementation&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="mongo.url"&gt;mongodb://localhost:27017&lt;/property&gt;
                &lt;property name="mongo.db"&gt;mydb&lt;/property&gt;
                &lt;property name="mongo.collection"&gt;supplements&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/map-store&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    supplements:
      map-store:
        enabled: true
        initial-mode: LAZY
        class-name: com.hazelcast.loader.YourMapStoreImplementation
        properties:
          mongo_url: mongodb://localhost:27017
          mongo.db: mydb
          mango.collection: supplements</code></pre>
</div>
</div>
<div class="paragraph">
<p>After you specified the database properties in your configuration,
you need to implement the <code>MapLoaderLifecycleSupport</code> interface and
give those properties in the <code>init()</code> method, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class YourMapStoreImplementation implements MapStore&lt;String, Supplement&gt;, MapLoaderLifecycleSupport {

    private MongoClient mongoClient;
    private MongoCollection collection;

    public YourMapStoreImplementation() {
    }

    @Override
    public void init(HazelcastInstance hazelcastInstance, Properties properties, String mapName) {
        String mongoUrl = (String) properties.get("mongo.url");
        String dbName = (String) properties.get("mongo.db");
        String collectionName = (String) properties.get("mongo.collection");
        this.mongoClient = new MongoClient(new MongoClientURI(mongoUrl));
        this.collection = mongoClient.getDatabase(dbName).getCollection(collectionName);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the full example <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/mongodb" target="_blank" rel="noopener">here</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="map-mapstore"><a class="anchor" href="#map-mapstore"></a>MapStore and MapLoader Methods Triggered by IMap Operations</h5>
<div class="paragraph">
<p>As it is explained in the above sections, you can configure
Hazelcast maps to be backed
by a map store to persist the entries. In this case many of the
IMap methods call
MapLoaderorMapStoremethods to load, store or remove data. This
section summarizes
these methods. Here are the Hazelcast IMap operations that may
trigger the MapStore or MapLoader methods:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">IMap Method</th>
<th class="tableblock halign-left valign-top">Impact on the MapStore/MapLoader</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>flush()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the map has a MapStore, this method flushes all the local dirty
entries. It calls the<code>MapStore.storeAll(Map)</code>or
<code>MapStore.deleteAll(Collection)</code> methods with the elements marked as dirty.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>put()</code></p>
</li>
<li>
<p><code>putAll()</code></p>
</li>
<li>
<p><code>putAsync()</code></p>
</li>
<li>
<p><code>tryPut()</code></p>
</li>
<li>
<p><code>putIfAbsent()</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>These methods are used to put entries to the map. They call the
<code>MapLoader.load(Object)</code> method for each entry not found in the memory
to load the value from the map store backing the map. They also call the
<code>MapStore.store(Object, Object)</code> method for each entry, if write-through
persistence mode is configured before the entry is added into the memory.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>set()</code></p>
</li>
<li>
<p><code>setAsync()</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>These methods put an entry into the map without returning the old value.
They call the <code>MapStore.store(Object, Object)</code> method if write-through
persistence mode is configured before the entry is added into the memory,
to write the value into the map store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>remove()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Removes the mapping for a key from the map if it is present. It calls the
<code>MapLoader.load(Object)</code> method if no value is found withkeyin the memory,
to load the value from the map store backing the map. It also calls the
<code>MapStore.delete(Object)</code> method if write-through persistence mode is
configured before the value is removed from the memory,to remove the value
from the map store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>removeAll()</code></p>
</li>
<li>
<p><code>delete()</code></p>
</li>
<li>
<p><code>removeAsync()</code></p>
</li>
<li>
<p><code>tryRemove()</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>These methods are used to remove entries from the map for various conditions.
They call the <code>MapStore.delete(Object)</code> method if write-through persistence mode
is configured before the value is removed from the memory,to remove the value
from the map store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>setTtl</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This method updates time-to-live of an existing entry. It calls the <code>MapLoader.load(Object)</code>
method if no value is found in the memory. It also calls <code>EntryStore.store(Object, MetadataAwareValue)</code>
with the entry whose time-to-live has been updated.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>clear()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It clears the map and deletes the items from the backing map store. It calls
the<code>MapStore.deleteAll(Collection)</code>method on each partition with the keys that the
given partition stores.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>replace()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It replaces the entry for a key only if currently mapped to a given value.
It calls the <code>MapStore.store(Object, Object)</code> method if write-through persistence
mode is configured before the value is stored in the memory,to write the value into
the map store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>executeOnKey()</code></p>
</li>
<li>
<p><code>executeOnKeys()</code></p>
</li>
<li>
<p><code>submitToKey()</code></p>
</li>
<li>
<p><code>executeOnAllEntries()</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>These methods apply the user definedentry processorsto the entry or entries.
They call the <code>MapLoader.load(Object)</code> method if the value withkeyis not found in the
memory,to load the value from the map store backing the map. If the entry processor
updates the entry and write-through persistence mode is configured, before the value is
stored in memory, they call the<code>MapStore.store(Object, Object)</code>method to write the value
into the map store. If the entry processor updates the entry&#8217;s value to null value and write-through
persistence mode is configured, before the value is removed from the memory,they call the
<code>MapStore.delete(Object)</code>method to delete the value from the map store.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="creating-near-cache-for-map"><a class="anchor" href="#creating-near-cache-for-map"></a>7.2.9. Creating Near Cache for Map</h4>
<div class="paragraph">
<p>The Hazelcast distributed map supports a local Near Cache for
remotely stored entries to increase the performance of local
read operations. See the <a href="#near-cache">Near Cache section</a> for a
detailed explanation of the Near Cache feature and its configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="locking-maps"><a class="anchor" href="#locking-maps"></a>7.2.10. Locking Maps</h4>
<div class="paragraph">
<p>Hazelcast Distributed Map (IMap) is thread-safe to meet your thread
safety requirements. When these requirements increase or you want to
have more control on the concurrency, consider the Hazelcast solutions described here.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class RacyUpdateMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( "map" );
        String key = "1";
        map.put( key, new Value() );
        System.out.println( "Starting" );
        for ( int k = 0; k &lt; 1000; k++ ) {
            if ( k % 100 == 0 ) System.out.println( "At: " + k );
            Value value = map.get( key );
            Thread.sleep( 10 );
            value.amount++;
            map.put( key, value );
        }
        System.out.println( "Finished! Result = " + map.get(key).amount );
    }

    static class Value implements Serializable {
        public int amount;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the above code is run by more than one cluster member simultaneously,
a race condition is likely. You can solve this condition with Hazelcast
using either pessimistic or optimistic locking.</p>
</div>
<div class="sect4">
<h5 id="pessimistic-looking"><a class="anchor" href="#pessimistic-looking"></a>Pessimistic Locking</h5>
<div class="paragraph">
<p>One way to solve the race issue is by using pessimistic locking -
lock the map entry until you are finished with it.</p>
</div>
<div class="paragraph">
<p>To perform pessimistic locking, use the lock mechanism provided by the
Hazelcast distributed map, i.e., the <code>map.lock</code> and <code>map.unlock</code> methods.
See the below example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PessimisticUpdateMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( "map" );
        String key = "1";
        map.put( key, new Value() );
        System.out.println( "Starting" );
        for ( int k = 0; k &lt; 1000; k++ ) {
            map.lock( key );
            try {
                Value value = map.get( key );
                Thread.sleep( 10 );
                value.amount++;
                map.put( key, value );
            } finally {
                map.unlock( key );
            }
        }
        System.out.println( "Finished! Result = " + map.get( key ).amount );
    }

    static class Value implements Serializable {
        public int amount;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The IMap lock will automatically be collected by the garbage collector
when the lock is released and no other waiting conditions exist on the lock.</p>
</div>
<div class="paragraph">
<p>The IMap lock is reentrant, but it does not support fairness.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In some cases, a client application connected to your
cluster may cause the entries in a map to remain locked
after the application has been restarted (which were already locked
before such a restart). This can be due to the
reasons such as incomplete/incorrect client implementations. In these cases,
you can unlock the entries, either from the thread which locked them
using the <code>IMap.unlock()</code> method, or check if the entry is locked
using the <code>IMap.isLock()</code> method and then call <code>IMap.forceUnlock()</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For the above case, as a workaround, you can also kill all the applications connected
to the cluster and use the Management Center&#8217;s scripting functionality to clear the map and
release the locks (instead of using <code>IMap.forceUnlock()</code>). Keep in mind that the scripting
functionality is limited to working with maps that have primitive key types, e.g., string keys
and limited to relaying only a single string of output per member to the result panel in the Management Center.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another way to solve the race issue is by acquiring a predictable <code>Lock</code>
object from Hazelcast. This way, every value in the map can be given a lock,
or you can create a stripe of locks.</p>
</div>
</div>
<div class="sect4">
<h5 id="optimistic-locking"><a class="anchor" href="#optimistic-locking"></a>Optimistic Locking</h5>
<div class="paragraph">
<p>In Hazelcast, you can apply the optimistic locking strategy with the
map&#8217;s <code>replace</code> method. This method compares values in object or data forms
depending on the in-memory format configuration. If the values are equal,
it replaces the old value with the new one. If you want to use your defined
<code>equals</code> method, <code>in-memory-format</code> should be <code>OBJECT</code>. Otherwise, Hazelcast
serializes objects to <code>BINARY</code> forms and compares them.</p>
</div>
<div class="paragraph">
<p>See the below example code.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The below example code is intentionally broken.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class OptimisticMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( "map" );
        String key = "1";
        map.put( key, new Value() );
        System.out.println( "Starting" );
        for ( int k = 0; k &lt; 1000; k++ ) {
            if ( k % 10 == 0 ) System.out.println( "At: " + k );
            for (; ; ) {
                Value oldValue = map.get( key );
                Value newValue = new Value( oldValue );
                Thread.sleep( 10 );
                newValue.amount++;
                if ( map.replace( key, oldValue, newValue ) )
                    break;
            }
        }
        System.out.println( "Finished! Result = " + map.get( key ).amount );
    }

    static class Value implements Serializable {
        public int amount;

        public Value() {
        }

        public Value( Value that ) {
            this.amount = that.amount;
        }

        public boolean equals( Object o ) {
            if ( o == this ) return true;
            if ( !( o instanceof Value ) ) return false;
            Value that = ( Value ) o;
            return that.amount == this.amount;
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pessimistic-vs-optimistic-locking"><a class="anchor" href="#pessimistic-vs-optimistic-locking"></a>Pessimistic vs. Optimistic Locking</h5>
<div class="paragraph">
<p>The locking strategy you choose depends on your locking requirements.</p>
</div>
<div class="paragraph">
<p>Optimistic locking is better for mostly read-only systems. It has a
performance boost over pessimistic locking.</p>
</div>
<div class="paragraph">
<p>Pessimistic locking is good if there are lots of updates on the same
key. It is more robust than optimistic locking from the perspective of data consistency.</p>
</div>
<div class="paragraph">
<p>In Hazelcast, use <code>IExecutorService</code> to submit a task to a key owner,
or to a member or members. This is the recommended way to perform task executions,
rather than using pessimistic or optimistic locking techniques. <code>IExecutorService</code>
has fewer network hops and less data over wire, and tasks are executed very near to the data.
See the <a href="#data-affinity">Data Affinity section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="solving-the-aba-problem"><a class="anchor" href="#solving-the-aba-problem"></a>Solving the ABA Problem</h5>
<div class="paragraph">
<p>The ABA problem occurs in environments when a shared resource is
open to change by multiple threads. Even if one thread sees the same value
for a particular key in consecutive reads, it does not mean that nothing
has changed between the reads. Another thread may change the value,
do work and change the value back, while the first thread thinks that nothing has changed.</p>
</div>
<div class="paragraph">
<p>To prevent these kind of problems, you can assign a version number and
check it before any write to be sure that nothing has changed between consecutive reads.
Although all the other fields are equal, the version field will prevent objects
from being seen as equal. This is the optimistic locking strategy; it is used in
environments that do not expect intensive concurrent changes on a specific key.</p>
</div>
<div class="paragraph">
<p>In Hazelcast, you can apply the <a href="#optimistic-locking">optimistic locking</a>
strategy with the map <code>replace</code> method.</p>
</div>
</div>
<div class="sect4">
<h5 id="lock-split-brain-protection-with-pessimistic-locking"><a class="anchor" href="#lock-split-brain-protection-with-pessimistic-locking"></a>Lock Split-Brain Protection with Pessimistic Locking</h5>
<div class="paragraph">
<p>Locks can be configured to check the number of currently present members
before applying a locking operation. If the check fails, the lock operation
fails with a <code>SplitBrainProtectionException</code> (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
As pessimistic locking uses lock operations internally, it also uses the configured
lock split-brain protection. This means that you can configure a lock split-brain protection with the same name or a
pattern that matches the map name. Note that the split-brain protection for IMap locking actions can be
different from the split-brain protection for other IMap actions.</p>
</div>
<div class="paragraph">
<p>The following actions check for lock split-brain protection before being applied:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IMap.lock(K)</code> and <code>IMap.lock(K, long, java.util.concurrent.TimeUnit)</code></p>
</li>
<li>
<p><code>IMap.isLocked()</code></p>
</li>
<li>
<p><code>IMap.tryLock(K)</code>, <code>IMap.tryLock(K, long, java.util.concurrent.TimeUnit)</code> and
<code>IMap.tryLock(K, long, java.util.concurrent.TimeUnit, long, java.util.concurrent.TimeUnit)</code></p>
</li>
<li>
<p><code>IMap.unlock()</code></p>
</li>
<li>
<p><code>IMap.forceUnlock()</code></p>
</li>
<li>
<p><code>MultiMap.lock(K)</code> and <code>MultiMap.lock(K, long, java.util.concurrent.TimeUnit)</code></p>
</li>
<li>
<p><code>MultiMap.isLocked()</code></p>
</li>
<li>
<p><code>MultiMap.tryLock(K)</code>, <code>MultiMap.tryLock(K, long, java.util.concurrent.TimeUnit)</code>
and <code>MultiMap.tryLock(K, long, java.util.concurrent.TimeUnit, long, java.util.concurrent.TimeUnit)</code></p>
</li>
<li>
<p><code>MultiMap.unlock()</code></p>
</li>
<li>
<p><code>MultiMap.forceUnlock()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An example of declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;split-brain-protection-ref&gt;map-actions-split-brain-protection&lt;/split-brain-protection-ref&gt;
    &lt;/map&gt;
    &lt;lock name="myMap"&gt;
        &lt;split-brain-protection-ref&gt;map-lock-actions-split-brain-protection&lt;/split-brain-protection-ref&gt;
    &lt;/lock&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      split-brain-protection-ref: map-actions-split-brain-protection
  lock:
    myMap:
      split-brain-protection-ref: map-lock-actions-split-brain-protection</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the configured map uses the <code>map-lock-actions-split-brain-protection</code> for
map lock actions and the <code>map-actions-split-brain-protection</code> for other map actions.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="accessing-entry-statistics"><a class="anchor" href="#accessing-entry-statistics"></a>7.2.11. Accessing Map and Entry Statistics</h4>
<div class="paragraph">
<p>You can retrieve the statistics of the map in your Hazelcast IMDG member
using the <code>getLocalMapStats()</code> method, which is the programmatic approach.
It returns information such as primary and backup entry count, last update
time and locked entry count. If you need the cluster-wide map statistics, you can
get the local map statistics from all members of the cluster and combine them.
Alternatively, you can see the map statistics on the
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#managing-maps" target="_blank" rel="noopener">Hazelcast Management Center</a>.</p>
</div>
<div class="paragraph">
<p>To be able to retrieve the map statistics, the <code>statistics-enabled</code>
element under the map configuration should be set as <code>true</code>, which is the default value:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      statistics-enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>When this element is set to <code>false</code>, the statistics are not gathered
for the map and cannot be seen on the Hazelcast Management Center, nor retrieved
by the <code>getLocalMapStats()</code> method.</p>
</div>
<div class="paragraph">
<p>Hazelcast also keeps statistics about each map entry, such as creation time,
last update time, last access time, and number of hits and version. To access
the map entry statistics, use an <code>IMap.getEntryView(key)</code> call. Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hz = Hazelcast.newHazelcastInstance();
EntryView entry = hz.getMap( "quotes" ).getEntryView( "1" );
System.out.println ( "size in memory  : " + entry.getCost() );
System.out.println ( "creationTime    : " + entry.getCreationTime() );
System.out.println ( "expirationTime  : " + entry.getExpirationTime() );
System.out.println ( "number of hits  : " + entry.getHits() );
System.out.println ( "lastAccessedTime: " + entry.getLastAccessTime() );
System.out.println ( "lastUpdateTime  : " + entry.getLastUpdateTime() );
System.out.println ( "version         : " + entry.getVersion() );
System.out.println ( "key             : " + entry.getKey() );
System.out.println ( "value           : " + entry.getValue() );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="map-listener"><a class="anchor" href="#map-listener"></a>7.2.12. Map Listener</h4>
<div class="paragraph">
<p>See the <a href="#listening-for-map-events">Listening for Map Events section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="listening-to-map-entries-with-predicates"><a class="anchor" href="#listening-to-map-entries-with-predicates"></a>7.2.13. Listening to Map Entries with Predicates</h4>
<div class="paragraph">
<p>You can listen to the modifications performed on specific map entries.
You can think of it as an entry listener with predicates. See the
<a href="#listening-for-map-events">Listening for Map Events section</a> for
information on how to add entry listeners to a map.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default backwards-compatible event publishing strategy only publishes
<code>UPDATED</code> events when map entries are updated to a value that
matches the predicate with which the listener was registered.
This implies that when using the default event publishing strategy,
your listener is not notified about an entry whose
value is updated from one that matches the predicate to a new value
that does not match the predicate.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since version 3.7, when you configure Hazelcast members with property
<code>hazelcast.map.entry.filtering.natural.event.types</code> set to <code>true</code>,
handling of entry updates conceptually treats value transition as entry,
update or exit with regards to the predicate value space.
The following table compares how a listener is notified about an update
to a map entry value under the default
backwards-compatible Hazelcast behavior (when property
<code>hazelcast.map.entry.filtering.natural.event.types</code> is not set or is set
to <code>false</code>) versus when set to <code>true</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.entry.filtering.natural.event.types = true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">When old value matches predicate, new value does not match predicate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No event is delivered to entry listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REMOVED</code> event is delivered to entry listener</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">When old value matches predicate, new value matches predicate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPDATED</code> event is delivered to entry listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPDATED</code> event is delivered to entry listener</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">When old value does not match predicate, new value does not match predicate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No event is delivered to entry listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No event is delivered to entry listener</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">When old value does not match predicate, new value matches predicate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPDATED</code> event is delivered to entry listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ADDED</code> event is delivered to entry listener</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>As an example, let&#8217;s listen to the changes made on an employee
with the surname "Smith". First, let&#8217;s create the <code>Employee</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee implements Serializable {

    private final String surname;

    public Employee(String surname) {
        this.surname = surname;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "surname='" + surname + '\'' +
                '}';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, let&#8217;s create a listener with predicate by adding a listener
that tracks <code>ADDED</code>, <code>UPDATED</code> and <code>REMOVED</code> entry events with the <code>surname</code> predicate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ListenerWithPredicate {

    public static void main(String[] args) {
        Config config = new Config();
        config.setProperty("hazelcast.map.entry.filtering.natural.event.types", "true");
        HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);
        IMap&lt;String, String&gt; map = hz.getMap("map");
        map.addEntryListener(new MyEntryListener(),
                Predicates.sql("surname=smith"), true);
        System.out.println("Entry Listener registered");
    }

    static class MyEntryListener
            implements EntryAddedListener&lt;String, String&gt;,
            EntryUpdatedListener&lt;String, String&gt;,
            EntryRemovedListener&lt;String, String&gt; {
        @Override
        public void entryAdded(EntryEvent&lt;String, String&gt; event) {
            System.out.println("Entry Added:" + event);
        }

        @Override
        public void entryRemoved(EntryEvent&lt;String, String&gt; event) {
            System.out.println("Entry Removed:" + event);
        }

        @Override
        public void entryUpdated(EntryEvent&lt;String, String&gt; event) {
            System.out.println("Entry Updated:" + event);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now, let&#8217;s play with the employee "smith" and see how that employee is listened to.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Modify {

    public static void main(String[] args) {
        Config config = new Config();
        config.setProperty("hazelcast.map.entry.filtering.natural.event.types", "true");
        HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);
        IMap&lt;String, Employee&gt; map = hz.getMap("map");

        map.put("1", new Employee("smith"));
        map.put("2", new Employee("jordan"));
        System.out.println("done");
        System.exit(0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you first run the class <code>ListenerWithPredicate</code> and then run <code>Modify</code>,
an output similar to the one below appears.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>entryAdded:EntryEvent {Address[192.168.178.10]:5702} key=1,oldValue=null,
value=Person{name= smith }, event=ADDED, by Member [192.168.178.10]:5702</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#continuous-query-cache">Continuous Query Cache section</a>
for more information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="removing-map-entries-in-bulk-with-predicates"><a class="anchor" href="#removing-map-entries-in-bulk-with-predicates"></a>7.2.14. Removing Map Entries in Bulk with Predicates</h4>
<div class="paragraph">
<p>You can remove all map entries that match your predicate. For this,
Hazelcast offers the method <code>removeAll()</code>. Its syntax is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void removeAll(Predicate&lt;K, V&gt; predicate);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Normally the map entries matching the predicate are found with a full scan
of the map. If the entries are indexed, Hazelcast uses the index search to find them.
With index, you can expect that finding the entries is faster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When <code>removeAll()</code> is called, ALL entries in the caller member&#8217;s
Near Cache are also removed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="adding-interceptors"><a class="anchor" href="#adding-interceptors"></a>7.2.15. Adding Interceptors</h4>
<div class="paragraph">
<p>You can add intercept operations and execute your own business logic
synchronously blocking the operations. You can change the returned value
from a <code>get</code> operation, change the value in <code>put</code>, or <code>cancel</code> operations
by throwing an exception.</p>
</div>
<div class="paragraph">
<p>Interceptors are different from listeners. With listeners, you take an action
after the operation has been completed. Interceptor actions are synchronous and
you can alter the behavior of operation, change its values, or totally cancel it.</p>
</div>
<div class="paragraph">
<p>Map interceptors are chained, so adding the same interceptor multiple times to the
same map can result in duplicate effects. This can easily happen when the interceptor
is added to the map at member initialization, so that each member adds the same interceptor.
When you add the interceptor in this way, be sure to implement the <code>hashCode()</code>
method to return the same value for every instance of the interceptor.
It is not strictly necessary, but it is a good idea to also implement <code>equals()</code>
as this ensures that the map interceptor can be removed reliably.</p>
</div>
<div class="paragraph">
<p>The IMap API has two methods for adding and removing an interceptor to the map:
<code>addInterceptor</code> and <code>removeInterceptor</code>. See also the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/MapInterceptor.html" target="_blank" rel="noopener"><code>MapInterceptor</code> interface</a>
to learn about the methods used to intercept the changes in a map.</p>
</div>
<div class="paragraph">
<p>The following is an example usage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MapInterceptorMember {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hz.getMap("themap");
        map.addInterceptor(new MyMapInterceptor());

        map.put("1", "1");
        System.out.println(map.get("1"));
    }

    private static class MyMapInterceptor implements MapInterceptor {

        @Override
        public Object interceptGet(Object value) {
            return value + "-foo";
        }

        @Override
        public void afterGet(Object value) {
        }

        @Override
        public Object interceptPut(Object oldValue, Object newValue) {
            return null;
        }

        @Override
        public void afterPut(Object value) {
        }

        @Override
        public Object interceptRemove(Object removedValue) {
            return null;
        }

        @Override
        public void afterRemove(Object value) {
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="preventing-out-of-memory-exceptions"><a class="anchor" href="#preventing-out-of-memory-exceptions"></a>7.2.16. Preventing Out of Memory Exceptions</h4>
<div class="paragraph">
<p>It is very easy to trigger an out of memory exception (OOME) with query-based map methods,
especially with large clusters or heap sizes. For example, on a cluster with five members
having 10 GB of data and 25 GB heap size per member, a single call of <code>IMap.entrySet()</code>
fetches 50 GB of data and crashes the calling instance.</p>
</div>
<div class="paragraph">
<p>A call of <code>IMap.values()</code> may return too much data for a single member.
This can also happen with a real query and an unlucky choice of predicates,
especially when the parameters are chosen by a user of your application.</p>
</div>
<div class="paragraph">
<p>To prevent this, you can configure a maximum result size limit for query based operations.
This is not a limit like <code>SELECT * FROM map LIMIT 100</code>, which you can achieve by a
<a href="#filtering-with-paging-predicates">Paging Predicate</a>. A maximum result size limit
for query based operations is meant to be a last line of defense to prevent your members
from retrieving more data than they can handle.</p>
</div>
<div class="paragraph">
<p>The Hazelcast component which calculates this limit is the <code>QueryResultSizeLimiter</code>.</p>
</div>
<div class="sect4">
<h5 id="setting-query-result-size-limit"><a class="anchor" href="#setting-query-result-size-limit"></a>Setting Query Result Size Limit</h5>
<div class="paragraph">
<p>If the <code>QueryResultSizeLimiter</code> is activated, it calculates a result size limit per partition.
Each <code>QueryOperation</code> runs on all partitions of a member, so it collects result entries
as long as the member limit is not exceeded. If that happens, a
<code>QueryResultSizeExceededException</code> is thrown and propagated to the calling instance.</p>
</div>
<div class="paragraph">
<p>This feature depends on an equal distribution of the data on the cluster members to
calculate the result size limit per member. Therefore, there is a minimum value defined
in <code>QueryResultSizeLimiter.MINIMUM_MAX_RESULT_LIMIT</code>. Configured values below the minimum
will be increased to the minimum.</p>
</div>
</div>
<div class="sect4">
<h5 id="local-pre-check"><a class="anchor" href="#local-pre-check"></a>Local Pre-check</h5>
<div class="paragraph">
<p>In addition to the distributed result size check in the <code>QueryOperations</code>,
there is a local pre-check on the calling instance. If you call the method from a client,
the pre-check is executed on the member that invokes the <code>QueryOperations</code>.</p>
</div>
<div class="paragraph">
<p>Since the local pre-check can increase the latency of a <code>QueryOperation</code>,
you can configure how many local partitions should be considered for the pre-check,
or you can deactivate the feature completely.</p>
</div>
</div>
<div class="sect4">
<h5 id="scope-of-result-size-limit"><a class="anchor" href="#scope-of-result-size-limit"></a>Scope of Result Size Limit</h5>
<div class="paragraph">
<p>Besides the designated query operations, there are other operations that use predicates internally.
Those method calls throw the <code>QueryResultSizeExceededException</code> as well.
See the following matrix for the methods that are covered by the query result size limit.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/Map-QueryResultSizeLimiterScope.png" alt="Methods Covered by Query Result Size Limit">
</div>
</div>
</div>
<div class="sect4">
<h5 id="configuring-query-result-size"><a class="anchor" href="#configuring-query-result-size"></a>Configuring Query Result Size</h5>
<div class="paragraph">
<p>The query result size limit is configured via the following system properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.query.result.size.limit</code>: Result size limit for query operations on maps.
This value defines the maximum number of returned elements for a single query result.
If a query exceeds this number of elements, a QueryResultSizeExceededException is thrown.</p>
</li>
<li>
<p><code>hazelcast.query.max.local.partition.limit.for.precheck</code>: Maximum value of local partitions
to trigger local pre-check for <code>Predicates#alwaysTrue()</code> query operations on maps.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#system-properties">System Properties appendix</a> to see the full descriptions
of these properties and how to set them.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="queue"><a class="anchor" href="#queue"></a>7.3. Queue</h3>
<div class="paragraph">
<p>Hazelcast distributed queue is an implementation of <code>java.util.concurrent.BlockingQueue</code>.
Being distributed, Hazelcast distributed queue enables all cluster members to interact with it.
Using Hazelcast distributed queue, you can add an item in one cluster member and remove it from another one.</p>
</div>
<div class="sect3">
<h4 id="getting-a-queue-and-putting-items"><a class="anchor" href="#getting-a-queue-and-putting-items"></a>7.3.1. Getting a Queue and Putting Items</h4>
<div class="paragraph">
<p>Use the Hazelcast instance&#8217;s <code>getQueue</code> method to get the queue, then use the queue&#8217;s
<code>put</code> method to put items into the queue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        BlockingQueue&lt;MyTask&gt; queue = hazelcastInstance.getQueue( "tasks" );
        queue.put( new MyTask() );
        MyTask task = queue.take();

        boolean offered = queue.offer( new MyTask(), 10, TimeUnit.SECONDS );
        task = queue.poll( 5, TimeUnit.SECONDS );
        if ( task != null ) {
            //process task
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>FIFO ordering applies to all queue operations across the cluster. The user objects
(such as <code>MyTask</code> in the example above) that are enqueued or dequeued have to be <code>Serializable</code>.</p>
</div>
<div class="paragraph">
<p>Hazelcast distributed queue performs no batching while iterating over the queue.
All items are copied locally and iteration occurs locally.</p>
</div>
<div class="paragraph">
<p>Hazelcast distributed queue uses <code>ItemListener</code> to listen to the events that occur
when items are added to and removed from the queue. See the <a href="#listening-for-item-events">Listening for Item Events section</a> for information on how to create an item listener
class and register it.</p>
</div>
</div>
<div class="sect3">
<h4 id="creating-an-example-queue"><a class="anchor" href="#creating-an-example-queue"></a>7.3.2. Creating an Example Queue</h4>
<div class="paragraph">
<p>The following example code illustrates a distributed queue that connects a producer and consumer.</p>
</div>
<div class="sect4">
<h5 id="putting-items-on-the-queue"><a class="anchor" href="#putting-items-on-the-queue"></a>Putting Items on the Queue</h5>
<div class="paragraph">
<p>Let&#8217;s <code>put</code> one integer on the queue every second, 100 integers total.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ProducerMember {

    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IQueue&lt;Integer&gt; queue = hz.getQueue( "queue" );
        for ( int k = 1; k &lt; 100; k++ ) {
            queue.put( k );
            System.out.println( "Producing: " + k );
            Thread.sleep(1000);
        }
        queue.put( -1 );
        System.out.println( "Producer Finished!" );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Producer</code> puts a <strong>-1</strong> on the queue to show that the <code>put</code>s are finished.</p>
</div>
</div>
<div class="sect4">
<h5 id="taking-items-off-the-queue"><a class="anchor" href="#taking-items-off-the-queue"></a>Taking Items off the Queue</h5>
<div class="paragraph">
<p>Now, let&#8217;s create a <code>Consumer</code> class to <code>take</code> a message from this queue, as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ConsumerMember {

    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IQueue&lt;Integer&gt; queue = hz.getQueue( "queue" );
        while ( true ) {
            int item = queue.take();
            System.out.println( "Consumed: " + item );
            if ( item == -1 ) {
                queue.put( -1 );
                break;
            }
            Thread.sleep( 5000 );
        }
        System.out.println( "Consumer Finished!" );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As seen in the above example code, <code>Consumer</code> waits five seconds before it consumes
the next message. It stops once it receives <strong>-1</strong>. Also note that <code>Consumer</code>
puts <strong>-1</strong> back on the queue before the loop is ended.</p>
</div>
<div class="paragraph">
<p>When you first start <code>Producer</code> and then start <code>Consumer</code>, items produced on the
queue will be consumed from the same queue.</p>
</div>
</div>
<div class="sect4">
<h5 id="balancing-the-queue-operations"><a class="anchor" href="#balancing-the-queue-operations"></a>Balancing the Queue Operations</h5>
<div class="paragraph">
<p>From the above example code, you can see that an item is produced every second and
consumed every five seconds. Therefore, the consumer keeps growing. To balance the
produce/consume operation, let&#8217;s start another consumer. This way, consumption is
distributed to these two consumers, as seen in the example outputs below.</p>
</div>
<div class="paragraph">
<p>The second consumer is started. After a while, here is the first consumer output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>...
Consumed 13
Consumed 15
Consumer 17
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the second consumer output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>...
Consumed 14
Consumed 16
Consumer 18
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case of a lot of producers and consumers for the queue, using a list of
queues may solve the queue bottlenecks. In this case, be aware that the order of the
messages sent to different queues is not guaranteed. Since in most cases strict ordering
is not important, a list of queues is a good solution.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The items are taken from the queue in the same order they were put on the queue.
However, if there is more than one consumer, this order is not guaranteed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="itemids-when-offering-items"><a class="anchor" href="#itemids-when-offering-items"></a>ItemIDs When Offering Items</h5>
<div class="paragraph">
<p>Hazelcast gives an <code>itemId</code> for each item you offer, which is an incrementing sequence
identification for the queue items. You should consider the following to understand the
<code>itemId</code> assignment behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a Hazelcast member has a queue and that queue is configured to have at least one
backup, and that member is restarted, the <code>itemId</code> assignment resumes from the last known
highest <code>itemId</code> before the restart; <code>itemId</code> assignment does not start from the beginning for the new items.</p>
</li>
<li>
<p>When the whole cluster is restarted, the same behavior explained in the above
consideration applies if your queue has a persistent data store (<code>QueueStore</code>).
If the queue has <code>QueueStore</code>, the <code>itemId</code> for the new items are given, starting
from the highest <code>itemId</code> found in the IDs returned by the method <code>loadAllKeys</code>.
If the method <code>loadAllKeys</code> does not return anything, the <code>itemId</code>s starts
from the beginning after a cluster restart.</p>
</li>
<li>
<p>The above two considerations mean there are no duplicated <code>itemId</code>s in the memory
or in the persistent data store.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setting-a-bounded-queue"><a class="anchor" href="#setting-a-bounded-queue"></a>7.3.3. Setting a Bounded Queue</h4>
<div class="paragraph">
<p>A bounded queue is a queue with a limited capacity. When the bounded queue is full,
no more items can be put into the queue until some items are taken out.</p>
</div>
<div class="paragraph">
<p>To turn a Hazelcast distributed queue into a bounded queue, set the capacity limit
with the <code>max-size</code> property. You can set the <code>max-size</code> property in the configuration,
as shown below. The <code>max-size</code> element specifies the maximum size of the queue.
Once the queue size reaches this value, <code>put</code> operations are blocked until the
queue size goes below <code>max-size</code>, which happens when a consumer removes items from the queue.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s set <strong>10</strong> as the maximum size of our example queue in <a href="#creating-an-example-queue">Creating an Example Queue</a>.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;queue name="queue"&gt;
        &lt;max-size&gt;10&lt;/max-size&gt;
    &lt;/queue&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  queue:
    queue:
      max-size: 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the producer is started, ten items are put into the queue and then the queue
will not allow more <code>put</code> operations. When the consumer is started, it will remove
items from the queue. This means that the producer can <code>put</code> more items into the
queue until there are ten items in the queue again, at which point the <code>put</code> operation
again becomes blocked.</p>
</div>
<div class="paragraph">
<p>In this example code, the producer is five times faster than the consumer.
It will effectively always be waiting for the consumer to remove items before
it can put more on the queue. For this example code, if maximum throughput is the goal,
it would be a good option to start multiple consumers to prevent the queue from filling up.</p>
</div>
</div>
<div class="sect3">
<h4 id="queueing-with-persistent-datastore"><a class="anchor" href="#queueing-with-persistent-datastore"></a>7.3.4. Queueing with Persistent Datastore</h4>
<div class="paragraph">
<p>Hazelcast allows you to load and store the distributed queue items from/to a persistent
datastore using the interface <code>QueueStore</code>. If queue store is enabled, each item added to
the queue is also stored at the configured queue store. When the number of items in the
queue exceeds the memory limit, the subsequent items are persisted in the queue store,
they are not stored in the queue memory.</p>
</div>
<div class="paragraph">
<p>The <code>QueueStore</code> interface enables you to store, load and delete queue items with methods like
<code>store</code>, <code>storeAll</code>, <code>load</code> and <code>delete</code>. The following example class includes all of the <code>QueueStore</code> methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TheQueueStore implements QueueStore&lt;Item&gt; {

    @Override
    public void delete(Long key) {
        System.out.println("delete");
    }

    @Override
    public void store(Long key, Item value) {
        System.out.println("store");
    }

    @Override
    public void storeAll(Map&lt;Long, Item&gt; map) {
        System.out.println("store all");
    }

    @Override
    public void deleteAll(Collection&lt;Long&gt; keys) {
        System.out.println("deleteAll");
    }

    @Override
    public Item load(Long key) {
        System.out.println("load");
        return null;
    }

    @Override
    public Map&lt;Long, Item&gt; loadAll(Collection&lt;Long&gt; keys) {
        System.out.println("loadALl");
        return null;
    }

    @Override
    public Set&lt;Long&gt; loadAllKeys() {
        System.out.println("loadAllKeys");
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Item</code> must be serializable. The following is an example queue store configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;queue name="queue"&gt;
        &lt;max-size&gt;10&lt;/max-size&gt;
        &lt;queue-store&gt;
            &lt;class-name&gt;com.hazelcast.QueueStoreImpl&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="binary"&gt;false&lt;/property&gt;
                &lt;property name="memory-limit"&gt;1000&lt;/property&gt;
                &lt;property name="bulk-load"&gt;500&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/queue-store&gt;
    &lt;/queue&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  queue:
    queue:
      max-size: 10
      queue-store:
        class-name: com.hazelcast.QueueStoreImpl
        properties:
          binary: false
          memory-limit: 1000
          bulk-load: 500</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions for each queue store property:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Binary</strong>: By default, Hazelcast stores the queue items in serialized form,
and before it inserts the queue items into the queue store, it deserializes them.
If you are not reaching the queue store from an external application, you might
prefer that the items be inserted in binary form. Do this by setting the <code>binary</code>
property to true: then you can get rid of the deserialization step, which is a performance
optimization. The <code>binary</code> property is false by default.</p>
</li>
<li>
<p><strong>Memory Limit</strong>: This is the number of items after which Hazelcast stores items
only to the datastore. For example, if the memory limit is 1000, then the 1001st item
is put only to the datastore. This feature is useful when you want to avoid out-of-memory
conditions. If you want to always use memory, you can set it to <code>Integer.MAX_VALUE</code>.
The default number for <code>memory-limit</code> is 1000.</p>
</li>
<li>
<p><strong>Bulk Load</strong>: When the queue is initialized, items are loaded from <code>QueueStore</code>
in bulks. Bulk load is the size of these bulks. The default value of <code>bulk-load</code> is 250.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="split-brain-protection-for-queue"><a class="anchor" href="#split-brain-protection-for-queue"></a>7.3.5. Split-Brain Protection for Queue</h4>
<div class="paragraph">
<p>Queues can be configured to check for a minimum number of available members before
applying queue operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE</p>
<div class="ulist">
<ul>
<li>
<p><code>Collection.addAll()</code></p>
</li>
<li>
<p><code>Collection.removeAll()</code>, <code>Collection.retainAll()</code></p>
</li>
<li>
<p><code>BlockingQueue.offer()</code>, <code>BlockingQueue.add()</code>, <code>BlockingQueue.put()</code></p>
</li>
<li>
<p><code>BlockingQueue.drainTo()</code></p>
</li>
<li>
<p><code>IQueue.poll()</code>, <code>Queue.remove()</code>, <code>IQueue.take()</code></p>
</li>
<li>
<p><code>BlockingQueue.remove()</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE</p>
<div class="ulist">
<ul>
<li>
<p><code>Collection.clear()</code></p>
</li>
<li>
<p><code>Collection.containsAll()</code>, <code>BlockingQueue.contains()</code></p>
</li>
<li>
<p><code>Collection.isEmpty()</code></p>
</li>
<li>
<p><code>Collection.iterator()</code>, <code>Collection.toArray()</code></p>
</li>
<li>
<p><code>Queue.peek()</code>, <code>Queue.element()</code></p>
</li>
<li>
<p><code>Collection.size()</code></p>
</li>
<li>
<p><code>BlockingQueue.remainingCapacity()</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="configuring-queue"><a class="anchor" href="#configuring-queue"></a>7.3.6. Configuring Queue</h4>
<div class="paragraph">
<p>The following are examples of queue configurations. It includes the
<code>QueueStore</code> configuration, which is explained in the <a href="#queueing-with-persistent-datastore">Queueing with Persistent Datastore</a> section.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;queue name="default"&gt;
        &lt;max-size&gt;0&lt;/max-size&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;empty-queue-ttl&gt;-1&lt;/empty-queue-ttl&gt;
        &lt;item-listeners&gt;
            &lt;item-listener&gt;com.hazelcast.examples.ItemListener&lt;/item-listener&gt;
        &lt;/item-listeners&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;queue-store&gt;
            &lt;class-name&gt;com.hazelcast.QueueStoreImpl&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="binary"&gt;false&lt;/property&gt;
                &lt;property name="memory-limit"&gt;10000&lt;/property&gt;
                &lt;property name="bulk-load"&gt;500&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/queue-store&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/queue&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  queue:
    default:
      max-size: 0
      backup-count: 1
      async-backup-count: 0
      empty-queue-ttl: -1
      item-listeners:
        - include-value: true
          class-name: com.hazelcast.examples.ItemListener
      statistics-enabled: true
      queue-store:
        class-name: com.hazelcast.QueueStoreImpl
        properties:
          binary: false
          memory-limit: 1000
          bulk-load: 500
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        QueueConfig queueConfig = config.getQueueConfig("default");
        queueConfig.setName("MyQueue")
                .setBackupCount(1)
                .setMaxSize(0)
                .setStatisticsEnabled(true)
                .setSplitBrainProtectionName("splitbrainprotectionname");
        queueConfig.getQueueStoreConfig()
                .setEnabled(true)
                .setClassName("com.hazelcast.QueueStoreImpl")
                .setProperty("binary", "false");
        config.addQueueConfig(queueConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast distributed queue has one synchronous backup by default.
By having this backup, when a cluster member with a queue goes down,
another member having the backup of that queue will continue. Therefore,
no items are lost. You can define the number of synchronous backups for a
queue using the <code>backup-count</code> element in the declarative configuration.
A queue can also have asynchronous backups: you can define the number of
asynchronous backups using the <code>async-backup-count</code> element.</p>
</div>
<div class="paragraph">
<p>To set the maximum size of the queue, use the <code>max-size</code> element.
To purge unused or empty queues after a period of time, use the <code>empty-queue-ttl</code> element.
If you define a value (time in seconds) for the <code>empty-queue-ttl</code> element,
then your queue will be destroyed if it stays empty or unused for the time in seconds that you give.</p>
</div>
<div class="paragraph">
<p>The following is the full list of queue configuration elements with their descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max-size</code>: Maximum number of items in the queue. It is used to set an
upper bound for the queue. You will not be able to put more items when the
queue reaches to this maximum size whether you have a queue store configured or not.</p>
</li>
<li>
<p><code>backup-count</code>: Number of synchronous backups. Queue is a non-partitioned
data structure, so all entries of a queue reside in one partition. When this
parameter is '1', it means there will be one backup of that queue in another
member in the cluster. When it is '2', two members will have the backup.</p>
</li>
<li>
<p><code>async-backup-count</code>: Number of asynchronous backups.</p>
</li>
<li>
<p><code>empty-queue-ttl</code>: Used to purge unused or empty queues. If you define a
value (time in seconds) for this element, then your queue will be destroyed
if it stays empty or unused for that time.</p>
</li>
<li>
<p><code>item-listeners</code>: Adds listeners (listener classes) for the queue items.
You can also set the attribute <code>include-value</code> to <code>true</code> if you want the item
event to contain the item values. You can set <code>local</code> to <code>true</code> if you want to
listen to the items on the local member.</p>
</li>
<li>
<p><code>queue-store</code>: Includes the queue store factory class name and the properties
<strong>binary</strong>, <strong>memory limit</strong> and <strong>bulk load</strong>. See the <a href="#queueing-with-persistent-datastore">Queueing with Persistent Datastore section</a>.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your queue.
If set to<code>false</code>, you cannot collect statistics in your implementation
(using <code>getLocalQueueStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-queues" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is<code>true</code>.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code> : Name of the split-brain protection configuration that you want this queue to use.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multimap"><a class="anchor" href="#multimap"></a>7.4. MultiMap</h3>
<div class="paragraph">
<p>Hazelcast <code>MultiMap</code> is a specialized map where you can store multiple values
under a single key. Just like any other distributed data structure implementation in
Hazelcast, <code>MultiMap</code> is distributed and thread-safe.</p>
</div>
<div class="paragraph">
<p>Hazelcast <code>MultiMap</code> is not an implementation of <code>java.util.Map</code> due to the difference
in method signatures. It supports most features of Hazelcast Map except for indexing,
predicates and MapLoader/MapStore. Yet, like Hazelcast Map, entries are almost evenly
distributed onto all cluster members. When a new member joins the cluster, the same
ownership logic used in the distributed map applies.</p>
</div>
<div class="sect3">
<h4 id="getting-a-multimap-and-putting-an-entry"><a class="anchor" href="#getting-a-multimap-and-putting-an-entry"></a>7.4.1. Getting a MultiMap and Putting an Entry</h4>
<div class="paragraph">
<p>The following example creates a MultiMap and puts items into it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        MultiMap&lt;String , String &gt; map = hazelcastInstance.getMultiMap( "map" );

        map.put( "a", "1" );
        map.put( "a", "2" );
        map.put( "b", "3" );
        System.out.println( "PutMember:Done" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the <code>getMultiMap</code> method to create the MultiMap and then use the <code>put</code>
method to put an entry into it.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s print the entries in this MultiMap using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        MultiMap&lt;String, String&gt; map = hazelcastInstance.getMultiMap("map");

        map.put("a", "1");
        map.put("a", "2");
        map.put("b", "3");
        System.out.printf("PutMember:Done");

        for (String key: map.keySet()){
            Collection&lt;String&gt; values = map.get(key);
            System.out.printf("%s -&gt; %s\n", key, values);
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>After you run <code>ExampleMultiMap</code>, run <code>PrintMember</code>. You will see the key <strong><code>a</code></strong> has
two values, as shown below:</p>
</div>
<div class="paragraph">
<p><code>b &#8594; [3]</code></p>
</div>
<div class="paragraph">
<p><code>a &#8594; [2, 1]</code></p>
</div>
<div class="paragraph">
<p>Hazelcast MultiMap uses <code>EntryListener</code> to listen to events which occur when
entries are added to, updated in or removed from the MultiMap. See the
<a href="#listening-for-multimap-events">Listening for MultiMap Events section</a>
for information on how to create an entry listener class and register it.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-multimap"><a class="anchor" href="#configuring-multimap"></a>7.4.2. Configuring MultiMap</h4>
<div class="paragraph">
<p>When using MultiMap, the collection type of the values can be either <strong>Set</strong> or <strong>List</strong>.
Configure the collection type with the <code>valueCollectionType</code> parameter. If you choose
<code>Set</code>, duplicate and null values are not allowed in your collection and ordering is irrelevant.
If you choose <code>List</code>, ordering is relevant and your collection can include duplicate but not null values.</p>
</div>
<div class="paragraph">
<p>You can also enable statistics for your MultiMap with the <code>statisticsEnabled</code> parameter.
If you enable <code>statisticsEnabled</code>, statistics can be retrieved with <code>getLocalMultiMapStats()</code> method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, eviction is not supported for the MultiMap data structure.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following are the example MultiMap configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;multimap name="default"&gt;
        &lt;backup-count&gt;0&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
        &lt;value-collection-type&gt;SET&lt;/value-collection-type&gt;
        &lt;entry-listeners&gt;
            &lt;entry-listener include-value="false" local="false" &gt;com.hazelcast.examples.EntryListener&lt;/entry-listener&gt;
        &lt;/entry-listeners&gt;
        &lt;split-brain-protection-ref&gt;split-brain-protection-name&lt;/split-brain-protection-ref&gt;
    &lt;/multimap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  multimap:
    default:
      backup-count: 0
      async-backup-count: 1
      value-collection-type: SET
      entry-listeners:
        - class-name: com.hazelcast.examples.EntryListener
          include-value: false
          local: false
      split-brain-protection-ref: split-brain-protection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        MultiMapConfig mmConfig = new MultiMapConfig();
        mmConfig.setName( "default" )
                .setBackupCount( 0 ).setAsyncBackupCount( 1 )
                .setValueCollectionType( "SET" )
                .setSplitBrainProtectionName( "splitbrainprotectionname" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the configuration elements and their descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>backup-count</code>: Defines the number of synchronous backups. For example,
if it is set to 1, backup of a partition will be
placed on one other member. If it is 2, it will be placed on two other members.</p>
</li>
<li>
<p><code>async-backup-count</code>: The number of asynchronous backups. Behavior is the
same as that of the <code>backup-count</code> element.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your MultiMap.
If set to<code>false</code>, you cannot collect statistics in your implementation
(using <code>getLocalMultiMapStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-multimaps" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is<code>true</code>.</p>
</li>
<li>
<p><code>value-collection-type</code>: Type of the value collection. It can be <code>SET</code> or <code>LIST</code>.</p>
</li>
<li>
<p><code>entry-listeners</code>: Lets you add listeners (listener classes) for the map entries.
You can also set the attribute
<code>include-value</code> to <code>true</code> if you want the item event to contain the entry values.
You can set
<code>local</code> to <code>true</code> if you want to listen to the entries on the local member.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this MultiMap to use.
See the <a href="#split-brain-protection-for-multimap-and-transactionalmultimap">Split-Brain
Protection for MultiMap and TransactionalMultiMap section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="split-brain-protection-for-multimap-and-transactionalmultimap"><a class="anchor" href="#split-brain-protection-for-multimap-and-transactionalmultimap"></a>7.4.3. Split-Brain Protection for MultiMap and TransactionalMultiMap</h4>
<div class="paragraph">
<p>MultiMap &amp; TransactionalMultiMap can be configured to check for a minimum number of
available members before applying their operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods that support split-brain protection checks. The list is grouped by the protection types.</p>
</div>
<div class="paragraph">
<p>MultiMap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>clear</code></p>
</li>
<li>
<p><code>forceUnlock</code></p>
</li>
<li>
<p><code>lock</code></p>
</li>
<li>
<p><code>put</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
<li>
<p><code>tryLock</code></p>
</li>
<li>
<p><code>unlock</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>containsEntry</code></p>
</li>
<li>
<p><code>containsKey</code></p>
</li>
<li>
<p><code>containsValue</code></p>
</li>
<li>
<p><code>entrySet</code></p>
</li>
<li>
<p><code>get</code></p>
</li>
<li>
<p><code>isLocked</code></p>
</li>
<li>
<p><code>keySet</code></p>
</li>
<li>
<p><code>localKeySet</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>valueCount</code></p>
</li>
<li>
<p><code>values</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TransactionalMultiMap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>put</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>get</code></p>
</li>
<li>
<p><code>valueCount</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for MultiMap can be configured programmatically using
the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/MultiMapConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;multimap name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/multimap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  multimap:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you configured
under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="set"><a class="anchor" href="#set"></a>7.5. Set</h3>
<div class="paragraph">
<p>Hazelcast Set (<code>ISet</code>) is a distributed and concurrent implementation of <code>java.util.Set</code>.
It has the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hazelcast Set does not allow duplicate elements.</p>
</li>
<li>
<p>Hazelcast Set does not preserve the order of elements.</p>
</li>
<li>
<p>Hazelcast Set is a non-partitioned data structure: all the data that belongs to
a set lives on one single partition in that member.</p>
</li>
<li>
<p>Hazelcast Set cannot be scaled beyond the capacity of a single machine.
Since the whole set lives on a single partition, storing a large amount of
data on a single set may cause memory pressure. Therefore, you should use multiple
sets to store a large amount of data. This way, all the sets are spread across the
cluster, sharing the load.</p>
</li>
<li>
<p>A backup of Hazelcast Set is stored on a partition of another member in the cluster
so that data is not lost in the event of a primary member failure.</p>
</li>
<li>
<p>All items are copied to the local member and iteration occurs locally.</p>
</li>
<li>
<p>The equals method implemented in Hazelcast Set uses a serialized byte version of
objects, as opposed to <code>java.util.HashSet</code>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="getting-a-set-and-putting-items"><a class="anchor" href="#getting-a-set-and-putting-items"></a>7.5.1. Getting a Set and Putting Items</h4>
<div class="paragraph">
<p>Use the <code>HazelcastInstance</code>s <code>getSet</code> method to get the Set, then use the <code>add</code> method to put items into it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ISet&lt;String&gt; set = hz.getSet("set");
        set.add("Tokyo");
        set.add("Paris");
        set.add("London");
        set.add("New York");
        System.out.println("Putting finished!");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast Set uses <code>ItemListener</code> to listen to events that occur when items are
added to and removed from the Set. See the <a href="#listening-for-item-events">Listening for Item Events section</a>
for information on how to create an item listener class and register it.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-set"><a class="anchor" href="#configuring-set"></a>7.5.2. Configuring Set</h4>
<div class="paragraph">
<p>The following are the example Hazelcast Set configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;set name="default"&gt;
        &lt;statistics-enabled&gt;false&lt;/statistics-enabled&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;max-size&gt;10&lt;/max-size&gt;
        &lt;item-listeners&gt;
            &lt;item-listener&gt;com.hazelcast.examples.ItemListener&lt;/item-listener&gt;
        &lt;/item-listeners&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  set:
    default:
      statistics-enabled: false
      backup-count: 1
      async-backup-count: 0
      max-size: 10
      item-listeners:
        - class-name: com.hazelcast.examples.ItemListener
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        CollectionConfig collectionSet = config.getSetConfig("MySet");
        collectionSet.setBackupCount(1)
                .setMaxSize(10)
                .setSplitBrainProtectionName("splitbrainprotectionname");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast Set configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>statistics-enabled</code>: True (default) if statistics gathering is
enabled on the Set, false otherwise.</p>
</li>
<li>
<p><code>backup-count</code>: Count of synchronous backups. Set is a non-partitioned
data structure, so all entries of a Set reside in one partition. When this
parameter is '1', it means there will be one backup of that Set in another
member in the cluster. When it is '2', two members will have the backup.</p>
</li>
<li>
<p><code>async-backup-count</code>: Count of asynchronous backups.</p>
</li>
<li>
<p><code>max-size</code>: The maximum number of entries for this Set. It can be any number
between 0 and Integer.MAX_VALUE. Its default value is 0, meaning there is no capacity constraint.</p>
</li>
<li>
<p><code>item-listeners</code>: Lets you add listeners (listener classes) for the list items.
You can also set the attributes <code>include-value</code> to <code>true</code> if you want the item event
to contain the item values. You can set <code>local</code> to <code>true</code> if you want to listen to
the items on the local member.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this Set to use.
See the <a href="#split-brain-protection-for-iset-and-transactionalset">Split-Brain Protection for ISet and TransactionalSet section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="split-brain-protection-for-iset-and-transactionalset"><a class="anchor" href="#split-brain-protection-for-iset-and-transactionalset"></a>7.5.3. Split-Brain Protection for ISet and TransactionalSet</h4>
<div class="paragraph">
<p>ISet &amp; TransactionalSet can be configured to check for a minimum number of
available members before applying queue operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support
split-brain protection checks:</p>
</div>
<div class="paragraph">
<p>ISet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>addAll</code></p>
</li>
<li>
<p><code>clear</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
<li>
<p><code>removeAll</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>contains</code></p>
</li>
<li>
<p><code>containsAll</code></p>
</li>
<li>
<p><code>isEmpty</code></p>
</li>
<li>
<p><code>iterator</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>toArray</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TransactionalSet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>size</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for ISet can be configured programmatically using
the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/SetConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>. The following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;set name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  set:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you
configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="list"><a class="anchor" href="#list"></a>7.6. List</h3>
<div class="paragraph">
<p>Hazelcast List (<code>IList</code>) is similar to Hazelcast Set, but it also
allows duplicate elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Besides allowing duplicate elements, Hazelcast List preserves the order of elements.</p>
</li>
<li>
<p>Hazelcast List is a non-partitioned data structure where values and each
backup are represented by their own single partition.</p>
</li>
<li>
<p>Hazelcast List cannot be scaled beyond the capacity of a single machine.</p>
</li>
<li>
<p>All items are copied to local and iteration occurs locally.</p>
</li>
</ul>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While IMap and ICache are the recommended data structures to be used by
<a href="https://jet.hazelcast.org/" target="_blank" rel="noopener">Hazelcast Jet</a>, IList can also be used by it for unit
testing or similar non-production situations. See <a href="https://docs.hazelcast.org/docs/jet/latest/manual/#imdg-list" target="_blank" rel="noopener">here</a>
in the Hazelcast Jet Reference Manual to learn how Jet can use IList, e.g., how it can fill
IList with data, consume it in a Jet job and drain the results to another IList.
See also the <a href="https://jet.hazelcast.org/use-cases/fast-batch-processing/" target="_blank" rel="noopener">Fast Batch Processing</a>
and <a href="https://jet.hazelcast.org/use-cases/real-time-stream-processing/" target="_blank" rel="noopener">Real-Time Stream Processing</a>
use cases for Hazelcast Jet.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="getting-a-list-and-putting-items"><a class="anchor" href="#getting-a-list-and-putting-items"></a>7.6.1. Getting a List and Putting Items</h4>
<div class="paragraph">
<p>Use the <code>HazelcastInstance</code>s <code>getList</code> method to get the List,
then use the <code>add</code> method to put items into it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IList&lt;String&gt; list = hz.getList("list");
        list.add("Tokyo");
        list.add("Paris");
        list.add("London");
        list.add("New York");
        System.out.println("Putting finished!");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast List uses <code>ItemListener</code> to listen to events that occur when
items are added to and removed from the List. See the <a href="#listening-for-item-events">Listening for Item Events section</a> for information on how to create an item listener
class and register it.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-list"><a class="anchor" href="#configuring-list"></a>7.6.2. Configuring List</h4>
<div class="paragraph">
<p>The following are the example Hazelcast List configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;list name="default"&gt;
        &lt;statistics-enabled&gt;false&lt;/statistics-enabled&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;max-size&gt;10&lt;/max-size&gt;
        &lt;item-listeners&gt;
            &lt;item-listener&gt;
                com.hazelcast.examples.ItemListener
            &lt;/item-listener&gt;
        &lt;/item-listeners&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/list&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  list:
    default:
      statistics-enabled: false
      backup-count: 1
      async-backup-count: 0
      max-size: 10
      item-listeners:
        - class-name: com.hazelcast.examples.ItemListener
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        CollectionConfig collectionList = config.getListConfig("MyList");
        collectionList.setBackupCount(1)
                .setMaxSize(10)
                .setSplitBrainProtectionName("splitbrainprotectionname");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast List configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>statistics-enabled</code>: True (default) if statistics gathering is
enabled on the list, false otherwise.</p>
</li>
<li>
<p><code>backup-count</code>: Number of synchronous backups. List is a non-partitioned
data structure, so all entries of a List reside in one partition. When this
parameter is '1', there will be one backup of that List in another member in
the cluster. When it is '2', two members will have the backup.</p>
</li>
<li>
<p><code>async-backup-count</code>: Number of asynchronous backups.</p>
</li>
<li>
<p><code>max-size</code>: The maximum number of entries for this List.</p>
</li>
<li>
<p><code>item-listeners</code>: Lets you add listeners (listener classes) for the list items.
You can also set the attribute <code>include-value</code> to <code>true</code> if you want the item event
to contain the item values. You can set the attribute <code>local</code> to <code>true</code> if you want
to listen the items on the local member.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this List to use.
See the <a href="#split-brain-protection-for-ilist-and-transactionallist">Split-Brain Protection for IList and TransactionalList section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="split-brain-protection-for-ilist-and-transactionallist"><a class="anchor" href="#split-brain-protection-for-ilist-and-transactionallist"></a>7.6.3. Split-Brain Protection for IList and TransactionalList</h4>
<div class="paragraph">
<p>IList &amp; TransactionalList can be configured to check for a minimum
number of available members before applying queue operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support split-brain protection checks:</p>
</div>
<div class="paragraph">
<p>IList:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>addAll</code></p>
</li>
<li>
<p><code>clear</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
<li>
<p><code>removeAll</code></p>
</li>
<li>
<p><code>set</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>contains</code></p>
</li>
<li>
<p><code>containsAll</code></p>
</li>
<li>
<p><code>get</code></p>
</li>
<li>
<p><code>indexOf</code></p>
</li>
<li>
<p><code>isEmpty</code></p>
</li>
<li>
<p><code>iterator</code></p>
</li>
<li>
<p><code>lastIndexOf</code></p>
</li>
<li>
<p><code>listIterator</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>subList</code></p>
</li>
<li>
<p><code>toArray</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TransactionalList:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>size</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for IList can be configured programmatically using
the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/ListConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;list name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/list&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  list:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you
configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ringbuffer"><a class="anchor" href="#ringbuffer"></a>7.7. Ringbuffer</h3>
<div class="paragraph">
<p>Hazelcast Ringbuffer is a replicated but not partitioned data structure that
stores its data in a ring-like structure. You can
think of it as a circular array with a given capacity. Each Ringbuffer has a
tail and a head. The tail is where the items are
added and the head is where the items are overwritten or expired. You can reach
each element in a Ringbuffer using a sequence
ID, which is mapped to the elements between the head and tail (inclusive) of the Ringbuffer.</p>
</div>
<div class="sect3">
<h4 id="getting-a-ringbuffer-and-reading-items"><a class="anchor" href="#getting-a-ringbuffer-and-reading-items"></a>7.7.1. Getting a Ringbuffer and Reading Items</h4>
<div class="paragraph">
<p>Reading from Ringbuffer is simple: get the Ringbuffer with the
HazelcastInstance <code>getRingbuffer</code> method, get its current head with
the <code>headSequence</code> method and start reading. Use the method <code>readOne</code> to
return the item at the
given sequence; <code>readOne</code> blocks if no item is available. To read the next item,
increment the sequence by one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        Ringbuffer&lt;String&gt; ringbuffer = hz.getRingbuffer("rb");
        long sequence = ringbuffer.headSequence();
        while(true){
            String item = ringbuffer.readOne(sequence);
            sequence++;
            // process item
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>By exposing the sequence, you can now move the item from the Ringbuffer
as long as the item is still available. If the item is not available
any longer, <code>StaleSequenceException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="adding-items-to-a-ringbuffer"><a class="anchor" href="#adding-items-to-a-ringbuffer"></a>7.7.2. Adding Items to a Ringbuffer</h4>
<div class="paragraph">
<p>Adding an item to a Ringbuffer is also easy with the Ringbuffer <code>add</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Ringbuffer&lt;String&gt; ringbuffer = hz.getRingbuffer("ExampleRB");
ringbuffer.add("someitem");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the method <code>add</code> to return the sequence of the inserted item; the
sequence value is always unique. You can use this as a
very cheap way of generating unique IDs if you are already using Ringbuffer.</p>
</div>
</div>
<div class="sect3">
<h4 id="iqueue-vs-ringbuffer"><a class="anchor" href="#iqueue-vs-ringbuffer"></a>7.7.3. IQueue vs. Ringbuffer</h4>
<div class="paragraph">
<p>Hazelcast Ringbuffer can sometimes be a better alternative than an
Hazelcast IQueue. Unlike IQueue, Ringbuffer does not remove the items, it only
reads items using a certain position. There are many advantages to this
approach as described below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The same item can be read multiple times by the same thread. This is
useful for realizing semantics of read-at-least-once or
read-at-most-once.</p>
</li>
<li>
<p>The same item can be read by multiple threads. Normally you could use an
IQueue per thread for the same semantic, but this is
less efficient because of the increased remoting. A take from an IQueue is
destructive, so the change needs to be applied for backup
also, which is why a <code>queue.take()</code> is more expensive than a <code>ringBuffer.read(&#8230;&#8203;)</code>.</p>
</li>
<li>
<p>Reads are extremely cheap since there is no change in the Ringbuffer.
Therefore no replication is required.</p>
</li>
<li>
<p>Reads and writes can be batched to speed up performance. Batching can
dramatically improve the performance of Ringbuffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="configuring-ringbuffer-capacity"><a class="anchor" href="#configuring-ringbuffer-capacity"></a>7.7.4. Configuring Ringbuffer Capacity</h4>
<div class="paragraph">
<p>By default, a Ringbuffer is configured with a <code>capacity</code> of 10000 items.
This creates an array with a size of 10000. If
a <code>time-to-live</code> is configured, then an array of longs is also created that
stores the expiration time for every item.
In a lot of cases you may want to change this <code>capacity</code> number to something
that better fits your needs.</p>
</div>
<div class="paragraph">
<p>Below is a declarative configuration example of a Ringbuffer with a <code>capacity</code> of 2000 items.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;capacity&gt;2000&lt;/capacity&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      capacity: 2000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently, Hazelcast Ringbuffer is not a partitioned data structure;
its data is stored in a single partition and the replicas
 are stored in another partition. Therefore, create a Ringbuffer that can
safely fit in a single cluster member.</p>
</div>
</div>
<div class="sect3">
<h4 id="backing-up-ringbuffer"><a class="anchor" href="#backing-up-ringbuffer"></a>7.7.5. Backing Up Ringbuffer</h4>
<div class="paragraph">
<p>Hazelcast Ringbuffer has a single synchronous backup by default. You can control
the Ringbuffer backup just like most of the other Hazelcast
distributed data structures by setting the synchronous and asynchronous backups:
<code>backup-count</code> and <code>async-backup-count</code>. In the example below, a Ringbuffer is configured with no
synchronous backups and one asynchronous backup:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;backup-count&gt;0&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      backup-count: 0
      async-backup-count: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>An asynchronous backup probably gives you better performance. However, there
is a chance that the item added will be lost
when the member owning the primary crashes before the backup could complete.
You may want to consider batching
methods if you need high performance but do not want to give up on consistency.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-ringbuffer-time-to-live"><a class="anchor" href="#configuring-ringbuffer-time-to-live"></a>7.7.6. Configuring Ringbuffer Time-To-Live</h4>
<div class="paragraph">
<p>You can configure Hazelcast Ringbuffer with a time-to-live in seconds. Using
this setting, you can control how long the items remain in
the Ringbuffer before they are expired. By default, the time-to-live is set to 0,
meaning that unless the item is overwritten,
it will remain in the Ringbuffer indefinitely. If you set a time-to-live and an item
is added, then, depending on the Overflow Policy,
either the oldest item is overwritten, or the call is rejected.</p>
</div>
<div class="paragraph">
<p>In the example below, a Ringbuffer is configured with a time-to-live of 180 seconds.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;time-to-live-seconds&gt;180&lt;/time-to-live-seconds&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      time-to-live-seconds: 180</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setting-ringbuffer-overflow-policy"><a class="anchor" href="#setting-ringbuffer-overflow-policy"></a>7.7.7. Setting Ringbuffer Overflow Policy</h4>
<div class="paragraph">
<p>Using the overflow policy, you can determine what to do if the oldest item
in the Ringbuffer is not old enough to expire when
 more items than the configured Ringbuffer capacity are being added. The below
options are currently available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OverflowPolicy.OVERWRITE</code>: The oldest item is overwritten.</p>
</li>
<li>
<p><code>OverflowPolicy.FAIL</code>: The call is aborted. The methods that make use of the
OverflowPolicy return <code>-1</code> to indicate that adding
the item has failed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Overflow policy gives you fine control on what to do if the Ringbuffer is full.
You can also use the overflow policy to apply
a back pressure mechanism. The following example code shows the usage of an exponential backoff.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Random random = new Random();
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        Ringbuffer&lt;Long&gt; rb = hz.getRingbuffer("rb");

        long i = 100;
        while (true) {
            long sleepMs = 100;
            for (; ; ) {
                long result = rb.addAsync(i, OverflowPolicy.FAIL).toCompletableFuture().get();
                if (result != -1) {
                    break;
                }
                TimeUnit.MILLISECONDS.sleep(sleepMs);
                sleepMs = min(5000, sleepMs * 2);
            }

            // add a bit of random delay to make it look a bit more realistic
            Thread.sleep(random.nextInt(10));

            System.out.println("Written: " + i);
            i++;
        }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ringbuffer-with-persistent-datastore"><a class="anchor" href="#ringbuffer-with-persistent-datastore"></a>7.7.8. Ringbuffer with Persistent Datastore</h4>
<div class="paragraph">
<p>Hazelcast allows you to load and store the Ringbuffer items from/to a persistent
datastore using the interface <code>RingbufferStore</code>. If a Ringbuffer store is enabled,
each item added to the Ringbuffer will also be stored at the configured Ringbuffer store.</p>
</div>
<div class="paragraph">
<p>If the Ringbuffer store is configured, you can get items with sequences which are
no longer in the actual Ringbuffer but are only in the Ringbuffer store. This is
probably much slower but still allows you to continue consuming items from the
Ringbuffer even if they are overwritten with newer items in the Ringbuffer.</p>
</div>
<div class="paragraph">
<p>When a Ringbuffer is being instantiated, it checks if the Ringbuffer store is
configured and requests the latest sequence in the Ringbuffer store. This is to
enable the Ringbuffer to start with sequences larger than the ones in the Ringbuffer
store. In this case, the Ringbuffer is empty but you can still request older items
from it (which will be loaded from the Ringbuffer store).</p>
</div>
<div class="paragraph">
<p>The Ringbuffer store stores items in the same format as the Ringbuffer. If the
<code>BINARY</code> in-memory format is used, the Ringbuffer store must implement the interface
<code>RingbufferStore&lt;byte[]&gt;</code> meaning that the Ringbuffer receives items in the binary format.
If the <code>OBJECT</code> in-memory format is used, the Ringbuffer store must implement the interface
<code>RingbufferStore&lt;K&gt;</code>, where <code>K</code> is the type of item being stored (meaning that the Ringbuffer
store receives the deserialized object).</p>
</div>
<div class="paragraph">
<p>When adding items to the Ringbuffer, the method <code>storeAll</code> allows you to store items in batches.</p>
</div>
<div class="paragraph">
<p>The following example class includes all of the <code>RingbufferStore</code> methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TheRingbufferObjectStore implements RingbufferStore&lt;Item&gt; {

    @Override
    public void store(long sequence, Item data) {
        System.out.println("Object store");
    }

    @Override
    public void storeAll(long firstItemSequence, Item[] items) {
        System.out.println("Object store all");
    }

    @Override
    public Item load(long sequence) {
        System.out.println("Object load");
        return null;
    }

    @Override
    public long getLargestSequence() {
        System.out.println("Object get largest sequence");
        return -1;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Item</code> must be serializable. The following is an example of a Ringbuffer with the
Ringbuffer store configured and enabled.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="default"&gt;
        &lt;capacity&gt;10000&lt;/capacity&gt;
        &lt;time-to-live-seconds&gt;30&lt;/time-to-live-seconds&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;ringbuffer-store&gt;
            &lt;class-name&gt;com.hazelcast.RingbufferStoreImpl&lt;/class-name&gt;
        &lt;/ringbuffer-store&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    default:
      capacity: 10000
      time-to-live-seconds: 30
      backup-count: 1
      async-backup-count: 0
      in-memory-format: BINARY
      ringbuffer-store:
        class-name: com.hazelcast.RingbufferStoreImpl</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the explanations for the Ringbuffer store configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>`class-name: Name of the Ringbuffer store factory class.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="configuring-ringbuffer-in-memory-format"><a class="anchor" href="#configuring-ringbuffer-in-memory-format"></a>7.7.9. Configuring Ringbuffer In-Memory Format</h4>
<div class="paragraph">
<p>You can configure Hazelcast Ringbuffer with an in-memory format that controls the
format of the Ringbuffer&#8217;s stored items. By default, <code>BINARY</code> in-memory format is used,
meaning that the object is stored in a serialized form. You can select the <code>OBJECT</code> in-memory
format, which is useful when filtering is
applied or when the <code>OBJECT</code> in-memory format has a smaller memory footprint than <code>BINARY</code>.</p>
</div>
<div class="paragraph">
<p>In the declarative configuration example below, a Ringbuffer is configured with the
<code>OBJECT</code> in-memory format:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;in-memory-format&gt;OBJECT&lt;/in-memory-format&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      in-memory-format: OBJECT</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-split-brain-protection-for-ringbuffer"><a class="anchor" href="#configuring-split-brain-protection-for-ringbuffer"></a>7.7.10. Configuring Split-Brain Protection for Ringbuffer</h4>
<div class="paragraph">
<p>Ringbuffer can be configured to check for a minimum number of available members before
applying Ringbuffer operations. This is a check to avoid performing successful Ringbuffer
operations on all parts of a cluster during a network partition and can be configured
using the element <code>split-brain-protection-ref</code>. You should set this element&#8217;s value as the quorum&#8217;s name,
which you configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>. Following is an example snippet:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>addAllAsync</code></p>
</li>
<li>
<p><code>addAsync</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>capacity</code></p>
</li>
<li>
<p><code>headSequence</code></p>
</li>
<li>
<p><code>readManyAsync</code></p>
</li>
<li>
<p><code>readOne</code></p>
</li>
<li>
<p><code>remainingCapacity</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>tailSequence</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="adding-batched-items"><a class="anchor" href="#adding-batched-items"></a>7.7.11. Adding Batched Items</h4>
<div class="paragraph">
<p>In the previous examples, the method <code>ringBuffer.add()</code> is used to add an item to the Ringbuffer.
The problems with this method
are that it always overwrites and that it does not support batching. Batching can have a huge
impact on the performance. You can use the method <code>addAllAsync</code> to support batching.</p>
</div>
<div class="paragraph">
<p>See the following example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;String&gt; items = Arrays.asList("1","2","3");
CompletionStage&lt;Long&gt; s = rb.addAllAsync(items, OverflowPolicy.OVERWRITE);
// block until all items are added
s.toCompletableFuture().join();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above case, three strings are added to the Ringbuffer using the policy
<code>OverflowPolicy.OVERWRITE</code>. See the <a href="#setting-ringbuffer-overflow-policy">Overflow
Policy section</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="reading-batched-items"><a class="anchor" href="#reading-batched-items"></a>7.7.12. Reading Batched Items</h4>
<div class="paragraph">
<p>In the previous example, the <code>readOne</code> method read items from the Ringbuffer.
<code>readOne</code> is simple but not very efficient for the following reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>readOne</code> does not use batching.</p>
</li>
<li>
<p><code>readOne</code> cannot filter items at the source; the items need to be retrieved
before being filtered.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The method <code>readManyAsync</code> can read a batch of items and can filter items at the source.</p>
</div>
<div class="paragraph">
<p>See the following example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletionStage&lt;ReadResultSet&lt;E&gt;&gt; readManyAsync(
    long startSequence,
    int minCount,
    int maxCount,
    IFunction&lt;E, Boolean&gt; filter);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The meanings of the <code>readManyAsync</code> arguments are given below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>startSequence</code>: Sequence of the first item to read.</p>
</li>
<li>
<p><code>minCount</code>: Minimum number of items to read. If you do not want to block,
set it to 0. If you want to block for at least one item,
set it to 1.</p>
</li>
<li>
<p><code>maxCount</code>: Maximum number of the items to retrieve. Its value cannot exceed 1000.</p>
</li>
<li>
<p><code>filter</code>: A function that accepts an item and checks if it should be returned.
If no filtering should be applied, set it to <code>null</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A full example is given below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">long sequence = rb.headSequence();
for(;;) {
    CompletionStage&lt;ReadResultSet&lt;String&gt;&gt; f = rb.readManyAsync(sequence, 1, 10, null);
    CompletionStage&lt;Integer&gt; readCountStage = f.thenApplyAsync(rs -&gt; {
        for (String s : rs) {
            System.out.println(s);
        }
        return rs.readCount();
    });
    sequence += readCountStage.toCompletableFuture().join();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please take a careful look at how your sequence is being incremented. You cannot
always rely on the number of items being returned
if the items are filtered out.</p>
</div>
<div class="paragraph">
<p>There is not any filtering applied in the above example. The following example shows
how you can apply a filter when reading batched items. First, let&#8217;s create our filter
as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class FruitFilter implements IFunction&lt;String, Boolean&gt; {
    public FruitFilter() {}

    public Boolean apply(String s) {
        return s.startsWith("a");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, the <code>FruitFilter</code> checks whether a String object starts with the letter "a".
You can see this filter in action in the below example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hz = Hazelcast.newHazelcastInstance();
Ringbuffer&lt;String&gt; rb = hz.getRingbuffer("rb");

rb.add("apple");
rb.add("orange");
rb.add("pear");
rb.add("peach");
rb.add("avocado");

long sequence = rb.headSequence();
CompletableFuture&lt;ReadResultSet&lt;String&gt;&gt; f = rb.readManyAsync(sequence, 2, 5, new FruitFilter()).toCompletableFuture();

ReadResultSet&lt;String&gt; rs = f.join();
for (String s : rs) {
    System.out.println(s);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-async-methods"><a class="anchor" href="#using-async-methods"></a>7.7.13. Using Async Methods</h4>
<div class="paragraph">
<p>Hazelcast Ringbuffer provides asynchronous methods for more powerful operations
like batched writing or batched reading with filtering.
To wait for the result of the operation in a blocking way, obtain a <code>CompletableFuture</code>
from the returned <code>CompletionStage</code> by invoking <code>CompletionStage#toCompletableFuture()</code> method, then
use either <code>CompletableFuture#get()</code> or <code>CompletableFuture#join()</code>.</p>
</div>
<div class="paragraph">
<p>See the following example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletionStage&lt;Long&gt; f = ringbuffer.addAsync(item, OverflowPolicy.FAIL);
f.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, you can also use <code>CompletionStage</code> API to add subsequent dependent computation
stages which will be executed when the operation  has completed. This way the thread used for
the call is not blocked until the response is returned.</p>
</div>
<div class="paragraph">
<p>See the below code as an example of when you want to
get notified when a batch of reads has completed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletionStage&lt;ReadResultSet&lt;String&gt;&gt; stage = rb.readManyAsync(sequence, min, max, someFilter);
stage.whenCompleteAsync((response, throwable) -&gt; {
    if (throwable == null) {
         for (String s : response) {
             System.out.println("Received:" + s);
         }
    } else {
        throwable.printStackTrace();
    }
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ringbuffer-configuration-examples"><a class="anchor" href="#ringbuffer-configuration-examples"></a>7.7.14. Ringbuffer Configuration Examples</h4>
<div class="paragraph">
<p>The following shows the declarative configuration of a Ringbuffer called <code>rb</code>.
The configuration is modeled after the Ringbuffer defaults.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;capacity&gt;10000&lt;/capacity&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      capacity: 10000
      backup-count: 1
      async-backup-count: 0
      time-to-live-seconds: 0
      in-memory-format: BINARY
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure a Ringbuffer programmatically. The following is a programmatic
version of the above declarative configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        RingbufferConfig rbConfig = config.getRingbufferConfig("myRB");
        rbConfig.setCapacity(10000)
                .setBackupCount(1)
                .setAsyncBackupCount(0)
                .setTimeToLiveSeconds(0)
                .setInMemoryFormat(InMemoryFormat.BINARY)
                .setSplitBrainProtectionName("splitbrainprotectionname");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="topic"><a class="anchor" href="#topic"></a>7.8. Topic</h3>
<div class="paragraph">
<p>Hazelcast provides a distribution mechanism for publishing messages that are delivered to multiple subscribers. This is
also known as a publish/subscribe (pub/sub) messaging model. Publishing and subscribing operations are cluster wide.
When a member subscribes to a topic, it is actually registering for messages published by any member in the cluster,
including the new members that joined after you add the listener.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Publish operation is async. It does not wait for operations to run in
remote members; it works as fire and forget.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="getting-a-topic-and-publishing-messages"><a class="anchor" href="#getting-a-topic-and-publishing-messages"></a>7.8.1. Getting a Topic and Publishing Messages</h4>
<div class="paragraph">
<p>Use the HazelcastInstance&#8217;s <code>getTopic</code> method to get the topic, then use the topic&#8217;s
<code>publish</code> method to publish your messages. The following is an example publisher:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TopicPublisher {

    public static void main(String[] args) {

        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ITopic&lt;Date&gt; topic = hz.getTopic("topic");
        topic.publish(new Date());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is an example subscriber:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TopicSubscriber {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ITopic&lt;Date&gt; topic = hz.getTopic("topic");
        topic.addMessageListener(new MessageListenerImpl());
        System.out.println("Subscribed");
    }

    private static class MessageListenerImpl implements MessageListener&lt;Date&gt; {
        public void onMessage(Message&lt;Date&gt; m) {
            System.out.println("Received: " + m.getMessageObject());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast Topic uses the <code>MessageListener</code> interface to listen for events that occur
when a message is received. See the <a href="#listening-for-topic-messages">Listening for Topic Messages section</a>
for information on how to create a message listener class and register it.</p>
</div>
</div>
<div class="sect3">
<h4 id="getting-topic-statistics"><a class="anchor" href="#getting-topic-statistics"></a>7.8.2. Getting Topic Statistics</h4>
<div class="paragraph">
<p>Topic has two statistic variables that you can query. These values are incremental and local to the member.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        ITopic&lt;Object&gt; myTopic = hazelcastInstance.getTopic( "myTopicName" );

        myTopic.getLocalTopicStats().getPublishOperationCount();
        myTopic.getLocalTopicStats().getReceiveOperationCount();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getPublishOperationCount</code> and <code>getReceiveOperationCount</code> returns the total
number of published and received messages since the start of this member, respectively.
Note that these values are not backed up, so if the member goes down, these values will be lost.</p>
</div>
<div class="paragraph">
<p>You can disable this feature with topic configuration. See the <a href="#configuring-topic">Configuring Topic section</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These statistics values can be also viewed in Management Center. See the
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-topics" target="_blank" rel="noopener">Monitoring Topics section</a>
in Hazelcast Management Center Reference Manual.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="understanding-topic-behavior"><a class="anchor" href="#understanding-topic-behavior"></a>7.8.3. Understanding Topic Behavior</h4>
<div class="paragraph">
<p>Each cluster member has a list of all registrations in the cluster.
When a new member is registered for a topic, it sends a registration message
to all members in the cluster. Also, when a new member joins the cluster, it
receives all registrations made so far in the cluster.</p>
</div>
<div class="paragraph">
<p>The behavior of a topic varies depending on the value of the configuration
parameter <code>globalOrderEnabled</code>.</p>
</div>
<div class="sect4">
<h5 id="ordering-messages-as-published"><a class="anchor" href="#ordering-messages-as-published"></a>Ordering Messages as Published</h5>
<div class="paragraph">
<p>If <code>globalOrderEnabled</code> is disabled, messages are not ordered and listeners
(subscribers) process the messages in the order that the messages are published.
If cluster member M publishes messages <strong>m1, m2, m3, &#8230;&#8203;, mn</strong> to a topic <strong>T</strong>,
then Hazelcast makes sure that all of the subscribers of topic <strong>T</strong> receive and
process <strong>m1, m2, m3, &#8230;&#8203;, mn</strong> in the given order.</p>
</div>
<div class="paragraph">
<p>Here is how it works: Let&#8217;s say that we have three members (<strong>member1</strong>, <strong>member2</strong> and
<strong>member3</strong>) and that <strong>member1</strong> and <strong>member2</strong> are registered to a topic named <code>news</code>.
Note that all three members know that <strong>member1</strong> and <strong>member2</strong> are registered to <code>news</code>.</p>
</div>
<div class="paragraph">
<p>In this example, <strong>member1</strong> publishes two messages: <code>a1</code> and <code>a2</code>. <strong>Member3</strong> publishes
two messages: <code>c1</code> and <code>c2</code>. When <strong>member1</strong> and <strong>member3</strong> publish a message, they check
their local list for registered members, discover that <strong>member1</strong> and <strong>member2</strong> are
in their lists, and then they fire messages to those members. One possible order of
the messages received could be the following.</p>
</div>
<div class="paragraph">
<p><strong>member1</strong> &#8594; <code>c1</code>, <code>a1</code>, <code>a2</code>, <code>c2</code></p>
</div>
<div class="paragraph">
<p><strong>member2</strong> &#8594; <code>c1</code>, <code>c2</code>, <code>a1</code>, <code>a2</code></p>
</div>
</div>
<div class="sect4">
<h5 id="ordering-messages-for-members"><a class="anchor" href="#ordering-messages-for-members"></a>Ordering Messages for Members</h5>
<div class="paragraph">
<p>If <code>globalOrderEnabled</code> is enabled, all members listening to the same topic
get its messages in the same order.</p>
</div>
<div class="paragraph">
<p>Here is how it works. Let&#8217;s say that we have three members (<strong>member1</strong>, <strong>member2</strong> and
<strong>member3</strong>) and that <strong>member1</strong> and <strong>member2</strong> are registered to a topic named <code>news</code>.
Note that all three members know that <strong>member1</strong> and <strong>member2</strong> are registered to <code>news</code>.</p>
</div>
<div class="paragraph">
<p>In this example, <strong>member1</strong> publishes two messages: <code>a1</code> and <code>a2</code>. <strong>Member3</strong> publishes
two messages: <code>c1</code> and <code>c2</code>. When a member publishes messages over the topic <code>news</code>,
it first calculates which partition the <code>news</code> ID corresponds to. Then it sends an
operation to the owner of the partition for that member to publish messages. Let&#8217;s assume
that <code>news</code> corresponds to a partition that <strong>member2</strong> owns. <strong>member1</strong> and <strong>member3</strong> first
sends all messages to <strong>member2</strong>. Assume that the messages are published in the following order:</p>
</div>
<div class="paragraph">
<p><strong>member1</strong> &#8594; <code>a1</code>, <code>c1</code>, <code>a2</code>, <code>c2</code></p>
</div>
<div class="paragraph">
<p><strong>member2</strong> then publishes these messages by looking at registrations in its local list.
It sends these messages to <strong>member1</strong> and <strong>member2</strong> (it makes a local dispatch for itself).</p>
</div>
<div class="paragraph">
<p><strong>member1</strong> &#8594; <code>a1</code>, <code>c1</code>, <code>a2</code>, <code>c2</code></p>
</div>
<div class="paragraph">
<p><strong>member2</strong> &#8594; <code>a1</code>, <code>c1</code>, <code>a2</code>, <code>c2</code></p>
</div>
<div class="paragraph">
<p>This way we guarantee that all members see the events in the same order.</p>
</div>
</div>
<div class="sect4">
<h5 id="keeping-generated-and-published-order-the-same"><a class="anchor" href="#keeping-generated-and-published-order-the-same"></a>Keeping Generated and Published Order the Same</h5>
<div class="paragraph">
<p>In both cases, there is a <code>StripedExecutor</code> in EventService that is responsible for
dispatching the received message. For all events in Hazelcast, the order that events
are generated and the order they are published to the user are guaranteed to be the
same via this <code>StripedExecutor</code>.</p>
</div>
<div class="paragraph">
<p>In <code>StripedExecutor</code>, there are as many threads as are specified in the property
<code>hazelcast.event.thread.count</code> (default is five). For a specific event source (for a
particular topic name), <strong>hash of that source&#8217;s name % 5</strong> gives the ID of the responsible
thread. Note that there can be another event source (entry listener of a map, item listener
of a collection, etc.) corresponding to the same thread. In order not to make other messages
to block, heavy processing should not be done in this thread. If there is time-consuming work
that needs to be done, the work should be handed over to another thread. See the
<a href="#getting-a-topic-and-publishing-messages">Getting a Topic and Publishing Messages section</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-topic"><a class="anchor" href="#configuring-topic"></a>7.8.4. Configuring Topic</h4>
<div class="paragraph">
<p>To configure a topic, set the topic name, decide on statistics and global ordering,
and set the message listeners.
The following are the default values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>global-ordering</code> is <strong>false</strong>, meaning that by default, there is no guarantee of global order.</p>
</li>
<li>
<p><code>statistics</code> is <strong>true</strong>, meaning that by default, statistics are calculated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can see the example configuration snippets below.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;topic name="yourTopicName"&gt;
        &lt;global-ordering-enabled&gt;true&lt;/global-ordering-enabled&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;message-listeners&gt;
            &lt;message-listener&gt;MessageListenerImpl&lt;/message-listener&gt;
        &lt;/message-listeners&gt;
    &lt;/topic&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  topic:
    yourTopicName:
      global-ordering-enabled: true
      statistics-enabled: true
      message-listeners:
        - MessageListenerImpl</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        TopicConfig topicConfig = new TopicConfig();
        topicConfig.setGlobalOrderingEnabled( true );
        topicConfig.setStatisticsEnabled( true );
        topicConfig.setName( "yourTopicName" );
        MessageListener&lt;String&gt; implementation = new MessageListener&lt;String&gt;() {
            @Override
            public void onMessage( Message&lt;String&gt; message ) {
                // process the message
            }
        };
        topicConfig.addMessageListenerConfig( new ListenerConfig( implementation ) );
        HazelcastInstance instance = Hazelcast.newHazelcastInstance();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Topic configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your topic.
If set to<code>false</code>, you cannot collect statistics in your implementation
(using <code>getLocalTopicStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-topics" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is<code>true</code>.</p>
</li>
<li>
<p><code>global-ordering-enabled</code>: Default is <code>false</code>, meaning there is no global order guarantee.</p>
</li>
<li>
<p><code>message-listeners</code>: Lets you add listeners (listener classes) for the topic messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Besides the above elements, there are the following system properties
that are topic related but not topic specific:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.event.queue.capacity</code> with a default value of 1,000,000</p>
</li>
<li>
<p><code>hazelcast.event.queue.timeout.millis</code> with a default value of 250</p>
</li>
<li>
<p><code>hazelcast.event.thread.count</code> with a default value of 5</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the descriptions of these parameters, see the <a href="#global-event-configuration">Global Event Configuration section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reliable-topic"><a class="anchor" href="#reliable-topic"></a>7.9. Reliable Topic</h3>
<div class="paragraph">
<p>Reliable Topic uses the same <code>ITopic</code> interface
as a regular topic. The main difference is that Reliable Topic
is backed up by the Ringbuffer data structure. The following are the advantages of this approach:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Events are not lost since the Ringbuffer is configured with one
synchronous backup by default.</p>
</li>
<li>
<p>Each Reliable <code>ITopic</code> gets its own Ringbuffer; if a topic has a
very fast producer, it will not lead to problems at topics that run at a slower pace.</p>
</li>
<li>
<p>Since the event system behind a regular <code>ITopic</code> is shared with other
data structures, e.g., collection listeners,
  you can run into isolation problems. This does not happen with the Reliable <code>ITopic</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example for a publisher using Reliable Topic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PublisherMember {
    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        Random random = new Random();
        ITopic&lt;Long&gt; topic = hz.getReliableTopic("sometopic");
        long messageId = 0;

        while (true) {
            topic.publish(messageId);
            messageId++;
            System.out.println("Written: " + messageId);
            sleepMillis(random.nextInt(100));
        }
    }
    public static boolean sleepMillis(int millis) {
        try {
            MILLISECONDS.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
        return true;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following is an example for the subscriber:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SubscribedMember {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ITopic&lt;Long&gt; topic = hz.getReliableTopic("sometopic");
        topic.addMessageListener(new MessageListenerImpl());
    }

    private static class MessageListenerImpl implements MessageListener&lt;Long&gt; {
        public void onMessage(Message&lt;Long&gt; m) {
            System.out.println("Received: " + m.getMessageObject());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you create a Reliable Topic, Hazelcast automatically creates a
Ringbuffer for it. You may configure this Ringbuffer by adding a Ringbuffer config
with the same name as the Reliable Topic. For instance, if you have a
Reliable Topic with the name "sometopic", you should add a Ringbuffer config
with the name "sometopic" to configure the backing Ringbuffer. Some of the
things that you may configure are the capacity, the time-to-live for the topic
messages, and you can even add a Ringbuffer store which allows you to have a persistent topic.
By default, a Ringbuffer does not have any TTL (time-to-live) and it has a limited
capacity; you may want to change that configuration. The following is an example
configuration for the "sometopic" given above.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;!-- This is the ringbuffer that is used by the 'sometopic' Reliable-topic. As you can see the
         ringbuffer has the same name as the topic. --&gt;
    &lt;ringbuffer name="sometopic"&gt;
        &lt;capacity&gt;1000&lt;/capacity&gt;
        &lt;time-to-live-seconds&gt;5&lt;/time-to-live-seconds&gt;
    &lt;/ringbuffer&gt;
    &lt;reliable-topic name="sometopic"&gt;
        &lt;topic-overload-policy&gt;BLOCK&lt;/topic-overload-policy&gt;
    &lt;/reliable-topic&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    sometopic:
      capacity: 1000
      time-to-live-seconds: 5
  reliable-topic:
    sometopic:
      topic-overload-policy: BLOCK</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#configuring-reliable-topic">Configuring Reliable Topic section</a>
below for the descriptions of all Reliable Topic configuration elements.</p>
</div>
<div class="paragraph">
<p>By default, the Reliable <code>ITopic</code> uses a shared thread pool. If you need a
better isolation, you can configure a custom executor on the
<code>ReliableTopicConfig</code>.</p>
</div>
<div class="paragraph">
<p>Because the reads on a Ringbuffer are not destructive, batching is easy to apply.
<code>ITopic</code> uses read batching and reads
ten items at a time (if available) by default. See <a href="#reading-batched-items">Reading Batched Items</a>
for more information.</p>
</div>
<div class="sect3">
<h4 id="slow-consumers"><a class="anchor" href="#slow-consumers"></a>7.9.1. Slow Consumers</h4>
<div class="paragraph">
<p>The Reliable <code>ITopic</code> provides control and a way to deal with slow consumers.
It is unwise to keep events for a slow consumer in memory
indefinitely since you do not know when the slow consumer is going to catch up.
You can control the size of the Ringbuffer by using its capacity. For the cases
when a Ringbuffer runs out of its capacity, you can specify the following policies
for the <code>TopicOverloadPolicy</code> configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DISCARD_OLDEST</code>: Overwrite the oldest item, even if a TTL is set.
In this case the fast producer supersedes a slow consumer.</p>
</li>
<li>
<p><code>DISCARD_NEWEST</code>: Discard the newest item.</p>
</li>
<li>
<p><code>BLOCK</code>: Wait until the items are expired in the Ringbuffer.</p>
</li>
<li>
<p><code>ERROR</code>: Immediately throw <code>TopicOverloadException</code> if there is no space in the Ringbuffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="configuring-reliable-topic"><a class="anchor" href="#configuring-reliable-topic"></a>7.9.2. Configuring Reliable Topic</h4>
<div class="paragraph">
<p>The following are example Reliable Topic configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;reliable-topic name="default"&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;message-listeners&gt;
            &lt;message-listener&gt;
                ...
            &lt;/message-listener&gt;
        &lt;/message-listeners&gt;
        &lt;read-batch-size&gt;10&lt;/read-batch-size&gt;
        &lt;topic-overload-policy&gt;BLOCK&lt;/topic-overload-policy&gt;
    &lt;/reliable-topic&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  reliable-topic:
    default:
      statistics-enabled: true
      message-listeners:
        - ...
      read-batch-size: 10
      topic-overload-policy: BLOCK</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
ReliableTopicConfig rtConfig = config.getReliableTopicConfig( "default" );
rtConfig.setTopicOverloadPolicy( TopicOverloadPolicy.BLOCK )
    .setReadBatchSize( 10 )
    .setStatisticsEnabled( true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Reliable Topic configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is
enabled for your Reliable Topic. If set to<code>false</code>, you cannot collect statistics
in your implementation and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-reliable-topics" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is<code>true</code>.</p>
</li>
<li>
<p><code>message-listener</code>: Message listener class that listens to the
messages when they are added or removed.</p>
</li>
<li>
<p><code>read-batch-size</code>: Minimum number of messages that Reliable Topic
tries to read in batches. Its default value is 10.</p>
</li>
<li>
<p><code>topic-overload-policy</code>: Policy to handle an overloaded topic.
Available values are <code>DISCARD_OLDEST</code>, <code>DISCARD_NEWEST</code>, <code>BLOCK</code> and <code>ERROR</code>.
Its default value is <code>BLOCK</code>. See <a href="#slow-consumers">Slow Consumers</a> for definitions of these policies.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lock"><a class="anchor" href="#lock"></a>7.10. FencedLock</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>FencedLock</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>FencedLock</code> is a linearizable and distributed implementation of
<code>java.util.concurrent.locks.Lock</code>, meaning that if you lock using a <code>FencedLock</code>,
the critical section that it guards is guaranteed to be executed by only one thread
in the entire cluster. Even though locks are great for synchronization, they can lead
to problems if not used properly. Also note that Hazelcast Lock does not support fairness.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For detailed information and configuration, see the <a href="#fencedlock">FencedLock section</a>
under the CP Subsystem chapter.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-try-catch-blocks-with-locks"><a class="anchor" href="#using-try-catch-blocks-with-locks"></a>7.10.1. Using Try-Catch Blocks with Locks</h4>
<div class="paragraph">
<p>Always use locks with <strong>try</strong>-<strong>catch</strong> blocks. This ensures that locks are
released if an exception is thrown from
the code in a critical section. Also note that the <code>lock</code> method is outside
the <strong>try</strong>-<strong>catch</strong> block because we do not want to unlock
if the lock operation itself fails.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

        Lock lock = hazelcastInstance.getCPSubsystem().getLock("myLock");
        lock.lock();
        try {
            // do something here
        } finally {
            lock.unlock();
        }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="releasing-locks-with-trylock-timeout"><a class="anchor" href="#releasing-locks-with-trylock-timeout"></a>7.10.2. Releasing Locks with tryLock Timeout</h4>
<div class="paragraph">
<p>If a lock is not released in the cluster, another thread that is trying to get the
lock can wait forever. To avoid this, use <code>tryLock</code> with a timeout value. You can
set a high value (normally it should not take that long) for <code>tryLock</code>.
You can check the return value of <code>tryLock</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if ( lock.tryLock ( 10, TimeUnit.SECONDS ) ) {
  try {
    // do some stuff here..
  } finally {
    lock.unlock();
  }
} else {
  // warning
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="understanding-lock-behavior"><a class="anchor" href="#understanding-lock-behavior"></a>7.10.3. Understanding Lock Behavior</h4>
<div class="ulist">
<ul>
<li>
<p>Locks are fail-safe. If a member holds a lock and some other members go down,
the cluster will keep your locks safe and available.
Moreover, when a member leaves the cluster, all the locks acquired by that
dead member will be removed so that those
locks are immediately available for live members.</p>
</li>
<li>
<p>Locks are not automatically removed. If a lock is not used anymore, Hazelcast
does not automatically perform garbage collection in the lock.
This can lead to an <code>OutOfMemoryError</code>. If you create locks on the fly,
make sure they are destroyed.</p>
</li>
<li>
<p>Locks are re-entrant. The same thread can lock multiple times on the same lock.
Note that for other threads to be able to require this lock, the owner of the lock
must call <code>unlock</code> as many times as the owner called <code>lock</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="iatomiclong"><a class="anchor" href="#iatomiclong"></a>7.11. IAtomicLong</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>IAtomicLong</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast <code>IAtomicLong</code> is the distributed implementation of
<code>java.util.concurrent.atomic.AtomicLong</code>. It offers most of AtomicLong&#8217;s operations
such as <code>get</code>, <code>set</code>, <code>getAndSet</code>, <code>compareAndSet</code> and <code>incrementAndGet</code>.
Since IAtomicLong is a distributed implementation, these operations involve remote
calls and thus their performances differ from AtomicLong.</p>
</div>
<div class="paragraph">
<p>The following example code creates an instance, increments it
by a million and prints the count.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IAtomicLong counter = hazelcastInstance.getCPSubsystem().getAtomicLong( "counter" );
        for ( int k = 0; k &lt; 1000 * 1000; k++ ) {
            if ( k % 500000 == 0 ) {
                System.out.println( "At: " + k );
            }
            counter.incrementAndGet();
        }
        System.out.printf( "Count is %s\n", counter.get() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you start other instances with the code above,
you will see the count as <strong>member count</strong> times <strong>a million</strong>.</p>
</div>
<div class="sect3">
<h4 id="sending-functions-to-iatomiclong"><a class="anchor" href="#sending-functions-to-iatomiclong"></a>7.11.1. Sending Functions to IAtomicLong</h4>
<div class="paragraph">
<p>You can send functions to an IAtomicLong. <code>IFunction</code> is a Hazelcast owned,
single method interface. The following example <code>IFunction</code> implementation
adds two to the original value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    private static class Add2Function implements IFunction&lt;Long, Long&gt; {
        @Override
        public Long apply( Long input ) {
            return input + 2;
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="executing-functions-on-iatomiclong"><a class="anchor" href="#executing-functions-on-iatomiclong"></a>7.11.2. Executing Functions on IAtomicLong</h4>
<div class="paragraph">
<p>You can use the following methods to execute functions on IAtomicLong:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>apply</code>: Applies the function to the value in IAtomicLong without
changing the actual value and returning the result.</p>
</li>
<li>
<p><code>alter</code>: Alters the value stored in the IAtomicLong by applying the function.
It does not send back a result.</p>
</li>
<li>
<p><code>alterAndGet</code>: Alters the value stored in the IAtomicLong by applying the function,
storing the result in the IAtomicLong and returning the result.</p>
</li>
<li>
<p><code>getAndAlter</code>: Alters the value stored in the IAtomicLong by applying the function
and returning the original value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example includes these methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IAtomicLong atomicLong = hazelcastInstance.getCPSubsystem().getAtomicLong( "counter" );

        atomicLong.set( 1 );
        long result = atomicLong.apply( new Add2Function() );
        System.out.println( "apply.result: " + result);
        System.out.println( "apply.value: " + atomicLong.get() );

        atomicLong.set( 1 );
        atomicLong.alter( new Add2Function() );
        System.out.println( "alter.value: " + atomicLong.get() );

        atomicLong.set( 1 );
        result = atomicLong.alterAndGet( new Add2Function() );
        System.out.println( "alterAndGet.result: " + result );
        System.out.println( "alterAndGet.value: " + atomicLong.get() );

        atomicLong.set( 1 );
        result = atomicLong.getAndAlter( new Add2Function() );
        System.out.println( "getAndAlter.result: " + result );
        System.out.println( "getAndAlter.value: " + atomicLong.get() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the above class when run is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apply.result: 3
apply.value: 1
alter.value: 3
alterAndGet.result: 3
alterAndGet.value: 3
getAndAlter.result: 1
getAndAlter.value: 3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reasons-to-use-functions-with-iatomic"><a class="anchor" href="#reasons-to-use-functions-with-iatomic"></a>7.11.3. Reasons to Use Functions with IAtomicLong</h4>
<div class="paragraph">
<p>The reason for using a function instead of a simple code line like
<code>atomicLong.set(atomicLong.get() + 2));</code> is that the IAtomicLong read and write
operations are not atomic. Since <code>IAtomicLong</code> is a distributed implementation,
those operations can be remote ones, which may lead to race problems. By using functions,
the data is not pulled into the code, but the code is sent to the data. This makes it more scalable.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="isemaphore"><a class="anchor" href="#isemaphore"></a>7.12. ISemaphore</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ISemaphore</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast ISemaphore is the distributed implementation of <code>java.util.concurrent.Semaphore</code>.</p>
</div>
<div class="sect3">
<h4 id="controlling-thread-counts-with-permits"><a class="anchor" href="#controlling-thread-counts-with-permits"></a>7.12.1. Controlling Thread Counts with Permits</h4>
<div class="paragraph">
<p>Semaphores offer <strong>permit</strong>s to control the thread counts when performing concurrent activities.
To execute a concurrent activity, a thread grants a permit or waits until a permit
becomes available. When the execution is completed, the permit is released.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>ISemaphore</code> with a single permit may be considered as a lock. Unlike the locks,
when semaphores are used, any thread can release the permit depending on the configuration,
and semaphores can have multiple permits. For more information, see the <a href="#semaphore-configuration">Semaphore Configuration section</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Hazelcast ISemaphore does not support fairness at all times. There are some edge cases
where the fairness is not honored, e.g., when the permit becomes available
at the time when an internal timeout occurs.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a permit is acquired on ISemaphore:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there are permits, the number of permits in the semaphore is decreased by one
and the calling thread performs its activity. If there is contention,
the longest waiting thread acquires the permit before all other threads.</p>
</li>
<li>
<p>If no permits are available, the calling thread blocks until a permit
becomes available. When a timeout happens during this block, the thread is interrupted.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="example-semaphore-code"><a class="anchor" href="#example-semaphore-code"></a>7.12.2. Example Semaphore Code</h4>
<div class="paragraph">
<p>The following example code uses an <code>IAtomicLong</code> resource 1000 times,
increments the resource when a thread starts to use it and decrements
it when the thread completes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        ISemaphore semaphore = hazelcastInstance.getCPSubsystem().getSemaphore( "semaphore" );
        IAtomicLong resource = hazelcastInstance.getCPSubsystem().getAtomicLong( "resource" );
        for ( int k = 0 ; k &lt; 1000 ; k++ ) {
            System.out.println( "At iteration: " + k + ", Active Threads: " + resource.get() );
            semaphore.acquire();
            try {
                resource.incrementAndGet();
                Thread.sleep( 1000 );
                resource.decrementAndGet();
            } finally {
                semaphore.release();
            }
        }
        System.out.println("Finished");</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you execute the above <code>SemaphoreMember</code> class 5 times,
the following output appears:</p>
</div>
<div class="paragraph">
<p><code>At iteration: 0, Active Threads: 1</code></p>
</div>
<div class="paragraph">
<p><code>At iteration: 1, Active Threads: 2</code></p>
</div>
<div class="paragraph">
<p><code>At iteration: 2, Active Threads: 3</code></p>
</div>
<div class="paragraph">
<p><code>At iteration: 3, Active Threads: 3</code></p>
</div>
<div class="paragraph">
<p><code>At iteration: 4, Active Threads: 3</code></p>
</div>
<div class="paragraph">
<p>As you can see, the maximum count of concurrent threads is equal or
smaller than three. If you remove the semaphore acquire/release statements
in <code>SemaphoreMember</code>, you will see that there is no limitation on the number
of concurrent usages.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="iatomicreference"><a class="anchor" href="#iatomicreference"></a>7.13. IAtomicReference</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>IAtomicReference</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>IAtomicLong</code> is very useful if you need to deal with a long,
but in some cases you need to deal with a reference. That is why Hazelcast
also supports the <code>IAtomicReference</code> which is the distributed version of
the <code>java.util.concurrent.atomic.AtomicReference</code>.</p>
</div>
<div class="paragraph">
<p>Here is an IAtomicReference example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();

        HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);

        IAtomicReference&lt;String&gt; ref = hz.getCPSubsystem().getAtomicReference("reference");
        ref.set("foo");
        System.out.println(ref.get());
        System.exit(0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you execute the above example, the output is as follows:</p>
</div>
<div class="paragraph">
<p><code>foo</code></p>
</div>
<div class="sect3">
<h4 id="sending-functions-to-iatomicreference"><a class="anchor" href="#sending-functions-to-iatomicreference"></a>7.13.1. Sending Functions to IAtomicReference</h4>
<div class="paragraph">
<p>Just like <code>IAtomicLong</code>, <code>IAtomicReference</code> has methods that accept a
'function' as an argument, such as <code>alter</code>, <code>alterAndGet</code>, <code>getAndAlter</code> and <code>apply</code>.
There are two big advantages of using these methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From a performance point of view, it is better to send the function to the data
than the data to the function. Often the function is a lot smaller than the data and
therefore cheaper to send over the line. Also the function only needs to be transferred
once to the target machine and the data needs to be transferred twice.</p>
</li>
<li>
<p>You do not need to deal with concurrency control. If you would perform a load, transform,
store, you could run into a data race since another thread might have updated the value you
are about to overwrite.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="using-iatomicreference"><a class="anchor" href="#using-iatomicreference"></a>7.13.2. Using IAtomicReference</h4>
<div class="paragraph">
<p>The following are some considerations you need to know when you use IAtomicReference:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IAtomicReference</code> works based on the byte-content and not on the object-reference.
If you use the <code>compareAndSet</code> method, do not change to the original value because its
serialized content will then be different. It is also important to know that if you rely
on Java serialization, sometimes (especially with hashmaps) the same object can result in
different binary content.</p>
</li>
<li>
<p>All methods returning an object return a private copy. You can modify the private copy,
but the rest of the world is shielded from your changes. If you want these changes to be
visible to the rest of the world, you need to write the change back to the <code>IAtomicReference</code>;
but be careful about introducing a data-race.</p>
</li>
<li>
<p>The 'in-memory format' of an <code>IAtomicReference</code> is <code>binary</code>. The receiving side does
not need to have the class definition available unless it needs to be deserialized on the
other side, e.g., because a method like 'alter' is executed. This deserialization is done
for every call that needs to have the object instead of the binary content, so be careful
with expensive object graphs that need to be deserialized.</p>
</li>
<li>
<p>If you have an object with many fields or an object graph and you only need to calculate
some information or need a subset of fields, you can use the <code>apply</code> method. With the <code>apply</code>
method, the whole object does not need to be sent over the line; only the information that is
relevant is sent.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="icountdownlatch"><a class="anchor" href="#icountdownlatch"></a>7.14. ICountDownLatch</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ICountDownLatch</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast <code>ICountDownLatch</code> is the distributed implementation of
<code>java.util.concurrent.CountDownLatch</code>. But unlike Java&#8217;s implementation,
Hazelcast&#8217;s <code>ICountDownLatch</code> count can be reset after a countdown has finished,
but not during an active count.</p>
</div>
<div class="sect3">
<h4 id="gate-keeping-concurrent-activities"><a class="anchor" href="#gate-keeping-concurrent-activities"></a>7.14.1. Gate-Keeping Concurrent Activities</h4>
<div class="paragraph">
<p><code>ICountDownLatch</code> is considered to be a gate keeper for concurrent activities.
It enables the threads to wait for other threads to complete their operations.
The following examples describe the mechanism of <code>ICountDownLatch</code>.</p>
</div>
<div class="paragraph">
<p>Assume that there is a leader process and there are follower processes that will
wait until the leader completes. Here is the leader:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Leader {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        ICountDownLatch latch = hazelcastInstance.getCPSubsystem().getCountDownLatch( "countDownLatch" );
        System.out.println( "Starting" );
        latch.trySetCount( 1 );
        Thread.sleep( 30000 );
        latch.countDown();
        System.out.println( "Leader finished" );
        latch.destroy();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since only a single step is needed to be completed as a sample, the above code
initializes the latch with 1. Then, the code sleeps for a while to simulate a
process and starts the countdown. Finally, it clears up the latch. Let&#8217;s write a follower:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Follower {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        ICountDownLatch latch = hazelcastInstance.getCPSubsystem().getCountDownLatch( "countDownLatch" );
        System.out.println( "Waiting" );
        boolean success = latch.await( 10, TimeUnit.SECONDS );
        System.out.println( "Complete: " + success );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The follower class above first retrieves <code>ICountDownLatch</code> and then calls the <code>await</code>
method to enable the thread to listen for the latch. The method <code>await</code> has a timeout
value as a parameter. This is useful when the <code>countDown</code> method fails. To see <code>ICountDownLatch</code>
in action, start the leader first and then start one or more followers. You will see that the
followers wait until the leader completes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pn-counter"><a class="anchor" href="#pn-counter"></a>7.15. PN Counter</h3>
<div class="paragraph">
<p>A Conflict-free Replicated Data Type (CRDT) is a distributed data structure
that achieves high availability by relaxing consistency constraints.
There may be several replicas for the same data and these replicas can be
modified concurrently without coordination. This means that you may achieve
high throughput and low latency when updating a CRDT data structure.
On the other hand, all of the updates are replicated asynchronously.
Each replica then receives updates made on other replicas eventually and
if no new updates are done, all replicas which can communicate to each other
return the same state (converge) after some time.</p>
</div>
<div class="paragraph">
<p>Hazelcast offers a lightweight CRDT PN counter (Positive-Negative Counter)
implementation where each Hazelcast instance can increment and decrement the
counter value and these updates are propagated to all replicas. Only a Hazelcast
member can store state for a counter which means that counter method invocations
performed on a Hazelcast member are usually local (depending on the configured
replica count). If there is no member failure, it is guaranteed that each replica
sees the final value of the counter eventually. Counter&#8217;s state converges with each
update and all CRDT replicas that can communicate to each other will eventually have the same state.</p>
</div>
<div class="paragraph">
<p>Using the PN Counter, you can get a distributed counter, increment and decrement it,
and query its value with RYW (read-your-writes) and monotonic reads. The implementation
borrows most methods from the <code>AtomicLong</code> which should be familiar in most cases and
easily interchangeable in the existing code.</p>
</div>
<div class="paragraph">
<p>Some examples of PN counter are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>counting the number of "likes" or "+1"</p>
</li>
<li>
<p>counting the number of logged in users</p>
</li>
<li>
<p>counting the number of page hits/views.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>How it works</strong></p>
</div>
<div class="paragraph">
<p>The counter supports adding and subtracting values as well as retrieving
the current counter value. Each replica of this counter can perform operations
locally without coordination with the other replicas, thus increasing availability.
The counter guarantees that whenever two members have received the same set of updates,
possibly in a different order, their state is identical, and any conflicting updates
are merged automatically. If no new updates are made to the shared state, all
members that can communicate will eventually have the same data.</p>
</div>
<div class="paragraph">
<p>The updates to the counter are applied locally when invoked on a CRDT replica.
A CRDT replica can be any Hazelcast instance <strong>which is NOT a client or a lite member</strong>.
You can configure the number of replicas in the cluster using the <code>replica-count</code>
configuration element.</p>
</div>
<div class="paragraph">
<p>When invoking updates from a non-replica instance, the invocation is remote.
This may lead to indeterminate state - the update may be applied but the response
has not been received. In this case, the caller is notified with a
<code>TargetDisconnectedException</code> when invoked from a client or a <code>MemberLeftException</code>
when invoked from a member.</p>
</div>
<div class="paragraph">
<p>The read and write methods provide monotonic read and RYW (read-your-write) guarantees.
These guarantees are session guarantees which mean that if no replica with the previously
observed state is reachable, the session guarantees are lost and the method invocation
throws a <code>ConsistencyLostException</code>. This does not mean that an update is lost.
All of the updates are part of some replica and eventually reflected in the state of all other replicas.
This exception just means that you cannot observe your own writes because all replicas
that contain your updates are currently unreachable. After you have received a
<code>ConsistencyLostException</code>, you can either wait for a sufficiently up-to-date replica
to become reachable in which case the session can be continued or you can reset the
session by calling the method `reset(). If you have called this method, a new session
is started with the next invocation to a CRDT replica.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The CRDT state is kept entirely on non-lite (data) members. If there aren&#8217;t any
and the methods here are invoked on a lite member, they fail with a <code>NoDataMemberInClusterException</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is an example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        final HazelcastInstance instance = Hazelcast.newHazelcastInstance();
        final PNCounter counter = instance.getPNCounter("counter");
        counter.addAndGet(5);
        final long value = counter.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code snippet creates an instance of a PN counter, increments it by 5 and retrieves the value.</p>
</div>
<div class="sect3">
<h4 id="configuring-pn-counter"><a class="anchor" href="#configuring-pn-counter"></a>7.15.1. Configuring PN Counter</h4>
<div class="paragraph">
<p>Following is an example declarative configuration snippet:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;pn-counter name="default"&gt;
        &lt;replica-count&gt;10&lt;/replica-count&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
    &lt;/pn-counter&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  pn-counter:
    default:
      replica-count: 10
      statistics-enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>PN Counter has the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of your PN Counter.</p>
</li>
<li>
<p><code>replica-count</code>: Number of replicas on which state for this PN counter is kept.
This number applies in quiescent state, if there are currently membership changes or
clusters are merging, the state may be temporarily kept on more replicas.
Its default value is Integer.MAX_VALUE. Generally, keeping the state on more replicas
means that more Hazelcast members are able to perform updates locally but it also means
that the PN counter state is kept on more replicas, increasing the network traffic,
decreasing the speed at which replica states converge and increasing the size of the
PN counter state kept on each replica.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your
PN Counter. If set to<code>false</code>, you cannot collect statistics in your implementation
(using <code>getLocalPNCounterStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-pn-counters" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is<code>true</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following is an equivalent snippet of Java configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        PNCounterConfig pnCounterConfig = new PNCounterConfig("default")
                .setReplicaCount(10)
                .setStatisticsEnabled(true);
        Config hazelcastConfig = new Config()
                .addPNCounterConfig(pnCounterConfig);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-the-crdt-replication-mechanism"><a class="anchor" href="#configuring-the-crdt-replication-mechanism"></a>7.15.2. Configuring the CRDT Replication Mechanism</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Configuring the replication mechanism is for advanced use
cases only - usually the default configuration works fine for most cases.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In some cases, you may want to configure the replication mechanism for all
CRDT implementations. The CRDT states are replicated in rounds (the period is
configurable) and in each round the state is replicated up to the configured number
of members. Generally speaking, you may increase the speed at which replicas converge
at the expense of more network traffic or decrease the network traffic at the expense
of slower convergence of replicas.
Hazelcast implements the state-based replication mechanism - the CRDT state for changed
CRDTs is replicated in its entirety to other replicas on each replication round.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;crdt-replication&gt;
        &lt;max-concurrent-replication-targets&gt;1&lt;/max-concurrent-replication-targets&gt;
        &lt;replication-period-millis&gt;1000&lt;/replication-period-millis&gt;
    &lt;/crdt-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  crdt-replication:
    max-concurrent-replication-targets: 1
    replication-period-millis: 1000</code></pre>
</div>
</div>
<div class="paragraph">
<p>CRDT replication has the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max-concurrent-replication-targets</code>: The maximum number of target members
that we replicate the CRDT states to in one period. A higher count leads to
states being disseminated more rapidly at the expense of burst-like behavior -
one update to a CRDT leads to a sudden burst in the number of replication messages
in a short time interval. Its default value is 1 which means that each replica
replicates state to only one other replica in each replication round.</p>
</li>
<li>
<p><code>replication-period-millis</code>: The period between two replications of CRDT states
in milliseconds. A lower value increases the speed at which changes are disseminated
to other cluster members at the expense of burst-like behavior - less updates are
batched together in one replication message, and one update to a CRDT may cause a
sudden burst of replication messages in a short time interval. The value must be a
positive non-null integer. Its default value is 1000 milliseconds which means that
the changed CRDT state is replicated every 1 second.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following is an equivalent snippet of Java configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        final CRDTReplicationConfig crdtReplicationConfig = new CRDTReplicationConfig()
                .setMaxConcurrentReplicationTargets(1)
                .setReplicationPeriodMillis(1000);
        Config hazelcastConfig = new Config()
                .setCRDTReplicationConfig(crdtReplicationConfig);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flakeidgenerator"><a class="anchor" href="#flakeidgenerator"></a>7.16. Flake ID Generator</h3>
<div class="paragraph">
<p>Hazelcast Flake ID Generator is used to generate cluster-wide unique identifiers.
Generated identifiers are <code>long</code> primitive values and are k-ordered (roughly ordered).
IDs are in the range from 0 to Long.MAX_VALUE.</p>
</div>
<div class="sect3">
<h4 id="generating-cluster-wide-flake-ids"><a class="anchor" href="#generating-cluster-wide-flake-ids"></a>7.16.1. Generating Cluster-Wide IDs</h4>
<div class="paragraph">
<p>The IDs contain timestamp component and a node ID component, which is assigned when the
member joins the cluster. This allows the IDs to be ordered and unique without any
coordination between the members, which makes the generator safe even in split-brain
scenarios (for limitations in this case, see the <a href="#node-id-assignment">Node ID assignment section</a> below).</p>
</div>
<div class="paragraph">
<p>Timestamp component is in milliseconds since 1.1.2018, 0:00 UTC and has 41 bits.
This caps the useful lifespan of the generator to little less than 70 years (until ~2088).
The sequence component is 6 bits. If more than 64 IDs are requested in single millisecond,
IDs gracefully overflow to the next millisecond and uniqueness is guaranteed in this case.
The implementation does not allow overflowing by more than 15 seconds, if IDs are requested
at higher rate, the call blocks. Note, however, that clients are able to generate even faster
because each call goes to a different (random) member and the 64 IDs/ms limit is for single member.</p>
</div>
</div>
<div class="sect3">
<h4 id="flakeidgenerator-performance"><a class="anchor" href="#flakeidgenerator-performance"></a>7.16.2. Performance</h4>
<div class="paragraph">
<p>Operation on member is always local, if the member has valid node ID, otherwise it&#8217;s remote.
On the client, the <code>newId()</code> method goes to a random member and gets a batch of IDs,
which is then returned locally for a limited time. The pre-fetch size and the validity
time can be configured for each client and member.</p>
</div>
</div>
<div class="sect3">
<h4 id="flakeidgenerator-example"><a class="anchor" href="#flakeidgenerator-example"></a>7.16.3. Example</h4>
<div class="paragraph">
<p>Let&#8217;s write an example identifier generator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ExampleFlakeIdGenerator {
    public static void main(String[] args) {
        HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance();

        ClientConfig clientConfig = new ClientConfig()
                .addFlakeIdGeneratorConfig(new ClientFlakeIdGeneratorConfig("idGenerator")
                        .setPrefetchCount(10)
                        .setPrefetchValidityMillis(MINUTES.toMillis(10)));
        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);

        FlakeIdGenerator idGenerator = client.getFlakeIdGenerator("idGenerator");
        for (int i = 0; i &lt; 10000; i++) {
            sleepSeconds(1);
            System.out.printf("Id: %s\n", idGenerator.newId());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="node-id-assignment"><a class="anchor" href="#node-id-assignment"></a>7.16.4. Node ID Assignment</h4>
<div class="paragraph">
<p>Flake IDs require a unique node ID to be assigned to each member, from which point the
member can generate unique IDs without any coordination. Hazelcast uses the member list
version from the moment when the member joined the cluster as a unique node ID.</p>
</div>
<div class="paragraph">
<p>The join algorithm is specifically designed to ensure that member list join version is unique
for each member in the cluster. This ensures that IDs are unique even during network splits,
with one caveat: at most one member is allowed to join the cluster during a network split.
If two members join different subclusters, they are likely to get the same node ID. This is
resolved when the cluster heals, but until then, they can generate duplicate IDs.</p>
</div>
<div class="sect4">
<h5 id="node-id-overflow"><a class="anchor" href="#node-id-overflow"></a>Node ID Overflow</h5>
<div class="paragraph">
<p>Node ID component of the ID has 16 bits. Members with the member list join version higher
than 2^16 won&#8217;t be able to generate IDs, but functionality is preserved by forwarding to another member.
It is possible to generate IDs on any member or client as long as there is at least one
member with join version smaller than 2^16 in the cluster. The remedy is to restart the cluster:
the node ID component will be reset and assigned starting from zero again. Uniqueness after the
restart will be preserved thanks to the timestamp component.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_flake_id_generator"><a class="anchor" href="#_configuring_flake_id_generator"></a>7.16.5. Configuring Flake ID Generator</h4>
<div class="paragraph">
<p>Following is an example declarative configuration snippet:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;flake-id-generator name="default"&gt;
        &lt;prefetch-count&gt;100&lt;/prefetch-count&gt;
        &lt;prefetch-validity-millis&gt;600000&lt;/prefetch-validity-millis&gt;
        &lt;epoch-start&gt;1514764800000&lt;/epoch-start&gt;
        &lt;node-id-offset&gt;0&lt;/node-id-offset&gt;
        &lt;bits-sequence&gt;6&lt;/bits-sequence&gt;
        &lt;bits-node-id&gt;16&lt;/bits-node-id&gt;
        &lt;allowed-future-millis&gt;15000&lt;/allowed-future-millis&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
    &lt;/flake-id-generator&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  flake-id-generator:
    default:
      prefetch-count: 100
      prefetch-validity-millis: 600000
      epoch-start: 1514764800000
      node-id-offset: 0
      bits-sequence: 6
      bits-node-id: 16
      allowed-future-millis: 15000
      statistics-enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions of configuration elements and attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of your Flake ID Generator. It is a required attribute.</p>
</li>
<li>
<p><code>prefetch-count</code>: Count of IDs which are pre-fetched on the background
when one call to FlakeIdGenerator.newId() is made. Its value must be in the
range 1 -100,000. Its default value is 100. This setting pertains only to
<code>newId()</code> calls made on the member that configured it.</p>
</li>
<li>
<p><code>prefetch-validity-millis</code>: Specifies for how long the pre-fetched IDs can
be used. After this time elapses, a new batch of IDs are fetched. Time unit is
milliseconds. Its default value is 600,000 milliseconds (10 minutes). The IDs
contain a timestamp component, which ensures a rough global ordering of them.
If an ID is assigned to an object that was created later, it will be out of order.
If ordering is not important, set this value to 0. This setting pertains only to
<code>newId()</code> calls made on the member that configured it.</p>
</li>
<li>
<p><code>epoch-start</code>: Offset of the timestamp component. Time unit is
milliseconds, default is 1514764800000 (1.1.2018 0:00 UTC)</p>
</li>
<li>
<p><code>node-id-offset</code>: Specifies the offset that is added to the node ID assigned
to cluster member for this generator. Might be useful in A/B deployment scenarios
where you have cluster A which you want to upgrade. You create cluster B and
for some time both will generate IDs and you want to have them unique.
In this case, configure node ID offset for generators on cluster B.</p>
</li>
<li>
<p><code>bits-sequence</code>: Bit-length of the sequence component. Default value is 6 bits.</p>
</li>
<li>
<p><code>bits-node-id</code>: Bit-length of node id component. Default value is 16 bits.</p>
</li>
<li>
<p><code>allowed-future-millis</code>: Sets how far to the future is the generator allowed to
generate IDs without blocking. Default is 15 seconds.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled
for your Flake ID Generator. If set to<code>false</code>, you cannot collect statistics
in your implementation (using <code>getLocalFlakeIdGeneratorStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-flake-id-generators" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is<code>true</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="replicated-map"><a class="anchor" href="#replicated-map"></a>7.17. Replicated Map</h3>
<div class="paragraph">
<p>A Replicated Map is a distributed key-value data structure where
the data is replicated to all members in the cluster.
It provides full replication of entries to all members for high speed access.</p>
</div>
<div class="paragraph">
<p>The following are the features of Replicated Map:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When you have a Replicated Map in the  cluster, your clients
can communicate with any cluster member.</p>
</li>
<li>
<p>All cluster members are able to perform write operations.</p>
</li>
<li>
<p>It supports all methods of the interface <code>java.util.Map</code>.</p>
</li>
<li>
<p>It supports automatic initial fill up when a new member is started.</p>
</li>
<li>
<p>It provides statistics for entry access, write and update so that
you can monitor it using Hazelcast Management Center.</p>
</li>
<li>
<p>New members joining to the cluster pull all the data from the existing members.</p>
</li>
<li>
<p>You can listen to entry events using listeners. See the
<a href="#using-entrylistener-on-replicated-map">Using EntryListener on Replicated Map section</a>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="replicating-instead-of-partitioning"><a class="anchor" href="#replicating-instead-of-partitioning"></a>7.17.1. Replicating Instead of Partitioning</h4>
<div class="paragraph">
<p>A Replicated Map does not partition data
(it does not spread data to different cluster members); instead,
it replicates the data to all members.</p>
</div>
<div class="paragraph">
<p>Replication leads to higher memory consumption.
However, a Replicated Map has faster read and write access since
the data is available on all members.</p>
</div>
<div class="paragraph">
<p>Writes could take place on local/remote members in order to provide write-order,
eventually being replicated to all other members.</p>
</div>
<div class="paragraph">
<p>Replicated Map is suitable for objects, catalog data, or idempotent calculable data
(such as HTML pages). It fully implements the <code>java.util.Map</code> interface,
but it lacks the methods from <code>java.util.concurrent.ConcurrentMap</code> since
there are no atomic guarantees to writes or reads.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If Replicated Map is used from a unisocket client and this
unisocket client is connected to a lite member, the entry listeners cannot be registered/de-registered.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot use Replicated Map from a lite member.
A <code>com.hazelcast.replicatedmap.ReplicatedMapCantBeCreatedOnLiteMemberException</code>
is thrown if <code>com.hazelcast.core.HazelcastInstance.getReplicatedMap(name)</code>
is invoked on a lite member.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="example-replicated-map-code"><a class="anchor" href="#example-replicated-map-code"></a>7.17.2. Example Replicated Map Code</h4>
<div class="paragraph">
<p>Here is an example of Replicated Map code. The HazelcastInstance&#8217;s
<code>getReplicatedMap</code> method gets the Replicated Map, and the Replicated Map&#8217;s
<code>put</code> method creates map entries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        Map&lt;String, String&gt; map = hz.getReplicatedMap("map");

        map.put("1", "Tokyo");
        map.put("2", "Paris");
        map.put("3", "New York");

        System.out.println("Finished loading map");
        hz.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HazelcastInstance.getReplicatedMap()</code> returns
<code>com.hazelcast.core.ReplicatedMap</code> which, as stated above, extends the
<code>java.util.Map</code> interface.</p>
</div>
<div class="paragraph">
<p>The <code>com.hazelcast.core.ReplicatedMap</code> interface has some
additional methods for registering entry listeners or retrieving
values in an expected order.</p>
</div>
</div>
<div class="sect3">
<h4 id="considerations-for-replicated-map"><a class="anchor" href="#considerations-for-replicated-map"></a>7.17.3. Considerations for Replicated Map</h4>
<div class="paragraph">
<p>If you have a large cluster or very high occurrences of updates,
the Replicated Map may not scale linearly as expected since
it has to replicate update operations to all members in the cluster.</p>
</div>
<div class="paragraph">
<p>Since the replication of updates is performed in an asynchronous manner,
we recommend you enable back pressure in case your system has high occurrences
of updates. See the <a href="#back-pressure">Back Pressure section</a> to learn how to enable it.</p>
</div>
<div class="paragraph">
<p>Replicated Map has an anti-entropy system that converges values to a
common one if some of the members are missing replication updates.</p>
</div>
<div class="paragraph">
<p>Replicated Map does not guarantee eventual consistency because there are
some edge cases that fail to provide consistency.</p>
</div>
<div class="paragraph">
<p>Replicated Map uses the internal partition system of Hazelcast in order to
serialize updates happening on the same key at the same time. This happens
by sending updates of the same key to the same Hazelcast member in the cluster.</p>
</div>
<div class="paragraph">
<p>Due to the asynchronous nature of replication, a Hazelcast member could
die before successfully replicating a "write" operation to other members
after sending the "write completed" response to its caller during the write process.
In this scenario, Hazelcast&#8217;s internal partition system promotes one of the replicas
of the partition as the primary one. The new primary partition does not have
the latest "write" since the dead member could not successfully replicate the update.
(This leaves the system in a state that the caller is the only one that has the
update and the rest of the cluster have not.) In this case even the anti-entropy
system simply could not converge the value since the source of true information
is lost for the update. This leads to a break in the eventual consistency
because different values can be read from the system for the same key.</p>
</div>
<div class="paragraph">
<p>Other than the aforementioned scenario, the Replicated Map behaves
like an eventually consistent system with read-your-writes and monotonic-reads consistency.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuration-design-for-replicated-map"><a class="anchor" href="#configuration-design-for-replicated-map"></a>7.17.4. Configuration Design for Replicated Map</h4>
<div class="paragraph">
<p>There are several technical design decisions you should consider when you configure a Replicated Map.</p>
</div>
<div class="paragraph">
<p><strong>Initial Provisioning</strong></p>
</div>
<div class="paragraph">
<p>If a new member joins the cluster, there are two ways you can handle
the initial provisioning that is executed to replicate all existing
values to the new member. Each involves how you configure the async fill up.</p>
</div>
<div class="paragraph">
<p>First, you can configure async fill up to true, which does not block
reads while the fill up operation is underway. That way,
you have immediate access on the new member, but it will take time until
all the values are eventually accessible. Not yet
replicated values are returned as non-existing (null).</p>
</div>
<div class="paragraph">
<p>Second, you can configure for a synchronous initial fill up (by configuring
the async fill up to false), which blocks every read or write access to the map until the
fill up operation is finished. Use this with caution since it might block your
application from operating.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-replicated-map"><a class="anchor" href="#configuring-replicated-map"></a>7.17.5. Configuring Replicated Map</h4>
<div class="paragraph">
<p>Replicated Map can be configured programmatically or declaratively.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="paragraph">
<p>You can declare your Replicated Map configuration in the Hazelcast configuration
file <code>hazelcast.xml</code>. See the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;replicatedmap name="default"&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;async-fillup&gt;true&lt;/async-fillup&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;entry-listeners&gt;
            &lt;entry-listener include-value="true"&gt;
                com.hazelcast.examples.EntryListener
            &lt;/entry-listener&gt;
       &lt;/entry-listeners&gt;
       &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/replicatedmap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  replicatedmap:
    default:
      in-memory-format: BINARY
      async-fillup: true
      statistics-enabled: true
      entry-listeners:
        - class-name: com.hazelcast.examples.EntryListener
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>Replicated Map has the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>in-memory-format</code>: Internal storage format.  See the
<a href="#in-memory-format-on-replicated-map">In-Memory Format section</a>. Its default value is <code>OBJECT</code>.</p>
</li>
<li>
<p><code>async-fillup</code>: Specifies whether the Replicated Map is available
for reads before the initial replication is completed. Its default value is <code>true</code>.
If set to <code>false</code>, i.e., synchronous initial fill up, no exception is thrown when
the Replicated Map is not yet ready, but <code>null</code> values can be seen until the initial
replication is completed.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled
for your Replicated Map. If set to<code>false</code>, you cannot collect statistics in your
implementation (using <code>getLocalReplicatedMapStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-replicated-maps" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is<code>true</code>.</p>
</li>
<li>
<p><code>entry-listener</code>: Full canonical classname of the <code>EntryListener</code> implementation.</p>
<div class="ulist">
<ul>
<li>
<p><code>entry-listener#include-value</code>: Specifies whether the event includes the value or not.
Sometimes the key is enough to react on an event. In those situations, setting this value
to <code>false</code> saves a deserialization cycle. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>entry-listener#local</code>: Not used for Replicated Map since listeners are always local.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of quorum configuration that you want this Replicated Map to use.
See the <a href="#split-brain-protection-for-replicated-map">Split-Brain Protection for Replicated Map section</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="paragraph">
<p>You can configure a Replicated Map programmatically, as you can do for all other
data structures in Hazelcast. You must create the configuration upfront, when you
instantiate the <code>HazelcastInstance</code>.
A basic example of how to configure the Replicated Map using the programmatic approach
is shown in the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();

        ReplicatedMapConfig replicatedMapConfig =
                config.getReplicatedMapConfig( "default" );

        replicatedMapConfig.setInMemoryFormat( InMemoryFormat.BINARY )
                .setSplitBrainProtectionName( "splitbrainprotectionname" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>All properties that can be configured using the declarative configuration
are also available using programmatic configuration
by transforming the tag names into getter or setter names.</p>
</div>
<div class="sect4">
<h5 id="in-memory-format-on-replicated-map"><a class="anchor" href="#in-memory-format-on-replicated-map"></a>In-Memory Format on Replicated Map</h5>
<div class="paragraph">
<p>Currently, you can use the following <code>in-memory-format</code> options with the Replicated Map:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OBJECT</code> (default): The data is stored in deserialized form.
This configuration is the default choice since
the data replication is mostly used for high speed access. Please
be aware that changing the values without a <code>Map.put()</code> is
not reflected on the other members but is visible on the changing members
for later value accesses.</p>
</li>
<li>
<p><code>BINARY</code>: The data is stored in serialized binary format and has to be
deserialized on every request. This
option offers higher encapsulation since changes to values are always
discarded as long as the newly changed object is
not explicitly <code>Map.put()</code> into the map again.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-entrylistener-on-replicated-map"><a class="anchor" href="#using-entrylistener-on-replicated-map"></a>7.17.6. Using EntryListener on Replicated Map</h4>
<div class="paragraph">
<p>A <code>com.hazelcast.core.EntryListener</code> used on a Replicated Map serves
the same purpose as it would on other
data structures in Hazelcast. You can use it to react on add, update
and remove operations. Replicated Maps do not yet support eviction.</p>
</div>
<div class="sect4">
<h5 id="difference-in-entrylistener-on-replicated-map"><a class="anchor" href="#difference-in-entrylistener-on-replicated-map"></a>Difference in EntryListener on Replicated Map</h5>
<div class="paragraph">
<p>The fundamental difference in Replicated Map behavior, compared to the
other data structures, is that an EntryListener only reflects
changes on local data. Since replication is asynchronous, all listener
events are fired only when an operation is finished
on a local member. Events can fire at different times on different members.</p>
</div>
</div>
<div class="sect4">
<h5 id="example-of-replicated-map-entrylistener"><a class="anchor" href="#example-of-replicated-map-entrylistener"></a>Example of Replicated Map EntryListener</h5>
<div class="paragraph">
<p>Here is a code example for using EntryListener on a Replicated Map.</p>
</div>
<div class="paragraph">
<p>The <code>HazelcastInstance</code> s <code>getReplicatedMap</code> method gets a
Replicated Map (customers), and the <code>ReplicatedMap</code> s <code>addEntryListener</code>
method adds an entry listener to the Replicated Map. Then, the <code>ReplicatedMap</code> s <code>put</code>
method adds a Replicated Map
entry and updates it. The method <code>remove</code> removes the entry.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ReplicatedMap&lt;String, String&gt; map = hz.getReplicatedMap("somemap");
        map.addEntryListener(new MyEntryListener());
        System.out.println("EntryListener registered");
    }

    private static class MyEntryListener implements EntryListener&lt;String, String&gt; {

        @Override
        public void entryAdded(EntryEvent&lt;String, String&gt; event) {
            System.out.println("entryAdded: " + event);
        }

        @Override
        public void entryRemoved(EntryEvent&lt;String, String&gt; event) {
            System.out.println("entryRemoved: " + event);
        }

        @Override
        public void entryUpdated(EntryEvent&lt;String, String&gt; event) {
            System.out.println("entryUpdated: " + event);
        }

        @Override
        public void entryEvicted(EntryEvent&lt;String, String&gt; event) {
            System.out.println("entryEvicted: " + event);
        }
        @Override
        public void entryExpired(EntryEvent&lt;String, String&gt; event) {
            System.out.println( "Entry expired: " + event );
        }
        @Override
        public void mapEvicted(MapEvent event) {
            System.out.println("mapEvicted:" + event);

        }

        @Override
        public void mapCleared(MapEvent event) {
            System.out.println("mapCleared: " + event);
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="split-brain-protection-for-replicated-map"><a class="anchor" href="#split-brain-protection-for-replicated-map"></a>7.17.7. Split-Brain Protection for Replicated Map</h4>
<div class="paragraph">
<p>Replicated Map can be configured to check for a minimum number of available
members before applying its operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a
cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support split-brain
protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>clear</code></p>
</li>
<li>
<p><code>put</code></p>
</li>
<li>
<p><code>putAll</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>containsKey</code></p>
</li>
<li>
<p><code>containsValue</code></p>
</li>
<li>
<p><code>entrySet</code></p>
</li>
<li>
<p><code>get</code></p>
</li>
<li>
<p><code>isEmpty</code></p>
</li>
<li>
<p><code>keySet</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>values</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for Replicated Map can be configured programmatically
using the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/ReplicatedMapConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;replicatedmap name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/replicatedmap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  replicatedmap:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you
configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cardinality-estimator"><a class="anchor" href="#cardinality-estimator"></a>7.18. Cardinality Estimator Service</h3>
<div class="paragraph">
<p>Hazelcast&#8217;s cardinality estimator service is a data structure which implements
Flajolet&#8217;s HyperLogLog algorithm for estimating cardinalities of unique objects in theoretically huge data sets.
The implementation offered by Hazelcast includes improvements from Google&#8217;s
version of the algorithm, i.e., HyperLogLog++.</p>
</div>
<div class="paragraph">
<p>The cardinality estimator service does not provide any ways to configure
its properties, but rather uses some well tested defaults:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>P</code>: Stands for precision with a default value of 14
(using the 14 LSB of the hash for the index)</p>
</li>
<li>
<p><code>M</code>: 2 ^ P = 16384 (16K) registers</p>
</li>
<li>
<p><code>P'</code>: Stands for sparse precision with a default value of 25</p>
</li>
<li>
<p><code>Durability</code>: Count of backups for each estimator with a default value of 2</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to understand that this data structure is not
100% accurate, it is used to provide estimates. The error rate is typically
a result of <code>1.04/sqrt(M)</code> which in our implementation is around 0.81% for high percentiles.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The memory consumption of this data structure is close to 16K despite the
size of elements in the source data set or stream.</p>
</div>
<div class="paragraph">
<p>There are two phases in using the cardinality estimator.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add objects to the instance of the estimator, e.g., for IPs <code>estimator.add("0.0.0.0.")</code>.
The provided object is first serialized and then the byte array is used to
generate a hash for that object.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Objects must be serializable in a form that Hazelcast understands.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Compute the estimate of the set so far <code>estimator.estimate()</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/cardinality/CardinalityEstimator.html" target="_blank" rel="noopener">cardinality estimator Javadoc</a>
for more information on its API.</p>
</div>
<div class="paragraph">
<p>The following is an example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        CardinalityEstimator visitorsEstimator = hz.getCardinalityEstimator("visitors");

        InputStreamReader isr = new InputStreamReader(ExampleCardinalityEstimator.class.getResourceAsStream("visitors.txt"));
        BufferedReader br = new BufferedReader(isr);
        try {
            String visitor = br.readLine();
            while (visitor != null) {
                visitorsEstimator.add(visitor);
                visitor = br.readLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeResource(br);
            closeResource(isr);
        }

        System.out.printf("Estimated unique visitors seen so far: %d%n", visitorsEstimator.estimate());

        Hazelcast.shutdownAll();</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="split-brain-protection-for-cardinality-estimator"><a class="anchor" href="#split-brain-protection-for-cardinality-estimator"></a>7.18.1. Split-Brain Protection for Cardinality Estimator</h4>
<div class="paragraph">
<p>Cardinality Estimator can be configured to check for a minimum number of
available members before applying its operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>). This is a check to avoid performing successful queue
operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support
split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>addAsync</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>estimate</code></p>
</li>
<li>
<p><code>estimateAsync</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for Cardinality Estimator can be configured
programmatically using the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/CardinalityEstimatorConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>.
Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cardinality-estimator name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/cardinality-estimator&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cardinality-estimator:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name
which you configured under the <code>split-brain-protection</code> element as explained in the
<a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
<div class="paragraph">
<p><strong>Configuring Merge Policy</strong></p>
</div>
<div class="paragraph">
<p>While recovering from a split-brain syndrome, Cardinality Estimator
in the small cluster merges into the bigger cluster based on a configured
merge policy. When an estimator merges into the cluster, an estimator with
the same name might already exist in the cluster.
So the merge policy resolves these kinds of conflicts with different out-of-the-box strategies.
It can be configured programmatically using the method
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/CardinalityEstimatorConfig.html" target="_blank" rel="noopener">setMergePolicyConfig()</a>,
or declaratively using the element <code>merge-policy</code>.
Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cardinality-estimator name="default"&gt;
        &lt;merge-policy batch-size="102"&gt;HyperLogLogMergePolicy&lt;/merge-policy&gt;
    &lt;/cardinality-estimator&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cardinality-estimator:
      merge-policy:
        batch-size: 102
        class-name: HyperLogLogMergePolicy</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following out-of-the-box merge policies are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DiscardMergePolicy</code>: Estimator from the smaller cluster is discarded.</p>
</li>
<li>
<p><code>HyperLogLogMergePolicy</code>: Estimator merges with the existing one,
using the algorithmic merge for HyperLogLog. This is the default policy.</p>
</li>
<li>
<p><code>PassThroughMergePolicy</code>: Estimator from the smaller cluster wins.</p>
</li>
<li>
<p><code>PutIfAbsentMergePolicy</code>: Estimator from the smaller cluster wins if it doesn&#8217;t exist in the cluster.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="event-journal"><a class="anchor" href="#event-journal"></a>7.19. Event Journal</h3>
<div class="paragraph">
<p>The event journal is a distributed data structure that stores the history
of mutation actions on map or cache. Each action on the map or cache which
modifies its contents (such as <code>put</code>, <code>remove</code> or scheduled tasks which are
not triggered by using the public API) creates an event which is stored in
the event journal. The event stores the event type as well as the key, old
value and updated value for the entry (when applicable). As a user, you can
only append to the journal indirectly by using the map and cache methods or
configuring the expiration and eviction.  By reading from the event journal
you can recreate the state of the map or cache at any point in time.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently the event journal does not expose a public API for reading the
event journal in Hazelcast IMDG. The event journal can be used to stream event
data to Hazelcast Jet, so it should be used in conjunction with
<a href="http://jet.hazelcast.org/" target="_blank" rel="noopener">Hazelcast Jet</a>. Because of this we describe
how to configure it but not how to use it from IMDG in this section. If you
enable and configure the event journal, you may only reach it through private
API and you most probably do not get any benefits but the journal retains events
nevertheless and consumes heap space.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The event journal has a fixed capacity and an expiration time. Internally it is
structured as a ringbuffer (partitioned by ringbuffer item) and shares many
similarities with it.</p>
</div>
<div class="sect3">
<h4 id="interaction-with-evictions-and-expiration-for-imap"><a class="anchor" href="#interaction-with-evictions-and-expiration-for-imap"></a>7.19.1. Interaction with Evictions and Expiration for IMap</h4>
<div class="paragraph">
<p>Configuring IMap with eviction and expiration can cause the event journal to
contain different events on the different replicas of the same partition. You
can run into issues if you are reading from the event journal and the partition
owner is terminated. A backup replica is then promoted into the partition owner
but the event journal will contain different events. The event count should stay
the same but the entries which you previously thought were evicted and expired
could now be "alive" and vice versa.</p>
</div>
<div class="paragraph">
<p>This is because eviction and expiration randomly choose entries to be
evicted/expired. The entry is not coordinated between partition replicas.
In these cases, the event journal diverges and will not converge at any
future point, but will remain inconsistent just as well as the contents
of the internal record stores are inconsistent between replicas. You may
say that the event journal on a specific replica is in-sync with the record
store on that replica but the event journals and record stores between
replicas are out-of-sync.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-event-journal-capacity"><a class="anchor" href="#configuring-event-journal-capacity"></a>7.19.2. Configuring Event Journal Capacity</h4>
<div class="paragraph">
<p>By default, an event journal is configured with a <code>capacity</code> of 10000 items.
This creates a single array per partition, roughly the size of the capacity
divided by the number of partitions. Thus, if the configured capacity is
10000 and number of partitions is 271, we create 271 arrays of size 36
(10000/271). If
a <code>time-to-live</code> is configured, then an array of longs is also created
that stores the expiration time for every item.
A single array of the event journal keeps events that are only related
to the map entries in that partition. In a lot of cases you may want to
change this <code>capacity</code> number to something that better fits your needs.
As the capacity is shared between partitions, keep in mind not to set it
to a value which is too low for you. Setting the capacity to a number
lower than the partition count results in an error when initializing the
event journal.</p>
</div>
<div class="paragraph">
<p>Below is a declarative configuration example of an event journal with a
<code>capacity</code> of 5000 items for a map and 10000 items for a cache:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;event-journal enabled="true"&gt;
            &lt;capacity&gt;5000&lt;/capacity&gt;
            &lt;time-to-live-seconds&gt;20&lt;/time-to-live-seconds&gt;
        &lt;/event-journal&gt;
    &lt;/map&gt;
    ...
    &lt;cache name="default"&gt;
        &lt;event-journal enabled="true"&gt;
            &lt;capacity&gt;10000&lt;/capacity&gt;
            &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;/event-journal&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      event-journal:
        enabled: true
        capacity: 5000
        time-to-live-seconds: 20
  cache:
    default:
      event-journal:
        enabled: true
        capacity: 10000
        time-to-live-seconds: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure an event journal programmatically. The following
is a programmatic version of the above declarative configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        EventJournalConfig eventJournalMapConfig = new EventJournalConfig()
                .setEnabled(true)
                .setCapacity(5000)
                .setTimeToLiveSeconds(20);

        EventJournalConfig eventJournalCacheConfig = new EventJournalConfig()
                .setEnabled(true)
                .setCapacity(10000)
                .setTimeToLiveSeconds(0);

        Config config = new Config();
        config.getMapConfig("myMap").setEventJournalConfig(eventJournalMapConfig);
        config.getCacheConfig("myCache").setEventJournalConfig(eventJournalCacheConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>mapName</code> and <code>cacheName</code> attributes define the map or cache to which
this event journal configuration applies. You can use pattern-matching and
the <code>default</code> keyword when doing so. For instance, by using a <code>mapName</code> of
<code>journaled*</code>, the journal configuration applies to all maps whose names start
with "journaled" and don&#8217;t have other journal configurations that match (e.g.,
if you would have a more specific journal configuration with an exact name match).
If you specify the <code>mapName</code> or <code>cacheName</code> as <code>default</code>, the journal configuration
applies to all maps and caches that don&#8217;t have any other journal configuration.
This means that potentially all maps and/or caches have one single
event journal configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="event-journal-partitioning"><a class="anchor" href="#event-journal-partitioning"></a>7.19.3. Event Journal Partitioning</h4>
<div class="paragraph">
<p>The event journal is a partitioned data structure. The partitioning
is done by the event key. Because of this, the map and cache entry
with a specific key is co-located with the events for that key and
will be migrated accordingly.
Also, the backup count for the event journal is equal to the backup
count of the map or cache for which it contains events. The events on
the backup replicas will be created with the map or cache backup operations
and no additional network traffic is introduced when appending events
to the event journal.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-event-journal-ttl"><a class="anchor" href="#configuring-event-journal-ttl"></a>7.19.4. Configuring Event Journal time-to-live</h4>
<div class="paragraph">
<p>You can configure Hazelcast event journal with a <code>time-to-live</code> in seconds.
Using this setting, you can control how long the items remain in
the event journal before they are expired. By default, the <code>time-to-live</code>
is set to 0, meaning that unless the item is overwritten,
it remains in the journal indefinitely. The expiration time of the existing
journal events is checked whenever a new event is appended to the event
journal or when the event journal is being read. If the journal is not
being read from or written to, the journal may keep expired items indefinitely.</p>
</div>
<div class="paragraph">
<p>In the example below, an event journal is configured with a <code>time-to-live</code> of 180 seconds:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cache name="myCache"&gt;
        &lt;event-journal enabled="true"&gt;
            &lt;capacity&gt;10000&lt;/capacity&gt;
            &lt;time-to-live-seconds&gt;180&lt;/time-to-live-seconds&gt;
        &lt;/event-journal&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cache:
    myCache:
      event-journal:
        enabled: true
        capacity: 10000
        time-to-live-seconds: 180</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distributed-events"><a class="anchor" href="#distributed-events"></a>8. Distributed Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can register for Hazelcast entry events so you are notified
when those events occur. Event listeners are cluster-wide: when a
listener is registered in one member of cluster, it is actually
registered for the events that originated at any member in the cluster.
When a new member joins, events originated at the new member are also delivered.</p>
</div>
<div class="paragraph">
<p>An event is created only if you registered an event listener. If no listener
is registered, then no event is created. If you provided a predicate
when you registered the event listener, pass the predicate before sending
the event to the listener (member/client).</p>
</div>
<div class="paragraph">
<p>As a rule of thumb, your event listener should not implement heavy processes
in its event methods that block the thread for a long time. If needed, you can
use <code>ExecutorService</code> to transfer long running processes to another thread and
thus offload the current listener thread.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In a failover scenario, events are not highly available and may get lost.
However, you can perform workarounds such as configuring the event queue capacity
as explained in the <a href="#global-event-configuration">Global Event Configuration section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast offers the following event listeners.</p>
</div>
<div class="paragraph">
<p>For cluster events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Membership Listener</strong> for cluster membership events</p>
</li>
<li>
<p><strong>Distributed Object Listener</strong> for distributed object creation and destruction events</p>
</li>
<li>
<p><strong>Migration Listener</strong> for partition migration start and completion events</p>
</li>
<li>
<p><strong>Partition Lost Listener</strong> for partition lost events</p>
</li>
<li>
<p><strong>Lifecycle Listener</strong> for <code>HazelcastInstance</code> lifecycle events</p>
</li>
<li>
<p><strong>Client Listener</strong> for client connection events</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For distributed object events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Entry Listener</strong> for <code>IMap</code> and <code>MultiMap</code> entry events</p>
</li>
<li>
<p><strong>Item Listener</strong> for <code>IQueue</code>, <code>ISet</code> and <code>IList</code> item events</p>
</li>
<li>
<p><strong>Message Listener</strong> for <code>ITopic</code> message events</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For Hazelcast JCache implementation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cacheentrylistener">Cache Entry Listener</a></p>
</li>
<li>
<p><a href="#icache-partition-lost-listener">ICache Partition Lost Listener</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For Hazelcast clients:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Lifecycle Listener</strong></p>
</li>
<li>
<p><strong>Membership Listener</strong></p>
</li>
<li>
<p><strong>Distributed Object Listener</strong></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="cluster-events"><a class="anchor" href="#cluster-events"></a>8.1. Cluster Events</h3>
<div class="sect3">
<h4 id="listening-for-member-events"><a class="anchor" href="#listening-for-member-events"></a>8.1.1. Listening for Member Events</h4>
<div class="paragraph">
<p>The Membership Listener interface has methods that are invoked
for the following events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>memberAdded</code>: A new member is added to the cluster.</p>
</li>
<li>
<p><code>memberRemoved</code>: An existing member leaves the cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To write a Membership Listener class, you implement the MembershipListener
interface and its methods.</p>
</div>
<div class="paragraph">
<p>The following is an example Membership Listener class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ClusterMembershipListener implements MembershipListener {

    public void memberAdded(MembershipEvent membershipEvent) {
        System.err.println("Added: " + membershipEvent);
    }

    public void memberRemoved(MembershipEvent membershipEvent) {
        System.err.println("Removed: " + membershipEvent);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a respective event is fired, the membership listener outputs the
addresses of the members that joined and left, and also which attribute
changed on which member.</p>
</div>
<div class="sect4">
<h5 id="registering-membership-listeners"><a class="anchor" href="#registering-membership-listeners"></a>Registering Membership Listeners</h5>
<div class="paragraph">
<p>After you create your class, you can configure your cluster to include the
membership listener. Below is an example using the method <code>addMembershipListener</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
hazelcastInstance.getCluster().addMembershipListener( new ClusterMembershipListener() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
listeners in the configuration. You can register listeners using declarative,
programmatic, or Spring configuration, as shown below.</p>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.addListenerConfig(
new ListenerConfig( "com.yourpackage.ClusterMembershipListener" ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.ClusterMembershipListener
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  listeners:
    - com.yourpackage.ClusterMembershipListener</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:listeners&gt;
    &lt;hz:listener class-name="com.yourpackage.ClusterMembershipListener"/&gt;
    &lt;hz:listener implementation="MembershipListener"/&gt;
&lt;/hz:listeners&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="listening-for-distributed-object-events"><a class="anchor" href="#listening-for-distributed-object-events"></a>8.1.2. Listening for Distributed Object Events</h4>
<div class="paragraph">
<p>The Distributed Object Listener methods <code>distributedObjectCreated</code> and
<code>distributedObjectDestroyed</code> are invoked when a distributed object is
created and destroyed throughout the cluster. To write a Distributed Object
Listener class, you implement the DistributedObjectListener interface and its methods.</p>
</div>
<div class="paragraph">
<p>The following is an example Distributed Object Listener class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ExampleDistObjListener implements DistributedObjectListener {

    @Override
    public void distributedObjectCreated(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println("Created " + instance.getName() + ", service=" + instance.getServiceName());
    }

    @Override
    public void distributedObjectDestroyed(DistributedObjectEvent event) {
        System.out.println("Destroyed " + event.getObjectName() + ", service=" + event.getServiceName());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a respective event is fired, the distributed object listener
outputs the event type, the object name and a service name
(for example, for a Map object the service name is <code>"hz:impl:mapService"</code>).</p>
</div>
<div class="sect4">
<h5 id="registering-distributed-object-listeners"><a class="anchor" href="#registering-distributed-object-listeners"></a>Registering Distributed Object Listeners</h5>
<div class="paragraph">
<p>After you create your class, you can configure your cluster to
include distributed object listeners. Below is an example using
the method <code>addDistributedObjectListener</code>. You can also see this
portion in the above class creation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
ExampleDistObjListener example = new ExampleDistObjListener();

hazelcastInstance.addDistributedObjectListener( example );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
the listeners in the configuration. You can register listeners using
declarative, programmatic, or Spring configuration, as shown below.</p>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">config.addListenerConfig(
new ListenerConfig( "com.yourpackage.ExampleDistObjListener" ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.ExampleDistObjListener
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  listeners:
    - com.yourpackage.ExampleDistObjListener</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:listeners&gt;
    &lt;hz:listener class-name="com.yourpackage.ExampleDistObjListener"/&gt;
    &lt;hz:listener implementation="DistributedObjectListener"/&gt;
&lt;/hz:listeners&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="listening-for-migration-events"><a class="anchor" href="#listening-for-migration-events"></a>8.1.3. Listening for Migration Events</h4>
<div class="paragraph">
<p>The Migration Listener interface has methods that are invoked
for the following events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>migrationStarted</code>: The migration starts. A migration consists of a
group of replica migrations which are planned together. The <code>MigrationState</code>
parameter of the  <code>migrationStarted</code> method shows information about
the migration: start time of the process, number of the planned migrations, etc.</p>
</li>
<li>
<p><code>migrationFinished</code>: The migration finishes. <code>MigrationState</code> parameter
shows the result of the migration: number of the completed migrations,
number of the remaining migrations, total elapsed time, etc.</p>
</li>
<li>
<p><code>replicaMigrationCompleted</code>: A partition replica migration starts.
Method&#8217;s parameter, <code>ReplicaMigrationEvent</code>, shows information about
a replica migration: partition ID, replica index, source and destination
members of the migration and elapsed time for this replica migration.
Also it shows the progress of the overall migration: number of the completed
and remaining replica migrations and total elapsed time.</p>
</li>
<li>
<p><code>replicaMigrationFailed</code>: A partition replica migration fails.
The <code>MigrationEvent</code> parameter shows the information about this replica migration
and overall migration similar to the <code>migrationCompleted</code> method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To write a Migration Listener class, you implement the <code>MigrationListener</code>
interface and its methods.</p>
</div>
<div class="paragraph">
<p>The following is an example Migration Listener class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ClusterMigrationListener implements MigrationListener {

    @Override
    public void migrationStarted(MigrationState state) {
        System.out.println("Migration Started: " + state);
    }

    @Override
    public void migrationFinished(MigrationState state) {
        System.out.println("Migration Finished: " + state);
    }

    @Override
    public void replicaMigrationCompleted(ReplicaMigrationEvent event) {
        System.out.println("Replica Migration Completed: " + event);
    }

    @Override
    public void replicaMigrationFailed(ReplicaMigrationEvent event) {
        System.out.println("Replica Migration Failed: " + event);
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_registering_migration_listeners"><a class="anchor" href="#_registering_migration_listeners"></a>Registering Migration Listeners</h5>
<div class="paragraph">
<p>After you create your class, you can configure your cluster to include
migration listeners. Below is an example using the method <code>addMigrationListener</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

PartitionService partitionService = hazelcastInstance.getPartitionService();
partitionService.addMigrationListener( new ClusterMigrationListener() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
the listeners in the configuration. You can register listeners using
declarative, programmatic, or Spring configuration, as shown below.</p>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">config.addListenerConfig(
new ListenerConfig( "com.yourpackage.ClusterMigrationListener" ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.ClusterMigrationListener
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  listeners:
    - com.yourpackage.ClusterMigrationListener</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:listeners&gt;
    &lt;hz:listener class-name="com.yourpackage.ClusterMigrationListener"/&gt;
    &lt;hz:listener implementation="MigrationListener"/&gt;
&lt;/hz:listeners&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="listening-for-partition-lost-events"><a class="anchor" href="#listening-for-partition-lost-events"></a>8.1.4. Listening for Partition Lost Events</h4>
<div class="paragraph">
<p>Hazelcast provides fault-tolerance by keeping multiple copies of your data.
For each partition, one of your cluster members becomes the owner and
some of the other members become replica members, based on your configuration.
Nevertheless, data loss may occur if a few members crash simultaneously.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following example with three members: N1, N2, N3 for
a given partition-0. N1 is owner of partition-0. N2 and N3 are the first
and second replicas respectively. If N1 and N2 crash simultaneously,
partition-0 loses its data that is configured with less than two backups.
For instance, if we configure a map with one backup, that map loses its
data in partition-0 since both owner and first replica of partition-0 have
crashed. However, if we configure our map with two backups, it does not
lose any data since a copy of partition-0&#8217;s data for the given map
also resides in N3.</p>
</div>
<div class="paragraph">
<p>The Partition Lost Listener notifies for possible data loss occurrences
with the information of how many replicas are lost for a partition. It
listens to <code>PartitionLostEvent</code> instances. Partition lost events are
dispatched per partition.</p>
</div>
<div class="paragraph">
<p>Partition loss detection is done after a member crash is detected by the
other members and the crashed member is removed from the cluster.
Please note that false-positive <code>PartitionLostEvent</code> instances may be
fired on the network split errors.</p>
</div>
<div class="sect4">
<h5 id="_writing_a_partition_lost_listener_class"><a class="anchor" href="#_writing_a_partition_lost_listener_class"></a>Writing a Partition Lost Listener Class</h5>
<div class="paragraph">
<p>To write a Partition Lost Listener, you implement the PartitionLostListener
interface and its <code>partitionLost</code> method, which is invoked when a partition
loses its owner and all backups.</p>
</div>
<div class="paragraph">
<p>The following is an example Partition Lost Listener class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ConsoleLoggingPartitionLostListener implements PartitionLostListener {
    @Override
    public void partitionLost(PartitionLostEvent event) {
        System.out.println(event);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a <code>PartitionLostEvent</code> is fired, the partition lost listener given
above outputs the partition ID, the replica index that is lost and the
member that has detected the partition loss. The following is an example output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>com.hazelcast.partition.PartitionLostEvent{partitionId=242, lostBackupCount=0,
eventSource=Address[192.168.2.49]:5701}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_registering_partition_lost_listeners"><a class="anchor" href="#_registering_partition_lost_listeners"></a>Registering Partition Lost Listeners</h5>
<div class="paragraph">
<p>After you create your class, you can configure your cluster programmatically
or declaratively to include the partition lost listener. Below is an example
of its programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
hazelcastInstance.getPartitionService().addPartitionLostListener( new ConsoleLoggingPartitionLostListener() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.ConsoleLoggingPartitionLostListener
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  listeners:
    - com.yourpackage.ConsoleLoggingPartitionLostListener</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="listening-for-lifecycle-events"><a class="anchor" href="#listening-for-lifecycle-events"></a>8.1.5. Listening for Lifecycle Events</h4>
<div class="paragraph">
<p>The Lifecycle Listener notifies for the following events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>STARTING</code>: A member is starting.</p>
</li>
<li>
<p><code>STARTED</code>: A member started.</p>
</li>
<li>
<p><code>SHUTTING_DOWN</code>: A member is shutting down.</p>
</li>
<li>
<p><code>SHUTDOWN</code>: A member&#8217;s shutdown has completed.</p>
</li>
<li>
<p><code>MERGING</code>: A member is merging with the cluster.</p>
</li>
<li>
<p><code>MERGED</code>: A member&#8217;s merge operation has completed.</p>
</li>
<li>
<p><code>CLIENT_CONNECTED</code>: A Hazelcast Client connected to the cluster.</p>
</li>
<li>
<p><code>CLIENT_DISCONNECTED</code>: A Hazelcast Client disconnected from the cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example Lifecycle Listener class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class NodeLifecycleListener implements LifecycleListener {
     @Override
     public void stateChanged(LifecycleEvent event) {
         System.err.println(event);
     }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This listener is local to an individual member. It notifies the
application that uses Hazelcast about the events mentioned above
for a particular member.</p>
</div>
<div class="sect4">
<h5 id="_registering_lifecycle_listeners"><a class="anchor" href="#_registering_lifecycle_listeners"></a>Registering Lifecycle Listeners</h5>
<div class="paragraph">
<p>After you create your class, you can configure your cluster to
include lifecycle listeners. Below is an example using the method
<code>addLifecycleListener</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
hazelcastInstance.getLifecycleService().addLifecycleListener( new NodeLifecycleListener() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
the listeners in the configuration. You can register listeners using
declarative, programmatic, or Spring configuration, as shown below.</p>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">config.addListenerConfig(
    new ListenerConfig( "com.yourpackage.NodeLifecycleListener" ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.NodeLifecycleListener
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  listeners:
    - com.yourpackage.NodeLifecycleListener</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:listeners&gt;
    &lt;hz:listener class-name="com.yourpackage.NodeLifecycleListener"/&gt;
    &lt;hz:listener implementation="LifecycleListener"/&gt;
&lt;/hz:listeners&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="listening-for-clients"><a class="anchor" href="#listening-for-clients"></a>8.1.6. Listening for Clients</h4>
<div class="paragraph">
<p>The client listener is used by the Hazelcast cluster members.
It notifies the cluster member when a client is connected to or
disconnected from it, i.e., the clients fire an event from only one member
they are connected to. Other cluster members do not fire a "client is connected"
or "client is disconnected" event.</p>
</div>
<div class="paragraph">
<p>To write a client listener class, you implement the <code>ClientListener</code>
interface and its methods <code>clientConnected</code> and <code>clientDisconnected</code>,
which are invoked when a client is connected to or disconnected from the
cluster. You can add your client listener as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">hazelcastInstance.getClientService().addClientListener(new ExampleClientListener());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.ExampleClientListener
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  listeners:
    - com.yourpackage.ExampleClientListener</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:listeners&gt;
    &lt;hz:listener class-name="com.yourpackage.ExampleClientListener"/&gt;
    &lt;hz:listener implementation="com.yourpackage.ExampleClientListener"/&gt;
&lt;/hz:listeners&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also add event listeners to a Hazelcast client. See the
<a href="#configuring-client-listeners">Client Listenerconfig section</a> for the
related information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="distributed-object-events"><a class="anchor" href="#distributed-object-events"></a>8.2. Distributed Object Events</h3>
<div class="sect3">
<h4 id="_listening_for_map_events"><a class="anchor" href="#_listening_for_map_events"></a>8.2.1. Listening for Map Events</h4>
<div class="paragraph">
<p>You can listen to map-wide or entry-based events using the listeners
provided by the Hazelcast&#8217;s eventing framework. To listen to these events,
implement a <code>MapListener</code> sub-interface.</p>
</div>
<div class="paragraph">
<p>A map-wide event is fired as a result of a map-wide operation. For
example, <code>IMap.clear()</code> or <code>IMap.evictAll()</code>.
An entry-based event is fired after the operations that affect a
specific entry. For example, <code>IMap.remove()</code> or <code>IMap.evict()</code>.</p>
</div>
<div class="sect4">
<h5 id="_catching_a_map_event"><a class="anchor" href="#_catching_a_map_event"></a>Catching a Map Event</h5>
<div class="paragraph">
<p>To catch an event, you should explicitly
implement a corresponding sub-interface of a <code>MapListener</code>,
such as <code>EntryAddedListener</code> or <code>MapClearedListener</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>EntryListener</code> interface still can be implemented (we kept
it for backward compatibility reasons). However, if you need to listen to a
different event, one that is not available in the <code>EntryListener</code> interface, you should also
implement a relevant <code>MapListener</code> sub-interface.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at the following class example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Listen {

    public static void main( String[] args ) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hz.getMap( "somemap" );
        map.addEntryListener( new MyEntryListener(), true );
        System.out.println( "EntryListener registered" );
    }

    static class MyEntryListener implements
            EntryAddedListener&lt;String, String&gt;,
            EntryRemovedListener&lt;String, String&gt;,
            EntryUpdatedListener&lt;String, String&gt;,
            EntryEvictedListener&lt;String, String&gt;,
            EntryLoadedListener&lt;String,String&gt;,
            MapEvictedListener,
            MapClearedListener   {
        @Override
        public void entryAdded( EntryEvent&lt;String, String&gt; event ) {
            System.out.println( "Entry Added:" + event );
        }

        @Override
        public void entryRemoved( EntryEvent&lt;String, String&gt; event ) {
            System.out.println( "Entry Removed:" + event );
        }

        @Override
        public void entryUpdated( EntryEvent&lt;String, String&gt; event ) {
            System.out.println( "Entry Updated:" + event );
        }

        @Override
        public void entryEvicted( EntryEvent&lt;String, String&gt; event ) {
            System.out.println( "Entry Evicted:" + event );
        }

        @Override
        public void entryLoaded( EntryEvent&lt;String, String&gt; event ) {
            System.out.println( "Entry Loaded:" + event );
        }

        @Override
        public void mapEvicted( MapEvent event ) {
            System.out.println( "Map Evicted:" + event );
        }

        @Override
        public void mapCleared( MapEvent event ) {
            System.out.println( "Map Cleared:" + event );
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s perform some modifications on the map entries using the following example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ModifyMap {

    public static void main( String[] args ) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hz.getMap( "somemap");
        String key = "" + System.nanoTime();
        String value = "1";
        map.put( key, value );
        map.put( key, "2" );
        map.delete( key );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you execute the <code>Listen</code> class and then the <code>Modify</code> class, you get the following output
produced by the <code>Listen</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Entry Added:EntryEvent{entryEventType=ADDED, member=Member [192.168.1.100]]:5702
 - ffedb655-bbad-43ea-aee8-d429d37ce528, name='somemap', key=11455268066242,
 oldValue=null, value=1, mergingValue=null}

Entry Updated:EntryEvent{entryEventType=UPDATED, member=Member [192.168.1.100]]:5702
 - ffedb655-bbad-43ea-aee8-d429d37ce528, name='somemap', key=11455268066242,
 oldValue=1, value=2, mergingValue=null}

Entry Removed:EntryEvent{entryEventType=REMOVED, member=Member [192.168.1.100]]:5702
 - ffedb655-bbad-43ea-aee8-d429d37ce528, name='somemap', key=11455268066242,
 oldValue=null, value=null, mergingValue=null}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please note that the method <code>IMap.clear()</code> does not fire an
"EntryRemoved" event, but fires a "MapCleared" event.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Listeners have to offload all blocking operations to another thread (pool).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_listening_for_lost_map_partitions"><a class="anchor" href="#_listening_for_lost_map_partitions"></a>8.2.2. Listening for Lost Map Partitions</h4>
<div class="paragraph">
<p>You can listen to <code>MapPartitionLostEvent</code> instances by registering an implementation
of <code>MapPartitionLostListener</code>, which is also a sub-interface of <code>MapListener</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following example code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ListenMapPartitionLostEvents {

    public static void main(String[] args) {
        Config config = new Config();
        // keeps its data if a single node crashes
        config.getMapConfig("map").setBackupCount(1);

        HazelcastInstance instance = HazelcastInstanceFactory.newHazelcastInstance(config);

        IMap&lt;Object, Object&gt; map = instance.getMap("map");
        map.put(0, 0);

        map.addPartitionLostListener(new MapPartitionLostListener() {
            @Override
            public void partitionLost(MapPartitionLostEvent event) {
                System.out.println(event);
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Within this example code, a <code>MapPartitionLostListener</code> implementation is registered to a map
that is configured with one backup. For this particular map and any of the partitions in the
system, if the partition owner member and its first backup member crash simultaneously, the
given <code>MapPartitionLostListener</code> receives a
corresponding <code>MapPartitionLostEvent</code>. If only a single member crashes in the cluster,
there is no <code>MapPartitionLostEvent</code> fired for this map since backups for the partitions
owned by the crashed member are kept on other members.</p>
</div>
<div class="paragraph">
<p>See the <a href="#listening-for-partition-lost-events">Listening for Partition Lost Events section</a> for more
information about partition lost detection and partition lost events.</p>
</div>
<div class="sect4">
<h5 id="_registering_map_listeners"><a class="anchor" href="#_registering_map_listeners"></a>Registering Map Listeners</h5>
<div class="paragraph">
<p>After you create your listener class, you can configure your cluster
to include map listeners using the method <code>addEntryListener</code> (as you
can see in the example <code>Listen</code> class above). Below is the related portion
from this code, showing how to register a map listener.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hz = Hazelcast.newHazelcastInstance();
IMap&lt;String, String&gt; map = hz.getMap( "somemap" );
map.addEntryListener( new MyEntryListener(), true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
listeners in configuration. You can register listeners using declarative,
programmatic, or Spring configuration, as shown below.</p>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mapConfig.addEntryListenerConfig(
new EntryListenerConfig( "com.yourpackage.MyEntryListener",
                                 false, false ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="somemap"&gt;
        &lt;entry-listeners&gt;
            &lt;entry-listener include-value="false" local="false"&gt;
                com.yourpackage.MyEntryListener
            &lt;/entry-listener&gt;
        &lt;/entry-listeners&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  somemap:
    map:
      entry-listeners:
        - class-name: com.your-package.MyEntryListener
          include-value: false
          local: false</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:map name="somemap"&gt;
    &lt;hz:entry-listeners&gt;
        &lt;hz:entry-listener include-value="true"
            class-name="com.hazelcast.spring.DummyEntryListener"/&gt;
        &lt;hz:entry-listener implementation="dummyEntryListener" local="true"/&gt;
    &lt;/hz:entry-listeners&gt;
&lt;/hz:map&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_map_listener_attributes"><a class="anchor" href="#_map_listener_attributes"></a>Map Listener Attributes</h5>
<div class="paragraph">
<p>As you see, there are attributes of the map listeners in the above
examples: <code>include-value</code> and <code>local</code>. The attribute <code>include-value</code>
is a boolean attribute that is optional, and if you set it to <code>true</code>,
the map event contains the map value. Its default value is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The attribute <code>local</code> is also a boolean attribute that is optional, and
if you set it to <code>true</code>, you can listen to the map on the local member.
Its default value is <code>false</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_listening_for_multimap_events"><a class="anchor" href="#_listening_for_multimap_events"></a>8.2.3. Listening for MultiMap Events</h4>
<div class="paragraph">
<p>You can listen to entry-based events in the MultiMap using <code>EntryListener</code>.
The following is an example entry listener implementation for MultiMap.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ExampleEntryListener implements EntryListener&lt;String, String&gt; {
    @Override
    public void entryAdded(EntryEvent&lt;String, String&gt; event) {
        System.out.println("Entry Added: " + event);
    }
    @Override
    public void entryRemoved( EntryEvent&lt;String, String&gt; event ) {
        System.out.println( "Entry Removed: " + event );
    }
    @Override
    public void entryUpdated(EntryEvent&lt;String, String&gt; event) {
        System.out.println( "Entry Updated: " + event );
    }
    @Override
    public void entryEvicted(EntryEvent&lt;String, String&gt; event) {
        System.out.println( "Entry evicted: " + event );
    }
    @Override
    public void entryExpired(EntryEvent&lt;String, String&gt; event) {
        System.out.println( "Entry expired: " + event );
    }
    @Override
    public void mapCleared(MapEvent event) {
        System.out.println( "Map Cleared: " + event );
    }
    @Override
    public void mapEvicted(MapEvent event) {
        System.out.println( "Map Evicted: " + event );
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_registering_multimap_listeners"><a class="anchor" href="#_registering_multimap_listeners"></a>Registering MultiMap Listeners</h5>
<div class="paragraph">
<p>After you create your listener class, you can configure your cluster to
include MultiMap listeners using the method <code>addEntryListener</code>. Below
is the related portion from a code, showing how to register a map listener.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hz = Hazelcast.newHazelcastInstance();
MultiMap&lt;String, String&gt; map = hz.getMultiMap( "somemap" );
map.addEntryListener( new ExampleEntryListener(), true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
listeners in the configuration. You can register listeners using declarative,
programmatic, or Spring configuration, as shown below.</p>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">multiMapConfig.addEntryListenerConfig(
  new EntryListenerConfig( "com.yourpackage.ExampleEntryListener",
    false, false ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;multimap name="somemap"&gt;
        &lt;value-collection-type&gt;SET&lt;/value-collection-type&gt;
        &lt;entry-listeners&gt;
            &lt;entry-listener include-value="false" local="false"&gt;
                com.yourpackage.ExampleEntryListener
            &lt;/entry-listener&gt;
        &lt;/entry-listeners&gt;
    &lt;/multimap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  multimap:
    somemap:
      value-collection: SET
      entry-listeners:
        - class-name: com.your-package.MyEntryListener
          include-value: false
          local: false</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:multimap name="somemap" value-collection-type="SET"&gt;
    &lt;hz:entry-listeners&gt;
        &lt;hz:entry-listener include-value="false"
            class-name="com.yourpackage.ExampleEntryListener"/&gt;
        &lt;hz:entry-listener implementation="EntryListener" local="false"/&gt;
    &lt;/hz:entry-listeners&gt;
&lt;/hz:multimap&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_multimap_listener_attributes"><a class="anchor" href="#_multimap_listener_attributes"></a>MultiMap Listener Attributes</h5>
<div class="paragraph">
<p>As you see, there are attributes of the MultiMap listeners in the above
examples: <code>include-value</code> and <code>local</code>. The attribute <code>include-value</code> is
a boolean attribute that is optional, and if you set it to <code>true</code>, the
MultiMap event contains the map value. Its default value is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The attribute <code>local</code> is also a boolean attribute that is optional, and
if you set it to <code>true</code>, you can listen to the MultiMap on the local member.
Its default value is <code>false</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_listening_for_item_events"><a class="anchor" href="#_listening_for_item_events"></a>8.2.4. Listening for Item Events</h4>
<div class="paragraph">
<p>The Item Listener is used by the Hazelcast <code>IQueue</code>, <code>ISet</code> and <code>IList</code> interfaces.</p>
</div>
<div class="paragraph">
<p>To write an Item Listener class, you implement the ItemListener
interface and its methods <code>itemAdded</code> and <code>itemRemoved</code>. These methods
are invoked when an item is added or removed.</p>
</div>
<div class="paragraph">
<p>The following is an example Item Listener class for an <code>ISet</code> structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ExampleItemListener implements ItemListener&lt;Price&gt; {

    @Override
    public void itemAdded(ItemEvent&lt;Price&gt; event) {
        System.out.println( "Item added:  " + event );
    }

    @Override
    public void itemRemoved(ItemEvent&lt;Price&gt; event) {
        System.out.println( "Item removed: " + event );
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can use <code>ICollection</code> when creating any of the collection
(queue, set and list) data structures, as shown above. You can also
use <code>IQueue</code>, <code>ISet</code> or <code>IList</code> instead of <code>ICollection</code>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_registering_item_listeners"><a class="anchor" href="#_registering_item_listeners"></a>Registering Item Listeners</h5>
<div class="paragraph">
<p>After you create your class, you can configure your cluster to include
item listeners. Below is an example using the method <code>addItemListener</code>
for <code>ISet</code> (it applies also to <code>IQueue</code> and <code>IList</code>). You can also see
this portion in the above class creation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

ICollection&lt;Price&gt; set = hazelcastInstance.getSet( "default" );
// or ISet&lt;Prices&gt; set = hazelcastInstance.getSet( "default" );
set.addItemListener( new ExampleItemListener(), true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above approach, there is the possibility of missing events
between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register
listeners in the configuration. You can register listeners using
declarative, programmatic, or Spring configuration, as shown below.</p>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">setConfig.addItemListenerConfig(
new ItemListenerConfig( "com.yourpackage.ExampleItemListener", true ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;set&gt;
        &lt;item-listeners&gt;
            &lt;item-listener include-value="true"&gt;
                com.yourpackage.ExampleItemListener
            &lt;/item-listener&gt;
        &lt;/item-listeners&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  set:
    default:
      item-listeners:
        - class-name: com.yourpackage.ExampleItemListener
          include-value: true</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:set name="default" &gt;
    &lt;hz:item-listeners&gt;
        &lt;hz:item-listener include-value="true"
            class-name="com.yourpackage.ExampleItemListener"/&gt;
    &lt;/hz:item-listeners&gt;
&lt;/hz:set&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_item_listener_attributes"><a class="anchor" href="#_item_listener_attributes"></a>Item Listener Attributes</h5>
<div class="paragraph">
<p>As you see, there is an attribute in the above examples: <code>include-value</code>.
It is a boolean attribute that is optional, and if you set it to <code>true</code>,
the item event contains the item value. Its default value is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>There is also another attribute called <code>local</code>, which is not shown in the
above examples. It is also a boolean attribute that is optional, and
if you set it to <code>true</code>, you can listen to the items on the local member.
Its default value is <code>false</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_listening_for_topic_messages"><a class="anchor" href="#_listening_for_topic_messages"></a>8.2.5. Listening for Topic Messages</h4>
<div class="paragraph">
<p>The Message Listener is used by the <code>ITopic</code> interface. It notifies
when a message is received for the registered topic.</p>
</div>
<div class="paragraph">
<p>To write a Message Listener class, you implement the MessageListener
interface and its method <code>onMessage</code>, which is invoked
when a message is received for the registered topic.</p>
</div>
<div class="paragraph">
<p>The following is an example Message Listener class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ExampleMessageListener implements MessageListener&lt;MyEvent&gt; {

    public void onMessage( Message&lt;MyEvent&gt; message ) {
        MyEvent myEvent = message.getMessageObject();
        System.out.println( "Message received = " + myEvent.toString() );
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_registering_message_listeners"><a class="anchor" href="#_registering_message_listeners"></a>Registering Message Listeners</h5>
<div class="paragraph">
<p>After you create your class, you can configure your cluster to include
message listeners. Below is an example using the method <code>addMessageListener</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

ITopic topic = hazelcastInstance.getTopic( "default" );
topic.addMessageListener( new ExampleMessageListener() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above approach, there is the possibility of missing messaging
events between the creation of the instance and registering the listener.
To overcome this race condition, Hazelcast allows you to register this
listener in the configuration. You can register it using declarative,
programmatic, or Spring configuration, as shown below.</p>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">topicConfig.addMessageListenerConfig(
  new ListenerConfig( "com.yourpackage.ExampleMessageListener" ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of the equivalent declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;topic name="default"&gt;
        &lt;message-listeners&gt;
            &lt;message-listener&gt;
                com.yourpackage.ExampleMessageListener
            &lt;/message-listener&gt;
        &lt;/message-listeners&gt;
    &lt;/topic&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  topic:
    default:
      message-listeners:
        - com.yourpackage.ExampleMessageListener</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:topic name="default"&gt;
    &lt;hz:message-listeners&gt;
        &lt;hz:message-listener
            class-name="com.yourpackage.ExampleMessageListener"/&gt;
    &lt;/hz:message-listeners&gt;
&lt;/hz:topic&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_event_listeners_for_hazelcast_clients"><a class="anchor" href="#_event_listeners_for_hazelcast_clients"></a>8.3. Event Listeners for Hazelcast Clients</h3>
<div class="paragraph">
<p>You can add event listeners to Hazelcast clients.
You can configure the following listeners to listen to the events
on the client side:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#listening-for-lifecycle-events">Lifecycle Listener</a>: Notifies
when the client is starting, started, shutting down and shutdown.</p>
</li>
<li>
<p><a href="#listening-for-member-events">Membership Listener</a>: Notifies when
a member joins to/leaves the cluster to which the client is connected,
or when an attribute is changed in a member.</p>
</li>
<li>
<p><a href="#listening-for-distributed-object-events">Distributed Object Listener</a>:
Notifies when a distributed object is created or destroyed throughout
the cluster to which the client is connected. Also notifies for the events
happening in the distributed data structures, e.g., entry, item and message
listeners.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For Hazelcast Java client example code/configuration snippets, see the
sections of the current chapter, i.e., <a href="#distributed-events">Distributed Events</a>.
See also the <a href="#configuring-client-listeners">Configuring Client Listeners section</a>
for more information.</p>
</div>
<div class="paragraph">
<p>Follow the below links to learn how to configure the event listeners on other
Hazelcast clients:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-csharp-client#75-distributed-events" target="_blank" rel="noopener">.NET client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-cpp-client#75-distributed-events" target="_blank" rel="noopener">C++ client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-nodejs-client/blob/master/DOCUMENTATION.md#75-distributed-events" target="_blank" rel="noopener">Node.js client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-go-client#75-distributed-events" target="_blank" rel="noopener">Go client</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-python-client#75-distributed-events" target="_blank" rel="noopener">Python client</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that you can simply add a listener to your client that you already configured
and registered on the member side. You do not need to configure the listener on the client.
Assuming that you implemented a listener for a map, .e.g., <code>MyListener</code> on the member side,
see the following example for a Java client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;Object, Object&gt; map = client.getMap("mymap");
map.addEntryListener(new MyListener(), true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see, no configuration is needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_global_event_configuration"><a class="anchor" href="#_global_event_configuration"></a>8.4. Global Event Configuration</h3>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.event.queue.capacity</code>: default value is 1000000</p>
</li>
<li>
<p><code>hazelcast.event.queue.timeout.millis</code>: default value is 250</p>
</li>
<li>
<p><code>hazelcast.event.thread.count</code>: default value is 5</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A striped executor in each cluster member controls and dispatches
the received events. This striped executor also guarantees the event
order. For all events in Hazelcast, the order in which events are
generated and the order in which they are published are guaranteed
for given keys. For map and multimap, the order is preserved for the
operations on the same key of the entry. For list, set, topic and queue,
the order is preserved for events on that instance of the distributed
data structure.</p>
</div>
<div class="paragraph">
<p>To achieve the order guarantee, you make only one thread responsible
for a particular set of events (entry events of a key in a map, item
events of a collection, etc.) in <code>StripedExecutor</code> (within <code>com.hazelcast.util.executor</code>).</p>
</div>
<div class="paragraph">
<p>If the event queue reaches its capacity (<code>hazelcast.event.queue.capacity</code>)
and the last item cannot be put into the event queue for the period
specified in <code>hazelcast.event.queue.timeout.millis</code>, these events are
dropped with a warning message, such as "EventQueue overloaded".</p>
</div>
<div class="paragraph">
<p>If event listeners perform a computation that takes a long time, the
event queue can reach its maximum capacity and lose events. For map
and multimap, you can configure <code>hazelcast.event.thread.count</code> to a
higher value so that fewer collisions occur for keys, and therefore
worker threads do not block each other in <code>StripedExecutor</code>. For list, set,
topic and queue, you should offload heavy work to another thread.
To preserve order guarantee, you should implement similar logic with
<code>StripedExecutor</code> in the offloaded thread pool.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hazelcast-jet"><a class="anchor" href="#hazelcast-jet"></a>9. Hazelcast Jet</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This chapter only briefly describes Hazelcast Jet.
For detailed information and Jet documentation,
please see the Jet homepage at <a href="https://jet-start.sh" target="_blank" rel="noopener">jet-start.sh</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="jet-overview"><a class="anchor" href="#jet-overview"></a>9.1. Overview</h3>
<div class="paragraph">
<p>Hazelcast Jet is a distributed batch and stream processing framework
based on Hazelcast IMDG.  It allows you to write, currently, modern Java code
that focuses purely on data transformation while it does all the heavy
lifting of getting the data flowing and computation running across a
cluster of members.  It supports working with both bounded (batch)
and unbounded (streaming) data.</p>
</div>
<div class="paragraph">
<p>You can follow the <a href="https://jet-start.sh/docs" target="_blank" rel="noopener">Getting Started Guide</a>
in the Hazelcast Jet documentation to see a simple example.</p>
</div>
<div class="paragraph">
<p>Jet supports a rich set of data transformations such as windowed aggregations.
For example, if your data is GPS location reports from millions of users,
Jet can compute every user&#8217;s velocity vector by using a sliding window and
just a few lines of code. Jet also supports <em>at-least-once</em> and <em>exactly-once</em>
processing.</p>
</div>
<div class="paragraph">
<p>Jet can be used to import/export data from/to
Hazelcast IMDG using a very wide variety of data sources including Hadoop,
S3, Apache Kafka, Elasticsearch, JDBC and JMS. For example, you can read data
from Kafka and write to <code>IMap</code> with just a few lines of code. You can
<a href="https://jet-start.sh/docs/how-tos/stream-imap" target="_blank" rel="noopener"><em>stream</em> changes</a> from an <code>IMap</code>
and write it to an external system or you can <a href="https://jet-start.sh/docs/tutorials/map-join" target="_blank" rel="noopener">join to a stream</a>
reference data that is already stored in <code>IMap</code>.</p>
</div>
<div class="paragraph">
<p>For a full list of external systems that Jet integrates with,
see the <a href="https://jet-start.sh/docs/api/sources-sinks" target="_blank" rel="noopener">Sources and Sinks section</a>
of Jet&#8217;s documentation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distributed-computing"><a class="anchor" href="#distributed-computing"></a>10. Distributed Computing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter explains Hazelcast&#8217;s executor service, durable/scheduled executor services and entry processor implementations.</p>
</div>
<div class="sect2">
<h3 id="executor-service"><a class="anchor" href="#executor-service"></a>10.1. Executor Service</h3>
<div class="paragraph">
<p>One of the coolest features of Java is the Executor framework, which allows you to asynchronously execute your tasks (logical units of work), such as database queries, complex calculations and image rendering.</p>
</div>
<div class="paragraph">
<p>The default implementation of this framework (<code>ThreadPoolExecutor</code>) is designed to run within a single JVM (cluster member). In distributed systems, this implementation is not desired since you may want a task submitted in one JVM and processed in another one. Hazelcast offers <code>IExecutorService</code> for you to use in distributed environments. It implements <code>java.util.concurrent.ExecutorService</code> to serve the applications requiring computational and data processing power.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that you may want to use <a href="https://jet.hazelcast.org/" target="_blank" rel="noopener">Hazelcast Jet</a> if you want to process batch or real-time streaming data. See the <a href="https://jet.hazelcast.org/use-cases/fast-batch-processing/" target="_blank" rel="noopener">Fast Batch Processing</a> and <a href="https://jet.hazelcast.org/use-cases/real-time-stream-processing/" target="_blank" rel="noopener">Real-Time Stream Processing</a> use cases for Hazelcast Jet.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With <code>IExecutorService</code>, you can execute tasks asynchronously and perform other useful tasks. If your task execution takes longer than expected, you can cancel the task execution. Tasks should be <code>Serializable</code> since they are distributed.</p>
</div>
<div class="paragraph">
<p>In the Java Executor framework, you implement tasks two ways: Callable or Runnable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Callable: If you need to return a value and submit it to Executor, implement the task as <code>java.util.concurrent.Callable</code>.</p>
</li>
<li>
<p>Runnable: If you do not need to return a value, implement the task as <code>java.util.concurrent.Runnable</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that, the distributed executor service (<code>IExecutorService</code>) is intended to run processing where the data is hosted: on the server members. In general, you cannot run a Java Runnable or Callable on the clients as the clients may not be Java. Also, the clients do not host any data, so they would have to fetch what data they need from the servers potentially. If you want something to run on all or some clients connected to your cluster, you could implement this using the publish/subscribe mechanism; a payload could be sent to an <a href="#topic"><code>ITopic</code></a> with the necessary execution parameters, and clients listening can act on the message.</p>
</div>
<div class="sect3">
<h4 id="_implementing_a_callable_task"><a class="anchor" href="#_implementing_a_callable_task"></a>10.1.1. Implementing a Callable Task</h4>
<div class="paragraph">
<p>In Hazelcast, when you implement a task as <code>java.util.concurrent.Callable</code> (a task that returns a value), you implement Callable and Serializable.</p>
</div>
<div class="paragraph">
<p>Below is an example of a Callable task. SumTask prints out map keys and returns the summed map values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SumTask
        implements Callable&lt;Integer&gt;, Serializable, HazelcastInstanceAware {

    private transient HazelcastInstance hazelcastInstance;

    public void setHazelcastInstance( HazelcastInstance hazelcastInstance ) {
        this.hazelcastInstance = hazelcastInstance;
    }

    public Integer call() throws Exception {
        IMap&lt;String, Integer&gt; map = hazelcastInstance.getMap( "map" );
        int result = 0;
        for ( String key : map.localKeySet() ) {
            System.out.println( "Calculating for key: " + key );
            result += map.get( key );
        }
        System.out.println( "Local Result: " + result );
        return result;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another example is the Echo callable below. In its call() method, it returns the local member and the input passed in. Remember that <code>instance.getCluster().getLocalMember()</code> returns the local member and <code>toString()</code> returns the member&#8217;s address (IP + port) in String form, just to see which member actually executed the code for our example. Of course, the <code>call()</code> method can do and return anything you like.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Echo implements Callable&lt;String&gt;, Serializable, HazelcastInstanceAware {
    String input = null;

    private transient HazelcastInstance hazelcastInstance;

    public Echo() {
    }

    public void setHazelcastInstance( HazelcastInstance hazelcastInstance ) {
        this.hazelcastInstance = hazelcastInstance;
    }

    public Echo(String input) {
        this.input = input;
    }

    public String call() {
        return hazelcastInstance.getCluster().getLocalMember().toString() + ":" + input;
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_executing_a_callable_task"><a class="anchor" href="#_executing_a_callable_task"></a>Executing a Callable Task</h5>
<div class="paragraph">
<p>To execute a callable task:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>retrieve the Executor from <code>HazelcastInstance</code></p>
</li>
<li>
<p>submit a task which returns a <code>Future</code></p>
</li>
<li>
<p>after executing the task, you do not have to wait for the execution to complete, you can process other things</p>
</li>
<li>
<p>when ready, use the <code>Future</code> object to retrieve the result as shown in the code example below.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below, the Echo task is executed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MasterMember {

    public static void main( String[] args ) throws Exception {
        HazelcastInstance instance = Hazelcast.newHazelcastInstance();
        IExecutorService executorService = instance.getExecutorService( "executorService" );
        Future&lt;String&gt; future = executorService.submit( new Echo( "myinput") );
        //while it is executing, do some useful stuff
        //when ready, get the result of your execution
        String result = future.get();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note that the <code>Echo</code> callable in the above example also implements a Serializable interface, since it may be sent to another member to be processed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When a task is deserialized, HazelcastInstance needs to be accessed. To do this, the task should implement <code>HazelcastInstanceAware</code> interface. See the <a href="#implementing-hazelcastinstanceaware">HazelcastInstanceAware Interface section</a> for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_a_runnable_task"><a class="anchor" href="#_implementing_a_runnable_task"></a>10.1.2. Implementing a Runnable Task</h4>
<div class="paragraph">
<p>In Hazelcast, when you implement a task as <code>java.util.concurrent.runnable</code> (a task that does not return a value), you implement Runnable and Serializable.</p>
</div>
<div class="paragraph">
<p>Below is Runnable example code. It is a task that waits for some time and echoes a message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class EchoTask implements Runnable, Serializable {

    private final String msg;

    public EchoTask( String msg ) {
        this.msg = msg;
    }

    @Override
    public void run() {
        try {
            Thread.sleep( 5000 );
        } catch ( InterruptedException e ) {
        }
        System.out.println( "echo:" + msg );
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_executing_a_runnable_task"><a class="anchor" href="#_executing_a_runnable_task"></a>Executing a Runnable Task</h5>
<div class="paragraph">
<p>To execute the runnable task:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>retrieve the Executor from <code>HazelcastInstance</code></p>
</li>
<li>
<p>submit the tasks to the Executor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now let&#8217;s write a class that submits and executes these echo messages. Executor is retrieved from <code>HazelcastInstance</code> and 1000 echo tasks are submitted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class RunnableMasterMember {

    public static void main( String[] args ) throws Exception {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IExecutorService executor = hazelcastInstance.getExecutorService( "exec" );
        for ( int k = 1; k &lt;= 1000; k++ ) {
            Thread.sleep( 1000 );
            System.out.println( "Producing echo task: " + k );
            executor.execute( new EchoTask( String.valueOf( k ) ) );
        }
        System.out.println( "EchoTaskMain finished!" );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scaling-the-executor-service"><a class="anchor" href="#scaling-the-executor-service"></a>10.1.3. Scaling The Executor Service</h4>
<div class="paragraph">
<p>You can scale the Executor service both vertically (scale up) and horizontally (scale out).</p>
</div>
<div class="paragraph">
<p>To scale up, you should improve the processing capacity of the cluster member (JVM). You can do this by increasing the <code>pool-size</code> property mentioned in <a href="#configuring-executor-service">Configuring Executor Service</a> (i.e., increasing the thread count). However, please be aware of your member&#8217;s capacity. If you think it cannot handle such an additional load caused by increasing the thread count, you may want to consider improving the member&#8217;s resources (CPU, memory, etc.). As an example, set the <code>pool-size</code> to 5 and run the above <code>MasterMember</code>. You will see that <code>EchoTask</code> is run as soon as it is produced.</p>
</div>
<div class="paragraph">
<p>To scale out, add more members instead of increasing only one member&#8217;s capacity. In reality, you may want to expand your cluster by adding more physical or virtual machines. For example, in the EchoTask example in the <a href="#implementing-a-runnable-task">Runnable section</a>, you can create another Hazelcast instance. That instance automatically gets involved in the executions started in <code>MasterMember</code> and start processing.</p>
</div>
</div>
<div class="sect3">
<h4 id="executing-code-in-the-cluster"><a class="anchor" href="#executing-code-in-the-cluster"></a>10.1.4. Executing Code in the Cluster</h4>
<div class="paragraph">
<p>The distributed executor service is a distributed implementation of <code>java.util.concurrent.ExecutorService</code>. It allows you to execute your code in the cluster. In this section, the code examples are based on the <a href="#implementing-a-callable-task">Echo class above</a> (please note that the Echo class is <code>Serializable</code>). The code examples show how Hazelcast can execute your code (<code>Runnable, Callable</code>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>echoOnTheMember</code>: On a specific cluster member you choose with the <code>IExecutorService</code> <code>submitToMember</code> method.</p>
</li>
<li>
<p><code>echoOnTheMemberOwningTheKey</code>: On the member owning the key you choose with the <code>IExecutorService</code> <code>submitToKeyOwner</code> method.</p>
</li>
<li>
<p><code>echoOnSomewhere</code>: On the member Hazelcast picks with the <code>IExecutorService</code> <code>submit</code> method.</p>
</li>
<li>
<p><code>echoOnMembers</code>: On all or a subset of the cluster members with the <code>IExecutorService</code> <code>submitToMembers</code> method.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void echoOnTheMember( String input, Member member ) throws Exception {
    Callable&lt;String&gt; task = new Echo( input );
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    IExecutorService executorService =
      hazelcastInstance.getExecutorService( "default" );

    Future&lt;String&gt; future = executorService.submitToMember( task, member );
    String echoResult = future.get();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void echoOnTheMemberOwningTheKey( String input, Object key ) throws Exception {
    Callable&lt;String&gt; task = new Echo( input );
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    IExecutorService executorService =
      hazelcastInstance.getExecutorService( "default" );

    Future&lt;String&gt; future = executorService.submitToKeyOwner( task, key );
    String echoResult = future.get();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void echoOnSomewhere( String input ) throws Exception {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    IExecutorService executorService =
      hazelcastInstance.getExecutorService( "default" );

    Future&lt;String&gt; future = executorService.submit( new Echo( input ) );
    String echoResult = future.get();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void echoOnMembers( String input, Set&lt;Member&gt; members ) throws Exception {
    HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
    IExecutorService executorService =
      hazelcastInstance.getExecutorService( "default" );

    Map&lt;Member, Future&lt;String&gt;&gt; futures = executorService
      .submitToMembers( new Echo( input ), members );

    for ( Future&lt;String&gt; future : futures.values() ) {
        String echoResult = future.get();
        // ...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can obtain the set of cluster members via <code>HazelcastInstance.getCluster().getMembers()</code> call.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="canceling-an-executing-task"><a class="anchor" href="#canceling-an-executing-task"></a>10.1.5. Canceling an Executing Task</h4>
<div class="paragraph">
<p>A task in the code that you execute in a cluster might take longer than expected. If you cannot stop/cancel that task, it keeps eating your resources.</p>
</div>
<div class="paragraph">
<p>To cancel a task, you can use the standard Java executor framework&#8217;s <code>cancel()</code> API. This framework encourages us to code and design for cancellations, a highly ignored part of software development.</p>
</div>
<div class="sect4">
<h5 id="_example_task_to_cancel"><a class="anchor" href="#_example_task_to_cancel"></a>Example Task to Cancel</h5>
<div class="paragraph">
<p>The Fibonacci callable class below calculates the Fibonacci number for a given number. In the <code>calculate</code> method, we check if the current thread is interrupted so that the code can respond to cancellations once the execution is started.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    int input = 0;

    public FibonacciCallable( int input ) {
        this.input = input;
    }

    public Long call() {
        return calculate( input );
    }

    private long calculate( int n ) {
        if ( Thread.currentThread().isInterrupted() ) {
            return 0;
        }
        if ( n &lt;= 1 ) {
            return n;
        } else {
            return calculate( n - 1 ) + calculate( n - 2 );
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_example_method_to_execute_and_cancel_the_task"><a class="anchor" href="#_example_method_to_execute_and_cancel_the_task"></a>Example Method to Execute and Cancel the Task</h5>
<div class="paragraph">
<p>The <code>fib()</code> method below submits the Fibonacci calculation task above for number 'n' and waits a maximum of 3 seconds for the result. If the execution does not completed in three seconds, the <code>future.get()</code> method throws a <code>TimeoutException</code> and upon catching it, we cancel the execution, saving some CPU cycles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    long fib( int n ) throws Exception {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IExecutorService es = hazelcastInstance.getExecutorService("es");
        Future&lt;Long&gt; future = es.submit( new FibonacciCallable( n ) );
        try {
            long result = future.get( 3, TimeUnit.SECONDS );
            System.out.println(result);
        } catch ( TimeoutException e ) {
            future.cancel( true );
        }
        return -1;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fib(20)</code> probably takes less than 3 seconds. However, <code>fib(50)</code> takes much longer. (This is not an example for writing better Fibonacci calculation code, but for showing how to cancel a running execution that takes too long.) The method <code>future.cancel(false)</code> can only cancel execution before it is running (executing), but <code>future.cancel(true)</code> can interrupt running executions provided that your code is able to handle the interruption. If you are willing to cancel an already running task, then your task should be designed to handle interruptions. If the <code>calculate (int n)</code> method did not have the <code>(Thread.currentThread().isInterrupted())</code> line, then you would not be able to cancel the execution after it is started.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="callback-when-task-completes"><a class="anchor" href="#callback-when-task-completes"></a>10.1.6. Callback When Task Completes</h4>
<div class="paragraph">
<p>You can use the <code>ExecutionCallback</code> offered by Hazelcast to asynchronously be notified when the execution is done. To be notified when your task completes without an error, implement the <code>onResponse</code> method. To be notified when your task completes with an error, implement the <code>onFailure</code> method.</p>
</div>
<div class="sect4">
<h5 id="_example_task_to_callback"><a class="anchor" href="#_example_task_to_callback"></a>Example Task to Callback</h5>
<div class="paragraph">
<p>Let&#8217;s use the Fibonacci series to explain this. The example code below is the calculation that is executed. Note that it is Callable and Serializable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Fibonacci2 implements Callable&lt;Long&gt;, Serializable {

    private final int input;

    public Fibonacci2(int input) {
        this.input = input;
    }

    public Long call() {
        return calculate(input);
    }

    private long calculate(int n) {
        if (Thread.currentThread().isInterrupted()) {
            System.out.println("FibonacciCallable is interrupted");
            throw new RuntimeException("FibonacciCallable is interrupted");
        }
        if (n &lt;= 1) {
            return n;
        } else {
            return calculate(n - 1) + calculate(n - 2);
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_example_method_to_callback_the_task"><a class="anchor" href="#_example_method_to_callback_the_task"></a>Example Method to Callback the Task</h5>
<div class="paragraph">
<p>The example code below submits the Fibonacci calculation to <code>ExecutionCallback</code> and prints the result asynchronously. <code>ExecutionCallback</code> has the methods <code>onResponse</code> and <code>onFailure</code>. In this example code, <code>onResponse</code> is called upon a valid response and prints the calculation result, whereas <code>onFailure</code> is called upon a failure and prints the stacktrace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MasterMemberCallback {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IExecutorService executor = hz.getExecutorService("executor");

        ExecutionCallback&lt;Long&gt; executionCallback = new ExecutionCallback&lt;Long&gt;() {
            public void onFailure(Throwable t) {
                t.printStackTrace();
            }

            public void onResponse(Long response) {
                System.out.println("Result: " + response);
            }
        };

        executor.submit(new FibonacciCallable(10), executionCallback);
        System.out.println("Fibonacci task submitted");
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="selecting-members-for-task-execution"><a class="anchor" href="#selecting-members-for-task-execution"></a>10.1.7. Selecting Members for Task Execution</h4>
<div class="paragraph">
<p>As previously mentioned, it is possible to indicate where in the Hazelcast cluster the <code>Runnable</code> or <code>Callable</code> is executed. Usually you execute these in the cluster based on the location of a key or a set of keys, or you allow Hazelcast to select a member.</p>
</div>
<div class="paragraph">
<p>If you want more control over where your code runs, use the <code>MemberSelector</code> interface. For example, you may want certain tasks to run only on certain members, or you may wish to implement some form of custom load balancing regime.  The <code>MemberSelector</code> is an interface that you can implement and then provide to the <code>IExecutorService</code> when you submit or execute.</p>
</div>
<div class="paragraph">
<p>The <code>select(Member)</code> method is called for every available member in the cluster. Implement this method to decide if the member is going to be used or not.</p>
</div>
<div class="paragraph">
<p>In a simple example shown below, we select the cluster members based on the presence of an attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyMemberSelector implements MemberSelector {
    public boolean select(Member member) {
        return Boolean.TRUE.equals(member.getBooleanAttribute("my.special.executor"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>MemberSelector</code> instances provided by the <code>com.hazelcast.cluster.memberselector.MemberSelectors</code> class. For example, you can select a lite member for running a task using <code>com.hazelcast.cluster.memberselector.MemberSelectors#LITE_MEMBER_SELECTOR</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-executor-service"><a class="anchor" href="#configuring-executor-service"></a>10.1.8. Configuring Executor Service</h4>
<div class="paragraph">
<p>The following are example configurations for executor service.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;executor-service name="exec"&gt;
        &lt;pool-size&gt;1&lt;/pool-size&gt;
        &lt;queue-capacity&gt;10&lt;/queue-capacity&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ..
  executor-service:
    exec:
      pool-size: 1
      queue-capacity: 10
      statistics-enabled: true
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        ExecutorConfig executorConfig = config.getExecutorConfig("exec");
        executorConfig.setPoolSize( 1 ).setQueueCapacity( 10 )
                .setStatisticsEnabled( true )
                .setSplitBrainProtectionName( "splitbrainprotectionname" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Executor service configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>pool-size</code>: The number of executor threads per Member for the Executor. By default, Executor is configured to have 16 threads in the pool. You can change that with this element.</p>
</li>
<li>
<p><code>queue-capacity</code>: Executor&#8217;s task queue capacity; the number of tasks this queue can hold.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your Executor Service. If set to<code>false</code>, you cannot collect statistics in your implementation (using <code>getLocalExecutorStats()</code>) and also <a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-executors" target="_blank" rel="noopener">Hazelcast Management Center</a> will not show them. Its default value is<code>true</code>.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this Executor Service to use. See the <a href="#split-brain-protection-for-iexecutorservice">Split-Brain Protection for IExecutorService section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_split_brain_protection_for_iexecutorservice"><a class="anchor" href="#_split_brain_protection_for_iexecutorservice"></a>10.1.9. Split-Brain Protection for IExecutorService</h4>
<div class="paragraph">
<p>IExecutorService can be configured to check for a minimum number of available members before applying its operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>). This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the operations, that support split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>execute</code></p>
</li>
<li>
<p><code>executeOnAllMembers</code></p>
</li>
<li>
<p><code>executeOnKeyOwner</code></p>
</li>
<li>
<p><code>executeOnMember</code></p>
</li>
<li>
<p><code>executeOnMembers</code></p>
</li>
<li>
<p><code>shutdown</code></p>
</li>
<li>
<p><code>shutdownNow</code></p>
</li>
<li>
<p><code>submit</code></p>
</li>
<li>
<p><code>submitToAllMembers</code></p>
</li>
<li>
<p><code>submitToKeyOwner</code></p>
</li>
<li>
<p><code>submitToMember</code></p>
</li>
<li>
<p><code>submitToMembers</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for Executor Service can be configured programmatically using the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/ExecutorConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>, or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;executor-service name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ..
  executor-service:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_durable_executor_service"><a class="anchor" href="#_durable_executor_service"></a>10.2. Durable Executor Service</h3>
<div class="paragraph">
<p>Hazelcast&#8217;s durable executor service is a data structure which is able to store an execution task both on the executing Hazelcast member and its backup member(s), if configured. By this way, you do not lose any tasks if a member goes down or any results if the submitter (member or client) goes down while executing the task. When using the durable executor service you can either submit or execute a task randomly or on the owner of a provided key. Note that in <a href="#executor-service">executor service</a>, you can submit or execute tasks to/on the selected member(s).</p>
</div>
<div class="paragraph">
<p>Processing of the tasks when using durable executor service involves two invocations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Sending the task to primary Hazelcast member (primary partition) and to its backups, if configured, and executing the task.</p>
</li>
<li>
<p>Retrieving the result of the task.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you may already know, Hazelcast&#8217;s executor service returns a <code>future</code> representing the task to the user. With the above two-invocations approach, it is guaranteed that the task is executed before the <code>future</code> returns and you can track the response of a submitted task with a unique ID. Hazelcast stores the task on both primary and backup members, and starts the execution also.</p>
</div>
<div class="paragraph">
<p>With the first invocation, a <a href="#ringbuffer">Ringbuffer</a> stores the task and a generated sequence for the task is returned to the caller as a result. In addition to the storing, the task is executed on the local execution service for the primary member. By this way, the task is now resilient to member failures and you are able to track the task with its ID.</p>
</div>
<div class="paragraph">
<p>After the first invocation has completed and the sequence of task is returned, second invocation starts to retrieve the result of task with that sequence. This retrieval waits in the waiting operations queue until notified, or it runs immediately if the result is already available.</p>
</div>
<div class="paragraph">
<p>When task execution is completed, Ringbuffer replaces the task with the result for the given task sequence. This replacement notifies the waiting operations queue.</p>
</div>
<div class="sect3">
<h4 id="_configuring_durable_executor_service"><a class="anchor" href="#_configuring_durable_executor_service"></a>10.2.1. Configuring Durable Executor Service</h4>
<div class="paragraph">
<p>This section presents example configurations for durable executor service along with the descriptions of its configuration elements and attributes.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;durable-executor-service name="myDurableExecSvc"&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;pool-size&gt;8&lt;/pool-size&gt;
        &lt;durability&gt;1&lt;/durability&gt;
        &lt;capacity&gt;1&lt;/capacity&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/durable-executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  durable-executor-service:
    myDurableExecSvc:
      statistics-enabled: true
      pool-size: 8
      durability: 1
      capacity: 1
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        config.getDurableExecutorConfig( "myDurableExecSvc" )
                .setPoolSize ( 8 )
                .setDurability( 1 )
                .setCapacity( 1 )
                .setSplitBrainProtectionName( "splitbrainprotectionname" );

        HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance(config);
        DurableExecutorService durableExecSvc = hazelcast.getDurableExecutorService("myDurableExecSvc");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions of each configuration element and attribute:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of the executor task.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled. If set to<code>false</code>, you cannot collect statistics.</p>
</li>
<li>
<p><code>pool-size</code>: Number of executor threads per member for the executor.</p>
</li>
<li>
<p><code>durability</code>: Number of backups in the cluster for the submitted task. Its default value is 1.</p>
</li>
<li>
<p><code>capacity</code>: Executor&#8217;s task queue capacity; the number of tasks this queue can hold.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this Durable Executor Service to use. See the <a href="#split-brain-protection-for-durable-executor-service">Split-Brain Protection for Durable Executor Service section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_split_brain_protection_for_durable_executor_service"><a class="anchor" href="#_split_brain_protection_for_durable_executor_service"></a>10.2.2. Split-Brain Protection for Durable Executor Service</h4>
<div class="paragraph">
<p>Durable Executor Service can be configured to check for a minimum number of available members before applying its operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>). This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the operations, that support split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>disposeResult</code></p>
</li>
<li>
<p><code>execute</code></p>
</li>
<li>
<p><code>executeOnKeyOwner</code></p>
</li>
<li>
<p><code>retrieveAndDisposeResult</code></p>
</li>
<li>
<p><code>shutdown</code></p>
</li>
<li>
<p><code>shutdownNow</code></p>
</li>
<li>
<p><code>submit</code></p>
</li>
<li>
<p><code>submitToKeyOwner</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>retrieveResult</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for Durable Executor Service can be configured programmatically using the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/DurableExecutorConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>, or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;durable-executor-service name="myDurableExecSvc"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/durable-executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  durable-executor-service:
    myDurableExecSvc:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_scheduled_executor_service"><a class="anchor" href="#_scheduled_executor_service"></a>10.3. Scheduled Executor Service</h3>
<div class="paragraph">
<p>Hazelcast&#8217;s scheduled executor service (IScheduledExecutorService)
is a data structure which implements <code>java.util.concurrent.ScheduledExecutorService</code>, partially.
By partially, we mean the behavior difference in scheduling a task at a fixed rate (<code>scheduleAtFixedRate()</code>).
Hazelcast&#8217;s behavior guarantees that a task is not executed by multiple threads concurrently:
a scheduled execution is skipped, instead of postponing, if another thread is still running the same task.</p>
</div>
<div class="paragraph">
<p>On top of the Vanilla Scheduling API, IScheduledExecutorService allows additional methods such as the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>scheduleOnMember</code>: On a specific cluster member.</p>
</li>
<li>
<p><code>scheduleOnKeyOwner</code>: On the partition owning that key.</p>
</li>
<li>
<p><code>scheduleOnAllMembers</code>: On all cluster members.</p>
</li>
<li>
<p><code>scheduleOnAllMembers</code>: On all given members.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/scheduledexecutor/IScheduledExecutorService.html" target="_blank" rel="noopener">IScheduledExecutorService Javadoc</a> for its API details.</p>
</div>
<div class="paragraph">
<p>There are two different modes of durability for the service:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Upon partition specific scheduling, the future task is stored both in the primary partition and also in its N backups, N being the <code>&lt;durability&gt;</code> property in the configuration. More specifically, there are always one or more backups to take ownership of the task in the event of a lost member. If a member is lost, the task is re-scheduled on the backup (new primary) member, which might induce further delays on the subsequent executions of the task.
For example, if we schedule a task to run in 10 seconds from now, <code>schedule(new ExampleTask(), 10, TimeUnit.SECONDS);</code> and after 5 seconds the owner member goes down (before the execution takes place), then the backup owner re-schedules the task in 10 seconds from now. Therefore, from the user&#8217;s perspective waiting on the result, this will be available in <code>10 + 5 = 15</code> seconds rather than 10 seconds as it is anticipated originally. If <code>atFixedRate</code> was used, then only the initial delay is affected in the above scenario, all subsequent executions should adhere to the given period parameter.</p>
</li>
<li>
<p>Upon member specific scheduling, the future task is <strong>only</strong> stored in the member itself, which means that in the event of a lost member, the task is lost as well.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To accomplish the described durability, all tasks provide a unique identity/name before the scheduling takes place. The name allows the service to reach the scheduled task even after the caller (client or member) goes down and also allows to prevent duplicate tasks.
The name of the task can be user-defined if it needs to be, by implementing the <code>com.hazelcast.scheduledexecutor.NamedTask</code> interface (plain wrapper util is available here: <code>com.hazelcast.scheduledexecutor.TaskUtils.named(java.lang.String, java.lang.Runnable)</code>). If the task does not provide a name in its implementation, the service provides a random UUID for it, internally.</p>
</div>
<div class="paragraph">
<p>Upon scheduling, the service returns an <code>IScheduledFuture</code>, which on top of the <code>java.util.concurrent.ScheduledFuture</code> functionality, provides an API to get the resource handler of the task <code>ScheduledTaskHandler</code> and also the runtime statistics of the task.</p>
</div>
<div class="paragraph">
<p>Futures associated with a scheduled task, in order to be aware of lost partitions and/or members, act as listeners on the local member/client. Therefore, they are always strongly referenced, on the member/client side. In order to clean up their resources, once completed, you can use the method <code>dispose()</code>. This method also cancels further executions of the task if scheduled at a fixed rate. See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/scheduledexecutor/IScheduledFuture.html" target="_blank" rel="noopener">IScheduledFuture Javadoc</a> for its API details.</p>
</div>
<div class="paragraph">
<p>The task handler is a descriptor class holding information for the scheduled future, which is used to pinpoint the actual task in the cluster. It contains the name of the task, the owner (member or partition) and the scheduler name.</p>
</div>
<div class="paragraph">
<p>The handler is always available after scheduling and can be stored in a plain string format <code>com.hazelcast.scheduledexecutor.ScheduledTaskHandler.toUrn()</code> and re-constructed back from that String <code>com.hazelcast.scheduledexecutor.ScheduledTaskHandler.of()</code>. If the handler is lost, you can still find a task under a given scheduler by using the Scheduler&#8217;s <code>com.hazelcast.scheduledexecutor.IScheduledExecutorService.getAllScheduledFutures()</code>.</p>
</div>
<div class="paragraph">
<p>Last but not least, similar to <a href="#executor-service">executor service</a>, the scheduled executor service allows Stateful tasks to be scheduled. Stateful tasks, are tasks that require any kind of state during their runtime, which must also be durable along with the task in the event of a lost partition.</p>
</div>
<div class="paragraph">
<p>Stateful tasks can be created by implementing the <code>com.hazelcast.scheduledexecutor.StatefulTask</code> interface, providing implementation details for saving the state and loading it back. If a partition is lost, then the re-scheduled task loads the previously saved state before its execution.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with the tasks, Objects stored in the state Map need to be Hazelcast serializable.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_configuring_scheduled_executor_service"><a class="anchor" href="#_configuring_scheduled_executor_service"></a>10.3.1. Configuring Scheduled Executor Service</h4>
<div class="paragraph">
<p>This section presents example configurations for scheduled executor service along with the descriptions of its configuration elements and attributes.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;scheduled-executor-service name="myScheduledExecSvc"&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;pool-size&gt;16&lt;/pool-size&gt;
        &lt;durability&gt;1&lt;/durability&gt;
        &lt;capacity&gt;100&lt;/capacity&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/scheduled-executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  scheduled-executor-service:
    myScheduledExecSvc:
      statistics-enabled: true
      pool-size: 16
      durability: 1
      capacity: 100
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        config.getScheduledExecutorConfig( "myScheduledExecSvc" )
                .setPoolSize ( 16 )
                .setCapacity( 100 )
                .setDurability( 1 )
                .setSplitBrainProtectionName( "splitbrainprotectionname" );

        HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance(config);
        IScheduledExecutorService myScheduledExecSvc = hazelcast.getScheduledExecutorService("myScheduledExecSvc");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions of each configuration element and attribute:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of the scheduled executor.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled. If set to<code>false</code>, you cannot collect statistics.</p>
</li>
<li>
<p><code>pool-size</code>: Number of executor threads per member for the executor.</p>
</li>
<li>
<p><code>capacity</code>: Maximum number of tasks that a scheduler can have per partition. Attempt to schedule more results in <code>RejectedExecutionException</code>. To free up the capacity, tasks should get disposed by the user.</p>
</li>
<li>
<p><code>durability</code>: Durability of the executor.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this Scheduled Executor Service to use. See the <a href="#split-brain-protection-for-ischeduled-executor-service">Split-Brain Protection for IScheduled Executor Service section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="scheduled-exec-srv-examples"><a class="anchor" href="#scheduled-exec-srv-examples"></a>10.3.2. Examples</h4>
<div class="paragraph">
<p>Scheduling a callable that computes the cluster size in <code>10 seconds</code> from now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class DelayedClusterSizeTask implements Callable&lt;Integer&gt;, HazelcastInstanceAware, Serializable {

    private transient HazelcastInstance instance;

    @Override
    public Integer call()
            throws Exception {
        return instance.getCluster().getMembers().size();
    }

    @Override
    public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {
        this.instance = hazelcastInstance;
    }
}

HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance();
IScheduledExecutorService executorService = hazelcast.getScheduledExecutorService("myScheduler");
IScheduledFuture&lt;Integer&gt; future = executorService.schedule(
        new DelayedClusterSizeTask(), 10, TimeUnit.SECONDS);

int membersCount = future.get(); // Block until we get the result
ScheduledTaskStatistics stats = future.getStats();
future.dispose(); // Always dispose futures that are not in use any more, to release resources
long totalTaskRuns = stats.getTotalRuns(); // = 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_split_brain_protection_for_ischeduled_executor_service"><a class="anchor" href="#_split_brain_protection_for_ischeduled_executor_service"></a>10.3.3. Split-Brain Protection for IScheduled Executor Service</h4>
<div class="paragraph">
<p>IScheduledExecutorService can be configured to check for a minimum number of available members before applying its operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>). This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the operations, that support split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>schedule</code></p>
</li>
<li>
<p><code>scheduleAtFixedRate</code></p>
</li>
<li>
<p><code>scheduleOnAllMembers</code></p>
</li>
<li>
<p><code>scheduleOnAllMembersAtFixedRate</code></p>
</li>
<li>
<p><code>scheduleOnKeyOwner</code></p>
</li>
<li>
<p><code>scheduleOnKeyOwnerAtFixedRate</code></p>
</li>
<li>
<p><code>scheduleOnMember</code></p>
</li>
<li>
<p><code>scheduleOnMemberAtFixedRate</code></p>
</li>
<li>
<p><code>scheduleOnMembers</code></p>
</li>
<li>
<p><code>scheduleOnMembersAtFixedRate</code></p>
</li>
<li>
<p><code>shutdown</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>getAllScheduledFutures</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for Scheduled Executor Service can be configured programmatically using the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/ScheduledExecutorConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>, or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;scheduled-executor-service name="myScheduledExecSvc"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/scheduled-executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  scheduled-executor-service:
    myScheduledExecSvc:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_entry_processor"><a class="anchor" href="#_entry_processor"></a>10.4. Entry Processor</h3>
<div class="paragraph">
<p>Hazelcast supports entry processing. An entry processor is a function that executes your code on a map entry in an atomic way.</p>
</div>
<div class="paragraph">
<p>An entry processor is a good option if you perform bulk processing on an <code>IMap</code>. Usually you perform a loop of keys - executing <code>IMap.get(key)</code>, mutating the value and finally putting the entry back in the map using <code>IMap.put(key,value)</code>.  If you perform this process from a client or from a member where the keys do not exist, you effectively perform two network hops for each update: the first to retrieve the data and the second to update the mutated value.</p>
</div>
<div class="paragraph">
<p>If you are doing the process described above, you should consider using entry processors. An entry processor executes a read and updates upon the member where the data resides.  This eliminates the costly network hops described above.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Entry processor is meant to process a single entry per call. Processing multiple entries and data structures in an entry processor is not supported as it may result in deadlocks.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that Hazelcast Jet is a good fit when you want to perform processing that involves multiple entries (aggregations, joins, etc.), or involves multiple computing steps to be made parallel. Hazelcast Jet contains an Entry Processor Sink to allow you to update Hazelcast IMDG data as a result of your Hazelcast Jet computation. See the <a href="https://docs.hazelcast.org/docs/jet/latest/manual/index.html#connector-imdg" target="_blank" rel="noopener">Hazelcast Jet Reference Manual</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_performing_fast_in_memory_map_operations"><a class="anchor" href="#_performing_fast_in_memory_map_operations"></a>10.4.1. Performing Fast In-Memory Map Operations</h4>
<div class="paragraph">
<p>An entry processor enables fast in-memory operations on your map without you having to worry about locks or concurrency issues. You can apply it to a single map entry or to all map entries. Entry processors support choosing target entries using predicates. You do not need any explicit lock on entry thanks to the isolated threading model: Hazelcast runs the entry processor for all entries on a <code>partitionThread</code> so there will NOT be any interleaving of the entry processor and other mutations.</p>
</div>
<div class="paragraph">
<p>Hazelcast sends the entry processor to each cluster member and these members apply it to map entries. Therefore, if you add more members, your processing completes faster.</p>
</div>
<div class="sect4">
<h5 id="_using_indexes"><a class="anchor" href="#_using_indexes"></a>Using Indexes</h5>
<div class="paragraph">
<p>Entry processors can be used with predicates. Predicates help to process a subset of data by selecting eligible entries. This selection can happen either by doing a full-table scan or by using indexes. To accelerate entry selection step, you can consider to add indexes. If indexes are there, entry processor automatically uses them.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_object_in_memory_format"><a class="anchor" href="#_using_object_in_memory_format"></a>Using OBJECT In-Memory Format</h5>
<div class="paragraph">
<p>If entry processing is the major operation for a map and if the map consists of complex objects, you should use <code>OBJECT</code> as the <code>in-memory-format</code> to minimize serialization cost. By default, the entry value is stored as a byte array (<code>BINARY</code> format). When it is stored as an object (<code>OBJECT</code> format), then the entry processor is applied directly on the object. In that case, no serialization or deserialization is performed. However, if there is a defined event listener, a new entry value will be serialized when passing to the event publisher service.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When <code>in-memory-format</code> is <code>OBJECT</code>, the old value of the updated entry will be null.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_processing_entries"><a class="anchor" href="#_processing_entries"></a>Processing Entries</h5>
<div class="paragraph">
<p>The <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/IMap.html" target="_blank" rel="noopener">IMap interface</a> provides the following methods for entry processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>executeOnKey</code> processes an entry mapped by a key, blocking until the processing is complete and the result is returned.</p>
</li>
<li>
<p><code>executeOnKeys</code> processes entries mapped by a collection of keys, blocking until the processing is complete and the results are returned.</p>
</li>
<li>
<p><code>submitToKey</code> processes an entry mapped by a key and provides a way to register a callback to receive notifications about the result of the entry processing.</p>
</li>
<li>
<p><code>executeOnEntries</code> processes all entries in a map, blocking until the processing is complete and the results are returned.</p>
</li>
<li>
<p><code>executeOnEntries</code> also processes all entries in a map matching the provided predicate, blocking until the processing is complete and the results are returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using the <code>executeOnEntries</code> method, if the number of entries is high and you do not need the results, then returning null with the <code>process()</code> method is a good practice. This method is offered by the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/EntryProcessor.html" target="_blank" rel="noopener">EntryProcessor interface</a>. By returning null, results of the processing are not collected and thus out of memory errors are eliminated.</p>
</div>
<div class="paragraph">
<p>If you do not need to read or modify the entry in any way but would like to execute a task on the member owning the entry with that key (i.e. the member is the partition owner for that key), you can also use <code>executeOnKeyOwner</code> provided by <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/core/IExecutorService.html#executeOnKeyOwner-java.lang.Runnable-java.lang.Object-" target="_blank" rel="noopener">IExecutorService</a>. You need to make sure that the runnable can be serialized (using any of the available serialization techniques in Hazelcast). The runnable will not receive the map entry key or value and is not running on the same thread as operations reading the map data so operations such as <code>map.get()</code> or <code>map.put()</code> will not be blocked.</p>
</div>
<div class="paragraph">
<p>You can also use entry processors to remove entries from your map simply
by setting the value(s) of a single entry or multiple entries to <code>null</code>. See the following
example code snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class EntryDeletingProcessor implements EntryProcessor&lt;String, MyData, Boolean&gt; {

    public Boolean process(Map.Entry&lt;String, MyData&gt; entry) {
        entry.setValue(null);
        return true;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Related to above, IMap&#8217;s <code>executeOnEntries()</code> method accepts predicates; you can also
remove entries that match to a predicate that you provide.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Entry processors run via operation threads that are dedicated to specific partitions. Therefore, with long running entry processor executions, other partition operations such as <code>map.put(key)</code> on some partitions can be blocked while partition operations on other partitions might run concurrently. With this in mind, it is a good practice to make your entry processor executions as quick as possible.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_respecting_locks_on_single_keys"><a class="anchor" href="#_respecting_locks_on_single_keys"></a>Respecting Locks on Single Keys</h5>
<div class="paragraph">
<p>The entry processor respects locks ONLY when its executions are performed on a single key. As explained in the above section, the entry processor has the following methods to process a single key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">&lt;R&gt; R executeOnKey(K key, EntryProcessor&lt;K, V, R&gt; entryProcessor);
&lt;R&gt; CompletionStage&lt;R&gt; submitToKey(K key, EntryProcessor&lt;K, V, R&gt; entryProcessor);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Therefore, if you want to to perform an entry processor execution on a single key using one of these methods and that key has a lock on it, the execution will wait until the lock on that key is removed.</p>
</div>
</div>
<div class="sect4">
<h5 id="_processing_backup_entries"><a class="anchor" href="#_processing_backup_entries"></a>Processing Backup Entries</h5>
<div class="paragraph">
<p>If your code modifies the data, then you will most likely need to modify backup entries as well. This should be done to prevent divergence of map values between copies of data in the cluster (the primary and backup replicas). In most cases, this is simple. By implementing the <code>EntryProcessor</code> interface and providing only the <code>process()</code> method, the same entry processor will be applied on all copies of the map entry.</p>
</div>
<div class="paragraph">
<p>If, however, you would like to run a custom processor on backup entries, you may provide the processor by overriding the <code>EntryProcessor#getBackupProcessor</code> method. The method should return an instance of an <code>EntryProcessor</code> which will be run on backup entries exclusively. As such, it may carry some state that was derived from running the entry processor on primary replicas.</p>
</div>
<div class="paragraph">
<p>You may also return <code>null</code> from the <code>EntryProcessor#getBackupProcessor</code> method. This signifies that there is nothing to be done on the backup replicas which is most convenient when you are using the entry processor to read and not modify entries.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is possible that an entry processor could see that a key exists though its backup processor may not find it due to an unsent backup of a previous operation, e.g., a previous put operation. In those situations, Hazelcast internally/eventually synchronizes those owner and backup partitions so you do not lose any data. When coding a backup entry processor, you should take that case into account, otherwise <code>NullPointerException</code> can be seen since <code>Map.Entry.getValue()</code> may return <code>null</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creating_an_entry_processor"><a class="anchor" href="#_creating_an_entry_processor"></a>10.4.2. Creating an Entry Processor</h4>
<div class="paragraph">
<p>The class <code>IncrementingEntryProcessor</code> creates an entry processor to process the map
entries. It implements the <code>EntryProcessor</code> interface. The <code>process()</code> method will be called for both primary and backup entries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IncrementingEntryProcessor implements EntryProcessor&lt;Integer, Integer, Integer&gt; {
    public Integer process( Map.Entry&lt;Integer, Integer&gt; entry ) {
        Integer value = entry.getValue();
        entry.setValue( value + 1 );
        return value + 1;
    }

    @Override
    public EntryProcessor&lt;Integer, Integer, Integer&gt; getBackupProcessor() {
        return IncrementingEntryProcessor.this;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example usage is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;Integer, Integer&gt; map = hazelcastInstance.getMap( "myMap" );
for ( int i = 0; i &lt; 100; i++ ) {
    map.put( i, i );
}
Map&lt;Integer, Object&gt; res = map.executeOnEntries( new IncrementingEntryProcessor() );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You should explicitly call the <code>setValue</code> method of <code>Map.Entry</code> when modifying data in the entry processor. Otherwise, the entry processor is accepted as read-only.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An entry processor instance is not thread-safe. If you are storing a partition specific state between invocations, be sure to register this in a thread-local.  An entry processor instance can be used by multiple partition threads.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_entry_processor_performance_optimizations"><a class="anchor" href="#_entry_processor_performance_optimizations"></a>10.4.3. Entry Processor Performance Optimizations</h4>
<div class="paragraph">
<p>By default the entry processor executes on a partition thread. A partition thread is responsible for handling
one or more partitions. The design of entry processor assumes users have fast user code execution of the <code>process()</code> method.
In the pathological case where the code is very heavy and executes in multi-milliseconds, this may create a bottleneck.</p>
</div>
<div class="paragraph">
<p>We have a slow user code detector which can be used to log a warning controlled by the following system properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.slow.operation.detector.enabled</code> (default: true)</p>
</li>
<li>
<p><code>hazelcast.slow.operation.detector.threshold.millis</code> (default: 10000)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The defaults catch extremely slow operations but you should set this much lower, say to 1ms, at development time to catch entry processors that could be problematic in production. These are good candidates for our optimizations.</p>
</div>
<div class="paragraph">
<p>We have two optimizations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Offloadable</code> which moves execution off the partition thread to an executor thread</p>
</li>
<li>
<p><code>ReadOnly</code> which means we can avoid taking a lock on the key</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are enabled very simply by implementing these interfaces in your <code>EntryProcessor</code>.</p>
</div>
<div class="paragraph">
<p>As of Hazelcast IMDG 3.9, these optimizations apply to the following IMap methods only:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>executeOnKey(Object, EntryProcessor)</code></p>
</li>
<li>
<p><code>submitToKey(Object, EntryProcessor)</code></p>
</li>
<li>
<p><code>submitToKey(Object, EntryProcessor, ExecutionCallback)</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_offloadable_entry_processor"><a class="anchor" href="#_offloadable_entry_processor"></a>Offloadable Entry Processor</h5>
<div class="paragraph">
<p>If an entry processor implements the <code>Offloadable</code> interface, the <code>process()</code> method is executed in the executor
specified by the <code>Offloadable</code>'s <code>getExecutorName()</code> method.</p>
</div>
<div class="paragraph">
<p>Offloading unblocks the partition thread allowing the user to profit from much higher throughput.
The key is locked for the time span of the processing in order to not generate a write conflict.</p>
</div>
<div class="paragraph">
<p>In this case the threading looks as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>partition thread (fetch entry &amp; lock key)</p>
</li>
<li>
<p>execution thread (process(entry) method)</p>
</li>
<li>
<p>partition thread (set new value &amp; unlock key, or just unlock key if the entry has not been modified)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The method <code>getExecutorName()</code> method may also return two constants defined in the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/core/Offloadable.html" target="_blank" rel="noopener">Offloadable interface</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NO_OFFLOADING: Processing is not offloaded if the method <code>getExecutorName()</code> returns this constant; it is executed as if it does not implement the <code>Offloadable</code> interface.</p>
</li>
<li>
<p>OFFLOADABLE_EXECUTOR: Processing is offloaded to the default <code>ExecutionService.OFFLOADABLE_EXECUTOR</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that if the method <code>getExecutorName()</code> cannot find an executor whose name matches the one called by this method, then the default executor service is used. Here is the configuration for the "default" executor:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;executor-service name="default"&gt;
        &lt;pool-size&gt;16&lt;/pool-size&gt;
        &lt;queue-capacity&gt;0&lt;/queue-capacity&gt;
    &lt;/executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
    ...
  executor-service:
    default:
      pool-size: 16
      queue-capacity: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example of an Offloadable called "OffloadedInventoryEntryProcessor" would be as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;executor-service name="OffloadedInventoryEntryProcessor&gt;
        &lt;pool-size&gt;30&lt;/pool-size&gt;
        &lt;queue-capacity&gt;0&lt;/queue-capacity&gt;
    &lt;/executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  executor-service:
    OffloadedInventoryEntryProcessor:
      pool-size: 30
      queue-capacity: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember to set the <code>pool-size</code> (count of executor threads per member) according to your execution needs. See the <a href="#configuring-executor-service">Configuring Executor Service section</a> for the configuration details.</p>
</div>
</div>
<div class="sect4">
<h5 id="_readonly_entry_processor"><a class="anchor" href="#_readonly_entry_processor"></a>ReadOnly Entry Processor</h5>
<div class="paragraph">
<p>By default, an entry processor does not run if the key is locked.
It waits until the key has been unlocked (it applies to the <code>executeOnKey</code>, <code>submitToKey</code> methods, that were mentioned before).</p>
</div>
<div class="paragraph">
<p>If the entry processor implements the <code>ReadOnly</code> interface without implementing the <code>Offloadable</code> interface, the processing is not offloaded to an external executor. However, the entry processor does not observe if the key of the processed entry is
locked, nor tries to acquire the lock since the entry processor will not do any modifications.</p>
</div>
<div class="paragraph">
<p>If the entry processor implements <code>ReadOnly</code> and modifies the entry, an <code>UnsupportedOperationException</code> is thrown.</p>
</div>
</div>
<div class="sect4">
<h5 id="_readonly_and_offloadable_entry_processor"><a class="anchor" href="#_readonly_and_offloadable_entry_processor"></a>ReadOnly and Offloadable Entry Processor</h5>
<div class="paragraph">
<p>If the entry processor implements both <code>ReadOnly</code> and <code>Offloadable</code> interfaces, we observe the combination of both
optimizations described above.</p>
</div>
<div class="paragraph">
<p>The <code>process()</code> method is executed in the executor specified by the <code>Offloadable&#8217;s `getExecutorName()</code> method.
Also, the entry processor does not observe if the key of the processed entry is locked, nor tries to acquire the
lock since the entry processor will not do any modifications.</p>
</div>
<div class="paragraph">
<p>In this case the threading looks as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>partition thread (fetch entry)</p>
</li>
<li>
<p>execution thread (process(entry))</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this case the <code>EntryProcessor.getBackupProcessor()</code> has to return null; otherwise an <code>IllegalArgumentException</code>
exception is thrown.</p>
</div>
<div class="paragraph">
<p>If the entry processor implements <code>ReadOnly</code> and modifies the entry, an <code>UnsupportedOperationException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>Putting it all together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class OffloadableReadOnlyEntryProcessor implements EntryProcessor&lt;String, Employee, Object&gt;,
        Offloadable, ReadOnly {

    @Override
    public Object process(Map.Entry&lt;String, Employee&gt; entry) {
        // heavy logic
        return null;
    }

    @Override
    public EntryProcessor&lt;String, Employee, Object&gt; getBackupProcessor() {
        // ReadOnly EntryProcessor has to return null, since it's just a read-only operation that will not be
        // executed on the backup
        return null;
    }

    @Override
    public String getExecutorName() {
        return OFFLOADABLE_EXECUTOR;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sql"><a class="anchor" href="#_sql"></a>11. SQL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The SQL service provided by Hazelcast allows you to query data stored in <code>IMap</code> declaratively.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The SQL feature is currently in beta. The compatibility between versions
is not guaranteed. API might change between versions without notice.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_example_how_to_query_an_imap_using_sql"><a class="anchor" href="#_example_how_to_query_an_imap_using_sql"></a>11.1. Example: How to Query an IMap using SQL</h3>
<div class="paragraph">
<p>Consider that we have a map called <code>emp</code> that contains values of type <code>Employee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee implements Serializable {
    private String name;
    private int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code prints names of the employees whose age is less than 30:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try (SqlResult result = hazelcastInstance.getSql().execute("SELECT name FROM emp WHERE age &lt; ?", 30)) {
    for (SqlRow row : result) {
        String name = row.getObject(0);

        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can run the same code snippet from a member or a client.</p>
</div>
</div>
<div class="sect2">
<h3 id="_querying_imap"><a class="anchor" href="#_querying_imap"></a>11.2. Querying IMap</h3>
<div class="paragraph">
<p>The following subsections describe how you can access Hazelcast map objects
and perform queries on them.</p>
</div>
<div class="sect3">
<h4 id="_names"><a class="anchor" href="#_names"></a>11.2.1. Names</h4>
<div class="paragraph">
<p>The SQL service exposes <code>IMap</code> objects as tables in the predefined <code>partitioned</code>
schema using exact names. This schema is in the SQL service search path so that
you can access the <code>IMap</code> objects with or without the schema name.</p>
</div>
<div class="paragraph">
<p>Schema and table names are case-sensitive; you can access the <code>employee</code> map, for example,
as <code>employee</code> or <code>partitioned.employee</code>, but not as <code>Employee</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT * FROM employee
SELECT * FROM partitioned.employee</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fields"><a class="anchor" href="#_fields"></a>11.2.2. Fields</h4>
<div class="paragraph">
<p>The SQL service resolves fields accessible from the SQL automatically. The
service reads the first local entry pair of the <code>IMap</code> to construct the
list of fields. If the <code>IMap</code> does not have local entries on the member where
the query is started, then the list of fields cannot be resolved, and an
exception is thrown.</p>
</div>
<div class="paragraph">
<p>Field names are case-sensitive.</p>
</div>
<div class="sect4">
<h5 id="_key_and_value_objects"><a class="anchor" href="#_key_and_value_objects"></a>Key and Value Objects</h5>
<div class="paragraph">
<p>An <code>IMap</code> entry consists of a key and a value. These are accessible
through the <code>__key</code> and <code>this</code> aliases. The following query returns
the keys and values of all entries in a map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT __key, this FROM employee</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_key_and_value_fields"><a class="anchor" href="#_key_and_value_fields"></a>Key and Value Fields</h5>
<div class="paragraph">
<p>You may also access the nested fields of a key or a value. The list of exposed
fields depends on the serialization format, as described below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For Java objects (<code>Serializable</code>, <code>DataSerializable</code>, <code>IdentifiedDataSerializable</code>),
the object is deserialized if needed and then analyzed using the reflection mechanism. Only public
fields and getters are taken into account. A public field is exposed using its exact name.
A getter is exposed using the JavaBean naming conventions.</p>
</li>
<li>
<p>For <code>Portable</code> objects, the fields that are written in the <code>Portable.writePortable</code>
method are exposed using their exact names.</p>
</li>
<li>
<p><code>HazelcastJsonValue</code> objects cannot be queried at the moment. This limitation will be
removed in future releases.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the <code>Employee</code> class from the example above; the SQL service can access
the following fields:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VARCHAR</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INTEGER</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Together with the key and value objects, you may query the following fields from
<code>IMap&lt;Long, Employee&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT __key, this, name, age FROM employee</code></pre>
</div>
</div>
<div class="paragraph">
<p>If both the key and value have fields with the same name, then the field of the
value is exposed.</p>
</div>
</div>
<div class="sect4">
<h5 id="_select_queries"><a class="anchor" href="#_select_queries"></a>"SELECT *" Queries</h5>
<div class="paragraph">
<p>You may use the <code>SELECT * FROM &lt;table&gt;</code> syntax to get all the table fields.</p>
</div>
<div class="paragraph">
<p>The <code>__key</code> and <code>this</code> fields are returned by the <code>SELECT *</code> queries if they do not
have nested fields. For <code>IMap&lt;Long, Employee&gt;</code>, the following query does
not return the <code>this</code> field, because the value has nested fields <code>name</code> and <code>age</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">-- Returns __key, name, age
SELECT * FROM employee</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_indexes"><a class="anchor" href="#_indexes"></a>11.2.3. Indexes</h4>
<div class="paragraph">
<p>The SQL service can use <code>IMap</code> indexes to speed up the execution of certain queries.
<code>SORTED</code> and <code>HASH</code> indexes are supported.</p>
</div>
<div class="paragraph">
<p>See the <a href="#indexing-queries">Indexing Queries section</a> for more information on <code>IMap</code>
index creation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_high_density_memory_store"><a class="anchor" href="#_high_density_memory_store"></a>11.2.4. High-Density Memory Store</h4>
<div class="paragraph">
<p>You can query the <code>IMap</code> objects with <code>InMemoryFormat.NATIVE</code> if they have
at least one index.</p>
</div>
<div class="paragraph">
<p>See <a href="#configuring-with-system-properties">Configuring with System Properties</a> for
more information on setting system properties.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_data_types"><a class="anchor" href="#_data_types"></a>11.3. Data Types</h3>
<div class="paragraph">
<p>The SQL service supports a set of SQL data types. Every data type is mapped to a Java
class that represents the type&#8217;s value.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. SQL Data Types</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type Name</th>
<th class="tableblock halign-left valign-top">Java Class</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BOOLEAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.Boolean</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VARCHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TINYINT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.Byte</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SMALLINT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.Short</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INTEGER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.Integer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BIGINT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.Long</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DECIMAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.math.BigDecimal</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.Float</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DOUBLE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.Double</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DATE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time.LocalDate</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TIME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time.LocalTime</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TIMESTAMP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time.LocalDateTime</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TIMESTAMP_WITH_TIME_ZONE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time.OffsetDateTime</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OBJECT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any Java class</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_select"><a class="anchor" href="#_select"></a>11.4. SELECT</h3>
<div class="sect3">
<h4 id="_synopsis"><a class="anchor" href="#_synopsis"></a>11.4.1. Synopsis</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT [ * | expression [ [ AS ] expression_alias ] [, ...] ]
FROM table_name [ [ AS ] table_alias ]
[WHERE condition]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_description"><a class="anchor" href="#_description"></a>11.4.2. Description</h4>
<div class="paragraph">
<p>The <code>SELECT</code> command retrieves rows from a table. A row is a sequence of expressions defined after the <code>SELECT</code> keyword.
Expressions may have optional aliases.</p>
</div>
<div class="paragraph">
<p><code>table_name</code> refers to a single <code>IMap</code> data structure. A table may have an optional alias.</p>
</div>
<div class="paragraph">
<p>An optional <code>WHERE</code> clause defines a <code>condition</code>, that is any expression that evaluates to a result of type boolean.
Any row that doesn&#8217;t satisfy the condition is eliminated from the result.</p>
</div>
<div class="paragraph">
<p>The following features are <strong>not supported</strong> and are planned for future releases:
<code>ORDER BY</code>, <code>LIMIT</code>/<code>OFFSET</code>, <code>GROUP BY</code>/<code>HAVING</code>, <code>JOIN</code>, set operators (<code>UNION</code>, <code>INTERSECT</code>, <code>MINUS</code>), subqueries.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_expressions"><a class="anchor" href="#_expressions"></a>11.5. Expressions</h3>
<div class="paragraph">
<p>Hazelcast SQL supports logical predicates, <code>IS</code> predicates, comparison operators, mathematical functions and operators,
string functions, and special functions.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. AND/OR Operators</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>a</code></th>
<th class="tableblock halign-left valign-top"><code>b</code></th>
<th class="tableblock halign-left valign-top"><code>a AND b</code></th>
<th class="tableblock halign-left valign-top"><code>a OR b</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. NOT Operator</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>a</code></th>
<th class="tableblock halign-left valign-top"><code>NOT a</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULL</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. IS Operator</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Predicate</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates to <code>TRUE</code> if the boolean argument is <code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age &lt; 30 IS TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS NOT TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates to <code>TRUE</code> if the boolean argument is <code>FALSE</code> or <code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age &lt; 30 IS NOT TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates to <code>TRUE</code> if the boolean argument is <code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age &lt; 30 IS FALSE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS NOT FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates to <code>TRUE</code> if the boolean argument is <code>TRUE</code> or <code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age &lt; 30 IS NOT FALSE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates to <code>TRUE</code> if the argument is <code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name IS NULL</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS NOT NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluates to <code>TRUE</code> if the argument is not <code>NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name IS NOT NULL</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Comparison Operators</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operator</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equal to</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age = 30</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!=</code> or <code>&lt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not equal to</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age != 30</code> or <code>age &lt;&gt; 30</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Less than</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age &lt; 30</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Greater than</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age &gt; 30</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Less than or equal to</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age &lt;= 30</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Greater than or equal to</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>age &gt;= 30</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Mathematical Operators</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operator</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Addition</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5 + 2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Subtraction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5 - 2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multiplication</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5 * 2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Division</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5 / 2</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Mathematical Functions</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
<th class="tableblock halign-left valign-top">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ABS(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aboslute value of the argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ABS(-5)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CEIL(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The nearest integer greater than or equal to argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CEIL(25.3)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>26</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEGREES(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert radians to degrees</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEGREES(0.67)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>38.38817227376516</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXP(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exponential</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXP(2.5)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>12.182493960703473</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FLOOR(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The nearest integer less than or equal to argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FLOOR(25.3)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>25</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LN(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Natural logarithm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LN(2.5)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0.9162907318741551</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG10(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Base 10 logarithm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG(2.5)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0.3979400086720376</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RADIANS(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert degrees to radians</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RADIANS(38.39)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0.6700318998406232</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Random value in the range [0.0; 1.0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAND()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0.6324099982812553</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAND(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Random value in the range [0.0; 1.0) using the given seed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAND(10)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0.7304302967434272</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROUND(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Round to an integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROUND(34.5678)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>35</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROUND(number, s integer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Round to <code>s</code> decimal places</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROUND(34.5678, 2)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>34.57</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SIGN(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return -1, 0 or 1 for negative, zero or positive argument, respectively</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SIGN(-25)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUNCATE(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Truncate to an integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUNC(34.5678)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>34</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUNCATE(number, s integer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Truncate to <code>s</code> decimal places</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUNC(34.5678, 2)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>34.56</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Trigonometric Functions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACOS(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inverse cosine</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ASIN(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inverse sine</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ATAN(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inverse tangent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>COS(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cosine</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>COT(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cotangent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SIN(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sine</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TAN(double)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tangent</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. String Functions</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
<th class="tableblock halign-left valign-top">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>string || string</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Concatenate two strings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'John' || ' ' || 'Doe'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>John Doe</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ASCII(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII code of the first character of the argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ASCII('a')</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>97</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BTRIM(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>TRIM(BOTH ' ' FROM string)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INITCAP(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert the first letter of each word to upper case, and the rest to lower case</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INITCAP('john DOE')</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>John Doe</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LENGTH(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Length of the string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LENGTH('John Doe')</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return <code>TRUE</code> if the value string follows the pattern</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'John Doe' LIKE '%Doe'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIKE &#8230;&#8203; ESCAPE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return <code>TRUE</code> if the value string follows the pattern, escaping a special character in the pattern</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'text' LIKE '!_ext' ESCAPE '!'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert the string to lower case</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER('John Doe')</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>john doe</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LTRIM(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>TRIM(LEADING ' ' FROM string)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RTRIM(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>TRIM(TRAILING ' ' FROM string)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBSTRING(string FROM integer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extract substring starting with the given position</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBSTRING('John Doe' FROM 6)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Doe</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBSTRING(string FROM integer FOR integer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extract substring starting with the given position for the given length</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBSTRING('John Doe' FROM 1 FOR 4)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>John</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRIM([LEADING|TRAILING|BOTH] [characters FROM] string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove <code>characters</code> (a space by default) from the start/end/both ends of the string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRIM(BOTH '[]' FROM '[John Doe]')</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>John Doe</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRIM(characters FROM string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>TRIM(BOTH characters FROM string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRIM('[]' FROM '[John Doe]')</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>John Doe</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRIM(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>TRIM(BOTH ' ' FROM string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRIM(' John Doe ')</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>John Doe</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPPER(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert the string to upper case</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPPER('John Doe')</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JOHN DOE</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. Special Functions</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CAST(value AS type)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert the value to the given type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CAST(age AS VARCHAR)</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_lite_members"><a class="anchor" href="#_lite_members"></a>11.6. Lite Members</h3>
<div class="paragraph">
<p>You cannot start SQL queries on lite members. This limitation will be removed in
future releases.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_distributed_sql_works"><a class="anchor" href="#_how_distributed_sql_works"></a>11.7. How Distributed SQL Works</h3>
<div class="paragraph">
<p>When an SQL statement is submitted for execution, the SQL service parses and
optimizes it using Apache Calcite. The result is an executable plan that
is cached and reused by subsequent executions of the same statement.</p>
</div>
<div class="paragraph">
<p>The plan contains a tree of query fragments. A query fragment is a tree of
operators that could be executed on a single member independently. Child
fragments supply data to parent fragments, possibly over a network, until
the root fragment is reached. The root fragment returns the query results.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_distributed_query"><a class="anchor" href="#_distributed_query"></a>12. Distributed Query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Distributed queries access data from multiple data sources stored on
either the same or different members.</p>
</div>
<div class="paragraph">
<p>Hazelcast partitions your data and spreads it across cluster of members.
You can iterate over the map entries and look for certain entries
(specified by predicates) you are interested in. However, this is not
very efficient because you have to bring the entire entry set and iterate
locally. Instead, Hazelcast allows you to run distributed queries on your
distributed map.</p>
</div>
<div class="sect2">
<h3 id="_how_distributed_query_works"><a class="anchor" href="#_how_distributed_query_works"></a>12.1. How Distributed Query Works</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The requested predicate is sent to each member in the cluster.</p>
</li>
<li>
<p>Each member looks at its own local entries and filters them according
to the predicate. At this stage, key/value pairs of the entries are
deserialized and then passed to the predicate.</p>
</li>
<li>
<p>The predicate requester merges all the results coming from each
member into a single set.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Distributed query is highly scalable. If you add new members to the
cluster, the partition count for each member is reduced and thus the
time spent by each member on iterating its entries is reduced. In addition,
the pool of partition threads evaluates the entries concurrently in each
member and the network traffic is also reduced since only filtered data
is sent to the requester.</p>
</div>
<div class="paragraph">
<p>Hazelcast offers the following APIs for distributed query purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Criteria API</p>
</li>
<li>
<p>Distributed SQL Query</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_employee_map_query_example"><a class="anchor" href="#_employee_map_query_example"></a>12.1.1. Employee Map Query Example</h4>
<div class="paragraph">
<p>Assume that you have an "employee" map containing values of
<code>Employee</code> objects, as coded below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee implements Serializable {
    private String name;
    private int age;
    private boolean active;
    private double salary;

    public Employee(String name, int age, boolean active, double salary) {
        this.name = name;
        this.age = age;
        this.active = active;
        this.salary = salary;
    }

    public Employee() {
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public double getSalary() {
        return salary;
    }

    public boolean isActive() {
        return active;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s look for the employees who are active and have an age less
than 30 using the aforementioned APIs (Criteria API and Distributed
SQL Query). The following subsections describe each query mechanism
for this example.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using Portable objects, if one field of an object exists
on one member but does not exist on another one, Hazelcast does not
throw an unknown field exception.
Instead, Hazelcast treats that predicate, which tries to perform a
query on an unknown field, as an always false predicate.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_querying_with_criteria_api"><a class="anchor" href="#_querying_with_criteria_api"></a>12.1.2. Querying with Criteria API</h4>
<div class="paragraph">
<p>Criteria API is a programming interface offered by Hazelcast that
is similar to the Java Persistence Query Language (JPQL). Below
is the code for the <a href="#employee-map-query-example">above example query</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;String, Employee&gt; map = hazelcastInstance.getMap( "employee" );

EntryObject e = Predicates.newPredicateBuilder().getEntryObject();
Predicate predicate = e.is( "active" ).and( e.get( "age" ).lessThan( 30 ) );

Collection&lt;Employee&gt; employees = map.values( predicate );</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example code, <code>predicate</code> verifies whether the entry is
active and its <code>age</code> value is less than 30. This <code>predicate</code> is
applied to the <code>employee</code> map using the <code>map.values(predicate)</code> method.
This method sends the predicate to all cluster members
and merges the results coming from them. Since the predicate is
communicated between the members, it needs to
be serializable.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Predicates can also be applied to <code>keySet</code>, <code>entrySet</code> and
<code>localKeySet</code> of the Hazelcast distributed map.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_predicates_class_operators"><a class="anchor" href="#_predicates_class_operators"></a>Predicates Class Operators</h5>
<div class="paragraph">
<p>The <code>Predicates</code> class includes many operators for your query requirements.
The following are descriptions for some of them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>equal</code>: Checks if the result of an expression is equal to a given value.</p>
</li>
<li>
<p><code>notEqual</code>: Checks if the result of an expression is not equal to a given value.</p>
</li>
<li>
<p><code>instanceOf</code>: Checks if the result of an expression has a certain type.</p>
</li>
<li>
<p><code>like</code>: Checks if the result of an expression matches some string pattern. %
(percentage sign) is the placeholder for many characters,  (underscore) is
placeholder for only one character.</p>
</li>
<li>
<p><code>ilike</code>: A case-insensitive variant of <code>like</code>.</p>
</li>
<li>
<p><code>greaterThan</code>: Checks if the result of an expression is greater than a
certain value.</p>
</li>
<li>
<p><code>greaterEqual</code>: Checks if the result of an expression is greater than or
equal to a certain value.</p>
</li>
<li>
<p><code>lessThan</code>: Checks if the result of an expression is less than a certain
value.</p>
</li>
<li>
<p><code>lessEqual</code>: Checks if the result of an expression is less than or equal
to a certain value.</p>
</li>
<li>
<p><code>between</code>: Checks if the result of an expression is between two values
(this is inclusive).</p>
</li>
<li>
<p><code>in</code>: Checks if the result of an expression is an element of a certain
collection.</p>
</li>
<li>
<p><code>isNot</code>: Checks if the result of an expression is false.</p>
</li>
<li>
<p><code>regex</code>: Checks if the result of an expression matches some regular
expression.</p>
</li>
<li>
<p><code>alwaysTrue</code>: The result of an expression always matches.</p>
</li>
<li>
<p><code>alwaysFalse</code>: The result of an expression ever matches.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/query/Predicates.html" target="_blank" rel="noopener">Predicates Javadoc</a>
for all predicates provided.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_combining_predicates_with_and_or_not"><a class="anchor" href="#_combining_predicates_with_and_or_not"></a>Combining Predicates with AND, OR, NOT</h5>
<div class="paragraph">
<p>You can combine predicates using the <code>and</code>, <code>or</code> and <code>not</code> operators,
as shown in the below examples.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Collection&lt;Employee&gt; getWithNameAndAge( String name, int age ) {
    Predicate namePredicate = Predicates.equal( "name", name );
    Predicate agePredicate = Predicates.equal( "age", age );
    Predicate predicate = Predicates.and( namePredicate, agePredicate );
    return employeeMap.values( predicate );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Collection&lt;Employee&gt; getWithNameOrAge( String name, int age ) {
    Predicate namePredicate = Predicates.equal( "name", name );
    Predicate agePredicate = Predicates.equal( "age", age );
    Predicate predicate = Predicates.or( namePredicate, agePredicate );
    return employeeMap.values( predicate );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Collection&lt;Employee&gt; getNotWithName( String name ) {
    Predicate namePredicate = Predicates.equal( "name", name );
    Predicate predicate = Predicates.not( namePredicate );
    return employeeMap.values( predicate );
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_simplifying_with_predicatebuilder"><a class="anchor" href="#_simplifying_with_predicatebuilder"></a>Simplifying with PredicateBuilder</h5>
<div class="paragraph">
<p>You can simplify predicate usage with the <code>PredicateBuilder</code> interface,
which offers simpler predicate building. See the
below example code which selects all people with a certain name and age.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Collection&lt;Employee&gt; getWithNameAndAgeSimplified( String name, int age ) {
    EntryObject e = Predicates.newPredicateBuilder().getEntryObject();
    Predicate agePredicate = e.get( "age" ).equal( age );
    Predicate predicate = e.get( "name" ).equal( name ).and( agePredicate );
    return employeeMap.values( predicate );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_querying_with_sql"><a class="anchor" href="#_querying_with_sql"></a>12.1.3. Querying with SQL</h4>
<div class="paragraph">
<p><code>Predicates.sql()</code> takes the regular SQL <code>where</code> clause.
Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;String, Employee&gt; map = hazelcastInstance.getMap( "employee" );
Set&lt;Employee&gt; employees = map.values( Predicates.sql( "active AND age &lt; 30" ) );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hazelcast offers an SQL service that allows to execute SQL queries,
as opposed to SQL-like predicates in case of <code>Predicates.sql()</code>. See the
<a href="#sql">SQL chapter</a> for more information.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_supported_sql_syntax"><a class="anchor" href="#_supported_sql_syntax"></a>Supported SQL Syntax</h5>
<div class="paragraph">
<p><strong>AND/OR:</strong> `&lt;expression&gt; AND &lt;expression&gt; AND &lt;expression&gt;&#8230;&#8203; `</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>active AND age&gt;30</code></p>
</li>
<li>
<p><code>active=false OR age = 45 OR name = 'Joe'</code></p>
</li>
<li>
<p><code>active AND ( age &gt; 20 OR salary &lt; 60000 )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Equality:</strong> <code>=, !=, &lt;, &#8656;, &gt;, &gt;=</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;expression&gt; = value</code></p>
</li>
<li>
<p><code>age &#8656; 30</code></p>
</li>
<li>
<p><code>name = 'Joe'</code></p>
</li>
<li>
<p><code>salary != 50000</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>BETWEEN: </strong> <code>&lt;attribute&gt; [NOT] BETWEEN &lt;value1&gt; AND &lt;value2&gt;</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>age BETWEEN 20 AND 33 ( same as age &gt;= 20  AND age &#8656; 33 )</code></p>
</li>
<li>
<p><code>age NOT BETWEEN 30 AND 40 ( same as age &lt; 30 OR age &gt; 40 )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>IN:</strong> <code>&lt;attribute&gt; [NOT] IN (val1, val2,&#8230;&#8203;)</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>age IN ( 20, 30, 40 )</code></p>
</li>
<li>
<p><code>age NOT IN ( 60, 70 )</code></p>
</li>
<li>
<p><code>active AND ( salary &gt;= 50000 OR ( age NOT BETWEEN 20 AND 30 ) )</code></p>
</li>
<li>
<p><code>age IN ( 20, 30, 40 ) AND salary BETWEEN ( 50000, 80000 )</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>LIKE:</strong> <code>&lt;attribute&gt; [NOT] LIKE "expression"</code></p>
</div>
<div class="paragraph">
<p>The <code>%</code> (percentage sign) is placeholder for multiple characters,
an <code>_</code> (underscore) is placeholder for only one character.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name LIKE 'Jo%'</code> (true for 'Joe', 'Josh', 'Joseph' etc.)</p>
</li>
<li>
<p><code>name LIKE 'Jo_'</code> (true for 'Joe'; false for 'Josh')</p>
</li>
<li>
<p><code>name NOT LIKE 'Jo_'</code> (true for 'Josh'; false for 'Joe')</p>
</li>
<li>
<p><code>name LIKE 'J_s%'</code> (true for 'Josh', 'Joseph'; false 'John', 'Joe')</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>ILIKE:</strong> <code>&lt;attribute&gt; [NOT] ILIKE 'expression'</code></p>
</div>
<div class="paragraph">
<p>Similar to LIKE predicate but in a case-insensitive manner.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name ILIKE 'Jo%'</code> (true for 'Joe', 'joe', 'jOe','Josh','joSH', etc.)</p>
</li>
<li>
<p><code>name ILIKE 'Jo_'</code> (true for 'Joe' or 'jOE'; false for 'Josh')</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>REGEX</strong>: <code>&lt;attribute&gt; [NOT] REGEX 'expression'</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name REGEX 'abc-.*'</code> (true for 'abc-123'; false for 'abx-123')</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can escape the <code>%</code> and <code>_</code> placeholder characters in your
SQL queries with predicates using the
backslash (<code>\</code>) character. The apostrophe (<code>'</code>) can be escaped with another
apostrophe, i.e., <code>''</code>. If you use REGEX, you need to escape characters
according to the normal Java escape syntax; see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">here</a>
for the details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_querying_entry_keys_with_predicates"><a class="anchor" href="#_querying_entry_keys_with_predicates"></a>Querying Entry Keys with Predicates</h5>
<div class="paragraph">
<p>You can use <code>__key</code> attribute to perform a predicated search for entry
keys. See the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;String, Person&gt; personMap = hazelcastInstance.getMap(persons);
personMap.put("Alice", new Person("Alice", 35, Gender.FEMALE));
personMap.put("Andy",  new Person("Andy",  37, Gender.MALE));
personMap.put("Bob",   new Person("Bob",   22, Gender.MALE));
[...]
Predicate predicate = Predicates.sql("__key like A%");
Collection&lt;Person&gt; startingWithA = personMap.values(predicate);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the code creates a collection with the entries whose
keys start with the letter "A.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_querying_json_strings"><a class="anchor" href="#_querying_json_strings"></a>12.1.4. Querying JSON Strings</h4>
<div class="paragraph">
<p>You can query JSON strings stored inside your Hazelcast clusters. To
query a JSON string,
you first need to create a <code>HazelcastJsonValue</code> from the JSON string.
You can use <code>HazelcastJsonValue</code>s both as keys and values in the
distributed data structures. Then, it is
possible to query these objects using the Hazelcast query methods
explained in this section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String person1 = "{ \"name\": \"John\", \"age\": 35 }";
String person2 = "{ \"name\": \"Jane\", \"age\": 24 }";
String person3 = "{ \"name\": \"Trey\", \"age\": 17 }";

IMap&lt;Integer, HazelcastJsonValue&gt; idPersonMap = instance.getMap("jsonValues");

idPersonMap.put(1, new HazelcastJsonValue(person1));
idPersonMap.put(2, new HazelcastJsonValue(person2));
idPersonMap.put(3, new HazelcastJsonValue(person3));

Collection&lt;HazelcastJsonValue&gt; peopleUnder21 = idPersonMap.values(Predicates.lessThan("age", 21));</code></pre>
</div>
</div>
<div class="paragraph">
<p>When running the queries, Hazelcast treats values extracted from
the JSON documents as Java types so they
can be compared with the query attribute. JSON specification
defines five primitive types to be used in the JSON
documents: <code>number</code>,<code>string</code>, <code>true</code>, <code>false</code> and <code>null</code>. The <code>string</code>,
<code>true/false</code> and <code>null</code> types are treated
as <code>String</code>, <code>boolean</code> and <code>null</code>, respectively. We treat the extracted
<code>number</code> values as <code>long</code>s if they
can be represented by a <code>long</code>. Otherwise, <code>number</code>s are treated
as <code>double</code>s.</p>
</div>
<div class="paragraph">
<p>It is possible to query nested attributes and arrays in JSON documents.
The query syntax is the same
as querying other Hazelcast objects as explained in the
<a href="#querying-in-collections-and-arrays">Querying in Collections and Arrays section</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Sample JSON object
 *
 * {
 *     "departmentId": 1,
 *     "room": "alpha",
 *     "people": [
 *         {
 *             "name": "Peter",
 *             "age": 26,
 *             "salary": 50000
 *         },
 *         {
 *             "name": "Jonah",
 *             "age": 50,
 *             "salary": 140000
 *         }
 *     ]
 * }
 *
 *
 * The following query finds all the departments that have a person named "Peter" working in them.
 */
Collection&lt;HazelcastJsonValue&gt; departmentWithPeter = departments.values(Predicates.equal("people[any].name", "Peter"));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HazelcastJsonValue</code> is a lightweight wrapper around your JSON strings.
It is used merely as a way to indicate
that the contained string should be treated as a valid JSON value.
Hazelcast does not check the validity of JSON
strings put into to maps. Putting an invalid JSON string in a map is
permissible. However, in that case
whether such an entry is going to be returned or not from a query is not defined.</p>
</div>
<div class="sect4">
<h5 id="_metadata_creation_for_json_querying"><a class="anchor" href="#_metadata_creation_for_json_querying"></a>Metadata Creation for JSON Querying</h5>
<div class="paragraph">
<p>Hazelcast stores a metadata object per <code>HazelcastJsonValue</code> stored.
This metadata object is created every time
a <code>HazelcastJsonValue</code> is put into an IMap. Metadata is later used
to speed up the query operations. Metadata creation
is on by default. Depending on your application&#8217;s needs, you may want
to turn off the metadata creation
to decrease the put latency and increase the throughput. You can configure
this using <a href="#metadata-policy">Metadata Policy</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
JSON metadata is stored on-heap even when you use the <code>NATIVE</code>
in-memory format. If you are storing
<code>HazelcastJsonValue</code>s in your <code>NATIVE</code> maps, there is a certain
amount of on-heap cost per object. Metadata is not created unless you
put <code>HazelcastJsonValue</code>s in your <code>NATIVE</code> maps even when metadata
creation is on.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_filtering_with_paging_predicates"><a class="anchor" href="#_filtering_with_paging_predicates"></a>12.1.5. Filtering with Paging Predicates</h4>
<div class="paragraph">
<p>Hazelcast provides paging for defined predicates. With its <code>PagingPredicate</code>
interface, you can
get a collection of keys, values, or entries page by page by filtering
them with predicates and giving the size of the pages. Also, you
can sort the entries by specifying comparators. In this case, the comparator
should be <code>Serializable</code> and the serialization factory implementations you use,
e.g., <code>PortableFactory</code> and <code>DataSerializableFactory</code>, should be registered.
See the <a href="#serialization">Serialization chapter</a> on how to register these
factories.</p>
</div>
<div class="paragraph">
<p>Paging predicates require the objects to be deserialized both on the calling
side (either a member or client) and the member side from which the collection
is retrieved. Therefore, you need to register the serialization factories
you use on all the members and clients on which the paging predicates are used.
See the <a href="#serialization">Serialization chapter</a> on how to register these
factories.</p>
</div>
<div class="paragraph">
<p>In the example code below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>greaterEqual</code> predicate gets values from the "students" map. This
predicate has a filter
to retrieve the objects with an "age" greater than or equal to 18.</p>
</li>
<li>
<p>Then a <code>PagingPredicate</code> is constructed in which the page size is 5,
so that there are five objects in each page.
The first time the values are called creates the first page.</p>
</li>
<li>
<p>It gets subsequent pages with the <code>nextPage()</code>
method of <code>PagingPredicate</code> and querying the map again with the
updated <code>PagingPredicate</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;Integer, Student&gt; map = hazelcastInstance.getMap( "students" );
Predicate greaterEqual = Predicates.greaterEqual( "age", 18 );
PagingPredicate pagingPredicate = Predicates.pagingPredicate( greaterEqual, 5 );
// Retrieve the first page
Collection&lt;Student&gt; values = map.values( pagingPredicate );
...
// Set up next page
pagingPredicate.nextPage();
// Retrieve next page
values = map.values( pagingPredicate );
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a comparator is not specified for <code>PagingPredicate</code>, but you want
to get a collection of keys or values page by page, this collection must
be an instance of <code>Comparable</code> (i.e., it must implement <code>java.lang.Comparable</code>).
Otherwise, the <code>java.lang.IllegalArgument</code> exception is thrown.</p>
</div>
<div class="paragraph">
<p>You can also access a specific page more
easily with the help of the <code>setPage()</code> method. This way, if you make
a query for the hundredth page, for example, it gets all 100 pages at
once instead of reaching the hundredth page one by one using the <code>nextPage()</code> method.
Note that this feature tires the memory and see the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/query/PagingPredicate.html" target="_blank" rel="noopener">PagingPredicate Javadoc</a>.</p>
</div>
<div class="paragraph">
<p>Paging Predicate, also known as Order &amp; Limit, is not supported in
Transactional Context.</p>
</div>
</div>
<div class="sect3">
<h4 id="_filtering_with_partition_predicate"><a class="anchor" href="#_filtering_with_partition_predicate"></a>12.1.6. Filtering with Partition Predicate</h4>
<div class="paragraph">
<p>You can run queries on a single partition in your cluster using
the partition predicate (<code>PartitionPredicate</code>).</p>
</div>
<div class="paragraph">
<p>The <code>Predicates.partitionPredicate()</code> method takes a predicate and partition key
as parameters, gets the partition ID using the key and  runs that predicate only
on the partition where that key belongs.</p>
</div>
<div class="paragraph">
<p>See the following code snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
Predicate predicate = Predicates.partitionPredicate(partitionKey, Predicates.alwaysTrue());

Collection&lt;Integer&gt; values = map.values(predicate);
Collection&lt;String&gt; keys = map.keySet(predicate);
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default there are 271 partitions, and using a regular predicate,
each partition needs to be accessed. However, if the
partition predicate only accesses a single partition, this can lead
to a big performance gain.</p>
</div>
<div class="paragraph">
<p>For the partition predicate to work correctly, you need to know which
partition your data belongs to so that you can send the
request to the correct partition. One of the ways of doing it is to
make use of the <code>PartitionAware</code> interface when data is
inserted, thereby controlling the owning partition. See the
<a href="#partitionaware">PartitionAware section</a> for more information and examples.</p>
</div>
<div class="paragraph">
<p>A concrete example may be a web shop that sells phones and accessories.
To find all the accessories of a phone,
a query could be executed that selects all accessories for that phone.
This query is executed on all members in the cluster and
therefore could generate quite a lot of load. However, if we would store
the accessories in the same partition as the phone, the
partition predicate could use the <code>partitionKey</code> of the phone to select
the right partition and then it queries for
the accessories for that phone; and this reduces the load on the system
and get faster query results.</p>
</div>
</div>
<div class="sect3">
<h4 id="_indexing_queries"><a class="anchor" href="#_indexing_queries"></a>12.1.7. Indexing Queries</h4>
<div class="paragraph">
<p>Hazelcast distributed queries run on each member in parallel and return
only the results to the caller.
Then, on the caller side, the results are merged.</p>
</div>
<div class="paragraph">
<p>When a query runs on a
member, Hazelcast iterates through all the owned entries and finds the
matching ones. This can be made faster by indexing
the most-queried fields, just like you would do for your database.
Indexing adds overhead for each write
operation but reading will be a lot faster. If you query your map a
lot, make sure to add indexes for the most frequently
queried fields. For example, if you do <code>active AND age &lt; 30</code> query,
make sure you add an index for the <code>active</code> and
<code>age</code> fields. The following example code does that by getting the map
from the Hazelcast instance and adding indexes to the map with the
IMap <code>addIndex</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap map = hazelcastInstance.getMap( "employees" );
// ordered, since we have ranged queries for this field
map.addIndex(new IndexConfig(IndexType.SORTED, "age"));
// not ordered, because boolean field cannot have range
map.addIndex(new IndexConfig(IndexType.HASH, "active"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that creating indexes once is sufficient. Subsequent write
operations on the map are reflected in the index automatically. So,
although it is safe to call the <code>addIndex()</code> method repeatedly, there
will be a performance penalty due to the redundant index creation.</p>
</div>
<div class="paragraph">
<p>When you call, for example, <code>map.addIndex("fieldName", true)</code>, each
partition iterates over its records and adds each entry to the index.
The previously created index entry will be recreated and replaced with the new entry.
The performance penalty will be proportional to the number of entries. If you
have maps with a large number of entries, then synchronizing index addition process
is recommended.</p>
</div>
<div class="paragraph">
<p>Other than using the <code>addIndex()</code> method, you can define your index
declaratively or programmatically as described in the <a href="#configuring-imap-indexes">Configuring IMap Indexes section</a>.</p>
</div>
<div class="sect4">
<h5 id="_indexing_ranged_queries"><a class="anchor" href="#_indexing_ranged_queries"></a>Indexing Ranged Queries</h5>
<div class="paragraph">
<p><code>IMap.addIndex(IndexConfig)</code> is used for adding index. For
each indexed field, if you have ranged queries such as <code>age&gt;30</code>,
<code>age BETWEEN 40 AND 60</code>, then use <code>IndexType.SORTED</code> index
Otherwise, use <code>IndexType.HASH</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_imap_indexes"><a class="anchor" href="#_configuring_imap_indexes"></a>Configuring IMap Indexes</h5>
<div class="paragraph">
<p>Also, you can define <code>IMap</code> indexes in configuration. An example is
shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;indexes&gt;
            &lt;index type="HASH"&gt;
                &lt;attributes&gt;
                    &lt;attribute&gt;name&lt;/attribute&gt;
                &lt;/attributes&gt;
            &lt;/index&gt;
            &lt;index&gt;
                &lt;attributes&gt;
                    &lt;attribute&gt;age&lt;/attribute&gt;
                &lt;/attributes&gt;
            &lt;/index&gt;
        &lt;/indexes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      indexes:
        - type: HASH
            attributes:
              - "name"
        - attributes:
            - "age"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:map name="default"&gt;
    &lt;hz:indexes&gt;
        &lt;hz:index type="HASH"&gt;
            &lt;hz:attributes&gt;
                &lt;hz:attribute&gt;name&lt;/hz:attribute&gt;
            &lt;/hz:attributes&gt;
        &lt;/hz:index&gt;
        &lt;hz:index&gt;
            &lt;hz:attributes&gt;
                &lt;hz:attribute&gt;age&lt;/hz:attribute&gt;
            &lt;/hz:attributes&gt;
        &lt;/hz:index&gt;
    &lt;/hz:indexes&gt;
&lt;/hz:map&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also define <code>IMap</code> indexes using programmatic configuration,
as in the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mapConfig.addIndexConfig(new IndexConfig(IndexType.HASH, "name"));
mapConfig.addIndexConfig(new IndexConfig(IndexType.SORTED, "age"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the Spring declarative configuration for the same
example.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Non-primitive types to be indexed should implement <strong><code>Comparable</code></strong>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you configure the data structure to use
<a href="#configuring-high-density-memory-store">High-Density Memory Store</a> <strong>and</strong>
indexes, the indexes are automatically stored in the High-Density Memory Store
as well. This prevents from running into full garbage collections when doing
a lot of updates to index.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_composite_indexes"><a class="anchor" href="#_composite_indexes"></a>Composite Indexes</h5>
<div class="paragraph">
<p>Composite indexes, also known as compound indexes, are special kind of
indexes that are built on top of the multiple map entry attributes and
therefore may be used to significantly speed up the queries involving
those attributes simultaneously.</p>
</div>
<div class="paragraph">
<p>There are two distinct composite index types used for two different
purposes: unordered composite indexes and ordered ones.</p>
</div>
<div class="sect5">
<h6 id="_unordered_composite_indexes"><a class="anchor" href="#_unordered_composite_indexes"></a>Unordered Composite Indexes</h6>
<div class="paragraph">
<p>The unordered indexes are used to perform equality queries, also known
as the point queries, e.g., <code>name = 'Alice'</code>. These are specifically
optimized for equality queries and don&#8217;t support other comparison operators
like <code>&gt;</code> or <code>&lt;=</code>.</p>
</div>
<div class="paragraph">
<p>Additionally, the <em>composite</em> unordered indexes allow speeding up the equality
queries involving multiple attributes simultaneously, e.g., <code>name = 'Alice'
and age = 33</code>. This example query results in a single composite index lookup
operation which can be performed very efficiently.</p>
</div>
<div class="paragraph">
<p>The unordered composite index on the <code>name</code> and <code>age</code> attributes may be
configured for a map as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="persons"&gt;
        &lt;indexes&gt;
            &lt;index type="HASH"&gt;
                &lt;attributes&gt;
                    &lt;attribute&gt;name&lt;/attribute&gt;
                    &lt;attribute&gt;age&lt;/attribute&gt;
                &lt;/attributes&gt;
            &lt;/index&gt;
        &lt;/indexes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      - type: HASH
          attributes:
            - "name"
            - "age"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attributes indexed by the <em>unordered</em> composite indexes can&#8217;t be
matched partially: the <code>name = 'Alice'</code> query can&#8217;t utilize the composite
index configured above.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ordered_composite_indexes"><a class="anchor" href="#_ordered_composite_indexes"></a>Ordered Composite Indexes</h6>
<div class="paragraph">
<p>The ordered indexes are specifically designed to perform efficient order
comparison queries, also known as the range queries, e.g., <code>age &gt; 33</code>. The
equality queries, like <code>age = 33</code>, are still supported by the ordered indexes,
but they are handled in a slightly less efficient manner comparing to the
unordered indexes.</p>
</div>
<div class="paragraph">
<p>The <em>composite</em> ordered indexes extend the concept by allowing multiple
equality predicates and a single order comparison predicate to be combined
into a single index query operation. For instance, the <code>name = 'Alice' and
age &gt; 33</code> and <code>name = 'Bob' and age = 33 and balance &gt; 0.0</code> queries are good
candidates to be covered by an ordered composite index configured as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="persons"&gt;
        &lt;indexes&gt;
            &lt;index&gt;
                &lt;attributes&gt;
                    &lt;attribute&gt;name&lt;/attribute&gt;
                    &lt;attribute&gt;age&lt;/attribute&gt;
                    &lt;attribute&gt;balance&lt;/attribute&gt;
                &lt;/attributes&gt;
            &lt;/index&gt;
        &lt;/indexes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    persons:
      indexes:
        - attributes:
          - "name"
          - "age"
          - "balance"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the <em>unordered</em> composite indexes, partial attribute prefixes may be
matched for the <em>ordered</em> composite indexes. In general, a valid non-empty
attribute prefix is formed as a sequence of zero or more equality predicates
followed by a zero or exactly one order comparison predicate. Given the index
definition above, the following queries may be served by the index: <code>name = 'Alice'</code>,
<code>name &gt; 'Alice'</code>, <code>name = 'Alice' and age &gt; 33</code>, <code>name = 'Alice' and age = 33 and
balance = 5.0</code>. The following queries can&#8217;t be served the index: <code>age = 33</code>,
<code>age &gt; 33 and balance = 0.0</code>, <code>balance &gt; 0.0</code>.</p>
</div>
<div class="paragraph">
<p>While matching the ordered composite indexes, multiple order comparison
predicates acting on the same attribute are treated as a single range
predicate acting on that attribute. Given the index definition above, the
following queries may be served by the index: <code>name &gt; 'Alice' and name &lt; 'Bob'</code>,
<code>name = 'Alice' and age &gt; 33 and age &lt; 55</code>, <code>name = 'Alice' and age = 33 and
balance &gt; 0.0 and balance &lt; 100.0</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_composite_index_matching_and_selection"><a class="anchor" href="#_composite_index_matching_and_selection"></a>Composite Index Matching and Selection</h6>
<div class="paragraph">
<p>The order of attributes involved in a query plays no role in the selection
of the matching composite index: <code>name = 'Alice' and age = 33</code> and
<code>age = 33 and name = 'Alice'</code> queries are equivalent from the point of
view of the index matching procedure.</p>
</div>
<div class="paragraph">
<p>The attributes involved in a query can be matched partially by the composite
index matcher: <code>name = 'Alice' and age = 33 and balance &gt; 0.0</code> can be
partially matched by the <code>name, age</code> composite index, the <code>name = 'Alice'
and age = 33</code> predicates are served by the matched index, while the
<code>balance &gt; 0.0</code> predicate is processed by other means.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_bitmap_indexes"><a class="anchor" href="#_bitmap_indexes"></a>Bitmap Indexes</h5>
<div class="paragraph">
<p>Bitmap indexes provide capabilities similar to unordered/hash indexes.
The same set of predicates is supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>equal</code></p>
</li>
<li>
<p><code>notEqual</code></p>
</li>
<li>
<p><code>in</code>,</p>
</li>
<li>
<p><code>and</code></p>
</li>
<li>
<p><code>or</code></p>
</li>
<li>
<p><code>not</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But, unlike hash indexes, bitmap indexes are able
to achieve a much higher memory efficiency for low cardinality attributes
at the cost of reduced query performance. In practice, the query
performance is comparable to the performance of hash indexes, while
memory footprint reduction is high, usually around an order of magnitude.</p>
</div>
<div class="paragraph">
<p>Bitmap indexes are specifically designed for indexing of collection and
array attributes since a single <code>IMap</code> entry produces many index entries
in that case. A single hash index entry costs a few tens of bytes, while
a single bitmap index entry usually costs just a few bytes.</p>
</div>
<div class="paragraph">
<p>It&#8217;s also possible to improve the memory footprint while indexing regular
single-value attributes, but the improvement is usually minor, depending
on the data layout and total number of indexes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, bitmap indexes are not supported by off-heap High-Density
Memory Stores (HD).
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_configuring_bitmap_indexes"><a class="anchor" href="#_configuring_bitmap_indexes"></a>Configuring Bitmap Indexes</h6>
<div class="paragraph">
<p>In the simplest form, bitmap index for an <code>IMap</code> entry attribute can be
declaratively configured as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="persons"&gt;
        &lt;indexes&gt;
            &lt;index type="BITMAP"&gt;
                &lt;attributes&gt;
                    &lt;attribute&gt;age&lt;/attribute&gt;
                &lt;/attributes&gt;
            &lt;/index&gt;
        &lt;/indexes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    persons:
      indexes:
        - type: BITMAP
          attributes:
            - "age"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Internally, a unique non-negative <code>long</code> ID is assigned to every
indexed <code>IMap</code> entry based on the entry key. That unique ID is
required for bitmap indexes to distinguish one indexed <code>IMap</code> entry from
another.</p>
</div>
<div class="paragraph">
<p>The mapping between <code>IMap</code> entries and <code>long</code> IDs is not free and its
performance and memory footprint can be improved in certain cases. For
instance, if <code>IMap</code> entries already have a unique integer-valued
attribute, the attribute values can be used as unique <code>long</code> IDs
directly without any additional transformations. That can be configured
as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;age&lt;/attribute&gt;
    &lt;/attributes&gt;
    &lt;bitmap-index-options&gt;
        &lt;unique-key&gt;uniqueId&lt;/unique-key&gt;
        &lt;unique-key-transformation&gt;RAW&lt;/unique-key-transformation&gt;
    &lt;/bitmap-index-options&gt;
&lt;/index&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">indexes:
  - type: BITMAP
    attributes:
      - "age"
    bitmap-index-options:
      unique-key: uniqueId
      unique-key-transformation: RAW</code></pre>
</div>
</div>
<div class="paragraph">
<p>The index definition above instructs Hazelcast to create a bitmap index
on the <code>age</code> attribute, extract the unique key values from <code>uniqueId</code> attribute
and use the raw (<code>RAW</code>) extracted values directly as <code>long</code> IDs. If the
extracted unique key value is not of <code>long</code> type, the widening
conversion is performed for the following types: <code>byte</code>, <code>short</code> and
<code>int</code>; boxed variants are also supported.</p>
</div>
<div class="paragraph">
<p>In certain cases, the extracted raw IDs might be randomly distributed.
This causes increased memory usage in bitmap indexes since the best case
scenario for them is sequential contiguous IDs. That can be countered by
applying the renumbering technique:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;age&lt;/attribute&gt;
    &lt;/attributes&gt;
    &lt;bitmap-index-options&gt;
        &lt;unique-key&gt;uniqueId&lt;/unique-key&gt;
        &lt;unique-key-transformation&gt;LONG&lt;/unique-key-transformation&gt;
    &lt;/bitmap-index-options&gt;
&lt;/index&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">indexes:
  - type: BITMAP
    attributes:
      - "age"
    bitmap-index-options:
      unique-key: uniqueId
      unique-key-transformation: LONG</code></pre>
</div>
</div>
<div class="paragraph">
<p>The index definition above instructs the bitmap index to extract the unique
keys from <code>uniqueId</code> attribute, convert every extracted non-negative
value to <code>long</code> (<code>LONG</code>) and assign an internal sequential unique <code>long</code>
ID based on that extracted and then converted unique value. The widening
conversion is applied to the extracted values, if necessary.</p>
</div>
<div class="paragraph">
<p>This long-to-long mapping is performed more efficiently than the general
object-to-long mapping done for the simple index definitions. Basically,
the following simple bitmap index definition:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;age&lt;/attribute&gt;
    &lt;/attributes&gt;
&lt;/index&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">indexes:
  - type: BITMAP
    attributes:
      - "age"</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to the following full-form definition:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;age&lt;/attribute&gt;
    &lt;/attributes&gt;
    &lt;bitmap-index-options&gt;
        &lt;unique-key&gt;__key&lt;/unique-key&gt;
        &lt;unique-key-transformation&gt;OBJECT&lt;/unique-key-transformation&gt;
    &lt;/bitmap-index-options&gt;
&lt;/index&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">indexes:
  - type: BITMAP
    attributes:
      - "age"
    bitmap-index-options:
      unique-key: __key
      unique-key-transformation: OBJECT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which indexes <code>age</code> attribute, uses <code>IMap</code> entry keys (<code>__key</code>) interpreted
as Java objects (<code>OBJECT</code>) to assign internal unique <code>long</code> IDs.</p>
</div>
<div class="paragraph">
<p>The full-form definition syntax is defined as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;&lt;attr&gt;&lt;/attribute&gt;
    &lt;/attributes&gt;
    &lt;bitmap-index-options&gt;
        &lt;unique-key&gt;&lt;key&gt;&lt;/unique-key&gt;
        &lt;unique-key-transformation&gt;&lt;transformation&gt;&lt;/unique-key-transformation&gt;
    &lt;/bitmap-index-options&gt;
&lt;/index&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">indexes:
  - type: BITMAP
    attributes:
      - &lt;attribute&gt;
    bitmap-index-options:
      unique-key: &lt;key&gt;
      unique-key-transformation: &lt;transformation&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the parameter descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;attr&gt;</code>: Specifies the attribute index.</p>
</li>
<li>
<p><code>&lt;key&gt;</code>: Specifies the attribute to use as a unique key source
for internal unique <code>long</code> ID assignment.</p>
</li>
<li>
<p><code>&lt;transformation&gt;</code>: Specifies the transformation to be applied
to unique keys to generate unique <code>long</code> IDs from them. The following
transformations are supported:</p>
<div class="ulist">
<ul>
<li>
<p><code>OBJECT</code>: Object-to-long transformation. Each extracted unique
key value is interpreted as a Java object instance. Internally, an
object-to-long hash table is used to establish the mapping from unique
keys to unique IDs. Good as a general-purpose transformation.</p>
</li>
<li>
<p><code>LONG</code>: Long-to-long transformation. Each extracted unique key value
is interpreted as a non-negative <code>long</code> value, the widening conversion
from <code>byte</code>, <code>short</code> and <code>int</code> is performed, if necessary.
Internally, a long-to-long hash table is used to establish the mapping
from unique keys to unique IDs, which is more efficient than the
object-to-long hash table. It is good for sparse/random unique integer-valued keys
renumbering to raise the IDs density and to make the bitmap index more
memory-efficient as a result.</p>
</li>
<li>
<p><code>RAW</code>: Raw transformation. Each extracted unique key value is interpreted as
a non-negative <code>long</code> value, the widening conversion from <code>byte</code>, <code>short</code> and
<code>int</code> is performed, if necessary. Internally, no hash table of any kind is
used to establish the mapping from unique keys to unique IDs, the raw extracted
keys are used directly as IDs. It is good for dense unique integer-valued keys,
and it has the best performance in terms of time and memory.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The regular dotted attribute path syntax is supported for <code>&lt;attr&gt;</code> and
<code>&lt;key&gt;</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;name.first&lt;/attribute&gt;
    &lt;/attributes&gt;
&lt;/index&gt;
&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;name.first&lt;/attribute&gt;
    &lt;/attributes&gt;
    &lt;bitmap-index-options&gt;
        &lt;unique-key&gt;__key.id&lt;/unique-key&gt;
    &lt;/bitmap-index-options&gt;
&lt;/index&gt;
&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;name.first&lt;/attribute&gt;
    &lt;/attributes&gt;
    &lt;bitmap-index-options&gt;
        &lt;unique-key&gt;id.external&lt;/unique-key&gt;
    &lt;/bitmap-index-options&gt;
&lt;/index&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">indexes:
  - type: BITMAP
    attributes:
      - name.first
  - type: BITMAP
    attributes:
      - name.first
    bitmap-index-options:
      unique-key: __key.id
  - type: BITMAP
    attributes:
      - name.first
    bitmap-index-options:
      unique-key: id.external</code></pre>
</div>
</div>
<div class="paragraph">
<p>Collection and array indexing is also possible using the regular syntax:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;habits[any]&lt;/attribute&gt;
    &lt;/attributes&gt;
&lt;/index&gt;
&lt;index type="BITMAP"&gt;
    &lt;attributes&gt;
        &lt;attribute&gt;habits[0]&lt;/attribute&gt;
    &lt;/attributes&gt;
&lt;/index&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">indexes:
  - type: BITMAP
    attributes:
      - habits[any]
  - type: BITMAP
    attributes:
      - habits[0]</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#indexing-in-collections-and-arrays">Indexing in Collections and Arrays section</a>
for more details.</p>
</div>
</div>
<div class="sect5">
<h6 id="_bitmap_index_querying"><a class="anchor" href="#_bitmap_index_querying"></a>Bitmap Index Querying</h6>
<div class="paragraph">
<p>Bitmap index matching and selection for queries are performed
automatically. No special treatment is required. The querying can be
performed using the regular <code>IMap</code> querying methods:
<code>IMap.values(Predicate)</code>, <code>IMap.entrySet(Predicate)</code>, etc.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_copying_indexes"><a class="anchor" href="#_copying_indexes"></a>Copying Indexes</h5>
<div class="paragraph">
<p>The underlying data structures used by the indexes need to copy the
query results to make sure that the results are correct. This copying
process is performed either when reading the index from the data
structure (on-read) or writing to it (on-write).</p>
</div>
<div class="paragraph">
<p>On-read copying means that, for each index-read operation, the result
of the query is copied before it is sent to the caller. Depending on
the query result&#8217;s size, this type of index copying may be slower since
the result is stored in a map, i.e., all entries need to have the hash
calculated before being stored. Unlike the index-read operations, each
index-write operation is fast, since there is no copying. So, this
option can be preferred in index-write intensive cases.</p>
</div>
<div class="paragraph">
<p>On-write copying means that each index-write operation completely copies
the underlying map to provide the copy-on-write semantics and this may
be a slow operation depending on the index size. Unlike index-write operations,
each index-read operation is fast since the operation only includes accessing
the map that stores the results and returning them to the caller.</p>
</div>
<div class="paragraph">
<p>Another option is never copying the results of a query to a separate map.
This means the results backed by the underlying index-map can change after
the query has been executed (such as an entry might have been added or removed
from an index, or it might have been remapped). This option can be preferred
if you expect "mostly correct" results, i.e., if it is not a problem when
some entries returned in the query result set do not match the initial query
criteria. This is the fastest option since there is no copying.</p>
</div>
<div class="paragraph">
<p>You can set one these options using the system property
<code>hazelcast.index.copy.behavior</code>. The following values, which are explained
in the above paragraphs, can be set:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>COPY_ON_READ</code> (the default value)</p>
</li>
<li>
<p><code>COPY_ON_WRITE</code></p>
</li>
<li>
<p><code>NEVER</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Usage of this system property is supported for BINARY and OBJECT
in-memory formats. Only in Hazelcast 3.8.7, it is also supported for
NATIVE in-memory format.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_indexing_attributes_with_valueextractor"><a class="anchor" href="#_indexing_attributes_with_valueextractor"></a>Indexing Attributes with ValueExtractor</h5>
<div class="paragraph">
<p>You can also define custom attributes that may be referenced in predicates,
queries and indexes. Custom attributes can be defined by implementing a
<code>ValueExtractor</code>. See the <a href="#custom-attributes">Custom Attributes section</a>
for details.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_this_as_an_attribute"><a class="anchor" href="#_using_this_as_an_attribute"></a>Using "this" as an Attribute</h5>
<div class="paragraph">
<p>You can use the keyword <code>this</code> as an attribute name while adding an
index or creating a predicate. A basic usage is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">map.addIndex(new IndexConfig(IndexType.SORTED, "this"));
Predicate&lt;Integer, Integer&gt; lessEqual = Predicates.between("this", 12, 20);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another basic example using <code>SQL</code> predicate is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Predicates.sql("this = 'jones'")
Predicates.sql("this.age &gt; 33")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The special attribute <code>this</code> acts on the value of a map entry. Typically,
you do not need to specify it while accessing a property of an entry&#8217;s
value, since its presence is implicitly assumed if the special attribute
<a href="#querying-entry-keys-with-predicates">__key</a> is not specified.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_query_thread_pool"><a class="anchor" href="#_configuring_query_thread_pool"></a>12.1.8. Configuring Query Thread Pool</h4>
<div class="paragraph">
<p>You can change the size of thread pool dedicated to query operations
using the <code>pool-size</code> property. Each query consumes a single thread
from a Generic Operations ThreadPool on each Hazelcast member - let&#8217;s
call it the query-orchestrating thread.  That thread is blocked throughout
the whole execution-span of a query on the member.</p>
</div>
<div class="paragraph">
<p>The query-orchestrating thread uses the threads from the query-thread
pool in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if you run a <code>PagingPredicate</code> (since each page runs as a separate task)</p>
</li>
<li>
<p>if you set the system property <code>hazelcast.query.predicate.parallel.evaluation</code>
to true (since the predicates are evaluated in parallel)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#filtering-with-paging-predicates">Filtering with Paging Predicates section</a>
and <a href="#parallel-predicates">System Properties appendix</a> for information on paging
predicates and for description of the above system property.</p>
</div>
<div class="paragraph">
<p>Below is an example of that declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;executor-service name="hz:query"&gt;
        &lt;pool-size&gt;100&lt;/pool-size&gt;
    &lt;/executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  executor-service:
    "hz:query":
      pool-size: 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is the equivalent programmatic configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config cfg = new Config();
cfg.getExecutorConfig("hz:query").setPoolSize(100);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_query_requests_from_clients"><a class="anchor" href="#_query_requests_from_clients"></a>Query Requests from Clients</h5>
<div class="paragraph">
<p>When dealing with the query requests coming from the clients to your
members, Hazelcast offers the following system properties to tune your
thread pools:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.clientengine.thread.count</code> which is the number of threads
to process non-partition-aware client requests, like <code>map.size()</code> and
executor tasks. Its default value is the number of cores multiplied by 20.</p>
</li>
<li>
<p><code>hazelcast.clientengine.query.thread.count</code> which is the number of
threads to process query requests coming from the clients. Its default
value is the number of cores.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there are a lot of query request from the clients, you may want to
increase the value of <code>hazelcast.clientengine.query.thread.count</code>. In
addition to this tuning, you may also consider increasing the value of
<code>hazelcast.clientengine.thread.count</code> if the CPU load in your system is
not high and there is plenty of free memory.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_querying_in_collections_and_arrays"><a class="anchor" href="#_querying_in_collections_and_arrays"></a>12.2. Querying in Collections and Arrays</h3>
<div class="paragraph">
<p>Hazelcast allows querying in collections and arrays.
Querying in collections and arrays is compatible with all Hazelcast
serialization methods, including the Portable serialization.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a look at the following data structure expressed in pseudo-code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class Motorbike {
    Wheel[] wheels;
}

class Wheel {
   String name;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to query a single element of a collection/array, you can execute the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// it matches all motorbikes where the zero wheel's name is 'front-wheel'
Predicate p = Predicates.equal("wheels[0].name", "front-wheel");
Collection&lt;Motorbike&gt; result = map.values(p);</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to query a collection/array using the <code>any</code> semantic as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// it matches all motorbikes where any wheel's name is 'front-wheel'
Predicate p = Predicates.equal("wheels[any].name", "front-wheel");
Collection&lt;Motorbike&gt; result = map.values(p);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The exact same query may be executed using the <code>SQL</code> predicate as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Predicate p = Predicates.sql("wheels[any].name = 'front-wheel'");
Collection&lt;Motorbike&gt; result = map.values(p);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>[]</code> notation applies to both collections and arrays.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hazelcast requires all elements of a collection to have the same type. Considering
and expanding the above example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you have a <code>wheels</code> collection attribute, all of its elements must be of
the <code>Wheel</code> type, subclasses of <code>Wheel</code> are not allowed.</p>
</li>
<li>
<p>Lets say you have added a <code>seats</code> collection attribute, which is a <code>Seat</code>
object.  Then all of its elements must of this concrete <code>Seat</code> type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, you may have collections of different types in your map. However, each
collections elements must be of the same concrete type within that collection
attribute.</p>
</div>
<div class="paragraph">
<p>Consider custom attribute extractors if it is impossible or undesirable to reduce
the variety of types to a single type. See the <a href="#custom-attributes">Custom Attributes section</a>
for information on them.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_indexing_in_collections_and_arrays"><a class="anchor" href="#_indexing_in_collections_and_arrays"></a>12.2.1. Indexing in Collections and Arrays</h4>
<div class="paragraph">
<p>You can also create an index using a query in collections and arrays.</p>
</div>
<div class="paragraph">
<p>Please note that in order to leverage the index, the attribute name used
in the query has to be the same as the one used
in the index definition.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume you have the following index definition:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;indexes&gt;
        &lt;index type="HASH"&gt;
            &lt;attributes&gt;
                &lt;attribute&gt;wheels[any].name&lt;/attribute&gt;
            &lt;/attributes&gt;
        &lt;/index&gt;
    &lt;/indexes&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  indexes:
    - type: HASH
      attributes:
        - wheels.[any].name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query uses the index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Predicate p = Predicates.equal("wheels[any].name", "front-wheel");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query, however, does NOT leverage the index, since it does
not use exactly the same attribute name that
was used in the index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Predicates.equal("wheels[0].name", "front-wheel")</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to use the index in the case mentioned above, you have to create
another index, as shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;indexes&gt;
        &lt;index type="HASH"&gt;
            &lt;attributes&gt;
                &lt;attribute&gt;wheels[0].name&lt;/attribute&gt;
            &lt;/attributes&gt;
        &lt;/index&gt;
    &lt;/indexes&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  indexes:
    - type: HASH
      attributes:
        - wheels.[0].name</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_corner_cases"><a class="anchor" href="#_corner_cases"></a>12.2.2. Corner cases</h4>
<div class="paragraph">
<p>Handling of corner cases may be a bit different than in a programming
language like <code>Java</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a look at the following examples in order to understand the differences.
To make the analysis simpler, let&#8217;s assume that there is only one <code>Motorbike</code>
object stored in a Hazelcast Map.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 9.0909%;">
<col style="width: 45.4545%;">
<col style="width: 27.2727%;">
<col style="width: 9.0909%;">
<col style="width: 9.091%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Id</th>
<th class="tableblock halign-left valign-top">Query</th>
<th class="tableblock halign-left valign-top">Data State</th>
<th class="tableblock halign-left valign-top">Extraction Result</th>
<th class="tableblock halign-left valign-top">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicates.equal("wheels[7].name", "front-wheel")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wheels.size() == 1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicates.equal("wheels[7].name", null)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wheels.size() == 1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicates.equal("wheels[0].name", "front-wheel")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wheels[0].name == null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicates.equal("wheels[0].name", null)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wheels[0].name == null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicates.equal("wheels[0].name", "front-wheel")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wheels[0] == null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicates.equal("wheels[0].name", null)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wheels[0] == null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicates.equal("wheels[0].name", "front-wheel")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wheels == null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicates.equal("wheels[0].name", null)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wheels == null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>As you can see, <strong>no</strong> <code>NullPointerException</code>s or <code>IndexOutOfBoundException</code>s
are thrown in the extraction process, even
though parts of the expression are <code>null</code>.</p>
</div>
<div class="paragraph">
<p>Looking at examples 4, 6 and 8, we can also easily notice that it is impossible to
distinguish which part of the
expression was null.
If we execute the following query <code>wheels[1].name = null</code>, it may be evaluated to
true because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wheels</code> collection/array is null</p>
</li>
<li>
<p><code>index == 1</code> is out of bound</p>
</li>
<li>
<p><code>name</code> attribute of the wheels[1] object is <code>null</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to make the query unambiguous, extra conditions would have to be added, e.g.,
<code>wheels != null AND wheels[1].name = null</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_attributes"><a class="anchor" href="#_custom_attributes"></a>12.3. Custom Attributes</h3>
<div class="paragraph">
<p>It is possible to define a custom attribute that may be referenced in predicates,
queries and indexes.</p>
</div>
<div class="paragraph">
<p>A custom attribute is a "synthetic" attribute that does not exist as a <code>field</code> or
a <code>getter</code> in the object that it is extracted from.
Thus, it is necessary to define the policy on how the attribute is supposed to be
extracted.
Currently the only way to extract a custom attribute is to implement a
<code>com.hazelcast.query.extractor.ValueExtractor</code>
that encompasses the extraction logic.</p>
</div>
<div class="paragraph">
<p>Custom Attributes are compatible with all Hazelcast serialization methods,
including the Portable serialization.</p>
</div>
<div class="sect3">
<h4 id="_implementing_a_valueextractor"><a class="anchor" href="#_implementing_a_valueextractor"></a>12.3.1. Implementing a ValueExtractor</h4>
<div class="paragraph">
<p>In order to implement a <code>ValueExtractor</code>, implement the
<code>com.hazelcast.query.extractor.ValueExtractor</code> interface
and the <code>extract()</code> method. This method does not return any values
since the extracted value is collected by the <code>ValueCollector</code>.
In order to return multiple results from a single extraction, invoke the
<code>ValueCollector.collect()</code> method
multiple times, so that the collector collects all results.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/query/extractor/ValueExtractor.html" target="_blank" rel="noopener">ValueExtractor</a> and
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/query/extractor/ValueCollector.html" target="_blank" rel="noopener">ValueCollector</a> Javadocs.</p>
</div>
<div class="sect4">
<h5 id="_valueextractor_with_portable_serialization"><a class="anchor" href="#_valueextractor_with_portable_serialization"></a>ValueExtractor with Portable Serialization</h5>
<div class="paragraph">
<p>Portable serialization is a special kind of serialization where there
is no need to have the class of the serialized object on the
classpath in order to read its attributes. That is the reason why the
target object passed to the <code>ValueExtractor.extract()</code>
method is not of the exact type that has been stored. Instead, an instance
of a <code>com.hazelcast.query.extractor.ValueReader</code> is passed.
<code>ValueReader</code> enables reading the attributes of a Portable object in a
generic and type-agnostic way.
It contains two methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>read(String path, ValueCollector&lt;T&gt; collector)</code> - enables passing all
results directly to the <code>ValueCollector</code>.</p>
</li>
<li>
<p><code>read(String path, ValueCallback&lt;T&gt; callback)</code> - enables filtering, transforming
and grouping the result of the read operation and manually passing it to the
<code>ValueCollector</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/query/extractor/ValueReader.html" target="_blank" rel="noopener">ValueReader</a> Javadoc.</p>
</div>
</div>
<div class="sect4">
<h5 id="_returning_multiple_values_from_a_single_extraction"><a class="anchor" href="#_returning_multiple_values_from_a_single_extraction"></a>Returning Multiple Values from a Single Extraction</h5>
<div class="paragraph">
<p>It sounds counter-intuitive, but a single extraction may return multiple
values when arrays or collections are
involved.
Let&#8217;s have a look at the following data structure in pseudo-code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class Motorbike {
    Wheel[] wheel;
}

class Wheel {
    String name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we want to extract the names of all wheels from a
single motorbike object. Each motorbike has two
wheels so there are two names for each bike. In order to return both
values from the extraction operation, collect them
separately using the <code>ValueCollector</code>. Collecting multiple values in
this way allows you to operate on these multiple
values as if they were single values during the evaluation of the predicates.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we registered a custom extractor with the name <code>wheelName</code>
and executed the following query:
<code>wheelName = front-wheel</code>.</p>
</div>
<div class="paragraph">
<p>The extraction may return up to two wheel names for each <code>Motorbike</code> since
each <code>Motorbike</code> has up to two wheels.
In such a case, it is enough if a single value evaluates the predicate&#8217;s
condition to true to return a match, so
it returns a <code>Motorbike</code> if "any" of the wheels matches the expression.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_extraction_arguments"><a class="anchor" href="#_extraction_arguments"></a>12.3.2. Extraction Arguments</h4>
<div class="paragraph">
<p>A <code>ValueExtractor</code> may use a custom argument if it is specified in the query.
The custom argument may be passed within the square brackets located after the
name of the custom attribute,
e.g., <code>customAttribute[argument]</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a look at the following query: <code>currency[incoming] == EUR</code>
The <code>currency</code> is a custom attribute that uses a <code>com.test.CurrencyExtractor</code>
for extraction.</p>
</div>
<div class="paragraph">
<p>The string <code>incoming</code> is an argument that is passed to the <code>ArgumentParser</code>
during the extraction.
The parser parses the string according to its custom logic and it returns a
parsed object.
The parsed object may be a single object, array, collection, or any arbitrary
object.
It is up to the <code>ValueExtractor</code> implementation to understand the semantics of
the parsed argument object.</p>
</div>
<div class="paragraph">
<p>For now it is <strong>not</strong> possible to register a custom <code>ArgumentParser</code>, thus a
default parser is used.
It follows a <code>pass-through</code> semantic, which means that the string located in
the square brackets is passed "as is" to
the <code>ValueExtractor.extract()</code> method.</p>
</div>
<div class="paragraph">
<p>Please note that using square brackets within the argument string are not allowed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_a_custom_attribute_programmatically"><a class="anchor" href="#_configuring_a_custom_attribute_programmatically"></a>12.3.3. Configuring a Custom Attribute Programmatically</h4>
<div class="paragraph">
<p>The following snippet demonstrates how to define a custom attribute using a <code>ValueExtractor</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AttributeConfig attributeConfig = new AttributeConfig();
attributeConfig.setName("currency");
attributeConfig.setExtractorClassName("com.bank.CurrencyExtractor");

MapConfig mapConfig = new MapConfig();
mapConfig.addAttributeConfig(attributeConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>currency</code> is the name of the custom attribute that will be extracted using
the <code>CurrencyExtractor</code> class.</p>
</div>
<div class="paragraph">
<p>Keep in mind that an extractor may not be added after the map has been instantiated.
All extractors have to be defined upfront in the map&#8217;s initial configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_a_custom_attribute_declaratively"><a class="anchor" href="#_configuring_a_custom_attribute_declaratively"></a>12.3.4. Configuring a Custom Attribute Declaratively</h4>
<div class="paragraph">
<p>The following snippet demonstrates how to define a custom attribute in the
Hazelcast XML Configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="trades"&gt;
        &lt;attributes&gt;
            &lt;attribute extractor-class-name="com.bank.CurrencyExtractor"&gt;currency&lt;/attribute&gt;
        &lt;/attributes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    trades:
      attributes:
        currency:
          extractor-class-name: com.bank.CurrencyExtractor</code></pre>
</div>
</div>
<div class="paragraph">
<p>Analogous to the example above, <code>currency</code> is the name of the custom attribute
that will be extracted using the
<code>CurrencyExtractor</code> class.</p>
</div>
<div class="paragraph">
<p>Please note that an attribute name may begin with an ASCII letter [A-Za-z] or
digit [0-9] and may contain
ASCII letters [A-Za-z], digits [0-9] or underscores later on.</p>
</div>
</div>
<div class="sect3">
<h4 id="_indexing_custom_attributes"><a class="anchor" href="#_indexing_custom_attributes"></a>12.3.5. Indexing Custom Attributes</h4>
<div class="paragraph">
<p>You can create an index using a custom attribute.</p>
</div>
<div class="paragraph">
<p>The name of the attribute used in the index definition has to match the one
used in the attributes configuration.</p>
</div>
<div class="paragraph">
<p>Defining indexes with extraction arguments is allowed, as shown in the example
below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;indexes&gt;
        &lt;!-- custom attribute without an extraction argument --&gt;
        &lt;index&gt;
            &lt;attributes&gt;
                &lt;attribute&gt;currency&lt;/attribute&gt;
            &lt;/attributes&gt;
        &lt;/index&gt;
        &lt;!-- custom attribute using an extraction argument --&gt;
        &lt;index&gt;
            &lt;attributes&gt;
                &lt;attribute&gt;currency[incoming]&lt;/attribute&gt;
            &lt;/attributes&gt;
        &lt;/index&gt;
    &lt;/indexes&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ...
  indexes:
    attributes:
      - "currency"
      - "currency[incoming]"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aggregations"><a class="anchor" href="#aggregations"></a>12.4. Aggregations</h3>
<div class="paragraph">
<p>Aggregations allow to compute a value of some function (e.g sum or max) over the
stored map entries. The computation is performed in a fully distributed manner,
so no data other than the computed function value is transferred to a caller,
making the computation fast.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the <a href="#setting-in-memory-format">in-memory format</a> of your data is <code>NATIVE</code>,
aggregations always run on the partition threads. If the data is of type <code>BINARY</code>
or <code>OBJECT</code>, they also mostly run on the partition threads, however, they may run on
the separate query threads to avoid blocking partition threads (if there are no ongoing migrations).
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_aggregator_api"><a class="anchor" href="#_aggregator_api"></a>12.4.1. Aggregator API</h4>
<div class="paragraph">
<p>The aggregation is split into three phases represented by three methods:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>accumulate()</code></p>
</li>
<li>
<p><code>combine()</code></p>
</li>
<li>
<p><code>aggregate()</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There are also the following callbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>onAccumulationFinished()</code> called when the accumulation phase finishes</p>
</li>
<li>
<p><code>onCombinationFinished()</code> called when the combination phase finishes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These callbacks enable releasing the state that might have been initialized and
stored in the Aggregator - to reduce the network traffic.</p>
</div>
<div class="paragraph">
<p>Each phase is described below. See also the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/aggregation/Aggregator.html" target="_blank" rel="noopener">Aggregator Javadoc</a>
for the API&#8217;s details.</p>
</div>
<div class="paragraph">
<p><strong>Accumulation:</strong></p>
</div>
<div class="paragraph">
<p>During the accumulation phase each Aggregator accumulates all entries passed
to it by the query engine.
It accumulates only those pieces of information that are required to calculate
the aggregation result in the last phase - that&#8217;s implementation specific.</p>
</div>
<div class="paragraph">
<p>In case of the <code>DoubleAverage</code> aggregation the Aggregator would accumulate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the sum of the elements it accumulated</p>
</li>
<li>
<p>the count of the elements it accumulated</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Combination:</strong></p>
</div>
<div class="paragraph">
<p>Since aggregation is executed in parallel on each partition of the cluster,
the results need to be combined after the accumulation phase in order to be able
to calculate the final result.</p>
</div>
<div class="paragraph">
<p>In case of the <code>DoubleAverage</code> aggregation, the aggregator would sum up all
the sums of the elements and all the counts.</p>
</div>
<div class="paragraph">
<p><strong>Aggregation:</strong></p>
</div>
<div class="paragraph">
<p>Aggregation is the last phase that calculates the final result from the
results accumulated and combined in the preceding phases.</p>
</div>
<div class="paragraph">
<p>In case of the <code>DoubleAverage</code> aggregation, the Aggregator would just
divide the sum of the elements by their count (if non-zero).</p>
</div>
</div>
<div class="sect3">
<h4 id="_aggregations_and_map_interfaces"><a class="anchor" href="#_aggregations_and_map_interfaces"></a>12.4.2. Aggregations and Map Interfaces</h4>
<div class="paragraph">
<p>Aggregations are available on <code>com.hazelcast.map.IMap</code> only.
IMap offers the method <code>aggregate</code> to apply the aggregation logic on
the map entries. This method can be called with or without a predicate. You can refer
to its <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/IMap.html#aggregate-com.hazelcast.aggregation.Aggregator-" target="_blank" rel="noopener">Javadoc</a>
to see the method details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_example_implementation"><a class="anchor" href="#_example_implementation"></a>12.4.3. Example Implementation</h4>
<div class="paragraph">
<p>Here&#8217;s an example implementation of the Aggregator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    private static void simpleCustomAverageAggregation(IMap&lt;String, FAEmployee&gt; employees) {
        System.out.println("Calculating salary average");

        double avgSalary = employees.aggregate(new Aggregator&lt;Map.Entry&lt;String, FAEmployee&gt;, Double&gt;() {

            protected long sum;
            protected long count;

            @Override
            public void accumulate(Map.Entry&lt;String, FAEmployee&gt; entry) {
                count++;
                sum += entry.getValue().getSalaryPerMonth();
            }

            @Override
            public void combine(Aggregator aggregator) {

                this.sum += this.getClass().cast(aggregator).sum;
                this.count += this.getClass().cast(aggregator).count;
            }

            @Override
            public Double aggregate() {
                if (count == 0) {
                    return null;
                }
                return ((double) sum / (double) count);
            }

        });

        System.out.println("Overall average salary: " + avgSalary);
        System.out.println("\n");
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>accumulate()</code> method calculates the sum and count of the elements</p>
</li>
<li>
<p>the <code>combine()</code> method combines the results from all the accumulations</p>
</li>
<li>
<p>the <code>aggregate()</code> method calculates the final result.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_built_in_aggregations"><a class="anchor" href="#_built_in_aggregations"></a>12.4.4. Built-In Aggregations</h4>
<div class="paragraph">
<p>The <code>com.hazelcast.aggregation.Aggregators</code> class provides a wide variety of built-in Aggregators.
The full list is presented below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>count</code></p>
</li>
<li>
<p><code>distinct</code></p>
</li>
<li>
<p><code>bigDecimal</code> <code>sum</code>/<code>avg</code>/<code>min</code>/<code>max</code></p>
</li>
<li>
<p><code>bigInteger</code> <code>sum</code>/<code>avg</code>/<code>min</code>/<code>max</code></p>
</li>
<li>
<p><code>double</code> <code>sum</code>/<code>avg</code>/<code>min</code>/<code>max</code></p>
</li>
<li>
<p><code>integer</code> <code>sum</code>/<code>avg</code>/<code>min</code>/<code>max</code></p>
</li>
<li>
<p><code>long</code> <code>sum</code>/<code>avg</code>/<code>min</code>/<code>max</code></p>
</li>
<li>
<p><code>number</code> <code>avg</code></p>
</li>
<li>
<p><code>comparable</code> <code>min</code>/<code>max</code></p>
</li>
<li>
<p><code>fixedPointSum</code>, <code>floatingPointSum</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use the any of these Aggregators, instantiate them using the <code>Aggregators</code>
factory class.</p>
</div>
<div class="paragraph">
<p>Each built-in Aggregator can also navigate to an attribute of the object passed
to the <code>accumulate()</code> method (via reflection). For example, <code>Aggregators.distinct("address.city")</code>
extracts the <code>address.city</code> attribute from the object passed to the Aggregator and
accumulate the extracted value.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuration_options"><a class="anchor" href="#_configuration_options"></a>12.4.5. Configuration Options</h4>
<div class="paragraph">
<p>On each partition, after the entries have been passed to the aggregator, the
accumulation runs in parallel.
It means that each aggregator is cloned and receives a sub-set of the entries
received from a partition.
Then, it runs the accumulation phase in all of the cloned aggregators - at the
end, the result is combined into a single accumulation result.
It speeds up the processing by at least the factor of two - even in case of simple
aggregations. If the accumulation logic is more "heavy", the speed-up may be more significant.</p>
</div>
<div class="paragraph">
<p>In order to switch the accumulation into a sequential mode just set the
<code>hazelcast.aggregation.accumulation.parallel.evaluation</code> property to <code>false</code>
(it&#8217;s set to <code>true</code> by default).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_projections"><a class="anchor" href="#_projections"></a>12.5. Projections</h3>
<div class="paragraph">
<p>There are cases where instead of sending all the data returned by a query from
a member, you want to transform (strip down) each result object in order to avoid
redundant network traffic.</p>
</div>
<div class="paragraph">
<p>For example, you select all employees based on some criteria, but you just want to
return their name instead of the whole Employee object. It is easily doable with the
Projection API.</p>
</div>
<div class="sect3">
<h4 id="_projection_api"><a class="anchor" href="#_projection_api"></a>12.5.1. Projection API</h4>
<div class="paragraph">
<p>The Projection API provides the method <code>transform()</code> which is called on each result
object. Its result is then gathered as the final query result entity. You can refer
to the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/projection/Projection.html" target="_blank" rel="noopener">Projection Javadoc</a>
for the API&#8217;s details.</p>
</div>
<div class="sect4">
<h5 id="_projections_and_map_interfaces"><a class="anchor" href="#_projections_and_map_interfaces"></a>Projections and Map Interfaces</h5>
<div class="paragraph">
<p>Projections are available on <code>com.hazelcast.map.IMap</code> only. IMap offers the method
<code>project</code> to apply the projection logic on the map entries. This method can be called
with or without a predicate. See its
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/IMap.html#project-com.hazelcast.projection.Projection-" target="_blank" rel="noopener">Javadoc</a>
to see the method details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_example_implementation_2"><a class="anchor" href="#_example_implementation_2"></a>12.5.2. Example implementation</h4>
<div class="paragraph">
<p>Let&#8217;s consider the following domain object stored in an IMap:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee implements Serializable {

    private String name;

    public Employee() {
    }

    public String getName() {
        return name;
    }

    public void setName(String firstName) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To return just the names of the Employees, you can run the query in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Collection&lt;String&gt; names = employees.project(new Projection&lt;Map.Entry&lt;String, Employee&gt;, String&gt;() {

    @Override
    public String transform(Map.Entry&lt;String, Employee&gt; entry) {
        return entry.getValue().getName();
    }
}, somePredicate);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_built_in_projections"><a class="anchor" href="#_built_in_projections"></a>12.5.3. Built-In Projections</h4>
<div class="paragraph">
<p>The <code>com.hazelcast.projection.Projections</code> class provides two built-in
Projections:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>singleAttribute</code></p>
</li>
<li>
<p><code>multiAttribute</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>singleAttribute</code> Projection enables extracting a single attribute
from an object (via reflection). For example, <code>Projection.singleAttribute("address.city")</code>
extracts the <code>address.city</code> attribute from the object passed to the Projection.</p>
</div>
<div class="paragraph">
<p>The <code>multiAttribute</code> Projection enables extracting multiples attributes from an
object (via reflection). For example, <code>Projection.multiAttribute("address.city", "postalAddress.city")</code>
extracts both attributes from the object passed to the Projection and return them in an <code>Object[]</code> array.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_continuous_query_cache"><a class="anchor" href="#_continuous_query_cache"></a>12.6. Continuous Query Cache</h3>
<div class="paragraph">
<p>A continuous query cache is used to cache the result of a continuous query. After
the construction of a continuous query cache, all changes on IMap are asynchronously
reflected to this cache via events. This makes this cache as an asynchronously updated
view of IMap. You can create a continuous query cache either on the client or member.</p>
</div>
<div class="sect3">
<h4 id="_keeping_query_results_local_and_ready"><a class="anchor" href="#_keeping_query_results_local_and_ready"></a>12.6.1. Keeping Query Results Local and Ready</h4>
<div class="paragraph">
<p>A continuous query cache is beneficial when you need to query the distributed
<code>IMap</code> data in a very frequent and fast way. By using a continuous query cache,
the result of the query will always be ready and local to the application.</p>
</div>
</div>
<div class="sect3">
<h4 id="_accessing_continuous_query_cache_from_member"><a class="anchor" href="#_accessing_continuous_query_cache_from_member"></a>12.6.2. Accessing Continuous Query Cache from Member</h4>
<div class="paragraph">
<p>The following code snippet shows how you can access a continuous query cache
from a member.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        QueryCacheConfig queryCacheConfig = new QueryCacheConfig("cache-name");
        queryCacheConfig.getPredicateConfig().setImplementation(new OddKeysPredicate());

        MapConfig mapConfig = new MapConfig("map-name");
        mapConfig.addQueryCacheConfig(queryCacheConfig);

        Config config = new Config();
        config.addMapConfig(mapConfig);

        HazelcastInstance node = Hazelcast.newHazelcastInstance(config);
        IMap&lt;Integer, String&gt; map = (IMap) node.getMap("map-name");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_accessing_continuous_query_cache_from_client_side"><a class="anchor" href="#_accessing_continuous_query_cache_from_client_side"></a>12.6.3. Accessing Continuous Query Cache from Client Side</h4>
<div class="paragraph">
<p>The following code snippet shows how you can access a continuous query cache
from the client side.
The difference in this code from the member side code above is that you configure
and instantiate
a client instance instead of a member instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        QueryCacheConfig queryCacheConfig = new QueryCacheConfig("cache-name");
        queryCacheConfig.getPredicateConfig().setImplementation(new OddKeysPredicate());

        ClientConfig clientConfig = new ClientConfig();
        clientConfig.addQueryCacheConfig("map-name", queryCacheConfig);

        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
        IMap&lt;Integer, Integer&gt; clientMap = (IMap) client.getMap("map-name");

        QueryCache&lt;Integer, Integer&gt; cache = clientMap.getQueryCache("cache-name");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_features_of_continuous_query_cache"><a class="anchor" href="#_features_of_continuous_query_cache"></a>12.6.4. Features of Continuous Query Cache</h4>
<div class="paragraph">
<p>The following features of continuous query cache are valid for both
the member and client:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The initial query that is run on the existing <code>IMap</code> data during the
continuous query cache construction can be enabled/disabled according to
the supplied predicate via <code>QueryCacheConfig.setPopulate()</code>.</p>
</li>
<li>
<p>Continuous query cache allows you to run queries with indexes and perform
event batching and coalescing.</p>
</li>
<li>
<p>A continuous query cache is evictable. Note that a continuous query cache
has a default maximum capacity of 10000. If you need a non-evictable cache, you
should configure the eviction via <code>QueryCacheConfig.setEvictionConfig()</code>.</p>
</li>
<li>
<p>A listener can be added to a continuous query cache using <code>QueryCache.addEntryListener()</code>.</p>
</li>
<li>
<p><code>IMap</code> events are reflected in continuous query cache in the same order as
they were generated on map entries. Since events are created on entries stored
in partitions, ordering of events is maintained based on the ordering within
the partition. You can add listeners to capture lost events using <code>EventLostListener</code>
and you can recover lost events with the method <code>QueryCache.tryRecover()</code>.
Recovery of lost events largely depends on the size of the buffer on Hazelcast members.
Default buffer size is 16 per partition, i.e., 16 events per partition can be maintained
in the buffer. If the event generation is high, setting the buffer size to a higher
number provides better chances of recovering lost events. You can set buffer size
with <code>QueryCacheConfig.setBufferSize()</code>. You can use the following example code for a
recovery case.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">QueryCache queryCache = map.getQueryCache("cache-name", Predicates.sql("this &gt; 20"), true);
queryCache.addEntryListener(new EventLostListener() {
@Override
public void eventLost(EventLostEvent event) {
       queryCache.tryRecover();
      }
}, false);</code></pre>
</div>
</div>
</li>
<li>
<p>You can populate a continuous query cache with only the keys of its entries and
retrieve the subsequent values directly via <code>QueryCache.get()</code> from the underlying
<code>IMap</code>. This helps to decrease the initial population time when the values are very
large.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_continuous_query_cache"><a class="anchor" href="#_configuring_continuous_query_cache"></a>12.6.5. Configuring Continuous Query Cache</h4>
<div class="paragraph">
<p>You can configure continuous query cache declaratively or programmatically; the
latter is mostly explained in the previous section. The parent configuration element
is <code>&lt;query-caches&gt;</code> which should be placed within your <code>&lt;map&gt;</code> configuration. You can
create your query caches using the  <code>&lt;query-cache&gt;</code> sub-element under <code>&lt;query-caches&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map&gt;
        &lt;query-caches&gt;
            &lt;query-cache name="myContQueryCache"&gt;
                &lt;include-value&gt;true&lt;/include-value&gt;
                &lt;predicate type="class-name"&gt;com.hazelcast.examples.ExamplePredicate&lt;/predicate&gt;
                &lt;entry-listeners&gt;
                    &lt;entry-listener&gt;...&lt;/entry-listener&gt;
                &lt;/entry-listeners&gt;
                &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
                &lt;populate&gt;true&lt;/populate&gt;
                &lt;coalesce&gt;false&lt;/coalesce&gt;
                &lt;batch-size&gt;2&lt;/batch-size&gt;
                &lt;delay-seconds&gt;3&lt;/delay-seconds&gt;
                &lt;buffer-size&gt;32&lt;/buffer-size&gt;
                &lt;eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/&gt;
                &lt;indexes&gt;
                    &lt;index&gt;
                        &lt;attributes&gt;
                            &lt;attribute&gt;age&lt;/attribute&gt;
                        &lt;/attributes&gt;
                    &lt;/index&gt;
                &lt;/indexes&gt;
            &lt;/query-cache&gt;
        &lt;/query-caches&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    query-caches:
        myContQueryCache:
          include-value: true
          predicate:
            class-name: com.hazelcast.examples.ExamplePredicate
          entry-listeners:
            - class-name: "..."
          in-memory-format: BINARY
          populate: true
          coalesce: false
          batch-size: 2
          delay-seconds: 3
          buffer-size: 32
          eviction:
            size: 1000
            max-size-policy: ENTRY_COUNT
            eviction-policy: LFU
          indexes:
            - attributes:
              - "age"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Continuous query caches have the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of your continuous query cache.</p>
</li>
<li>
<p><code>include-value</code>: Specifies whether the value will be cached too. Its default
value is true.</p>
</li>
<li>
<p><code>predicate</code>: Predicate to filter events which are applied to the query cache.</p>
</li>
<li>
<p><code>entry-listeners</code>: Adds listeners (listener classes) for your query cache entries.
See the <a href="#registering-map-listeners">Registering Map Listeners section</a>.</p>
</li>
<li>
<p><code>in-memory-format</code>: Type of the data to be stored in your query cache.
See the <a href="#setting-in-memory-format">Setting In-Memory Format section</a>.
Its default value is BINARY.</p>
</li>
<li>
<p><code>populate</code>: Specifies whether the initial population of your query cache is
enabled. Its default value is true.</p>
</li>
<li>
<p><code>coalesce</code>: Specifies whether the coalescing of your query cache is enabled.
Its default value is false.</p>
</li>
<li>
<p><code>delay-seconds</code>: Minimum time in seconds that an event waits in the member&#8217;s
buffer. Its default value is 0.</p>
</li>
<li>
<p><code>batch-size</code>: Batch size used to determine the number of events sent in a
batch to your query cache. Its default value is 1.</p>
</li>
<li>
<p><code>buffer-size</code>: Maximum number of events which can be stored in a partition
buffer. Its default value is 16.</p>
</li>
<li>
<p><code>eviction</code>: Configuration for the eviction of your query cache. See the
<a href="#configuring-map-eviction">Configuring Map Eviction section</a>.</p>
</li>
<li>
<p><code>indexes</code>: Indexes for your query cache defined by using this element&#8217;s <code>&lt;index&gt;</code>
sub-elements. See the <a href="#configuring-imap-indexes">Configuring IMap Indexes section</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please take the following configuration considerations and publishing logic into account:</p>
</div>
<div class="paragraph">
<p>If  <code>delay-seconds</code> is equal to or smaller than <strong>0</strong>, then <code>batch-size</code> loses its
function. Each time there is an event, all the entries in the buffer are pushed to the subscriber.</p>
</div>
<div class="paragraph">
<p>If <code>delay-seconds</code> is bigger than <strong>0</strong>, the following logic applies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>coalesce</code> is set to <strong>true</strong>, the buffer is checked for an event with the
same key; if so, it is overridden by the current event. Then:</p>
<div class="ulist">
<ul>
<li>
<p>The current size of the buffer is checked: if the current size of the buffer
is equal to or larger than <code>batch-size</code>, then the events counted as much as the
<code>batch-size</code> are pushed to the subscriber. Otherwise, no events are sent.</p>
</li>
<li>
<p>After finishing with checking <code>batch-size</code>, the <code>delay-seconds</code> is checked.
The buffer is scanned from the oldest to youngest entries; all the entries that are
older than <code>delay-seconds</code> are pushed to the subscriber.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mapreduce_deprecation_and_removal"><a class="anchor" href="#_mapreduce_deprecation_and_removal"></a>12.7. MapReduce Deprecation and Removal</h3>
<div class="paragraph">
<p>This section informs Hazelcast users about the MapReduce deprecation and removal,
its motivation and replacements.</p>
</div>
<div class="sect3">
<h4 id="_motivation"><a class="anchor" href="#_motivation"></a>12.7.1. Motivation</h4>
<div class="paragraph">
<p>We&#8217;ve decided to deprecate the MapReduce framework in Hazelcast IMDG 3.8.
MapReduce support was completely removed in Hazelcast IMDG 4.0. The
MapReduce framework provided the distributed computing model and it was used
to back the old Aggregations system. Unfortunately the implementation didn&#8217;t
live up to the expectations and adoption wasn&#8217;t high, so it never got out of
Beta status. Apart from that the current shift in development away from M/R-like
processing to a more near-realtime, streaming approach left us with the decision
to deprecate and finally remove the MapReduce framework from Hazelcast IMDG. With
that said, we want to introduce the successors and replacements; fast Aggregations
on top of Query infrastructure and the Hazelcast Jet distributed computing platform.</p>
</div>
</div>
<div class="sect3">
<h4 id="_built_in_aggregations_2"><a class="anchor" href="#_built_in_aggregations_2"></a>12.7.2. Built-In Aggregations</h4>
<div class="paragraph">
<p>MapReduce is a very powerful tool, however it&#8217;s demanding in terms of space, time
and bandwidth. We realized that we don&#8217;t need so much power when we simply want
to find out a simple metric such as the number of entries matching a predicate.
Therefore, the built-in aggregations were rebuilt on top of the existing Query
infrastructure (count, sum, min, max, mean, variance) which automatically leverages
any matching query index. The aggregations are computed in tho phases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1st phase: on each member (scatter)</p>
</li>
<li>
<p>2nd phase: one member aggregates responses from members (gather)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is not as flexible as a full-blown M/R system due to the 2nd phase being
single-member and the input can be massive in some use cases. The member doing
the 2nd step needs enough capacity to hold all intermediate results from all
members from the 1st step, but in practice it is sufficient for many aggregation
tasks like "find average" or "find highest" and other common examples.</p>
</div>
<div class="paragraph">
<p>The benefits are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>improved performance</p>
</li>
<li>
<p>simplified API</p>
</li>
<li>
<p>utilization of existing indexes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#aggregations">Aggregations section</a> for examples. If you
need a more powerful tool like MapReduce, then there is Hazelcast Jet.
See its reference <a href="#hazelcast-jet">here</a> and <a href="https://jet.hazelcast.org/" target="_blank" rel="noopener">website</a>
for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jet_compared_with_new_aggregations"><a class="anchor" href="#_jet_compared_with_new_aggregations"></a>12.7.3. Jet Compared with New Aggregations</h4>
<div class="paragraph">
<p>Hazelcast has native support for aggregation operations on the contents of its
distributed data structures. They operate on the assumption that the aggregating
function is commutative and associative, which allows the two-tiered approach where
first the local data is aggregated, then all the local subresults sent to one member,
where they are combined and returned to the user. This approach works quite well as
long as the result is of manageable size. Many interesting aggregations produce an O(1)
result and for those, the native aggregations are a good match.</p>
</div>
<div class="paragraph">
<p>The main area where native aggregations may not be sufficient are the operations that
group the data by key and produce results of size O (<code>keyCount</code>). The architecture of
Hazelcast aggregations is not well adapted to this use case, although it still works
even for moderately-sized results (up to 100 MB, as a ballpark figure). Beyond these
numbers, and whenever something more than a single aggregation step is needed, Jet
becomes the preferred choice. In the mentioned use case Jet helps because it doesn&#8217;t
send the entire hashtables in serialized form and materialize all the results on the
user&#8217;s machine, but rather streams the key-value pairs directly into a target IMap.
Since it is a distributed structure, it doesn&#8217;t focus its load on a single member.</p>
</div>
<div class="paragraph">
<p>Jet&#8217;s DAG paradigm offers much more than the basic map-reduce-combine cascade. Among
other setups, it can compose several such cascades and also perform co-grouping,
joining and many other operations in complex combinations.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cp_subsystem"><a class="anchor" href="#_cp_subsystem"></a>13. CP Subsystem</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<strong>CP Subsystem operates in <em>the unsafe mode</em> by default without
the strong consistency guarantee.</strong> See the
<a href="#cp-subsystem-unsafe-mode">CP Subsystem Unsafe Mode</a> section for more
information. You should set a positive number to the CP member count
configuration to enable CP Subsystem and use it with the strong consistency
guarantee. See the <a href="#cp-subsystem-configuration">CP Subsystem Configuration</a>
section for details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>CP Subsystem is a component of a Hazelcast cluster that builds a strongly
consistent layer for a set of distributed data structures. Its APIs can be used
for implementing distributed coordination use cases, such as leader election,
distributed locking, synchronization, and metadata management. It is accessed
via <code>HazelcastInstance.getCPSubsystem()</code>. Its data structures are <em>CP</em> with
respect to the <a href="http://awoc.wolski.fi/dlib/big-data/Brewer_podc_keynote_2000.pdf"><em>CAP</em> principle</a>,
i.e., they always maintain <a href="https://aphyr.com/posts/313-strong-consistency-models">linearizability</a>
and prefer consistency over availability during network partitions. Besides
network partitions, CP Subsystem withstands server and client failures.</p>
</div>
<div class="paragraph">
<p>Currently, CP Subsystem contains only the implementations of Hazelcast&#8217;s
concurrency APIs. Since these APIs do not maintain large states, all members of
a Hazelcast cluster do not necessarily take part in CP Subsystem. The number of
Hazelcast members that take part in CP Subsystem is specified with
<code>CPSubsystemConfig.setCPMemberCount(int)</code>. Say that it is configured as <code>N</code>.
Then, when a Hazelcast cluster starts, the first <code>N</code> members form CP Subsystem.
These members are called <em>CP members</em> and they can also contain data for
the other regular <em>AP</em> Hazelcast data structures, such as <code>IMap</code>, <code>ISet</code>.</p>
</div>
<div class="paragraph">
<p>Data structures in CP Subsystem run in <em>CP groups</em>. Each CP group elects its
own Raft leader and runs the <a href="https://raft.github.io/">Raft consensus algorithm</a>
independently. CP Subsystem runs 2 CP groups by default:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first one is <em>the METADATA CP group</em> which is an internal CP group
responsible for managing CP members and CP groups. It is initialized during
cluster startup if CP Subsystem is enabled via <code>CPSubsystemConfig.setCPMemberCount(int)</code>.</p>
</li>
<li>
<p>The second CP group is <em>the DEFAULT CP group</em>, whose name is given in
<code>CPGroup.DEFAULT_GROUP_NAME</code>. If a group name is not specified while creating
a CP data structure proxy, that data structure is mapped to <em>the DEFAULT CP
group</em>. For instance, when a CP <code>IAtomicLong</code> instance is created via
<code>CPSubsystem.getAtomicLong("myAtomicLong")</code>, it is initialized on
<em>the DEFAULT CP group</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Besides these 2 predefined CP groups, custom CP groups can be created at
run-time while fetching the CP data structure proxies. For instance, if a CP
<code>IAtomicLong</code> is created by calling <code>.getAtomicLong("myAtomicLong@myGroup")</code>,
first a new CP group is created with the name <code>myGroup</code> and then <code>myAtomicLong</code>
is initialized on this custom CP group.</p>
</div>
<div class="paragraph">
<p>This design implies that each CP member can participate to more than one CP
group. CP Subsystem runs a periodic background task to ensure that each CP
member performs the Raft leadership role for roughly equal number of CP groups.
For instance, if there are 3 CP members and 3 CP groups, each CP member becomes
Raft leader for only 1 CP group. If one more CP group is created, then one of
the CP members gets the Raft leader role for 2 CP groups. This is done because
Raft is a leader-based consensus algorithm. A Raft leader node becomes
responsible for handling incoming requests from callers and replicating them to
follower nodes. If a CP member gets the Raft leadership role for too many CP
groups compared to other CP members, it can turn into a bottleneck.</p>
</div>
<div class="paragraph">
<p>CP member count of CP groups are specified via
<code>CPSubsystemConfig.setGroupSize(int)</code>. Please note that this configuration does
not have to be the same with the CP member count. Namely, the number of CP members in
CP Subsystem can be larger than the configured CP group size. CP groups usually
consist of an odd number of CP members between 3 and 7. Operations are
committed and executed only after they are successfully replicated to
the majority of CP members in a CP group. An odd number of CP members is more
advantageous to an even number because of the quorum or majority calculations.
For a CP group of <code>N</code> members, the majority is calculated as <code>N / 2 + 1</code>. For
instance, in a CP group of 5 CP members, operations are committed when they are
replicated to at least 3 CP members. This CP group can tolerate the failure of 2 CP
members and remain available. However, if we run a CP group with 6 CP members,
it can still tolerate the failure of 2 CP members because the majority of 6 is 4.
Therefore, it does not improve the degree of fault tolerance compared to 5 CP
members. In summary, CP subsystem remains available (and executes the operations)
as long as the majority ((N/2) + 1) of the members are alive.</p>
</div>
<div class="paragraph">
<p>CP Subsystem achieves horizontal scalability thanks to all of
the aforementioned CP group management capabilities. You can scale out
the throughput and memory capacity by distributing your CP data structures to
multiple CP groups, i.e., manual partitioning / sharding, and distributing
those CP groups over CP members, i.e., choosing a CP group size that is smaller
than the CP member count configuration. Nevertheless, the current set of CP
data structures has quite low memory overheads. Moreover, related to the Raft
consensus algorithm, each CP group makes use of internal heartbeat RPCs to
maintain authority of the Raft leader and help lagging CP group members to make
progress. Last, the new CP lock and semaphore implementations rely on a brand
new session mechanism. In a nutshell, a Hazelcast server or a client starts
a new session on the corresponding CP group when it makes its very first lock
or semaphore acquire request, and then periodically commits session heartbeats
to this CP group in order to indicate its liveliness. It means that if CP
locks and semaphores are distributed to multiple CP groups, there will be
a session management overhead on each CP group. See
the <a href="#cp-sessions">CP Sessions section</a> for more details. For these reasons,
we recommend developers to use a minimal number of CP groups. For most use
cases, <em>the DEFAULT CP group</em> should be sufficient to maintain all CP data
structure instances. Custom CP groups is recommended only when you benchmark
your deployment and decide that performance of <em>the DEFAULT CP group</em> is not
sufficient for your workload.</p>
</div>
<div class="paragraph">
<p>By default, CP Subsystem works only in memory without persisting any state to
disk. It means that a crashed CP member is not able to join to the cluster back
by restoring its previous state. Therefore, crashed CP members create a danger
for gradually losing majority of CP groups and eventually cause the total loss
of availability of CP Subsystem. To prevent such situations, crashed CP members
can be removed from CP Subsystem and replaced in CP groups with other available
CP members. This flexibility provides a good degree of fault tolerance at
run-time. See the <a href="#cp-subsystem-configuration">CP Subsystem Configuration section</a>
and <a href="#cp-subsystem-management">CP Subsystem Management section</a> for more
details. Moreover, CP Subsystem Persistence enables more robustness. When it is
enabled, CP members persist their local state to stable storage and can restore
their state after crashes. See the <a href="#cp-subsystem-persistence">CP Subsystem Persistence section</a>
for more details.</p>
</div>
<div class="paragraph">
<p><strong>API Code Sample:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSubsystem cpSubsystem = hazelcastInstance.getCPSubsystem();

        IAtomicLong atomicLong = cpSubsystem.getAtomicLong(name);

        IAtomicReference atomicRef = cpSubsystem.getAtomicReference(name);

        FencedLock lock = cpSubsystem.getLock(name);

        ISemaphore semaphore = cpSubsystem.getSemaphore(name);

        ICountDownLatch latch = cpSubsystem.getCountDownLatch(name);</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The CP data structure proxies differ from the other data Hazelcast structure
proxies in two aspects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An internal commit is performed on <em>the METADATA CP group</em> every time you
fetch a proxy from this interface. Hence, the callers should cache the returned proxy
objects.</p>
</li>
<li>
<p>If you call the <code>DistributedObject.destroy()</code> method on a CP data structure
proxy, that data structure is terminated on the underlying CP group and cannot
be reinitialized until the CP group is force-destroyed via
<code>CPSubsystemManagementService.forceDestroyCPGroup(String)</code>. For this reason,
please make sure that you are completely done with a CP data structure before
destroying its proxy.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_cp_discovery_process"><a class="anchor" href="#_cp_discovery_process"></a>13.1. CP Discovery Process</h3>
<div class="paragraph">
<p>CP Subsystem runs a discovery process on cluster startup. When CP Subsystem is
enabled by setting a positive value to
<code>CPSubsystemConfig.setCPMemberCount(int)</code>, say <code>N</code>, the first <code>N</code> members in
the Hazelcast cluster member list initiate this discovery process. Other
Hazelcast members skip this step. The CP discovery process runs out of the box
on top of Hazelcast&#8217;s cluster member list without requiring any custom
configuration for different environments. It is completed when each one of
the first <code>N</code> Hazelcast members initializes its local CP member list and
commits it to <em>the METADATA CP group</em>. <strong>A soon-to-be CP member terminates
itself if any of the following conditions occur before the CP discovery process
is completed:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any Hazelcast member leaves the cluster</p>
</li>
<li>
<p>The local Hazelcast member commits a CP member list which is different from
other members' committed CP member lists</p>
</li>
<li>
<p>The local Hazelcast member fails to commit its discovered CP member list for
any reason.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When CP Subsystem is reset via <code>CPSubsystemManagementService.reset()</code>,
the CP discovery process is triggered again. However, it does not terminate
Hazelcast members if the new CP discovery round fails for any of
the aforementioned reasons, because Hazelcast members are likely to contain
data for AP data structures and their termination can cause data loss. Hence,
you need to observe the cluster and check if the CP discovery process
completes successfully on the CP Subsystem reset. See the <a href="#cp-subsystem-management-apis">CP Subsystem Management APIs section</a>
for more details.</p>
</div>
<div class="paragraph">
<p>You can use the <code>CPSubsystemManagementService.awaitUntilDiscoveryCompleted(timeout, timeUnit)</code>
API to wait until the CP discovery process is completed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cp_subsystem_persistence"><a class="anchor" href="#_cp_subsystem_persistence"></a>13.2. CP Subsystem Persistence</h3>
<div class="paragraph">
<p><strong class="navy">Hazelcast IMDG Enterprise</strong></p>
</div>
<div class="sect3">
<h4 id="_cp_subsystem_persistence_overview"><a class="anchor" href="#_cp_subsystem_persistence_overview"></a>13.2.1. CP Subsystem Persistence Overview</h4>
<div class="paragraph">
<p>CP Subsystem Persistence enables CP members to recover from crash scenarios.
This capability significantly improves the overall reliability of CP Subsystem.
When it is enabled via <code>CPSubsystemConfig.setPersistenceEnabled(boolean)</code>, CP
members persist their local state to stable storage. When you restart the crashed
CP members, they restore their local state and resume working as if they have
never crashed. CP Subsystem Persistence enables you to handle single or
multiple CP member crashes, or even whole cluster crashes and guarantees that
committed operations are not lost after recovery. In other words, CP member
crashes and restarts do not create any consistency problem. As long as majority
of CP members are available after recovery, CP Subsystem remains operational.</p>
</div>
<div class="paragraph">
<p>Please see the <a href="#cp-subsystem-configuration">CP Subsystem Configuration section</a>
for the configuration options of CP Subsystem Persistence.</p>
</div>
<div class="paragraph">
<p>When CP Subsystem Persistence is enabled, all Hazelcast cluster members create
a sub-directory under the base persistence directory which is specified via
<code>CPSubsystemConfig.getBaseDir()</code>. This means that AP Hazelcast members, which
are the ones not marked as CP members during the CP discovery process, create
their persistence directories as well. Those members persist only
the information that they are not CP members. This is done because when
a Hazelcast member starts with CP Subsystem Persistence enabled, it checks if
there is a CP persistence directory belonging to itself. If it founds one, it
skips the CP discovery process and initializes its CP member identity from
the persisted data. If it was an AP member before shutdown or crash, it
restores this information and starts as an AP member. Otherwise, it could think
that the CP discovery process has not been executed and trigger it, which would
break CP Subsystem.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In light of this information, if you have both CP and AP members in
your cluster when CP Subsystem Persistence is enabled, and if you want to
perform a cluster-wide restart, you need to ensure that AP members are also
restarted with their CP persistence directories.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can check the code sample below to see how CP Subsystem Persistence works
in general. In this code sample, we configure CP Subsystem with 3 CP members
and also enable CP Subsystem Persistence. We start 3 Hazelcast members with
this configuration and update a CP <code>IAtomicLong</code> instance. Each member creates
a sub-directory for itself inside the default base CP Subsystem Persistence
directory and stores its local CP state there. Then, we terminate two of these
members as if they crash and restart only 1 of them back. When we fetch
the same <code>IAtomicLong</code> instance from the restarted members and get its current
value, we see that it returns the update that we made before terminating these
members. Please note that we make sure that we have the majority of CP members
alive to keep CP Subsystem available after restart.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        config.setLicenseKey("your-license-key");
        NetworkConfig networkConfig = config.getNetworkConfig();
        JoinConfig join = networkConfig.getJoin();
        TcpIpConfig tcpIpConfig = join.getTcpIpConfig();
        tcpIpConfig.setEnabled(true);
        tcpIpConfig.addMember("127.0.0.1");
       // config.getCPSubsystemConfig().setCPMemberCount(3).setPersistenceEnabled(true);

        HazelcastInstance instance1 = Hazelcast.newHazelcastInstance(config);
        HazelcastInstance instance2 = Hazelcast.newHazelcastInstance(config);
        HazelcastInstance instance3 = Hazelcast.newHazelcastInstance(config);

        IAtomicLong counter = instance1.getCPSubsystem().getAtomicLong("counter");
        counter.set(0);
        counter.incrementAndGet();

        instance1.getLifecycleService().terminate();
        instance2.getLifecycleService().terminate();

        instance1 = Hazelcast.newHazelcastInstance(config);

        counter = instance1.getCPSubsystem().getAtomicLong("counter");

        long val = counter.get();
        assert val == 1L;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cp_subsystem_persistence_behavior_during_cp_subsystem_reset"><a class="anchor" href="#_cp_subsystem_persistence_behavior_during_cp_subsystem_reset"></a>13.2.2. CP Subsystem Persistence Behavior During CP Subsystem Reset</h4>
<div class="paragraph">
<p>If the majority of CP members are permanently lost, CP Subsystem becomes
unavailable. There is no solution to recover from this failure case with strong
consistency guarantee. CP Subsystem Management API contains a method to delete
all CP Subsystem state on the remaining CP members and start from scratch.
<code>CPSubsystemManagementService.reset()</code> wipes and resets the whole CP
Subsystem state and initializes it as if the Hazelcast cluster is starting up
for the first time. This method deletes the persisted CP member states as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_interaction_with_hot_restart_persistence"><a class="anchor" href="#_interaction_with_hot_restart_persistence"></a>13.2.3. Interaction with Hot Restart Persistence</h4>
<div class="paragraph">
<p>Hazelcast offers another persistence capability which is called
<a href="#hot-restart-persistence">Hot Restart Persistence</a>. Hot Restart Persistence
is used for restarting a cluster with large AP data after a planned cluster
shutdown or a whole cluster-wide crash. Please note that CP Subsystem
Persistence and Hot Restart Persistence are separate features with different
behaviors and reliability guarantees. For instance, CP Subsystem Persistence
guarantees that committed operations will be restored and the linearizability
semantics of the CP Subsystem data structures will be preserved on restarts.
However, Hot Restart Persistence may lose some of the acknowledged updates on
AP data structures, based on how you configure the <code>fsync</code> behavior for your
persisted AP data structures. Moreover, if you store AP and CP data in a single
Hazelcast cluster and use both of the persistence features, Hazelcast member
restarts or cluster restarts can fail because of the Hot Restart Persistence
recovery semantics, even if the CP Subsystem Persistence recovery procedure is
successful, or vice-versa.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cp_member_shutdown"><a class="anchor" href="#_cp_member_shutdown"></a>13.3. CP Member Shutdown</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Please read this part carefully to notice the behavioral difference
in the CP member shutdown process when CP Subsystem Persistence is
enabled and disabled.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There is a significant behavioral difference during the CP member shutdown when CP
Subsystem Persistence is enabled and disabled. When disabled (the default mode
in which CP Subsystem works only in memory), a shutting down CP member is
replaced with other available CP members in all of its CP groups in order not
to decrease or more importantly not to lose majorities of CP groups. It is
because CP members keep their local state only in memory when CP Subsystem
Persistence is disabled, hence a shut-down CP member cannot join back with its
CP identity and state, hence it is better to remove it from CP Subsystem to not
to harm availability of CP groups. If there is no other available CP member to
replace a shutting down CP member in a CP group, that CP group&#8217;s size is
reduced by 1 and its majority value is recalculated. On the other hand, when CP
Subsystem Persistence is enabled, a shut-down CP member can come back by
restoring its CP state. Therefore, it is not automatically removed from CP
Subsystem when CP Subsystem Persistence is enabled. It is up to you to
remove shut-down CP members via
<code>CPSubsystemManagementService.removeCPMember(String)</code> if they will not come
back.</p>
</div>
<div class="paragraph">
<p>In summary, CP member shutdown behavior is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When CP Subsystem Persistence is disabled (the default mode), shutting down
CP members are removed from CP Subsystem and the CP group majority values are
recalculated.</p>
</li>
<li>
<p>When CP Subsystem Persistence is enabled, shutting down CP members are still
kept in CP Subsystem     so they will be a part of the CP group majority calculations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Moreover, there is a subtle point about concurrent shutdown of CP members when
CP Subsystem Persistence is disabled. If there are <code>N</code> CP members in CP
Subsystem, <code>HazelcastInstance.shutdown()</code> can be called on <code>N-2</code> CP members
concurrently. Once these <code>N-2</code> CP members complete their shutdown,
the remaining <code>2</code> CP members must be shut down serially. Even though
the shutdown API can be called concurrently on multiple members, <em>the METADATA
CP</em> group handles shutdown requests serially. Therefore, it would be simpler to
shut down CP members one by one, by calling <code>HazelcastInstance.shutdown()</code> on
the next CP member once the current CP member completes its shutdown. This rule
does not apply when CP Subsystem Persistence is enabled so you can shut down
your CP members concurrently if you enabled CP Subsystem Persistence. It is
enough for users to recall this rule while shutting down CP members when CP
Subsystem Persistence is disabled. If interested, you can read the rest of this
paragraph to learn the reasoning behind this rule. Each shutdown request
internally requires a Raft commit to <em>the METADATA CP group</em> when CP Subsystem
Persistence is disabled. A CP member proceeds to shutdown after it receives
a response of this commit. To be able to perform a Raft commit, <em>the METADATA
CP group</em> must have its majority up and running. When only 2 CP members are
left after graceful shutdowns, the majority of <em>the METADATA CP group</em> becomes
2. If the last 2 CP members shut down concurrently, one of them is likely to
perform its Raft commit faster than the other one and leave the cluster before
the other CP member completes its Raft commit. In this case, the last CP member
waits for a response of its commit attempt on <em>the METADATA CP group</em>, and
times out eventually. This situation causes an unnecessary delay on the shutdown
process of the last CP member. On the other hand, when the last 2 CP members
shut down serially, the <code>N-1</code>th member receives the response of its commit
after its shutdown request is committed also on the last CP member. Then,
the last CP member checks its local data to notice that it is the last CP
member alive, and proceeds its shutdown without attempting a Raft commit on
<em>the METADATA CP group</em>.</p>
</div>
<div class="paragraph">
<p>See the <a href="#cp-membership-listener">CP Membership Listener section</a> to get notified
about the CP member additions and removals.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cp_subsystems_fault_tolerance_capabilities"><a class="anchor" href="#_cp_subsystems_fault_tolerance_capabilities"></a>13.4. CP Subsystem&#8217;s Fault Tolerance Capabilities</h3>
<div class="paragraph">
<p>CP Subsystem&#8217;s fault tolerance capabilities are summarized in this section.
For the sake of simplicity, let&#8217;s assume that both the CP member count and CP
group size configurations are configured as the same and we use only
<em>the DEFAULT CP group</em>. <strong>In the list below, "a permanent crash" means that
a CP member either crashes while CP Subsystem Persistence is disabled, hence
it cannot be recovered with its CP identity and data, or it crashes while CP
Subsystem Persistence is enabled but its CP data cannot be recovered, for
instance, due to a total server crash or a disk failure.</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a CP member leaves the Hazelcast cluster, it is not automatically removed
from CP Subsystem because CP Subsystem cannot certainly determine if that
member has actually crashed or just disconnected from the cluster. Therefore,
absent CP members are still considered in majority calculations and cause a
danger for the availability of CP Subsystem. If you know for sure that
an absent CP member is crashed, you can remove that CP member from CP Subsystem
via <code>CPSubsystemManagementService.removeCPMember(String)</code>. This API call
removes the given CP member from all CP groups and recalculates their majority
values. If there is another available CP member in CP Subsystem, the removed CP
member is replaced with that one, or you can promote an AP member of
the Hazelcast cluster to the CP role via
<code>CPSubsystemManagementService.promoteToCPMember()</code>.</p>
</li>
<li>
<p>There might be a small window of unavailability after a CP member crash even
if the majority of CP members are still online. For instance, if a crashed CP
member is the Raft leader for some CP groups, those CP groups run a new leader
election round to elect a new leader among remaining CP group members. CP
Subsystem API calls that internally hit those CP groups are retried until they
have new Raft leaders. If a failed CP member has the Raft follower role, it
causes a very minimal disruption since Raft leaders are still able to replicate
and commit operations with the majority of their CP group members.</p>
</li>
<li>
<p>If a crashed CP member is restarted after it is removed from CP Subsystem,
its behavior depends on whether CP Subsystem Persistence is enabled or disabled. If
enabled, a restarted CP member is not able to
restore its CP data from disk because after it joins back to the cluster it
notices that it is no longer a CP member. Because of that, it fails its startup
process and prints an error message. The only thing to do in this case is
manually delete its CP persistence directory since its data is no longer
useful. On the other hand, if CP Subsystem Persistence is disabled, a failed CP
member cannot remember anything related to its previous CP identity, hence it
restarts as a new AP member.</p>
</li>
<li>
<p>A CP member can encounter a network issue and disconnect from
the cluster. If you remove this CP member from CP Subsystem even though it
is actually alive but only disconnected, you should terminate it
to prevent any accidental communication with the other CP members in
CP Subsystem.</p>
</li>
<li>
<p>If a network partition occurs, behavior of CP Subsystem depends on how CP
members are divided in different sides of the network partition and to which
sides Hazelcast clients are connected. Each CP group remains available on
the side that contains the majority of its CP members. If a Raft leader falls
into the minority side, its CP group elects a new Raft leader on the other side
and callers that are talking to the majority side continue to make successful
API calls on CP Subsystem. However, callers that are talking to the minority
side fail with operation timeouts. When the network problem is resolved, CP
members reconnect to each other and CP groups continue their operation
normally.</p>
</li>
<li>
<p>CP Subsystem can tolerate failure of the minority of CP members (less than
 <code>N / 2 + 1</code>) for availability. If <code>N / 2 + 1</code> or more CP members crash, CP
Subsystem loses its availability. If CP Subsystem Persistence is enabled and
the majority of CP members become online by successfully restarting some of
failed CP members, CP Subsystem regains its availability back. <strong>Otherwise, it
means that CP Subsystem has lost its majority irrevocably.</strong> In this case,
the only solution is to wipe-out the whole CP Subsystem state by performing
a force-reset via <code>CPSubsystemManagementService.reset()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>When <code>CPSubsystemConfig.getCPMemberCount()</code> is greater than
<code>CPSubsystemConfig.getGroupSize()</code>, CP groups are formed by selecting a subset
of CP members. In this case, each CP group can have a different set of CP
members, therefore different fault tolerance and availability conditions.</strong> In
the following list, CP Subsystem&#8217;s additional fault tolerance capabilities are
discussed for this configuration case.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the majority of a <em>non-METADATA CP group</em> permanently crash, that CP
group cannot make progress anymore, even though other CP groups in CP Subsystem
are running fine. Even a new CP member cannot join to this CP group, because
membership changes also go through the Raft consensus algorithm. For this
reason, the only option is to force-destroy this CP group via
<code>CPSubsystemManagementService.forceDestroyCPGroup(String)</code>. When this API is
called, the CP group is terminated non-gracefully without the Raft mechanics.
After this API call, all existing CP data structure proxies that talk to this
CP group fail with <code>CPGroupDestroyedException</code>. However, if a new proxy is
created afterwards, then this CP group is re-created from scratch with a new
set of CP members. Losing majority of a <em>non-METADATA CP group</em> can be likened
to partition-loss scenario of AP Hazelcast. Please note that <em>non-METADATA CP
groups</em> that have lost their majority must be force-destroyed immediately,
because they can block <em>the METADATA CP group</em> to perform membership changes on
CP Subsystem.</p>
</li>
<li>
<p>If the majority of <em>the METADATA CP group</em> permanently crash, unfortunately
it is equivalent to the permanent crash of the majority CP members of the whole
CP Subsystem, even though other CP groups are running fine. In fact, existing
CP groups continue serving to incoming requests, but since the <em>METADATA CP
group</em> is not available anymore, no management tasks can be performed on CP
Subsystem. For instance, a new CP group cannot be created. In this case,
the only solution is to wipe-out the whole CP Subsystem state by performing
a force-reset via <code>CPSubsystemManagementService.reset()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#cp-subsystem-management-apis">CP Subsystem Management APIs section</a> for
more details.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cp_subsystem_listeners"><a class="anchor" href="#_cp_subsystem_listeners"></a>13.5. CP Subsystem Listeners</h3>
<div class="paragraph">
<p>The CP Subsystem provides the following listeners:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CP membership listeners</p>
</li>
<li>
<p>CP group availability listeners</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following sections explain each listener and
how to register them.</p>
</div>
<div class="sect3">
<h4 id="_cp_membership_listener"><a class="anchor" href="#_cp_membership_listener"></a>13.5.1. CP Membership Listener</h4>
<div class="paragraph">
<p><code>CPMembershipListener</code> is notified when a CP member is added to or removed
from the CP Subsystem. Its signature is very similar to Hazelcast&#8217;s usual
<a href="#listening-for-member-events"><code>MembershipListener</code></a>.</p>
</div>
<div class="paragraph">
<p>The listener interface has methods that are invoked for the following events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>memberAdded</code>: A new CP member is added to the CP subsystem.</p>
</li>
<li>
<p><code>memberRemoved</code>: An existing CP member is removed from the CP subsystem.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To get notified for CP membership events, you implement the <code>CPMembershipListener</code> interface.</p>
</div>
<div class="paragraph">
<p>The following is an example <code>CPMembershipListener</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CPMembershipListenerImpl implements CPMembershipListener {

    /**
     * Called when a new CP member is added to the CP Subsystem.
     */
    public void memberAdded(CPMembershipEvent event) {
        System.out.println("Added: " + event);
    }

    /**
     * Called when a CP member is removed from the CP Subsystem.
     */
    public void memberRemoved(CPMembershipEvent event) {
        System.out.println("Removed: " + event);
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_registering_cp_membership_listeners"><a class="anchor" href="#_registering_cp_membership_listeners"></a>Registering CP Membership Listeners</h5>
<div class="paragraph">
<p><code>CPMembershipListener</code> can be defined in the configuration or can be registered
in runtime via the <code>CPSubsystem</code> API.</p>
</div>
<div class="paragraph">
<p>Below is an example registering the listener in runtime using the <code>CPSubsystem.addMembershipListener</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Either server or client
HazelcastInstance hazelcastInstance = ...;
hazelcastInstance.getCPSubsystem().addMembershipListener(new CPMembershipListenerImpl());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Server</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.addListenerConfig(new ListenerConfig("com.yourpackage.CPMembershipListenerImpl"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Client</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig config = new ClientConfig();
config.addListenerConfig(new ListenerConfig("com.yourpackage.CPMembershipListenerImpl"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The followings are examples of the equivalent declarative configurations:</p>
</div>
<div class="listingblock primary">
<div class="title">Server XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.CPMembershipListenerImpl
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Server YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  ...
  listeners:
    - com.yourpackage.CPMembershipListenerImpl</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Client XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.CPMembershipListenerImpl
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Client YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast-client:
  ...
  listeners:
    - com.yourpackage.CPMembershipListenerImpl</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cp_group_availability_listener"><a class="anchor" href="#_cp_group_availability_listener"></a>13.5.2. CP Group Availability Listener</h4>
<div class="paragraph">
<p><code>CPGroupAvailabilityListener</code> is notified when the availability of a CP group decreases
or it loses the majority completely.</p>
</div>
<div class="paragraph">
<p>In general, the availability decreases when a CP member becomes unreachable because of process crash,
network partition, out of memory, etc. Once a member is declared as unavailable
by the Hazelcast&#8217;s failure detector, that member is removed from the cluster.
If it is also a CP member, <code>CPGroupAvailabilityEvent</code>s are fired for each CP group
that member belongs to.</p>
</div>
<div class="paragraph">
<p>As a special case, <code>CPGroupAvailabilityListener</code> has a separate method to report
the loss of majority. When the majority of a CP group is lost, that CP group cannot make
progress anymore. Even a new CP member cannot join to this CP group
since membership changes also go through the Raft consensus algorithm.</p>
</div>
<div class="paragraph">
<p>When a CP group has lost its majority:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the group is a non-METADATA CP group, it must be force-destroyed immediately,
because it can block the METADATA CP group to perform membership changes on the CP Subsystem.</p>
</li>
<li>
<p>If the majority of the METADATA CP group permanently crashes, unfortunately
it is equivalent to the permanent crash of the majority CP members of the whole CP Subsystem,
even though other CP groups are running fine.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The listener interface has methods that are invoked for the following events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>availabilityDecreased</code>: A CP group&#8217;s availability decreases,
but still has the majority of members available.</p>
</li>
<li>
<p><code>majorityLost</code>: A CP group has lost its majority.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example <code>CPGroupAvailabilityListener</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CPGroupAvailabilityListenerImpl implements CPGroupAvailabilityListener {

    /**
     * Called when a CP group's availability decreases,
     * but still has the majority of members available.
     */
    public void availabilityDecreased(CPGroupAvailabilityEvent event) {
        System.out.println("Availability decreased: " + event);
    }

    /**
     * Called when a CP group has lost its majority.
     */
    public void majorityLost(CPGroupAvailabilityEvent event) {
        System.out.println("Majority Lost: " + event);
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_registering_cp_group_availability_listeners"><a class="anchor" href="#_registering_cp_group_availability_listeners"></a>Registering CP Group Availability Listeners</h5>
<div class="paragraph">
<p>Similar to <code>CPMembershipListener</code>, a <code>CPGroupAvailabilityListener</code> can be defined
in the configuration or can be registered in runtime via the <code>CPSubsystem</code> API.</p>
</div>
<div class="paragraph">
<p>Below is an example registering the listener in runtime using the <code>CPSubsystem.addGroupAvailabilityListener</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Either server or client
HazelcastInstance hazelcastInstance = ...;
hazelcastInstance.getCPSubsystem().addGroupAvailabilityListener(new CPGroupAvailabilityListenerImpl());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example programmatic configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Server</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.addListenerConfig(new ListenerConfig("com.yourpackage.CPGroupAvailabilityListenerImpl"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Client</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig config = new ClientConfig();
config.addListenerConfig(new ListenerConfig("com.yourpackage.CPGroupAvailabilityListenerImpl"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The followings are examples of the equivalent declarative configurations:</p>
</div>
<div class="listingblock primary">
<div class="title">Server XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.CPGroupAvailabilityListenerImpl
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Server YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast:
  ...
  listeners:
    - com.yourpackage.CPGroupAvailabilityListenerImpl</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Client XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            com.yourpackage.CPGroupAvailabilityListenerImpl
        &lt;/listener&gt;
    &lt;/listeners&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Client YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hazelcast-client:
  ...
  listeners:
    - com.yourpackage.CPGroupAvailabilityListenerImpl</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cp_sessions"><a class="anchor" href="#_cp_sessions"></a>13.6. CP Sessions</h3>
<div class="paragraph">
<p>For CP data structures that involve resource ownership management, such as
Locks or Semaphores, sessions are required to keep track of liveliness of
callers. In this context, <em>caller</em> means an entity that uses CP Subsystem
APIs. It can be either a Hazelcast member or a client. A caller initially
creates a session before sending its very first session based request to the CP
group, such as a Lock / Semaphore acquire. After creating a session on the CP
group, the caller stores its session ID locally and sends it alongside its
session-based operations. A single session is used for all lock and semaphore
proxies of the caller. When a CP group receives a session-based operation, it
checks the validity of the session using the session ID information available
in the operation. A session is valid if it is still open in the CP group.
An operation with a valid session ID is accepted as a new session heartbeat.
While a caller is idle, in other words, it does not send any session based
operation to the CP group for a while, it commits periodic heartbeats to
the CP group in the background in order to keep its session alive. This
interval is specified in
<code>CPSubsystemConfig.getSessionHeartbeatIntervalSeconds()</code>.</p>
</div>
<div class="paragraph">
<p>A session is closed when the caller does not touch the session during a
predefined duration. In this case, the caller is assumed to be crashed and all
its resources are released automatically. This duration is specified in
<code>CPSubsystemConfig.getSessionTimeToLiveSeconds()</code>. See
the <a href="#cp-subsystem-configuration">CP Subsystem Configuration section</a> for
recommendations to choose a reasonable session time-to-live duration.</p>
</div>
<div class="paragraph">
<p>Sessions offer a trade-off between liveliness and safety. If you set a very
small value using <code>CPSubsystemConfig.setSessionTimeToLiveSeconds(int)</code>, then a
session owner could be considered crashed very quickly and its resources can be
released prematurely. On the other hand, if you set a large value, a session
could be kept alive for an unnecessarily long duration even if its owner
actually crashes. However, it is a safer approach to not to use a small session
time-to-live duration. If a session owner is known to be crashed, its session
could be closed manually via
<code>CPSessionManagementService.forceCloseSession(String, long)</code>.</p>
</div>
<div class="paragraph">
<p>See the <a href="#cp-subsystem-configuration">CP Subsystem Configuration section</a> for
more details.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fencedlock"><a class="anchor" href="#_fencedlock"></a>13.7. FencedLock</h3>
<div class="paragraph">
<p><code>FencedLock</code> is a linearizable &amp; distributed &amp; reentrant implementation of
<code>j.u.c.locks.Lock</code>. <code>FencedLock</code> is accessed via <code>CPSubsystem.getLock(String)</code>.
It is CP with respect to the CAP principle. It works on top of the Raft
consensus algorithm. It offers linearizability during crash-stop failures and
network partitions. If a network partition occurs, it remains available on at
most one side of the partition.</p>
</div>
<div class="paragraph">
<p><code>FencedLock</code> works on top of CP sessions. Please see <a href="#cp-sessions">CP Sessions</a>
section for more information about CP sessions.</p>
</div>
<div class="paragraph">
<p>By default, <code>FencedLock</code> is reentrant. Once a caller acquires the lock, it can
acquire the lock reentrantly as many times as it wants in a linearizable manner.
You can configure the reentrancy behavior via <code>FencedLockConfig</code>. For instance,
reentrancy can be disabled and <code>FencedLock</code> can work as a non-reentrant mutex.
You can also set a custom reentrancy limit. When the reentrancy limit is
already reached, <code>FencedLock</code> does not block a lock call. Instead, it fails
with <code>LockAcquireLimitReachedException</code> or a specified return value. Please
check the locking methods to see details about the behavior and
<a href="#fencedlock-configuration">FencedLock Configuration section</a> for
the configuration.</p>
</div>
<div class="paragraph">
<p>Distributed locks are unfortunately <strong>not equivalent</strong> to single-node mutexes
because of the complexities in distributed systems, such as uncertain
communication patterns, and independent and partial failures.
In an asynchronous network, no lock service can guarantee mutual exclusion,
because there is no way to distinguish between a slow and a crashed process.
Consider the following scenario, where a Hazelcast client acquires
a <code>FencedLock</code>, then hits a long GC pause. Since it will not be able to commit
session heartbeats while paused, its CP session will be eventually closed.
After this moment, another Hazelcast client can acquire this lock. If the first
client wakes up again, it may not immediately notice that it has lost ownership
of the lock. In this case, multiple clients think they hold the lock. If they
attempt to perform an operation on a shared resource, they can break
the system. To prevent such situations, you can choose to use an infinite
session timeout, but this time probably you are going to deal with liveliness
issues. For the scenario above, even if the first client actually crashes,
the requests sent by two clients can be reordered in the network and hit
the external resource in the reverse order.</p>
</div>
<div class="paragraph">
<p>There is a simple solution for this problem. Lock holders are ordered by a
monotonic fencing token, which increments each time the lock is assigned to a
new owner. This fencing token can be passed to external services or resources
to ensure sequential execution of the side effects performed by lock holders.</p>
</div>
<div class="paragraph">
<p>The following diagram illustrates the idea. Client-1 acquires the lock first
and receives <code>1</code> as its fencing token. Then, it passes this token to
the external service, which is our shared resource in this scenario. Just after
that, Client-1 hits a long GC pause and eventually loses ownership of the lock
because it misses to commit CP session heartbeats. Then, Client-2 chimes in and
acquires the lock. Similar to Client-1, Client-2 passes its fencing token to
the external service. After that, once Client-1 comes back alive, its write
request will be rejected by the external service, and only Client-2 will be
able to safely talk to it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/FencedLock.png" alt="Fenced Lock">
</div>
</div>
<div class="paragraph">
<p>You can read more about the fencing token idea in Martin Kleppmann&#8217;s
<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a>
blog post and Google&#8217;s <a href="https://ai.google/research/pubs/pub27897">Chubby paper</a>.
<code>FencedLock</code> integrates this idea with the <code>j.u.c.locks.Lock</code> abstraction,
excluding <code>j.u.c.locks.Condition</code>. <code>newCondition()</code> is not implemented and
throws <code>UnsupportedOperationException</code>.</p>
</div>
<div class="paragraph">
<p>All of the API methods in the new <code>FencedLock</code> abstraction offer exactly-once
execution semantics. For instance, even if a <code>lock()</code> call is internally
retried because of a crashed CP member, the lock is acquired only once.
The same rule also applies to the other methods in the API.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuration"><a class="anchor" href="#_configuration"></a>13.8. Configuration</h3>
<div class="sect3">
<h4 id="_cp_subsystem_configuration"><a class="anchor" href="#_cp_subsystem_configuration"></a>13.8.1. CP Subsystem Configuration</h4>
<div class="ulist">
<ul>
<li>
<p><code>cp-member-count</code>: Number of CP members to initialize CP Subsystem. It is <code>0</code>
by default, meaning that CP Subsystem is disabled. CP Subsystem is enabled when
a positive value is set. After CP Subsystem is initialized successfully, more
CP members can be added at run-time and the number of active CP members can go
beyond the configured CP member count. The number of CP members can be smaller
than the total size of the Hazelcast cluster. For instance, you can run <code>5</code> CP
members in a Hazelcast cluster of <code>20</code> members.</p>
<div class="paragraph">
<p>If set, must be greater than or equal to <code>group-size</code>.</p>
</div>
</li>
<li>
<p><code>group-size</code>: Number of CP members to form CP groups. If set, it must be
an odd number between <code>3</code> and <code>7</code>. Otherwise, <code>cp-member-count</code> is respected
while forming CP groups.</p>
<div class="paragraph">
<p>If set, must be smaller than or equal to <code>cpMemberCount</code>.</p>
</div>
</li>
<li>
<p><code>session-time-to-live-seconds</code>: Duration for a CP session to be kept alive
after the last received heartbeat. A CP session is closed if no session
heartbeat is received during this duration. Session TTL must be decided wisely.
If a very low value is set, a CP session can be closed prematurely if its owner
Hazelcast instance temporarily loses connectivity to CP Subsystem because of a
network partition or a GC pause. In such an occasion, all CP resources of this
Hazelcast instance, such as <code>FencedLock</code> or <code>ISemaphore</code>, are released.
On the other hand, if a very large value is set, CP resources can remain
assigned to an actually crashed Hazelcast instance for too long and liveliness
problems can occur. CP Subsystem offers an API in <code>CPSessionManagementService</code>
to deal with liveliness issues related to CP sessions. In order to prevent
premature session expires, session TTL configuration can be set a relatively
large value and <code>CPSessionManagementService.forceCloseSession(String, long)</code>
can be manually called to close CP session of a crashed Hazelcast instance.</p>
<div class="paragraph">
<p>Must be greater than <code>session-heartbeat-interval-seconds</code>, and smaller than or
equal to <code>missing-cp-member-auto-removal-seconds</code>.</p>
</div>
<div class="paragraph">
<p>Default value is <code>300</code> seconds.</p>
</div>
</li>
<li>
<p><code>session-heartbeat-interval-seconds</code>: Interval for the periodically-committed
CP session heartbeats. A CP session is started on a CP group with the first
session-based request of a Hazelcast instance. After that moment, heartbeats
are periodically committed to the CP group.</p>
<div class="paragraph">
<p>Must be smaller than <code>session-time-to-live-seconds</code>.</p>
</div>
<div class="paragraph">
<p>Default value is <code>5</code> seconds.</p>
</div>
</li>
<li>
<p><code>missing-cp-member-auto-removal-seconds</code>: Duration to wait before
automatically removing a missing CP member from CP Subsystem. When a CP member
leaves the Hazelcast cluster, it is not automatically removed from CP
Subsystem, since it could be still alive and left the cluster because of
a network partition. On the other hand, if a missing CP member is actually
crashed, it creates a danger for its CP groups, because it will be still part
of majority calculations. This situation could lead to losing majority of CP
groups if multiple CP members leave the cluster over time.</p>
<div class="paragraph">
<p>With the default configuration, missing CP members are automatically removed
from CP Subsystem after <code>4</code> hours. This feature is very useful in terms of
fault tolerance when CP member count is also configured to be larger than group
size. In this case, a missing CP member will be safely replaced in its CP
groups with other available CP members in CP Subsystem. This configuration also
implies that no network partition is expected to be longer than the configured
duration.</p>
</div>
<div class="paragraph">
<p>If a missing CP member comes back alive after it is automatically removed from
CP Subsystem with this feature, that CP member must be terminated manually.</p>
</div>
<div class="paragraph">
<p>Must be greater than or equal to <code>session-time-to-live-seconds</code>.</p>
</div>
<div class="paragraph">
<p>Default value is <code>14400</code> seconds (<code>4</code> hours).</p>
</div>
</li>
<li>
<p><code>fail-on-indeterminate-operation-state</code>: Offers a choice between
at-least-once and at-most-once execution of the operations on top of the Raft
consensus algorithm. It is disabled by default and offers at-least-once
execution guarantee. If enabled, it switches to at-most-once execution
guarantee. When you invoke an API method on a CP data structure proxy, it
replicates an internal operation to the corresponding CP group. After this
operation is committed to majority of this CP group by the Raft leader node, it
sends a response for the public API call. If a failure causes loss of
the response, then the calling side cannot determine if the operation is
committed on the CP group or not. In this case, if this configuration is
disabled, the operation is replicated again to the CP group, and hence could be
committed multiple times. If it is enabled, the public API call fails with
<code>IndeterminateOperationStateException</code>.</p>
<div class="paragraph">
<p>Default value is <code>false</code>.</p>
</div>
</li>
<li>
<p><code>persistence-enabled</code>: Specifies whether CP Subsystem Persistence is globally
enabled for CP groups created in CP Subsystem. If enabled, CP members persist
their local CP data to stable storage and can recover from crashes.</p>
<div class="paragraph">
<p>Default value is <code>false</code>.</p>
</div>
</li>
<li>
<p><code>base-dir</code>: Specifies the parent directory where CP data is stored. You can
use the default value, or you can specify the value of another folder, but it
is mandatory that <code>base-dir</code> element has a value. This directory is created
automatically if it does not exist.</p>
<div class="paragraph">
<p><code>base-dir</code> is used as the parent directory, and a unique directory is created
inside <code>base-dir</code> for each CP member which uses the same <code>base-dir</code>. That
means, <code>base-dir</code> is shared among multiple CP members safely. This is
especially useful for cloud environments where CP members generally use
a shared filesystem.</p>
</div>
<div class="paragraph">
<p>Default value is <code>cp-data</code>.</p>
</div>
</li>
<li>
<p><code>data-load-timeout-seconds</code>: Timeout duration for CP members to restore their
data from disk. A CP member fails its startup if it cannot complete its CP data
restore process in the configured duration.</p>
<div class="paragraph">
<p>Default value is <code>120</code> seconds.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cp-subsystem&gt;
        &lt;cp-member-count&gt;7&lt;/cp-member-count&gt;
        &lt;group-size&gt;3&lt;/group-size&gt;
        &lt;session-time-to-live-seconds&gt;300&lt;/session-time-to-live-seconds&gt;
        &lt;session-heartbeat-interval-seconds&gt;5&lt;/session-heartbeat-interval-seconds&gt;
        &lt;missing-cp-member-auto-removal-seconds&gt;14400&lt;/missing-cp-member-auto-removal-seconds&gt;
        &lt;fail-on-indeterminate-operation-state&gt;false&lt;/fail-on-indeterminate-operation-state&gt;
        &lt;persistence-enabled&gt;true&lt;/persistence-enabled&gt;
        &lt;base-dir&gt;/custom-cp-dir&lt;/base-dir&gt;
    &lt;/cp-subsystem&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cp-subsystem:
    cp-member-count: 7
    group-size: 3
    session-time-to-live-seconds: 300
    session-heartbeat-interval-seconds: 5
    missing-cp-member-auto-removal-seconds: 14400
    fail-on-indeterminate-operation-state: false
    persistence-enabled: true
    base-dir: custom-cp-dir</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getCPSubsystemConfig()
              .setCPMemberCount(7)
              .setGroupSize(3)
              .setSessionTimeToLiveSeconds(300)
              .setSessionHeartbeatIntervalSeconds(5)
              .setMissingCPMemberAutoRemovalSeconds(14400)
              .setFailOnIndeterminateOperationState(false);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fencedlock_configuration"><a class="anchor" href="#_fencedlock_configuration"></a>13.8.2. FencedLock Configuration</h4>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of the <code>FencedLock</code>.</p>
</li>
<li>
<p><code>lock-acquire-limit</code>: Maximum number of reentrant lock acquires. Once
a caller acquires the lock this many times, it will not be able to acquire
the lock again, until it makes at least one <code>unlock()</code> call.</p>
<div class="paragraph">
<p>By default, no upper bound is set for the number of reentrant lock acquires,
which means that once a caller acquires a <code>FencedLock</code>, all of its further
<code>lock()</code> calls will succeed. However, for instance, if you set
<code>lock-acquire-limit</code> to <code>2</code>, once a caller acquires the lock, it will be able
to acquire it once more, but its third <code>lock()</code> call will not succeed.</p>
</div>
<div class="paragraph">
<p>If <code>lock-acquire-limit</code> is set to 1, then the lock becomes non-reentrant.</p>
</div>
<div class="paragraph">
<p><code>0</code> means there is no upper bound for the number of reentrant lock acquires.</p>
</div>
<div class="paragraph">
<p>Default value is <code>0</code>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cp-subsystem&gt;
        ...
        &lt;locks&gt;
            &lt;fenced-lock&gt;
                &lt;name&gt;reentrant-lock&lt;/name&gt;
                &lt;lock-acquire-limit&gt;0&lt;/lock-acquire-limit&gt;
            &lt;/fenced-lock&gt;
            &lt;fenced-lock&gt;
                &lt;name&gt;limited-reentrant-lock&lt;/name&gt;
                &lt;lock-acquire-limit&gt;10&lt;/lock-acquire-limit&gt;
            &lt;/fenced-lock&gt;
            &lt;fenced-lock&gt;
                &lt;name&gt;non-reentrant-lock&lt;/name&gt;
                &lt;lock-acquire-limit&gt;1&lt;/lock-acquire-limit&gt;
            &lt;/fenced-lock&gt;
        &lt;/locks&gt;
    &lt;/cp-subsystem&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cp-subsystem:
    locks:
      reentrant-lock:
        lock-acquire-limit: 0
      limited-reentrant-lock:
        lock-acquire-limit: 10
      non-reentrant-lock:
        lock-acquire-limit: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getCPSubsystemConfig()
              .addLockConfig(new FencedLockConfig("reentrant-lock", 0))
              .addLockConfig(new FencedLockConfig("limited-reentrant-lock", 10))
              .addLockConfig(new FencedLockConfig("non-reentrant-lock", 1));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_semaphore_configuration"><a class="anchor" href="#_semaphore_configuration"></a>13.8.3. Semaphore Configuration</h4>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of the CP <code>ISemaphore</code>.</p>
</li>
<li>
<p><code>jdk-compatible</code>: Enables / disables JDK compatibility of the CP
<code>ISemaphore</code>. When it is JDK compatible, just as in
the <code>j.u.c.Semaphore.release()</code> method, a permit can be released without
acquiring it first, because acquired permits are not bound to threads. However,
there is no auto-cleanup of the acquired permits upon Hazelcast server / client
failures. If a permit holder fails, its permits must be released manually. When
JDK compatibility is disabled, a <code>HazelcastInstance</code> must acquire permits
before releasing them and it cannot release a permit that it has not acquired.
It means, you can acquire a permit from one thread and release it from another
thread using the same <code>HazelcastInstance</code>, but not different
<code>HazelcastInstance</code>s. In this mode, acquired permits are automatically
released upon failure of the holder <code>HazelcastInstance</code>. So there is a minor
behavioral difference to the <code>j.u.c.Semaphore.release()</code> method.</p>
<div class="paragraph">
<p>JDK compatibility is disabled by default.</p>
</div>
</li>
<li>
<p><code>initial-permits</code>: Number of permits to initialize the Semaphore.
If a positive value is set, the Semaphore is initialized with the given number
of permits.</p>
<div class="paragraph">
<p>Default value is 0.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cp-subsystem&gt;
        ...
        &lt;semaphores&gt;
            &lt;cp-semaphore&gt;
                &lt;name&gt;jdk-compatible-semaphore&lt;/name&gt;
                &lt;jdk-compatible&gt;true&lt;/jdk-compatible&gt;
            &lt;/cp-semaphore&gt;
            &lt;cp-semaphore&gt;
                &lt;name&gt;another-semaphore&lt;/name&gt;
                &lt;jdk-compatible&gt;false&lt;/jdk-compatible&gt;
                &lt;initial-permits&gt;5&lt;/initial-permits&gt;
            &lt;/cp-semaphore&gt;
        &lt;/semaphores&gt;
    &lt;/cp-subsystem&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cp-subsystem:
    semaphores:
      jdk-compatible-semaphore:
        jdk-compatible: true
      another-semaphore:
        jdk-compatible: false
        initial-permits: 5</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getCPSubsystemConfig()
              .addSemaphoreConfig(new SemaphoreConfig("jdk-compatible-semaphore", true, 0))
              .addSemaphoreConfig(new SemaphoreConfig("another-semaphore", false, 5));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_raft_algorithm_configuration"><a class="anchor" href="#_raft_algorithm_configuration"></a>13.8.4. Raft Algorithm Configuration</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
These parameters tune specific parameters of Hazelcast&#8217;s Raft
consensus algorithm implementation and are only for power users.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>leader-election-timeout-in-millis</code>: Leader election timeout in milliseconds.
If a candidate cannot win the majority of the votes in time, a new election
round is initiated.</p>
<div class="paragraph">
<p>Default value is <code>2000</code> milliseconds.</p>
</div>
</li>
<li>
<p><code>leader-heartbeat-period-in-millis</code>: Duration in milliseconds for a Raft
leader node to send periodic heartbeat messages to its followers in order to
denote its liveliness. Periodic heartbeat messages are actually append entries
requests and can contain log entries for the lagging followers. If a too small
value is set, heartbeat messages are sent from Raft leaders to followers too
frequently and it can cause an unnecessary usage of CPU and network.</p>
<div class="paragraph">
<p>Default value is <code>5000</code> milliseconds.</p>
</div>
</li>
<li>
<p><code>max-missed-leader-heartbeat-count</code>: Maximum number of missed Raft leader
heartbeats for a follower to trigger a new leader election round. For instance,
if <code>leader-heartbeat-period-in-millis</code> is <code>1</code> second and this value is set to
<code>5</code>, then a follower triggers a new leader election round if <code>5</code> seconds pass
after the last heartbeat message of the current Raft leader node. If this
duration is too small, new leader election rounds can be triggered
unnecessarily if the current Raft leader temporarily slows down or a network
congestion occurs. If it is too large, it takes longer to detect failures of
Raft leaders.</p>
<div class="paragraph">
<p>Default value is <code>5</code>.</p>
</div>
</li>
<li>
<p><code>append-request-max-entry-count</code>: Maximum number of Raft log entries that can
be sent as a batch in a single append entries request. In Hazelcast&#8217;s Raft
consensus algorithm implementation, a Raft leader maintains a separate
replication pipeline for each follower. It sends a new batch of Raft log
entries to a follower after the follower acknowledges the last append entries
request sent by the leader.</p>
<div class="paragraph">
<p>Default value is <code>100</code>.</p>
</div>
</li>
<li>
<p><code>commit-index-advance-count-to-snapshot</code>: Number of new commits to initiate
a new snapshot after the last snapshot taken by the local Raft node. This value
must be configured wisely as it effects performance of the system in multiple
ways. If a small value is set, it means that snapshots are taken too frequently
and Raft nodes keep a very short Raft log. If snapshots are large and CP
Subsystem Persistence is enabled, this can create an unnecessary overhead on I/O
performance. Moreover, a Raft leader can send too many snapshots to followers
and this can create an unnecessary overhead on network. On the other hand, if
a very large value is set, it can create a memory overhead since Raft log
entries are going to be kept in memory until the next snapshot.</p>
<div class="paragraph">
<p>Default value is <code>10000</code>.</p>
</div>
</li>
<li>
<p><code>uncommitted-entry-count-to-reject-new-appends</code>: Maximum number of
uncommitted log entries in the leader&#8217;s Raft log before temporarily rejecting
new requests of callers. Since Raft leaders send log entries to followers in
batches, they accumulate incoming requests in order to improve the throughput.
You can configure this field by considering your degree of concurrency in your
callers. For instance, if you have at most <code>1000</code> threads sending requests to
a Raft leader, you can set this field to <code>1000</code> so that callers do not get
retry responses unnecessarily.</p>
<div class="paragraph">
<p>Default value is <code>100</code>.</p>
</div>
</li>
<li>
<p><code>append-request-backoff-timeout-in-millis</code>: Timeout duration in milliseconds
to apply backoff on append entries requests. After a Raft leader sends
an append entries request to a follower, it will not send a subsequent append
entries request either until the follower responds or this timeout occurs.
Backoff durations are increased exponentially if followers remain unresponsive.</p>
<div class="paragraph">
<p>Default value is <code>100</code> milliseconds.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cp-subsystem&gt;
        ...
        &lt;raft-algorithm&gt;
            &lt;leader-election-timeout-in-millis&gt;2000&lt;/leader-election-timeout-in-millis&gt;
            &lt;leader-heartbeat-period-in-millis&gt;5000&lt;/leader-heartbeat-period-in-millis&gt;
            &lt;max-missed-leader-heartbeat-count&gt;5&lt;/max-missed-leader-heartbeat-count&gt;
            &lt;append-request-max-entry-count&gt;100&lt;/append-request-max-entry-count&gt;
            &lt;commit-index-advance-count-to-snapshot&gt;10000&lt;/commit-index-advance-count-to-snapshot&gt;
            &lt;uncommitted-entry-count-to-reject-new-appends&gt;200&lt;/uncommitted-entry-count-to-reject-new-appends&gt;
            &lt;append-request-backoff-timeout-in-millis&gt;250&lt;/append-request-backoff-timeout-in-millis&gt;
        &lt;/raft-algorithm&gt;
        ...
    &lt;/cp-subsystem&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cp-subsystem:
    raft-algorithm:
      leader-election-timeout-in-millis: 2000
      leader-heartbeat-period-in-millis: 5000
      max-missed-leader-heartbeat-count: 5
      append-request-max-entry-count: 100
      commit-index-advance-count-to-snapshot: 10000
      uncommitted-entry-count-to-reject-new-appends: 200
      append-request-backoff-timeout-in-millis: 250</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getCPSubsystemConfig()
              .getRaftAlgorithmConfig()
              .setLeaderElectionTimeoutInMillis(2000)
              .setLeaderHeartbeatPeriodInMillis(5000)
              .setMaxMissedLeaderHeartbeatCount(5)
              .setAppendRequestMaxEntryCount(50)
              .setAppendRequestMaxEntryCount(1000)
              .setUncommittedEntryCountToRejectNewAppends(200)
              .setAppendRequestBackoffTimeoutInMillis(250);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cp_subsystem_unsafe_mode"><a class="anchor" href="#_cp_subsystem_unsafe_mode"></a>13.9. CP Subsystem Unsafe Mode</h3>
<div class="paragraph">
<p>When CP Subsystem is not enabled, that means
<code>CPSubsystemConfig.getCPMemberCount()</code> is <code>0</code>, CP data structures operate in
<em>the unsafe mode</em>. In this mode, they use Hazelcast&#8217;s partitioning and lazy
replication mechanisms instead of CP Subsystem&#8217;s consensus mechanism. For more
information about the lazy replication mechanism of Hazelcast, see
the <a href="#consistency-and-replication-model">Consistency and Replication Model chapter</a>.</p>
</div>
<div class="paragraph">
<p><em>The unsafe mode</em> provides weaker consistency guarantees compared to when CP
Subsystem is enabled. For example, when you increment an <code>IAtomicLong</code> or
acquire a <code>FencedLock</code>, just before crash of a member, even though you receive
a success response, the write operation (increment of <code>IAtomicLong</code> or acquire
of <code>FencedLock</code>) can be lost (which cannot happen when CP Subsystem is enabled).
For this reason, <em>the unsafe mode</em> is not recommended for use-cases requiring
strong consistency. It is more suitable for development or testing. You should
take this limitation into consideration if you use CP Subsystem in production
with <em>the unsafe mode</em>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
CP Subsystem Management APIs are not available in <em>the unsafe mode</em>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In <em>the unsafe mode</em>, split-brain protection is not supported.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_cp_subsystem_management"><a class="anchor" href="#_cp_subsystem_management"></a>13.10. CP Subsystem Management</h3>
<div class="paragraph">
<p>Unlike the dynamic nature of Hazelcast clusters, CP Subsystem requires manual
intervention while expanding/shrinking its size, or when a CP member crashes or
becomes unreachable. When a CP member becomes unreachable, it is not
automatically removed from CP Subsystem because it could be still alive and
partitioned away.</p>
</div>
<div class="paragraph">
<p>Moreover, by default CP Subsystem works in memory without persisting any state
to disk. It means that a crashed CP member will not be able to recover by
reloading its previous state. Therefore, crashed CP members create a danger for
gradually losing the majority of CP groups and eventually total loss of
the availability of CP Subsystem. To prevent such situations,
<code>CPSubsystemManagementService</code> offers a set of APIs. In addition, CP Subsystem
Persistence can be enabled to make CP members persist their local CP state to
stable storage. Please see <a href="#cp-subsystem-persistence">CP Subsystem Persistence section</a>
for more details.</p>
</div>
<div class="paragraph">
<p>CP Subsystem relies on Hazelcast&#8217;s failure detectors to test reachability of CP
members. Before removing a CP member from CP Subsystem, please make sure that
it is declared as unreachable by Hazelcast&#8217;s failure detector and removed from
Hazelcast cluster&#8217;s member list.</p>
</div>
<div class="paragraph">
<p>CP member additions and removals are internally handled by performing a single
membership change at a time. When multiple CP members are shutting down
concurrently, their shutdown process is executed serially. When a CP membership
change is triggered, <em>the METADATA CP group</em> creates a membership change plan
for CP groups. Then, the scheduled changes are applied to the CP groups one by
one. After all CP group member removals are done, the shutting down CP member
is removed from the active CP members list and its shutdown process is
completed. A shut-down CP member is automatically replaced with another
available CP member in all of its CP groups, including <em>the METADATA CP group</em>,
in order not to decrease or more importantly not to lose the majority of CP
groups. If there is no available CP member to replace a shutting down CP member
in a CP group, that group&#8217;s size is reduced by 1 and its majority value is
recalculated. Please note that this behavior is when CP Subsystem Persistence
is disabled. When CP Subsystem Persistence is enabled, shut-down CP members are
not automatically removed from the active CP members list and they are still
considered as part of CP groups and majority calculations, because they can come
back by restoring their local CP state from stable storage. If you know that a
shut-down CP member will not be restarted, you need to remove that member from
CP Subsystem via <code>CPSubsystemManagementService.removeCPMember(String)</code>.</p>
</div>
<div class="paragraph">
<p>A new CP member can be added to CP Subsystem to either increase the number of
available CP members for new CP groups or to fill the missing slots in existing
CP groups. After the initial Hazelcast cluster startup is done, an existing
Hazelcast member can be be promoted to the CP member role. This new CP member
automatically joins to CP groups that have missing members, and majority values
of these CP groups are recalculated.</p>
</div>
<div class="sect3">
<h4 id="_cp_subsystem_management_apis"><a class="anchor" href="#_cp_subsystem_management_apis"></a>13.10.1. CP Subsystem Management APIs</h4>
<div class="paragraph">
<p>You can access the CP Subsystem management APIs using the Java API or REST
interface. To communicate with the REST interface there are two options; one is
to access REST endpoint URL directly or using the <code>cp-subsystem.sh</code> shell
script, which comes with the Hazelcast package.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>cp-cluster.sh</code> script uses <code>curl</code> command, and <code>curl</code> must be
installed to be able to use the script.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Get Local CP Member:</strong></p>
<div class="paragraph">
<p>Returns the local CP member if this Hazelcast member is a part of CP Subsystem.</p>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPMember localMember = cpSubsystem.getLocalCPMember();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/members/local
OR
&gt; sh cp-subsystem.sh -o get-local-member --address 127.0.0.1 --port 5701
+
Sample Response:
{
    "uuid": "6428d7fd-6079-48b2-902c-bdf6a376051e",
    "address": "[127.0.0.1]:5701"
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Get CP Groups:</strong></p>
<div class="paragraph">
<p>Returns the list of active CP groups.</p>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSubsystemManagementService managementService = cpSubsystem.getCPSubsystemManagementService();
        CompletionStage&lt;Collection&lt;CPGroupId&gt;&gt; future = managementService.getCPGroupIds();
        Collection&lt;CPGroupId&gt; groups = future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/groups
OR
&gt; sh cp-subsystem.sh -o get-groups --address 127.0.0.1 --port 5701
+
Sample Response:
[{
    "name": "METADATA",
    "id": 0
}, {
    "name": "atomics",
    "id": 8
}, {
    "name": "locks",
    "id": 14
}]</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Get a single CP Group:</strong></p>
<div class="paragraph">
<p>Returns the active CP group with the given name. There can be at most one
active CP group with a given name.</p>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSubsystemManagementService managementService = cpSubsystem.getCPSubsystemManagementService();
        CompletionStage&lt;CPGroup&gt; future = managementService.getCPGroup(groupName);
        CPGroup group = future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/groups/${CPGROUP_NAME}
OR
&gt; sh cp-subsystem.sh -o get-group --group ${CPGROUP_NAME} --address 127.0.0.1 --port 5701
+
Sample Response:
{
    "id": {
        "name": "locks",
        "id": 14
    },
    "status": "ACTIVE",
    "members": [{
        "uuid": "33f84b0f-46ba-4a41-9e0a-29ee284c1c2a",
        "address": "[127.0.0.1]:5703"
    }, {
        "uuid": "59ca804c-312c-4cd6-95ff-906b2db13acb",
        "address": "[127.0.0.1]:5704"
    }, {
        "uuid": "777ff6ea-b8a3-478d-9642-47d1db019b37",
        "address": "[127.0.0.1]:5705"
    }, {
        "uuid": "c7856e0f-25d2-4717-9919-88fb3ecb3384",
        "address": "[127.0.0.1]:5702"
    }, {
        "uuid": "c6229b44-8976-4602-bb57-d13cf743ccef",
        "address": "[127.0.0.1]:5701"
    }]
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Get CP Members:</strong></p>
<div class="paragraph">
<p>Returns the list of active CP members in the cluster.</p>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSubsystemManagementService managementService = cpSubsystem.getCPSubsystemManagementService();
        CompletionStage&lt;Collection&lt;CPMember&gt;&gt; future = managementService.getCPMembers();
        Collection&lt;CPMember&gt; members = future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/members
OR
&gt; sh cp-subsystem.sh -o get-members --address 127.0.0.1 --port 5701
+
Sample Response:
[{
    "uuid": "33f84b0f-46ba-4a41-9e0a-29ee284c1c2a",
    "address": "[127.0.0.1]:5703"
}, {
    "uuid": "59ca804c-312c-4cd6-95ff-906b2db13acb",
    "address": "[127.0.0.1]:5704"
}, {
    "uuid": "777ff6ea-b8a3-478d-9642-47d1db019b37",
    "address": "[127.0.0.1]:5705"
}, {
    "uuid": "c6229b44-8976-4602-bb57-d13cf743ccef",
    "address": "[127.0.0.1]:5701"
}, {
    "uuid": "c7856e0f-25d2-4717-9919-88fb3ecb3384",
    "address": "[127.0.0.1]:5702"
}]</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Force Destroy a CP Group:</strong></p>
<div class="paragraph">
<p>Unconditionally destroys the given active CP group without using the Raft
algorithm mechanics. This method must be used only when a CP group loses its
majority and cannot make progress anymore. Normally, membership changes in CP
groups, such as CP member promotion or removal, are done via the Raft consensus
algorithm. However, when a CP group permanently loses its majority, it will not
be able to commit any new operation. Therefore, this method ungracefully
terminates the remaining members of the given CP group on the remaining CP
group members. It also performs a Raft commit to <em>the METADATA CP group</em> in
order to update the status of the destroyed group. Once a CP group is
destroyed, all CP data structure proxies created before the destroy fails
with <code>CPGroupDestroyedException</code>. However, if a new proxy is created
afterwards, then this CP group is re-created from scratch with a new set of CP
members.</p>
</div>
<div class="paragraph">
<p>This method is idempotent. It has no effect if the given CP group is already
destroyed.</p>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSubsystemManagementService managementService = cpSubsystem.getCPSubsystemManagementService();
        CompletionStage&lt;Void&gt; future = managementService.forceDestroyCPGroup(groupName);
        future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl -X POST --data "${GROUPNAME}&amp;${PASSWORD}" http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/groups/${CPGROUP_NAME}/remove
OR
&gt; sh cp-subsystem.sh -o force-destroy-group --group ${CPGROUP_NAME} --address 127.0.0.1 --port 5701 --groupname ${GROUPNAME} --password ${PASSWORD}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Remove a CP Member:</strong></p>
<div class="paragraph">
<p>Removes the given unreachable CP member from the active CP members list and all
CP groups it belongs to. If any other active CP member is available, it
replaces the removed CP member in its CP groups. Otherwise, CP groups which
the removed CP member is a member of shrinks and their majority values are
recalculated.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Before removing a CP member from CP Subsystem, please make sure that
it is declared as unreachable by Hazelcast&#8217;s failure detector and removed from
Hazelcast&#8217;s member list. The behavior is undefined when a running CP member is
removed from CP Subsystem.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSubsystemManagementService managementService = cpSubsystem.getCPSubsystemManagementService();
        CompletionStage&lt;Void&gt; future = managementService.removeCPMember(memberUUID);
        future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl -X POST --data "${GROUPNAME}&amp;${PASSWORD}" http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/members/${CPMEMBER_UUID}/remove
OR
&gt; sh cp-subsystem.sh -o remove-member --member ${CPMEMBER_UUID} --address 127.0.0.1 --port 5701 --groupname ${GROUPNAME} --password ${PASSWORD}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Promote Local Member to a CP Member</strong></p>
<div class="paragraph">
<p>Promotes the local Hazelcast member to the CP member. If the local member is
already in the active CP members list, i.e., it is already a CP member, then
this method has no effect. When the local member is promoted to the CP role,
its member UUID is assigned as CP member UUID. The promoted CP member will be
added to the CP groups that have missing members, i.e., whose current size is
smaller than <code>CPSubsystemConfig.getGroupSize()</code>.</p>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSubsystemManagementService managementService = cpSubsystem.getCPSubsystemManagementService();
        CompletionStage&lt;Void&gt; future = managementService.promoteToCPMember();
        future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl -X POST --data "${GROUPNAME}&amp;${PASSWORD}" http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/members
OR
&gt; sh cp-subsystem.sh -o promote-member --address 127.0.0.1 --port 5701 --groupname ${GROUPNAME} --password ${PASSWORD}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Wipe and Reset CP Subsystem</strong></p>
<div class="paragraph">
<p>Wipes and resets the whole CP Subsystem state and initializes it as if
the Hazelcast cluster is starting up initially. This method must be used only
when <em>the METADATA CP group</em> loses its majority and cannot make progress
anymore.</p>
</div>
<div class="paragraph">
<p>After this method is called, all CP state and data are wiped and CP members
start with empty state.</p>
</div>
<div class="paragraph">
<p>This method can be invoked only from the Hazelcast master member, which is
the first member in the Hazelcast cluster member list. Moreover, the Hazelcast
cluster must have at least <code>CPSubsystemConfig.getCPMemberCount()</code> members.</p>
</div>
<div class="paragraph">
<p>This method must not be called while there are membership changes in
the Hazelcast cluster. Before calling this method, please make sure that there
is no new member joining and all existing Hazelcast members have seen the same
member list.</p>
</div>
<div class="paragraph">
<p>To be able to use this method, the initial CP member count of CP Subsystem,
which is defined by <code>CPSubsystemConfig.getCPMemberCount()</code>, must be satisfied.
For instance, if <code>CPSubsystemConfig.getCPMemberCount()</code> is 5 and only 1 CP
member is alive, when this method is called, 4 additional AP Hazelcast members
should exist in the cluster, or new Hazelcast members must be started.</p>
</div>
<div class="paragraph">
<p>This method also deletes all data written by CP Subsystem Persistence.</p>
</div>
<div class="paragraph">
<p>This method triggers a new CP discovery process round. However, if the new CP
discovery round fails for any reason, Hazelcast members are not terminated,
because Hazelcast members are likely to contain data for AP data structures
and their termination can cause data loss. Hence, you need to observe
the cluster and check if the CP discovery process completes successfully.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This method is <strong>NOT</strong> idempotent and multiple invocations can break
the whole system! After calling this API, you must observe the system to see if
the reset process is successfully completed or failed before making another
call.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This method deletes all CP data written by CP Subsystem Persistence.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSubsystemManagementService managementService = cpSubsystem.getCPSubsystemManagementService();
        CompletionStage&lt;Void&gt; future = managementService.reset();
        future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl -X POST --data "${GROUPNAME}&amp;${PASSWORD}" http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/reset
OR
&gt; sh cp-subsystem.sh -o reset --address 127.0.0.1 --port 5701 --groupname ${GROUPNAME} --password ${PASSWORD}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_session_management_api"><a class="anchor" href="#_session_management_api"></a>13.10.2. Session Management API</h4>
<div class="paragraph">
<p>There are two management API methods for session management.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Get CP Group Sessions:</strong></p>
<div class="paragraph">
<p>Returns all CP sessions that are currently active in a CP group.</p>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSessionManagementService sessionManagementService = cpSubsystem.getCPSessionManagementService();
        CompletionStage&lt;Collection&lt;CPSession&gt;&gt; future = sessionManagementService.getAllSessions(groupName);
        Collection&lt;CPSession&gt; sessions = future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/groups/${CPGROUP_NAME}/sessions
OR
&gt; sh cp-subsystem.sh -o get-sessions --group ${CPGROUP_NAME} --address 127.0.0.1 --port 5701
+
Sample Response:
[{
    "id": 1,
    "creationTime": 1549008095530,
    "expirationTime": 1549008766630,
    "version": 73,
    "endpoint": "[127.0.0.1]:5701",
    "endpointType": "SERVER",
    "endpointName": "hz-member-1"
}, {
    "id": 2,
    "creationTime": 1549008115419,
    "expirationTime": 1549008765425,
    "version": 71,
    "endpoint": "[127.0.0.1]:5702",
    "endpointType": "SERVER",
    "endpointName": "hz-member-2"
}]</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Force Close a Session:</strong></p>
<div class="paragraph">
<p>If a Hazelcast instance that owns a CP session crashes, its CP session is not
terminated immediately. Instead, the session is closed after
<code>CPSubsystemConfig.getSessionTimeToLiveSeconds()</code> passes. If it is known for
sure that the session owner is not partitioned and definitely crashed, this
method can be used for closing the session and releasing its resources
immediately.</p>
</div>
<div class="listingblock">
<div class="title">Java API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        CPSessionManagementService sessionManagementService = cpSubsystem.getCPSessionManagementService();
        CompletionStage&lt;Boolean&gt; future = sessionManagementService.forceCloseSession(groupName, sessionId);
        future.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REST API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">&gt; curl -X POST --data "${GROUPNAME}&amp;${PASSWORD}" http://127.0.0.1:5701/hazelcast/rest/cp-subsystem/groups/${CPGROUP_NAME}/sessions/${CP_SESSION_ID}/remove
OR
&gt; sh cp-subsystem.sh -o force-close-session --group ${CPGROUP_NAME} --session-id ${CP_SESSION_ID} --address 127.0.0.1 --port 5701 --groupname ${GROUPNAME} --password ${PASSWORD}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transactions"><a class="anchor" href="#_transactions"></a>14. Transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter explains the usage of Hazelcast in a transactional context.
It describes the Hazelcast transaction types and how they work,
how to provide XA (e<strong>X</strong>tended <strong>A</strong>rchiteture) transactions and
how to integrate Hazelcast with J2EE containers.</p>
</div>
<div class="sect2">
<h3 id="_creating_a_transaction_interface"><a class="anchor" href="#_creating_a_transaction_interface"></a>14.1. Creating a Transaction Interface</h3>
<div class="paragraph">
<p>You create a <code>TransactionContext</code> object to begin, commit and rollback
a transaction. You can obtain transaction-aware instances of queues,
maps, sets, lists and multimaps via <code>TransactionContext</code>, work with
them and commit/rollback in one shot. You can see the TransactionContext API
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/transaction/TransactionContext.html" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="paragraph">
<p>Hazelcast supports two types of transactions: ONE_PHASE and TWO_PHASE.
The type of transaction controls what happens when a member crashes
while a transaction is committing. The default behavior is TWO_PHASE.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>ONE_PHASE</strong>: By selecting this transaction type, you execute the
transactions with a single phase that is committing the changes.
Since a preparing phase does not exist, the conflicts are not detected.
When a conflict happens while committing the changes, e.g., due to a
member crash, not all the changes are written and this leaves the
system in an inconsistent state.</p>
</li>
<li>
<p><strong>TWO_PHASE</strong>: When you select this transaction type, Hazelcast
first tries to execute the prepare phase. This phase fails if there
are any conflicts. Once the prepare phase is successful, Hazelcast
executes the commit phase (writing the changes). Before TWO_PHASE
commits, Hazelcast copies the commit log to other members, so in case
of a member failure, another member can complete the commit.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TransactionalMember {

    public static void main(String[] args) throws Exception {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

        TransactionOptions options = new TransactionOptions()
                .setTransactionType( TransactionOptions.TransactionType.ONE_PHASE );

        TransactionContext context = hazelcastInstance.newTransactionContext( options );
        context.beginTransaction();

        TransactionalQueue queue = context.getQueue( "myqueue" );
        TransactionalMap map = context.getMap( "mymap" );
        TransactionalSet set = context.getSet( "myset" );

        try {
            Object obj = queue.poll();
            //process obj
            map.put( "1", "value1" );
            set.add( "value" );
            //do other things
            context.commitTransaction();
        } catch ( Throwable t ) {
            context.rollbackTransaction();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a transaction, operations are not executed immediately.
Their changes are local to the <code>TransactionContext</code> until
committed. However, they ensure the changes via locks.</p>
</div>
<div class="paragraph">
<p>For the above example, when <code>map.put</code> is executed, no data
is put in the map but the key is locked against changes.
While committing, operations are executed, the value is put
to the map and the key is unlocked.</p>
</div>
<div class="paragraph">
<p>The isolation level in Hazelcast Transactions is <code>READ_COMMITTED</code>
on the level of a single partition. If you are in a transaction,
you can read the data in your transaction and the data that is
already committed. If you are not in a transaction, you can only
read the committed data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The REPEATABLE_READ isolation level can also be exercised
using the method <code>getForUpdate()</code> of <code>TransactionalMap</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The isolation levels might be broken if the objects involved
in the transaction span multiple partitions. A reader which is not
in a transaction can then temporarily observe partially committed data.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_queuesetlist_vs_mapmultimap"><a class="anchor" href="#_queuesetlist_vs_mapmultimap"></a>14.1.1. Queue/Set/List vs. Map/Multimap</h4>
<div class="paragraph">
<p>Hazelcast implements queue/set/list operations differently than
map/multimap operations. For queue operations (offer, poll), offered
and/or polled objects are copied to the owner member in order to safely
commit/rollback. For map/multimap, Hazelcast first acquires the locks
for the write operations (put, remove) and holds the differences (what
is added/removed/updated) locally for each transaction. When the
transaction is set to commit, Hazelcast releases the locks and apply
the differences. When rolling back, Hazelcast releases the locks and
discard the differences.</p>
</div>
<div class="paragraph">
<p><code>MapStore</code> and <code>QueueStore</code> do not participate in transactions.
Hazelcast suppresses exceptions thrown by the store in a transaction.
See the <a href="#providing-xa-transactions">XA Transactions section</a> for
further information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_one_phase_vs_two_phase"><a class="anchor" href="#_one_phase_vs_two_phase"></a>14.1.2. ONE_PHASE vs. TWO_PHASE</h4>
<div class="paragraph">
<p>As discussed in <a href="#creating-a-transaction-interface">Creating a Transaction
Interface</a>, when you choose ONE_PHASE as the transaction type, Hazelcast
tracks all changes you make locally in a commit log, i.e., a list of
changes. In this case, all the other members are asked to agree that the
commit can succeed and once they agree, Hazelcast starts to write the changes.
However, if the member that initiates the commit crashes after it has written
to at least one member (but has not completed writing to all other members),
your system may be left in an inconsistent state.</p>
</div>
<div class="paragraph">
<p>On the other hand, if you choose TWO_PHASE as the transaction type, the commit
log is again tracked locally but it is copied to another cluster member.
Therefore, when a failure happens, e.g., the member initiating the commit
crashes, you still have the commit log in another member and that member can
complete the commit. However, copying the commit log to another member makes
the TWO_PHASE approach slow.</p>
</div>
<div class="paragraph">
<p>Consequently, it is recommended that you choose ONE_PHASE as the transaction
type if you want better performance, and that you choose TWO_PHASE if reliability
of your system is more important than the performance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It should be noted that in split-brain situations or during a member
failure, Hazelcast might not be able to always hold ACID guarantees.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_providing_xa_transactions"><a class="anchor" href="#_providing_xa_transactions"></a>14.2. Providing XA Transactions</h3>
<div class="paragraph">
<p>XA describes the interface between the global transaction manager and the
local resource manager. XA allows multiple resources (such as databases,
application servers, message queues and transactional caches) to be accessed
within the same transaction, thereby preserving the ACID properties across
applications. XA uses a two-phase commit to ensure that all resources either
commit or rollback any particular transaction consistently (all do the same).</p>
</div>
<div class="paragraph">
<p>When you implement the <code>XAResource</code> interface, Hazelcast provides XA transactions.
You can obtain the <code>HazelcastXAResource</code> instance via the <code>HazelcastInstance getXAResource</code>
method. You can see the HazelcastXAResource API
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/transaction/HazelcastXAResource.html" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="paragraph">
<p>Below is example code that uses JTA API for transaction management.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        cleanAtomikosLogs();

        HazelcastInstance instance = Hazelcast.newHazelcastInstance();
        HazelcastXAResource xaResource = instance.getXAResource();

        UserTransactionManager tm = new UserTransactionManager();
        tm.begin();

        Transaction transaction = tm.getTransaction();
        transaction.enlistResource(xaResource);
        TransactionContext context = xaResource.getTransactionContext();
        TransactionalMap&lt;Object, Object&gt; map = context.getMap("map");
        map.put("key", "val");
        transaction.delistResource(xaResource, XAResource.TMSUCCESS);

        tm.commit();

        IMap&lt;Object, Object&gt; m = instance.getMap("map");
        Object val = m.get("key");
        System.out.println("value: " + val);

        cleanAtomikosLogs();
        Hazelcast.shutdownAll();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/index.adoc - include::jcache:index.adoc[]</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_integrated_clustering"><a class="anchor" href="#_integrated_clustering"></a>15. Integrated Clustering</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this chapter, we mention how Hazelcast is integrated with Hibernate
2nd level cache and Spring and how it helps with your Filter, Tomcat
and Jetty based web session replications.</p>
</div>
<div class="sect2">
<h3 id="_integration_with_hibernate_second_level_cache"><a class="anchor" href="#_integration_with_hibernate_second_level_cache"></a>15.1. Integration with Hibernate Second Level Cache</h3>
<div class="paragraph">
<p>Hazelcast provides its own distributed second level cache for your
Hibernate entities, collections and queries. This feature is offered
as a Hazelcast plugin. See <a href="#hazelcast-hibernate-2lc">Hazelcast Hibernate 2LC</a> for details.</p>
</div>
</div>
<div class="sect2">
<h3 id="_web_session_replications"><a class="anchor" href="#_web_session_replications"></a>15.2. Web Session Replications</h3>
<div class="paragraph">
<p>Hazelcast can cluster your web sessions using Servlet Filter,
Tomcat and Jetty based solutions.</p>
</div>
<div class="paragraph">
<p>See the following for more information on them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#filter-based-web-session-replication">Filter Based Web Session Replication</a></p>
</li>
<li>
<p><a href="#tomcat-based-web-session-replication">Tomcat Based Web Session Replication</a></p>
</li>
<li>
<p><a href="#jetty-based-web-session-replication">Jetty Based Web Session Replication</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_integration_with_java_ee"><a class="anchor" href="#_integration_with_java_ee"></a>15.3. Integration with Java EE</h3>
<div class="paragraph">
<p>You can integrate Hazelcast into Java EE containers.
This integration is offered as a Hazelcast plugin. See the
<a href="#hazelcast-jca-resource-adapter">Hazelcast JCA Resource Adapter section</a>
and its own GitHub repository <a href="https://github.com/hazelcast/hazelcast-ra" target="_blank" rel="noopener">here</a>
for information on configuring the resource adapter, Glassfish applications
and JBoss web applications.</p>
</div>
</div>
<div class="sect2">
<h3 id="_integration_with_spring"><a class="anchor" href="#_integration_with_spring"></a>15.4. Integration with Spring</h3>
<div class="paragraph">
<p>You can integrate Hazelcast with Spring and this section explains the
configuration of Hazelcast within Spring context.</p>
</div>
<div class="paragraph">
<p>Supported Versions are Spring 2.5 and higher releases and the latest
tested Spring version is 4.3.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Some old versions of Spring may require minor changes in
the Hazelcast configuration. The code and configuration snippets provided
in this section are tested using Spring 4.3.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_configuring_spring"><a class="anchor" href="#_configuring_spring"></a>15.4.1. Configuring Spring</h4>
<div class="paragraph">
<p><strong>Code Sample</strong>: See our <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/spring-configuration" target="_blank" rel="noopener">sample application</a>
for Spring Configuration.</p>
</div>
<div class="sect4">
<h5 id="_enabling_spring_integration"><a class="anchor" href="#_enabling_spring_integration"></a>Enabling Spring Integration</h5>
<div class="paragraph">
<p><em>Classpath Configuration:</em></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To enable Spring integration, either <code>hazelcast-spring-4.1.jar</code>
or <code>hazelcast-all-4.1.jar</code> must be in the classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you use Maven, add the following lines to your <code>pom.xml</code>.</p>
</div>
<div class="paragraph">
<p>If you use <code>hazelcast-all.jar</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast-all&lt;/artifactId&gt;
    &lt;version&gt;4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use <code>hazelcast-spring.jar</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt;
    &lt;version&gt;4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use other build systems, you have to adjust the definition of
dependencies to your needs.</p>
</div>
</div>
<div class="sect4">
<h5 id="_troubleshooting"><a class="anchor" href="#_troubleshooting"></a>Troubleshooting</h5>
<div class="paragraph">
<p>When the Spring Integration JARs are not correctly installed in the
Java classpath, you may see either of the following exceptions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>org.xml.sax.SAXParseException; systemId: http://hazelcast.com/schema/spring/hazelcast-spring.xsd; lineNumber: 2; columnNumber: 35; s4s-elt-character: Non-whitespace characters are not allowed in schema elements other than 'xs:appinfo' and 'xs:documentation'. Saw '301 Moved Permanently'.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Unable to locate Spring NamespaceHandler for XML schema namespace [http://www.hazelcast.com/schema/spring]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>org.xml.sax.SAXParseException; lineNumber: 25; columnNumber: 33; schema_reference.4: Failed to read schema document 'http://www.hazelcast.com/schema/spring/hazelcast-spring.xsd', because 1) could not find the document; 2) the document could not be read; 3) the root element of the document is not &lt;xsd:schema&gt;.</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, please ensure that the required classes are in the classpath,
as explained above.</p>
</div>
</div>
<div class="sect4">
<h5 id="_declaring_beans_by_spring_beans_namespace"><a class="anchor" href="#_declaring_beans_by_spring_beans_namespace"></a>Declaring Beans by Spring <strong>beans</strong> Namespace</h5>
<div class="paragraph">
<p><em>Bean Declaration:</em></p>
</div>
<div class="paragraph">
<p>You can declare Hazelcast Objects using the default Spring <strong>beans</strong> namespace.
Example code for a Hazelcast Instance declaration is listed below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="instance" class="com.hazelcast.core.Hazelcast" factory-method="newHazelcastInstance"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="com.hazelcast.config.Config"&gt;
            &lt;property name="clusterName" value="dev"/&gt;
            &lt;!-- and so on ... --&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="map" factory-bean="instance" factory-method="getMap"&gt;
    &lt;constructor-arg value="map"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_declaring_beans_by_hazelcast_namespace"><a class="anchor" href="#_declaring_beans_by_hazelcast_namespace"></a>Declaring Beans by <strong>hazelcast</strong> Namespace</h5>
<div class="paragraph">
<p>Hazelcast has its own namespace <strong>hazelcast</strong> for bean definitions.
You can easily add the namespace declaration <strong>xmlns:hz="http://www.hazelcast.com/schema/spring"</strong>
to the <code>beans</code> element in the context file so that <strong>hz</strong> namespace shortcut can be
used as a bean declaration.</p>
</div>
<div class="paragraph">
<p>Here is an example schema definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:hz="http://www.hazelcast.com/schema/spring"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
                http://www.hazelcast.com/schema/spring
                http://www.hazelcast.com/schema/spring/hazelcast-spring.xsd"&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_supported_configurations_with_hazelcast_namespace"><a class="anchor" href="#_supported_configurations_with_hazelcast_namespace"></a>Supported Configurations with <strong>hazelcast</strong> Namespace</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Configuring Hazelcast Instance</strong></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:hazelcast id="instance"&gt;
    &lt;hz:config&gt;
        &lt;hz:cluster-name name="dev"/&gt;
        &lt;hz:network port="5701" port-auto-increment="false"&gt;
            &lt;hz:join&gt;
                &lt;hz:multicast enabled="false"
                    multicast-group="224.2.2.3"
                    multicast-port="54327"/&gt;
                &lt;hz:tcp-ip enabled="true"&gt;
                    &lt;hz:members&gt;10.10.1.2, 10.10.1.3&lt;/hz:members&gt;
                &lt;/hz:tcp-ip&gt;
            &lt;/hz:join&gt;
        &lt;/hz:network&gt;
        &lt;hz:map name="map"
            backup-count="2"
            read-backup-data="true"
            merge-policy="com.hazelcast.spi.merge.PassThroughMergePolicy"&gt;
            &lt;hz:eviction eviction-policy="NONE" size="0"/&gt;
        &lt;/hz:map&gt;
    &lt;/hz:config&gt;
&lt;/hz:hazelcast&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Configuring Hazelcast Client</strong></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:client id="client"&gt;
    &lt;hz:cluster-name name="${cluster.name}"/&gt;
    &lt;hz:network connection-timeout="1000"
                redo-operation="true"
                smart-routing="true"&gt;
        &lt;hz:member&gt;10.10.1.2:5701&lt;/hz:member&gt;
        &lt;hz:member&gt;10.10.1.3:5701&lt;/hz:member&gt;
    &lt;/hz:network&gt;
&lt;/hz:client&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Hazelcast Supported Type Configurations and Examples</strong></p>
<div class="ulist">
<ul>
<li>
<p><code>map</code></p>
</li>
<li>
<p><code>multiMap</code></p>
</li>
<li>
<p><code>replicatedmap</code></p>
</li>
<li>
<p><code>queue</code></p>
</li>
<li>
<p><code>topic</code></p>
</li>
<li>
<p><code>reliableTopic</code></p>
</li>
<li>
<p><code>set</code></p>
</li>
<li>
<p><code>list</code></p>
</li>
<li>
<p><code>executorService</code></p>
</li>
<li>
<p><code>durableExecutorService</code></p>
</li>
<li>
<p><code>scheduledExecutorService</code></p>
</li>
<li>
<p><code>ringbuffer</code></p>
</li>
<li>
<p><code>cardinalityEstimator</code></p>
</li>
<li>
<p><code>idGenerator</code></p>
</li>
<li>
<p><code>flakeIdGenerator</code></p>
</li>
<li>
<p><code>atomicLong</code></p>
</li>
<li>
<p><code>atomicReference</code></p>
</li>
<li>
<p><code>semaphore</code></p>
</li>
<li>
<p><code>countDownLatch</code></p>
</li>
<li>
<p><code>lock</code></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:map id="map" instance-ref="client" name="map" lazy-init="true" /&gt;
&lt;hz:multiMap id="multiMap" instance-ref="instance" name="multiMap"
    lazy-init="false" /&gt;
&lt;hz:replicatedMap id="replicatedmap" instance-ref="instance"
    name="replicatedmap" lazy-init="false" /&gt;
&lt;hz:queue id="queue" instance-ref="client" name="queue"
    lazy-init="true" depends-on="instance"/&gt;
&lt;hz:topic id="topic" instance-ref="instance" name="topic"
    depends-on="instance, client"/&gt;
&lt;hz:reliableTopic id="reliableTopic" instance-ref="instance" name="reliableTopic"/&gt;
&lt;hz:set id="set" instance-ref="instance" name="set" /&gt;
&lt;hz:list id="list" instance-ref="instance" name="list"/&gt;
&lt;hz:executorService id="executorService" instance-ref="client"
    name="executorService"/&gt;
&lt;hz:durableExecutorService id="durableExec" instance-ref="instance" name="durableExec"/&gt;
&lt;hz:scheduledExecutorService id="scheduledExec" instance-ref="instance" name="scheduledExec"/&gt;
&lt;hz:ringbuffer id="ringbuffer" instance-ref="instance" name="ringbuffer"/&gt;
&lt;hz:cardinalityEstimator id="cardinalityEstimator" instance-ref="instance" name="cardinalityEstimator"/&gt;
&lt;hz:idGenerator id="idGenerator" instance-ref="instance"
    name="idGenerator"/&gt;
&lt;hz:flakeIdGenerator id="flakeIdGenerator" instance-ref="instance"
    name="flakeIdGenerator"/&gt;
&lt;hz:atomicLong id="atomicLong" instance-ref="instance" name="atomicLong"/&gt;
&lt;hz:atomicReference id="atomicReference" instance-ref="instance"
    name="atomicReference"/&gt;
&lt;hz:semaphore id="semaphore" instance-ref="instance" name="semaphore"/&gt;
&lt;hz:countDownLatch id="countDownLatch" instance-ref="instance"
    name="countDownLatch"/&gt;
&lt;hz:lock id="lock" instance-ref="instance" name="lock"/&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Supported Spring Bean Attributes</strong></p>
<div class="paragraph">
<p>Hazelcast also supports <code>lazy-init</code>, <code>scope</code> and <code>depends-on</code> bean attributes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:hazelcast id="instance" lazy-init="true" scope="singleton"&gt;
    ...
&lt;/hz:hazelcast&gt;
&lt;hz:client id="client" scope="prototype" depends-on="instance"&gt;
    ...
&lt;/hz:client&gt;</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Configuring MapStore and NearCache</strong></p>
<div class="paragraph">
<p>For map-store, you should set either the <strong>class-name</strong> or the <strong>implementation</strong> attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:config id="config"&gt;
    &lt;hz:map name="map1"&gt;
        &lt;hz:map-store enabled="true" class-name="com.foo.DummyStore"
            write-delay-seconds="0" /&gt;

        &lt;hz:near-cache time-to-live-seconds="0"
            max-idle-seconds="60" invalidate-on-change="true" &gt;
            &lt;hz:eviction eviction-policy="LRU" size="5000"/&gt;
        &lt;/hz:near-cache&gt;
    &lt;/hz:map&gt;

    &lt;hz:map name="map2"&gt;
        &lt;hz:map-store enabled="true" implementation="dummyMapStore"
            write-delay-seconds="0" /&gt;
    &lt;/hz:map&gt;
&lt;/hz:config&gt;

&lt;bean id="dummyMapStore" class="com.foo.DummyStore" /&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_enabling_springaware_objects"><a class="anchor" href="#_enabling_springaware_objects"></a>15.4.2. Enabling SpringAware Objects</h4>
<div class="paragraph">
<p>You can mark Hazelcast Distributed Objects with @SpringAware if the object wants to apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>bean properties</p>
</li>
<li>
<p>factory callbacks such as <code>ApplicationContextAware</code>, <code>BeanNameAware</code></p>
</li>
<li>
<p>bean post-processing annotations such as <code>InitializingBean</code>, <code>@PostConstruct</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hazelcast Distributed <code>ExecutorService</code>, or more generally any
Hazelcast managed object, can benefit from these features. To enable
SpringAware objects, you must first configure <code>HazelcastInstance</code> using
<strong>hazelcast</strong> namespace as explained in <a href="#configuring-spring">Configuring Spring</a>
and add <code>&lt;hz:spring-aware /&gt;</code> tag.</p>
</div>
<div class="sect4">
<h5 id="_springaware_examples"><a class="anchor" href="#_springaware_examples"></a>SpringAware Examples</h5>
<div class="ulist">
<ul>
<li>
<p>Configure a Hazelcast Instance via Spring Configuration and define <strong>someBean</strong> as Spring Bean.</p>
</li>
<li>
<p>Add <code>&lt;hz:spring-aware /&gt;</code> to Hazelcast configuration to enable @SpringAware.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:hz="http://www.hazelcast.com/schema/spring"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context-3.0.xsd
                http://www.hazelcast.com/schema/spring
                http://www.hazelcast.com/schema/spring/hazelcast-spring.xsd"&gt;

    &lt;context:component-scan base-package="..."/&gt;

    &lt;hz:hazelcast id="instance"&gt;
        &lt;hz:config&gt;
            &lt;hz:spring-aware /&gt;
            &lt;hz:cluster-name name="dev"/&gt;
            &lt;hz:network port="5701" port-auto-increment="false"&gt;
                &lt;hz:join&gt;
                    &lt;hz:multicast enabled="false" /&gt;
                    &lt;hz:tcp-ip enabled="true"&gt;
                        &lt;hz:members&gt;10.10.1.2, 10.10.1.3&lt;/hz:members&gt;
                    &lt;/hz:tcp-ip&gt;
                &lt;/hz:join&gt;
            &lt;/hz:network&gt;
            ...
        &lt;/hz:config&gt;
    &lt;/hz:hazelcast&gt;

    &lt;bean id="someBean" class="com.hazelcast.examples.spring.SomeBean"
      scope="singleton" /&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Distributed Map SpringAware Example:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a class called <code>SomeValue</code> which contains Spring Bean definitions
like <code>ApplicationContext</code> and <code>SomeBean</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringAware
@Component("someValue")
@Scope("prototype")
public class SomeValue implements Serializable, ApplicationContextAware {

    private transient ApplicationContext context;
    private transient SomeBean someBean;
    private transient boolean init = false;

    public void setApplicationContext( ApplicationContext applicationContext )
        throws BeansException {
        context = applicationContext;
    }

    @Autowired
    public void setSomeBean( SomeBean someBean)  {
        this.someBean = someBean;
    }

    @PostConstruct
    public void init() {
        someBean.doSomethingUseful();
        init = true;
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Get <code>SomeValue</code> Object from Context and put it into Hazelcast Distributed Map
on the first member.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance =
    (HazelcastInstance) context.getBean( "instance" );
SomeValue value = (SomeValue) context.getBean( "someValue" );
IMap&lt;String, SomeValue&gt; map = hazelcastInstance.getMap( "values" );
map.put( "key", value );</code></pre>
</div>
</div>
</li>
<li>
<p>Read <code>SomeValue</code> Object from Hazelcast Distributed Map and assert
that <code>init</code> method is called since it is annotated with <code>@PostConstruct</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance =
    (HazelcastInstance) context.getBean( "instance" );
IMap&lt;String, SomeValue&gt; map = hazelcastInstance.getMap( "values" );
SomeValue value = map.get( "key" );
Assert.assertTrue( value.init );</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>ExecutorService SpringAware Example:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a Callable Class called SomeTask which contains
Spring Bean definitions like <code>ApplicationContext</code>, <code>SomeBean</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringAware
public class SomeTask
    implements Callable&lt;Long&gt;, ApplicationContextAware, Serializable {

    private transient ApplicationContext context;
    private transient SomeBean someBean;

    public Long call() throws Exception {
        return someBean.value;
    }

    public void setApplicationContext( ApplicationContext applicationContext )
        throws BeansException {
        context = applicationContext;
    }

    @Autowired
    public void setSomeBean( SomeBean someBean ) {
        this.someBean = someBean;
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Submit <code>SomeTask</code> to two Hazelcast Members and assert that <code>someBean</code> is autowired.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance =
    (HazelcastInstance) context.getBean( "instance" );
SomeBean bean = (SomeBean) context.getBean( "someBean" );

Future&lt;Long&gt; f = hazelcastInstance.getExecutorService("executorService")
    .submit(new SomeTask());
Assert.assertEquals(bean.value, f.get().longValue());

// choose a member
Member member = hazelcastInstance.getCluster().getMembers().iterator().next();

Future&lt;Long&gt; f2 = (Future&lt;Long&gt;) hazelcast.getExecutorService("executorService")
    .submitToMember(new SomeTask(), member);
Assert.assertEquals(bean.value, f2.get().longValue());</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring managed properties/fields are marked as <code>transient</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adding_caching_to_spring"><a class="anchor" href="#_adding_caching_to_spring"></a>15.4.3. Adding Caching to Spring</h4>
<div class="paragraph">
<p><strong>Code Sample</strong>: See the sample application for
<a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/spring-cache-manager" target="_blank" rel="noopener">Spring Cache</a>.</p>
</div>
<div class="paragraph">
<p>As of version 3.1, Spring Framework provides support for adding caching
into an existing Spring application. Spring 3.2 and later versions support
JCache compliant caching providers. You can also use JCache caching
backed by Hazelcast if your Spring version supports JCache.</p>
</div>
<div class="sect4">
<h5 id="_declarative_spring_cache_configuration"><a class="anchor" href="#_declarative_spring_cache_configuration"></a>Declarative Spring Cache Configuration</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;cache:annotation-driven cache-manager="cacheManager" /&gt;

&lt;hz:hazelcast id="instance"&gt;
    ...
&lt;/hz:hazelcast&gt;

&lt;bean id="cacheManager" class="com.hazelcast.spring.cache.HazelcastCacheManager"&gt;
    &lt;constructor-arg ref="instance"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast uses its Map implementation for underlying cache.
You can configure a map with your cache&#8217;s name if you want to set
additional configuration such as <code>ttl</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;cache:annotation-driven cache-manager="cacheManager" /&gt;

&lt;hz:hazelcast id="instance"&gt;
    &lt;hz:config&gt;
        ...

        &lt;hz:map name="city" time-to-live-seconds="0" in-memory-format="BINARY" /&gt;
    &lt;/hz:config&gt;
&lt;/hz:hazelcast&gt;

&lt;bean id="cacheManager" class="com.hazelcast.spring.cache.HazelcastCacheManager"&gt;
    &lt;constructor-arg ref="instance"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface IDummyBean {
    @Cacheable("city")
    String getCity();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_defining_timeouts_for_cache_read_operation"><a class="anchor" href="#_defining_timeouts_for_cache_read_operation"></a>Defining Timeouts for Cache Read Operation</h5>
<div class="paragraph">
<p>You can define a timeout value for the get operations from your Spring cache.
This may be useful for some cases, such as SLA requirements. Hazelcast
provides a property to specify this timeout: <code>hazelcast.spring.cache.prop</code>.
This can be specified as a Java property (using <code>-D</code>) or you can add this
property to your Spring properties file (usually named as <code>application.properties</code>).</p>
</div>
<div class="paragraph">
<p>An example usage is given below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>hazelcast.spring.cache.prop=defaultReadTimeout=2,cache1=10,cache2=20</code></pre>
</div>
</div>
<div class="paragraph">
<p>The argument <code>defaultReadTimeout</code> applies to all of your Spring caches.
If you want to define different timeout values for some specific Spring
caches, you can provide them as a comma separated list as shown in the
above example usage. The values are in milliseconds. If you want to have
no timeout for a cache, simply set it to <code>0</code> or a negative value.</p>
</div>
</div>
<div class="sect4">
<h5 id="_declarative_hazelcast_jcache_based_caching_configuration"><a class="anchor" href="#_declarative_hazelcast_jcache_based_caching_configuration"></a>Declarative Hazelcast JCache Based Caching Configuration</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;cache:annotation-driven cache-manager="cacheManager" /&gt;

&lt;hz:hazelcast id="instance"&gt;
    ...
&lt;/hz:hazelcast&gt;

&lt;hz:cache-manager id="hazelcastJCacheCacheManager" instance-ref="instance" name="hazelcastJCacheCacheManager"/&gt;

&lt;bean id="cacheManager" class="org.springframework.cache.jcache.JCacheCacheManager"&gt;
    &lt;constructor-arg ref="hazelcastJCacheCacheManager" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use JCache implementation in both member and client mode.
A cache manager should be bound to an instance. Instance can be referenced
by <code>instance-ref</code> attribute or provided by <code>hazelcast.instance.name</code>
property which is passed to CacheManager. Instance should be specified
using one of these methods.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Instance name provided in properties overrides <code>instance-ref</code> attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can specify an URI for each cache manager with <code>uri</code> attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:cache-manager id="cacheManager2" name="cacheManager2" uri="testURI"&gt;
    &lt;hz:properties&gt;
        &lt;hz:property name="hazelcast.instance.name"&gt;named-spring-hz-instance&lt;/hz:property&gt;
        &lt;hz:property name="testProperty"&gt;testValue&lt;/hz:property&gt;
    &lt;/hz:properties&gt;
&lt;/hz:cache-manager&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_annotation_based_spring_cache_configuration"><a class="anchor" href="#_annotation_based_spring_cache_configuration"></a>Annotation-Based Spring Cache Configuration</h5>
<div class="paragraph">
<p>Annotation-Based Configuration does not require any XML definition.
To perform Annotation-Based Configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implement a <code>CachingConfiguration</code> class with related Annotations.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableCaching
public class CachingConfiguration extends CachingConfigurerSupport {
    @Bean
    public CacheManager cacheManager() {
        ClientConfig config = new ClientConfig();
        HazelcastInstance client = HazelcastClient.newHazelcastClient(config);
        return new com.hazelcast.spring.cache.HazelcastCacheManager(client);
    }
    @Bean
    public KeyGenerator keyGenerator() {
        return null;
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Launch Application Context and register <code>CachingConfiguration</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
context.register(CachingConfiguration.class);
context.refresh();</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information about Spring Cache, see
<a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html" target="_blank" rel="noopener">Spring Cache Abstraction</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_hibernate_second_level_cache"><a class="anchor" href="#_configuring_hibernate_second_level_cache"></a>15.4.4. Configuring Hibernate Second Level Cache</h4>
<div class="paragraph">
<p><strong>Code Sample</strong>: See the <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/spring-hibernate-2ndlevel-cache" target="_blank" rel="noopener">sample application</a>
for Hibernate 2nd Level Cache configuration.</p>
</div>
<div class="paragraph">
<p>If you are using Hibernate with Hazelcast as a second level cache provider, you can easily configure your
<code>LocalSessionFactoryBean</code> to use a Hazelcast instance by passing Hazelcast instance name. That way, you can use the
same <code>HazelcastInstance</code> as Hibernate L2 cache instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">...
&lt;bean id="sessionFactory"
      class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"
	  scope="singleton"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;props&gt;
            ...
            &lt;prop key="hibernate.cache.region.factory_class"&gt;com.hazelcast.hibernate.HazelcastLocalCacheRegionFactory&lt;/prop&gt;
            &lt;prop key="hibernate.cache.hazelcast.instance_name"&gt;${hz.instance.name}&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    ...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Hibernate RegionFactory Classes</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.hibernate.HazelcastLocalCacheRegionFactory</code></p>
</li>
<li>
<p><code>com.hazelcast.hibernate.HazelcastCacheRegionFactory</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://github.com/hazelcast/hazelcast-hibernate#configuring-regionfactory" target="_blank" rel="noopener">Configuring RegionFactory section</a>
in the Hazelcast Hibernate GitHub repository for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_hazelcast_transaction_manager"><a class="anchor" href="#_configuring_hazelcast_transaction_manager"></a>15.4.5. Configuring Hazelcast Transaction Manager</h4>
<div class="paragraph">
<p><strong>Code Sample</strong>: See the <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/spring-transaction-manager" target="_blank" rel="noopener">sample application</a>
for Hazelcast Transaction Manager in our code samples repository.</p>
</div>
<div class="paragraph">
<p>You can get rid of the boilerplate code to begin, commit or rollback
transactions by using <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/spring/transaction/HazelcastTransactionManager.html" target="_blank" rel="noopener">HazelcastTransactionManager</a>
which is a <code>PlatformTransactionManager</code> implementation to be used
with Spring Transaction API.</p>
</div>
<div class="sect4">
<h5 id="_example_configuration_for_hazelcast_transaction_manager"><a class="anchor" href="#_example_configuration_for_hazelcast_transaction_manager"></a>Example Configuration for Hazelcast Transaction Manager</h5>
<div class="paragraph">
<p>You need to register <code>HazelcastTransactionManager</code> as your
transaction manager implementation and also you need to
register <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/spring/transaction/ManagedTransactionalTaskContext.html" target="_blank" rel="noopener">ManagedTransactionalTaskContext</a>
to access transactional data structures within your service class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">...
&lt;hz:hazelcast id="instance"&gt;
    ...
&lt;/hz:hazelcast&gt;
...
&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;
&lt;bean id="transactionManager" class="com.hazelcast.spring.transaction.HazelcastTransactionManager"&gt;
    &lt;constructor-arg ref="instance"/&gt;
&lt;/bean&gt;
&lt;bean id="transactionalContext" class="com.hazelcast.spring.transaction.ManagedTransactionalTaskContext"&gt;
    &lt;constructor-arg ref="transactionManager"/&gt;
&lt;/bean&gt;
&lt;bean id="YOUR_SERVICE" class="YOUR_SERVICE_CLASS"&gt;
    &lt;property name="transactionalTaskContext" ref="transactionalContext"/&gt;
&lt;/bean&gt;
...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_example_transactional_method"><a class="anchor" href="#_example_transactional_method"></a>Example Transactional Method</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ServiceWithTransactionalMethod {

    private TransactionalTaskContext transactionalTaskContext;

    @Transactional
    public void transactionalPut(String key, String value) {
        transactionalTaskContext.getMap("testMap").put(key, value);
    }

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After marking your method as <code>Transactional</code> either declaratively
or by annotation and accessing the data structure
through the <code>TransactionalTaskContext</code>, <code>HazelcastTransactionManager</code>
begins, commits or rollbacks the transaction for you.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_best_practices"><a class="anchor" href="#_best_practices"></a>15.4.6. Best Practices</h4>
<div class="paragraph">
<p>Spring tries to create a new <code>Map</code>/<code>Collection</code> instance and fill
the new instance by iterating and converting values of the original
<code>Map</code>/<code>Collection</code> (<code>IMap</code>, <code>IQueue</code>, etc.) to required types when generic
type parameters of the original <code>Map</code>/<code>Collection</code> and the target property/attribute do not match.</p>
</div>
<div class="paragraph">
<p>Since Hazelcast <code>Map</code>s/<code>Collection</code>s are designed to hold very large
data which a single machine cannot carry, iterating through whole values can cause out of memory errors.</p>
</div>
<div class="paragraph">
<p>To avoid this issue, the target property/attribute can be declared as
un-typed <code>Map</code>/<code>Collection</code> as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SomeBean {
    @Autowired
    IMap map; // instead of IMap&lt;K, V&gt; map

    @Autowired
    IQueue queue; // instead of IQueue&lt;E&gt; queue
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, parameters of injection methods (constructor, setter) can be un-typed as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SomeBean {

    IMap&lt;K, V&gt; map;
    IQueue&lt;E&gt; queue;

    // Instead of IMap&lt;K, V&gt; map
    public SomeBean(IMap map) {
        this.map = map;
    }

    ...

    // Instead of IQueue&lt;E&gt; queue
    public void setQueue(IQueue queue) {
        this.queue = queue;
    }
    ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See <a href="https://jira.springsource.org/browse/SPR-3407" target="_blank" rel="noopener">Spring issue-3407</a> for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_storage"><a class="anchor" href="#_storage"></a>16. Storage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes Hazelcast&#8217;s High-Density Memory Store and
Hot Restart Persistence features along with their configurations and
gives recommendations on the storage sizing.</p>
</div>
<div class="sect2">
<h3 id="_high_density_memory_store_2"><a class="anchor" href="#_high_density_memory_store_2"></a>16.1. High-Density Memory Store</h3>
<div class="paragraph">
<p><strong class="navy">Hazelcast IMDG Enterprise HD</strong></p>
</div>
<div class="paragraph">
<p>By default, data structures in Hazelcast store data on heap in
serialized form for highest data compaction; yet, these data structures
are still subject to Java Garbage Collection (GC). Modern hardware has
much more available memory. If you want to make use of that hardware and
scale up by specifying higher heap sizes, GC becomes an increasing problem:
the application faces long GC pauses that make the application unresponsive.
Also, you may get out of memory errors if you fill your whole heap. Garbage
collection, which is the automatic process that manages the application&#8217;s
runtime memory, often forces you into configurations where multiple JVMs
with small heaps (sizes of 2-4GB per member) run on a single physical hardware
device to avoid garbage collection pauses. This results in oversized clusters
to hold the data and leads to performance level requirements.</p>
</div>
<div class="paragraph">
<p>In <strong class="navy">Hazelcast IMDG Enterprise HD</strong>, the High-Density Memory Store is
Hazelcast&#8217;s new enterprise in-memory storage solution. It solves garbage
collection limitations so that applications can exploit hardware memory
more efficiently without the need of oversized clusters. High-Density
Memory Store is designed as a pluggable memory manager which enables multiple
memory stores for different data structures. These memory stores are all
accessible by a common access layer that scales up to massive amounts of the main
memory on a single JVM by minimizing the GC pressure. High-Density Memory
Store enables predictable application scaling and boosts performance and
latency while minimizing garbage collection pauses.</p>
</div>
<div class="paragraph">
<p>This foundation includes, but is not limited to, storing keys and values
next to the heap in a native memory region.</p>
</div>
<div class="paragraph">
<p>High-Density Memory Store is currently provided for the following Hazelcast
features and implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#using-high-density-memory-store-with-map">Map</a></p>
</li>
<li>
<p><a href="#icache-configuration">JCache Implementation</a></p>
</li>
<li>
<p><a href="#near-cache">Near Cache</a></p>
</li>
<li>
<p><a href="#hot-restart-persistence">Hot Restart Persistence</a></p>
</li>
<li>
<p><a href="#using-high-density-memory-store-with-java-client">Java Client</a>, when using the Near Cache for client</p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-wm#using-high-density-memory-store" target="_blank" rel="noopener">Web Session Replications</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-hibernate" target="_blank" rel="noopener">Hibernate 2nd Level Caching</a></p>
</li>
<li>
<p>Paging and Partition Predicates</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_configuring_high_density_memory_store"><a class="anchor" href="#_configuring_high_density_memory_store"></a>16.1.1. Configuring High-Density Memory Store</h4>
<div class="paragraph">
<p>To use the High-Density memory storage, the native memory usage
must be enabled using the programmatic or declarative configuration.
Also, you can configure its size, memory allocator type, minimum
block size, page size and metadata space percentage.</p>
</div>
<div class="paragraph">
<p>The following are the configuration element descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>size:</strong> Size of the total native memory to allocate in megabytes.
Its default value is <strong>512 MB</strong>.</p>
</li>
<li>
<p><strong>allocator type</strong>: Type of the memory allocator. Available values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>STANDARD</strong>: This option is used internally by Hazelcast&#8217;s
POOLED allocator type or for debugging/testing purposes.</p>
<div class="ulist">
<ul>
<li>
<p>With this option, the memory is allocated or deallocated using
your operating system&#8217;s default memory manager.</p>
</li>
<li>
<p>It uses GNU C Library&#8217;s standard <code>malloc()</code> and <code>free()</code> methods
which are subject to contention on multithreaded/multicore systems.</p>
</li>
<li>
<p>Memory operations may become slower when you perform a lot of small
allocations and deallocations.</p>
</li>
<li>
<p>It may cause large memory fragmentations, unless you use a method in
the background that emphasizes fragmentation avoidance, such as <code>jemalloc()</code>.
Note that a large memory fragmentation can trigger the Linux Out of Memory
Killer if there is no swap space enabled in your system. Even if the swap
space is enabled, the killer can be again triggered if there is not enough
swap space left.</p>
</li>
<li>
<p>If you still want to use the operating system&#8217;s default memory management,
you can set the allocator type to STANDARD in your native memory configuration.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>POOLED</strong>: This is the default option, Hazelcast&#8217;s own pooling memory allocator.</p>
<div class="ulist">
<ul>
<li>
<p>With this option, memory blocks are managed using internal memory pools.</p>
</li>
<li>
<p>It allocates memory blocks, each of which has a 4MB page size by default,
and splits them into chunks or merges them to create larger chunks when required.
Sizing of these chunks follows the <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="noopener">buddy memory allocation</a>
algorithm, i.e., power-of-two sizing.</p>
</li>
<li>
<p>It never frees memory blocks back to the operating system.
It marks disposed memory blocks as available to be used later,
meaning that these blocks are reusable.</p>
</li>
<li>
<p>Memory allocation and deallocation operations (except the ones
requiring larger sizes than the page size) do not interact with the
operating system mostly.</p>
</li>
<li>
<p>For memory allocation, it tries to find the requested memory size inside
the internal memory pools. If it cannot be found, then it interacts with the operating system.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>minimum block size:</strong> Minimum size of the blocks in bytes to split and
fragment a page block to assign to an allocation request. It is used only
by the <strong>POOLED</strong> memory allocator. Its default value is <strong>16 bytes</strong>.</p>
</li>
<li>
<p><strong>page size:</strong> Size of the page in bytes to allocate memory as a block.
It is used only by the <strong>POOLED</strong> memory allocator. Its default value is <code>1 &lt;&lt; 22</code> = <strong>4194304 Bytes</strong>, about <strong>4 MB</strong>.</p>
</li>
<li>
<p><strong>metadata space percentage:</strong> Defines the percentage of the allocated
native memory that is used for internal memory structures by the High-Density
Memory for tracking the used and available memory blocks. It is used only by
the <strong>POOLED</strong> memory allocator. Its default value is <strong>12.5</strong>. Please note that
when the memory runs out, you get a <code>NativeOutOfMemoryException</code>;  if your store
has a large number of entries, you should consider increasing this percentage.</p>
</li>
<li>
<p><strong>persistent-memory:</strong> See the <a href="#using-persistent-memory">Using Persistent Memory section</a> below.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is the programmatic configuration example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        MemorySize memorySize = new MemorySize(512, MemoryUnit.MEGABYTES);
        NativeMemoryConfig nativeMemoryConfig =
                new NativeMemoryConfig()
                        .setAllocatorType(NativeMemoryConfig.MemoryAllocatorType.POOLED)
                        .setSize(memorySize)
                        .setEnabled(true)
                        .setMinBlockSize(16)
                        .setPageSize(1 &lt;&lt; 20);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the declarative configuration example.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;native-memory allocator-type="POOLED" enabled="true"&gt;
        &lt;size unit="MEGABYTES" value="512"/&gt;
        &lt;min-block-size&gt;16&lt;/min-block-size&gt;
        &lt;page-size&gt;4194304&lt;/page-size&gt;
        &lt;metadata-space-percentage&gt;12.5&lt;/metadata-space-percentage&gt;
        &lt;persistent-memory&gt;
            &lt;directories&gt;
                &lt;directory numa-node="0"&gt;/mnt/pmem0&lt;/directory&gt;
                &lt;directory numa-node="1"&gt;/mnt/pmem1&lt;/directory&gt;
            &lt;/directories&gt;
        &lt;/persistent-memory&gt;
    &lt;/native-memory&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  native-memory:
    enabled: true
    allocator-type: POOLED
    size:
      unit: MEGABYTES
      value: 512
    min-block-size: 16
    page-size: 4194304
    metadata-space-percentage: 12.5
    persistent-memory:
        directories:
            - directory: /mnt/pmem0
              numa-node: 0
            - directory: /mnt/pmem1
              numa-node: 1</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can check whether there is enough free physical memory for the
requested number of bytes using the system property <code>hazelcast.hidensity.check.freememory</code>.
See the <a href="#system-properties">System Properties appendix</a> on how to use Hazelcast
system properties.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-persistent-memory"><a class="anchor" href="#using-persistent-memory"></a>16.1.2. Using Persistent Memory</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The High-Density Memory Store uses the persistent memory in its volatile mode,
which means all data is lost after the instance restarts. For durability, please check
the <a href="#hot-restart-persistence">Hot Restart Persistence</a> feature.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To support larger and more affordable storage for data structures like IMap,
ICache and Near Cache, Hazelcast provides integration with persistent memory
technologies like Intel&#174; Optane&#8482; DC. To benefit from the technology you
do not need to make any changes in your application code.
Only a few configuration changes are required.</p>
</div>
<div class="paragraph">
<p>The optional <code>persistent-memory</code> element under the <code>native-memory</code>
configuration block defines the directories where the persistent memory is mounted.
This option enables usage of the persistent memory on the cluster member so
that all data structures backed by High-Density Memory Store use the specified
mounting directories to store data. If no persistent memory directory is configured,
standard RAM is used.</p>
</div>
<div class="paragraph">
<p>The following snippets demonstrate how to configure the persistent memory as
High-Density Memory Store in Hazelcast. The example assumes dual-socket machine,
both sockets are populated with Intel&#174; Optane&#8482; DC persistent memory DIMMs that
are configured in interleaved mode. The two sockets' DIMMs are mounted as <code>/mnt/pmem0</code>
and <code>/mnt/pmem1</code> and are known as NUMA node0 and node1 respectively.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;native-memory allocator-type="POOLED" enabled="true"&gt;
        &lt;size unit="GIGABYTES" value="100" /&gt;
        &lt;persistent-memory&gt;
            &lt;directories&gt;
                &lt;directory numa-node="0"&gt;/mnt/pmem0&lt;/directory&gt;
                &lt;directory numa-node="1"&gt;/mnt/pmem1&lt;/directory&gt;
            &lt;/directories&gt;
        &lt;/persistent-memory&gt;
    &lt;/native-memory&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  native-memory:
    enabled: true
    allocator-type: POOLED
    size:
      unit: GIGABYTES
      value: 100
    persistent-memory:
      directories:
        - directory: /mnt/pmem0
          numa-node: 0
        - directory: /mnt/pmem1
          numa-node: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
NativeMemoryConfig memoryConfig = new NativeMemoryConfig()
                .setEnabled(true)
                .setSize(new MemorySize(100, MemoryUnit.GIGABYTES))
                .setAllocatorType(POOLED);

PersistentMemoryConfig pmemConfig = memoryConfig.getPersistentMemoryConfig()
                .addDirectoryConfig(new PersistentMemoryDirectoryConfig("/mnt/pmem0", 0))
                .addDirectoryConfig(new PersistentMemoryDirectoryConfig("/mnt/pmem1", 1));

config.setNativeMemoryConfig(memoryConfig);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that integration with Intel&#174; Optane&#8482; DC is supported on Linux
operating system and it is for Optane DIMMs (not SSDs).
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_allocation_strategies"><a class="anchor" href="#_allocation_strategies"></a>Allocation Strategies</h5>
<div class="paragraph">
<p>Since on multi-socket machines there could be multiple persistent memory
mount points, the memory allocations need to follow an allocation strategy.
Starting with 4.1, Hazelcast supports two allocation strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Round-robin allocation strategy</p>
</li>
<li>
<p>NUMA-aware allocation strategy</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hazelcast&#8217;s memory allocator chooses and statically caches one of them for
every allocator thread for the entire lifetime of the Hazelcast instance.</p>
</div>
<div class="sect5">
<h6 id="_round_robin_allocation_strategy"><a class="anchor" href="#_round_robin_allocation_strategy"></a>Round-robin Allocation Strategy</h6>
<div class="paragraph">
<p>Hazelcast iterates over the configured persistent memory directories and
makes sure every allocation is done in a different directory than the last.
This is a best-effort attempt to distribute the allocations evenly on the
persistent memory DIMMs, which is important from the utilization and
performance points of view as well. This is the default allocation strategy.</p>
</div>
</div>
<div class="sect5">
<h6 id="_numa_aware_allocation_strategy"><a class="anchor" href="#_numa_aware_allocation_strategy"></a>NUMA-aware Allocation Strategy</h6>
<div class="paragraph">
<p>The persistent memory modules are mounted in the memory slots just like the
regular memory modules and sharing the same memory bus. Therefore, the same
NUMA locality concerns apply to the persistent memory that apply to regular
memory. This means accessing the persistent memory modules attached to the
socket on which the current thread runs is cheaper than accessing the
persistent memory modules attached to a different socket. These are typically
referenced as NUMA-local and NUMA-remote memories. To achieve the best
possible performance, Hazelcast implements a NUMA-aware  allocation strategy
to ensure all persistent memory accesses are local, if certain conditions hold.</p>
</div>
<div class="paragraph">
<p>To enable this allocation strategy for a certain thread, the thread has to be
bounded to a single NUMA node, which means the kernel&#8217;s scheduler makes sure
the thread can be scheduled only on the CPUs of a single NUMA node. Starting
with Hazelcast 4.1 this can be done with thread group granularity. For the
detailed explanation please refer to the thread affinity documentation. What
makes the biggest impact on performance is enabling the NUMA-aware allocation
strategy for the operation threads. An example configuration for that is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.operation.thread.affinity=[0-9,20-29]:20,[10-19,30-39]:20</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example configuration restricts all 40 operation threads to run on a single NUMA node
on a dual-socket 40 core system, where node0&#8217;s CPU set is <code>[0-9,20-29]</code> and
node1&#8217;s CPU set is <code>[10-19,30-39]</code>. The NUMA nodes and their CPU sets can be
discovered by the <code>numactl -H</code> command.</p>
</div>
<div class="paragraph">
<p>The second requirement for the NUMA-aware strategy is defining the NUMA node
for every persistent memory directory in the configuration. If both configurations
are done properly, the threads in the thread groups restricted to run on a single
NUMA node will use the NUMA-aware allocation strategy, while the rest of threads
will still use the round-robin strategy. To check which persistent memory is
attached to which NUMA node, the command <code>ndctl list -v -m fsdax</code> can be used.
Please check which mount point represents which persistent memory device in the
output of <code>ndctl</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_allocation_overflowing"><a class="anchor" href="#_allocation_overflowing"></a>Allocation Overflowing</h5>
<div class="paragraph">
<p>Since both allocation strategies try to allocate from a single persistent
memory directory, it may happen that the chosen directory cannot serve the
allocation request due to lack of free capacity. In this case, both strategies
take the other directories and try to serve the allocation from those. Please
note that this compromises the NUMA-aware strategy in the way that there will
be NUMA-remote persistent memory accesses.</p>
</div>
</div>
<div class="sect4">
<h5 id="_on_the_performance_of_persistent_memory"><a class="anchor" href="#_on_the_performance_of_persistent_memory"></a>On the Performance of Persistent Memory</h5>
<div class="paragraph">
<p>While the persistent memory modules are mounted next to the regular memory
modules and sharing the same memory bus, the two types of the modules have
different performance characteristics. First, the persistent memory modules
can be accessed with higher latency than the regular memory modules. Second,
while with the regular memory modules the performance of the reads and the
writes are not different, this is not the case with the persistent memory
modules. The persistent memory has an asymmetric performance profile, which
means the writes are slower than the reads.</p>
</div>
<div class="paragraph">
<p>Despite the above facts, whether the higher latency of the persistent memory
impacts the performance of Hazelcast depends on multiple factors. Since
Hazelcast is a distributed platform, the higher latency of the persistent memory
modules can easily be hidden by the latency variance of the network and in the
end, in certain use cases there may be no observable difference in the throughput
of Hazelcast if it stores its data on persistent memory or on regular memory.
Such a use case is caching, where accessing the entries remotely through
Hazelcast clients results in a very similar throughput. Based on our tests with
Intel&#174; Optane&#8482; DC persistent memory modules we recommend the Optane modules
for the caching use case up to 10KB entry size.</p>
</div>
<div class="paragraph">
<p>Other use cases that don&#8217;t involve networking, such as iterating over all entries
with entry processors can be impacted by the higher latency of the persistent
memory modules, especially, if the entry processors update a significant portion
of the entries. In general, in such a use case the higher the entry size, the
higher the impact on the performance. That means with smaller entry sizes the
performance of Hazelcast with persistent memory can be comparable to the
performance with regular memory.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sizing_practices"><a class="anchor" href="#_sizing_practices"></a>16.2. Sizing Practices</h3>
<div class="paragraph">
<p>Data in Hazelcast is both active data and backup data for high availability,
so the total memory footprint is the size of active data plus the size of
backup data. If you use a single backup, it means the total memory footprint
is two times the active data (active data + backup data). If you use, for example,
two backups, then the total memory footprint is three times the active data
(active data + backup data + backup data).</p>
</div>
<div class="paragraph">
<p>If you use only heap memory, each Hazelcast member with a 4 GB heap should
accommodate a maximum of 3.5 GB of total data (active and backup). If you use
the High-Density Memory Store, up to 75% of the configured physical memory
footprint may be used for active and backup data, with headroom of 25% for
normal memory fragmentation. In both cases, however, you should also keep some
memory headroom available to handle any member failure or explicit member shutdown.
When a member leaves the cluster, the data previously owned by the newly offline
member is distributed among the remaining members. For this reason, we recommend
that you plan to use only 60% of available memory, with 40% headroom to handle
member failure or shutdown.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hot_restart_persistence"><a class="anchor" href="#_hot_restart_persistence"></a>16.3. Hot Restart Persistence</h3>
<div class="paragraph">
<p><strong class="navy">Hazelcast IMDG Enterprise HD</strong></p>
</div>
<div class="paragraph">
<p>This chapter explains Hazelcast&#8217;s Hot Restart Persistence feature. It provides fast
cluster restarts by storing the states of the cluster members on the disk.
This feature is currently provided for the Hazelcast map data structure and Hazelcast JCache implementation.</p>
</div>
<div class="sect3">
<h4 id="_hot_restart_persistence_overview"><a class="anchor" href="#_hot_restart_persistence_overview"></a>16.3.1. Hot Restart Persistence Overview</h4>
<div class="paragraph">
<p>Hot Restart Persistence enables you to get your cluster up and running swiftly
after a cluster restart. A restart can be caused by a planned shutdown
(including rolling upgrades) or a sudden cluster-wide crash, e.g., power outage.
For Hot Restart Persistence, required states for Hazelcast clusters and members are
introduced. See the <a href="#managing-cluster-and-member-states">Managing Cluster and Member States section</a>
for information on the cluster and member states. The purpose of the Hot Restart Persistence
is to provide a maintenance window for member operations and restart the cluster
in a fast way. It is not meant to recover the catastrophic shutdown of one member.</p>
</div>
<div class="paragraph">
<p>Hot Restart Persistence supports optional data encryption. See the <a href="#encryption-at-rest">Encryption at Rest section</a>
for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hot_restart_types"><a class="anchor" href="#_hot_restart_types"></a>16.3.2. Hot Restart Types</h4>
<div class="paragraph">
<p>The Hot Restart feature is supported for the following restart types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Restart after a planned shutdown</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>The cluster is shut down completely and restarted with the exact same
previous setup and data.</p>
<div class="paragraph">
<p>You can shut down the cluster completely using the <code>HazelcastInstance.getCluster().shutdown()</code>
method or you can manually change the cluster state to <code>PASSIVE</code> and then shut
down each member one by one. When you send the command to shut the cluster down, i.e.,
<code>HazelcastInstance.getCluster().shutdown()</code>, the members that are not in the <code>PASSIVE</code>
state temporarily change their states to <code>PASSIVE</code>. Then, each member shuts itself down
by calling the method <code>HazelcastInstance.shutdown()</code>.</p>
</div>
<div class="paragraph">
<p>Difference between explicitly changing state to <code>PASSIVE</code> before shutdown and shutting
down cluster directly via <code>HazelcastInstance.getCluster().shutdown()</code> is, on the latter
case when cluster is restarted, the cluster state will be in the latest state before shutdown.
That means if cluster is <code>ACTIVE</code> before shutdown, cluster state automatically becomes
<code>ACTIVE</code> after restart is completed.</p>
</div>
</li>
<li>
<p>Rolling restart: The cluster is restarted intentionally member by member.
For example, this could be done to install an operating system patch or new hardware.</p>
<div class="paragraph">
<p>To be able to shut down the cluster member by member as part of a planned restart,
each member in the cluster should be in the <code>FROZEN</code> or <code>PASSIVE</code> state. After the
cluster state is changed to <code>FROZEN</code> or <code>PASSIVE</code>, you can manually shut down each
member by calling the method <code>HazelcastInstance.shutdown()</code>. When that member is
restarted, it rejoins the running cluster. After all members are restarted, the
cluster state can be changed back to <code>ACTIVE</code>.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Restart after a cluster crash</strong>: The cluster is restarted after all its members
crashed at the same time due to a power outage, networking interruptions, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_restart_process"><a class="anchor" href="#_restart_process"></a>16.3.3. Restart Process</h4>
<div class="paragraph">
<p>During the restart process, each member waits to load data until all the members in the
partition table are started. During this process, no operations are allowed. Once all
cluster members are started, Hazelcast changes the cluster state to <code>PASSIVE</code> and starts
to load data. When all data is loaded, Hazelcast changes the cluster state to its previous
known state before shutdown and starts to accept the operations which are allowed by the
restored cluster state.</p>
</div>
<div class="paragraph">
<p>If a member fails to either start, join the cluster in time (within the timeout), or
load its data, then that member is terminated immediately. After the problems causing
the failure are fixed, that member can be restarted. If the cluster start cannot be
completed in time, then all members fail to start. See the <a href="#configuring-hot-restart">Configuring Hot Restart section</a> for defining timeouts.</p>
</div>
<div class="paragraph">
<p>In the case of a restart after a cluster crash, the Hot Restart feature realizes that
it was not a clean shutdown and Hazelcast tries to restart the cluster with the last
saved data following the process explained above. In some cases, specifically when the
cluster crashes while it has an ongoing partition migration process, currently it is
not possible to restore the last saved state.</p>
</div>
<div class="sect4">
<h5 id="_restart_of_a_member_in_running_cluster"><a class="anchor" href="#_restart_of_a_member_in_running_cluster"></a>Restart of a Member in Running Cluster</h5>
<div class="paragraph">
<p>Assume the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a cluster consisting of members A, B and C with Hot Restart enabled,
which is initially stable.</p>
</li>
<li>
<p>Member B is killed.</p>
</li>
<li>
<p>Member B restarts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since only a single member has failed, the cluster performed the standard
High Availability routine by recovering member B&#8217;s data from backups and
redistributing the data among the remaining members (the members A and C
in this case). Member B&#8217;s persisted Hot Restart data is completely irrelevant.</p>
</div>
<div class="paragraph">
<p>Furthermore, when a member starts with existing Hot Restart data,
it expects to find itself within a cluster that has been shut down
as a whole and is now restarting as a whole. Since the reality is that
the cluster has been running all along, member B&#8217;s persisted cluster state
does not match the actual state. Depending on the <a href="#configuring-hot-restart">automatic removal of stale data (<code>auto-remove-stale-data</code>)</a> configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>auto-remove-stale-data</code> is enabled, member B automatically deletes its
Hot Restart directory inside the <a href="#configuring-hot-restart">base directory</a>
(<code>base-dir</code>) and starts as a fresh, empty member. The cluster assigns some
partitions to it, unrelated to the partitions it owned before going down.</p>
</li>
<li>
<p>Otherwise, member B aborts the initialization and shuts down. To be able
to join the cluster, Hot Restart directory previously used by member B inside
the <a href="#configuring-hot-restart">base directory</a> (<code>base-dir</code>) must be deleted manually.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_force_start"><a class="anchor" href="#_force_start"></a>16.3.4. Force Start</h4>
<div class="paragraph">
<p>A member can crash permanently and then be unable to recover from the failure.
In that case, restart process cannot be completed since some of the members do
not start or fail to load their own data. In that case, you can force the cluster
to clean its persisted data and make a fresh start. This process is called <strong>force start</strong>.</p>
</div>
<div class="paragraph">
<p>Assume the following which is a valid scenario to use force start:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have a cluster consisting of members A and B which is initially stable.</p>
</li>
<li>
<p>Cluster transitions into <code>FROZEN</code> or <code>PASSIVE</code> state.</p>
</li>
<li>
<p>Cluster gracefully shuts down.</p>
</li>
<li>
<p>Member A restarts, but member B does not.</p>
</li>
<li>
<p>Member A uses its Hot Restart data to initiate the Hot Restart procedure.</p>
</li>
<li>
<p>Since it knows the cluster originally contained member B as well, it waits
for it to join.</p>
</li>
<li>
<p>This never happens.</p>
</li>
<li>
<p>Now you have the choice to Force Start the cluster without member B.</p>
</li>
<li>
<p>Cluster discards all Hot Restart data and starts empty.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can trigger the force start process using the Management Center,
REST API and cluster management scripts.</p>
</div>
<div class="paragraph">
<p>Please note that force start is a destructive process, which results
in deletion of persisted Hot Restart data.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#hot-restart" target="_blank" rel="noopener">Hot Restart functionality</a>
of the Management Center section to learn how you can perform a
force start using the Management Center.</p>
</div>
</div>
<div class="sect3">
<h4 id="_partial_start"><a class="anchor" href="#_partial_start"></a>16.3.5. Partial Start</h4>
<div class="paragraph">
<p>When one or more members fail to start or have incorrect Hot Restart
data (stale or corrupted data) or fail to load their Hot Restart data,
cluster becomes incomplete and restart mechanism cannot proceed.
One solution is to use <a href="#force-start">Force Start</a> and make a fresh
start with existing members. Another solution is to do a partial start.</p>
</div>
<div class="paragraph">
<p>Partial start means that the cluster starts with an incomplete member set.
Data belonging to those missing members is assumed lost and Hazelcast tries
to recover missing data using the restored backups. For example, if you have
minimum two backups configured for all maps and caches, then a partial start
up to two missing members will be safe against data loss. If there are more
than two missing members or there are maps/caches with less than two backups,
then data loss is expected.</p>
</div>
<div class="paragraph">
<p>Partial start is controlled by <code>cluster-data-recovery-policy</code> configuration
parameter and is not allowed by default. To enable partial start, one of the
configuration values <code>PARTIAL_RECOVERY_MOST_RECENT</code> or <code>PARTIAL_RECOVERY_MOST_COMPLETE</code>
should be set. See the <a href="#configuring-hot-restart">Configuring Hot Restart section</a>
for details.</p>
</div>
<div class="paragraph">
<p>When partial start is enabled, Hazelcast can perform a partial start
automatically or manually, in case of some members are unable to restart
successfully. Partial start proceeds automatically when some members fail to
start and join to the cluster in <code>validation-timeout-seconds</code>. After the
<code>validation-timeout-seconds</code> duration is passed, Hot Restart chooses to perform
partial start with the members present in the cluster. Moreover, partial start can
be requested manually using the
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#hot-restart" target="_blank" rel="noopener">Management Center</a>,
<a href="#using-rest-api-for-cluster-management">REST API</a> and <a href="#example-usages-for-cluster-sh">cluster management scripts</a>
before the <code>validation-timeout-seconds</code> duration passes.</p>
</div>
<div class="paragraph">
<p>The other situation to decide to perform a partial start is failures during
the data load phase. When Hazelcast learns data load result of all members which
have passed the validation step, it automatically performs a partial start with
the ones which have successfully restored their Hot Restart data. Please note that
partial start does not expect every member to succeed in the data load step.
It completes the process when it learns data load result for every member and
there is at least one member which has successfully restored its Hot Restart data.
Relatedly, if it cannot learn data load result of all members before <code>data-load-timeout-seconds</code>
duration, it proceeds with the ones which have already completed the data load process.</p>
</div>
<div class="paragraph">
<p>Selection of members to perform partial start among live members is done
according to the <code>cluster-data-recovery-policy</code> configuration.
Set of members which are not selected by the <code>cluster-data-recovery-policy</code>
are called <code>Excluded members</code> and they are instructed to perform <a href="#force-start">force start</a>.
Excluded members are allowed to join cluster only when they clean their
Hot Restart data and make a fresh-new start. This is a completely automatic
process. For instance, if you start the missing members after partial start
is completed, they clean their Hot Restart data and join to the cluster.</p>
</div>
<div class="paragraph">
<p>Please note that partial start is a destructive process. Once it is completed,
it cannot be repeated with a new configuration. For this reason, one may need
to perform the partial start process manually. Automatic behavior of partial start
relies on <code>validation-timeout-seconds</code> and <code>data-load-timeout-seconds</code> configuration
values. If you need to control the process manually, <code>validation-timeout-seconds</code> and
<code>data-load-timeout-seconds</code> properties can be set to very big values so that
Hazelcast cannot make progress on timeouts automatically. Then, the overall
process can be managed manually via aforementioned methods, i.e.,
Management Center, REST API and cluster management scripts.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_hot_restart"><a class="anchor" href="#_configuring_hot_restart"></a>16.3.6. Configuring Hot Restart</h4>
<div class="paragraph">
<p>You can configure Hot Restart feature programmatically or declaratively.
There are two steps of configuration:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Enabling and configuring the Hot Restart feature globally in your Hazelcast
configuration: This is done using the configuration element <code>hot-restart-persistence</code>.
See the <a href="#global-hot-restart-configuration">Global Hot Restart Configuration section</a> below.</p>
</li>
<li>
<p>Enabling and configuring the Hazelcast data structures to use the
Hot Restart feature: This is done using the configuration element <code>hot-restart</code>.
See the <a href="#per-data-structure-hot-restart-configuration">Per Data Structure Hot Restart Configuration section</a> below.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_global_hot_restart_configuration"><a class="anchor" href="#_global_hot_restart_configuration"></a>Global Hot Restart Configuration</h5>
<div class="paragraph">
<p>This is where you configure the Hot Restart feature itself using the
<code>hot-restart-persistence</code> element. The following are the descriptions of its attribute and sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Attribute of the <code>hot-restart-persistence</code> element which
specifies whether the feature is globally enabled in your Hazelcast
configuration. Set this attribute to <code>true</code> if you want any of your
data structures to use the Hot Restart feature.</p>
</li>
<li>
<p><code>base-dir</code>: Specifies the parent directory where the Hot Restart data
is stored. The default value for <code>base-dir</code> is <code>hot-restart</code>. You can use
the default value, or you can specify the value of another folder containing
the Hot Restart configuration, but it is mandatory that <code>base-dir</code> element has
a value. This directory is created automatically if it does not exist.</p>
<div class="paragraph">
<p><code>base-dir</code> is used as the parent directory, and a unique Hot Restart
directory is created inside <code>base-dir</code> for each Hazelcast member which
uses the same <code>base-dir</code>. That means, <code>base-dir</code> can be shared among
multiple Hazelcast members safely. This is especially useful for cloud
environments where the members generally use a shared filesystem.</p>
</div>
<div class="paragraph">
<p>When a Hazelcast member starts, it tries to acquire the ownership of the
first available Hot Restart directory inside the <code>base-dir</code>. If <code>base-dir</code>
is empty or if the starting member fails to acquire the ownership of any
directory (happens when all the directories are already acquired by other
Hazelcast members), then it creates its own fresh directory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Previously, <code>base-dir</code> was being used only by a single Hazelcast member.
If such an existing <code>base-dir</code> is configured for a Hazelcast member, Hot Restart
starts in legacy mode and <code>base-dir</code> is used only by a single member, without
creating a unique sub-directory. Other members trying to use that <code>base-dir</code>
fails during the startup.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>backup-dir</code>: Specifies the directory under which Hot Restart snapshots
(Hot Backups) are stored. See the <a href="#hot-backup">Hot Backup section</a> for
more information.</p>
</li>
<li>
<p><code>parallelism</code>: Level of parallelism in Hot Restart Persistence. There
are this many I/O threads, each writing in parallel to its own files.
During the Hot Restart procedure, this many I/O threads are reading the files
and this many rebuilder threads are rebuilding the Hot Restart metadata. The
default value for this property is 1. This is a good default in most but not
all cases. You should measure the raw I/O throughput of your infrastructure and
test with different values of parallelism. In some cases such as dedicated
hardware higher parallelism can yield more throughput of Hot Restart. In other
cases such as running on EC2, it can yield diminishing returns - more thread
scheduling, more contention on I/O and less efficient garbage collection.</p>
</li>
<li>
<p><code>validation-timeout-seconds</code>: Validation timeout for the Hot Restart process
when validating the cluster members expected to join and the partition table on the whole cluster.</p>
</li>
<li>
<p><code>data-load-timeout-seconds</code>: Data load timeout for the Hot Restart process.
All members in the cluster should finish restoring their local data before this timeout.</p>
</li>
<li>
<p><code>cluster-data-recovery-policy</code>: Specifies the data recovery policy that is
respected during the Hot Restart cluster start. Valid values are;</p>
<div class="ulist">
<ul>
<li>
<p><code>FULL_RECOVERY_ONLY</code>: Starts the cluster only when all expected members
are present and correct. Otherwise, it fails. This is the default value.</p>
</li>
<li>
<p><code>PARTIAL_RECOVERY_MOST_RECENT</code>: Starts the cluster with the members which have
most up-to-date partition table and successfully restored their data. All other
members leave the cluster and force start themselves. If no member restores its
data successfully, cluster start fails.</p>
</li>
<li>
<p><code>PARTIAL_RECOVERY_MOST_COMPLETE</code>: Starts the cluster with the largest group of
members which have the same partition table version and successfully restored their
data. All other members leave the cluster and force start themselves. If no member
restores its data successfully, cluster start fails.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>auto-remove-stale-data</code>: Enables automatic removal of the stale Hot Restart data.
When a member terminates or crashes when the cluster state is <code>ACTIVE</code>, the remaining
members redistribute the data among themselves and the data persisted on terminated
member&#8217;s storage becomes stale. That terminated member cannot rejoin the cluster
without removing Hot Restart data. When auto-removal of stale Hot Restart data is enabled,
while restarting that member, Hot Restart data is automatically removed and it joins
the cluster as a completely new member. Otherwise, Hot Restart data should be removed manually.</p>
</li>
<li>
<p><code>encryption-at-rest</code>: Configures encryption on the Hot Restart data level.
See the <a href="#encryption-at-rest">Encryption at Rest section</a> for more information.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_per_data_structure_hot_restart_configuration"><a class="anchor" href="#_per_data_structure_hot_restart_configuration"></a>Per Data Structure Hot Restart Configuration</h5>
<div class="paragraph">
<p>This is where you configure the data structures of your choice, so that they can
have the Hot Restart feature. This is done using the <code>hot-restart</code> configuration
element. As it is explained in the <a href="#hot-restart-persistence">introduction</a>
paragraph, Hot Restart feature is currently supported by Hazelcast map data
structure and JCache implementation (<code>map</code> and <code>cache</code>), each of which has the
<code>hot-restart</code> configuration element. The following are the descriptions of this
element&#8217;s attribute and sub-element:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Attribute of the <code>hot-restart</code> element which specifies whether the
Hot Restart feature is enabled for the related data structure. Its default value
is <code>false</code>.</p>
</li>
<li>
<p><code>fsync</code>: Turning on <code>fsync</code> guarantees that data is persisted to the disk
device when a write operation returns successful response to the caller. By default,
<code>fsync</code> is turned off (<code>false</code>). That means data is persisted to the disk device
eventually, instead of on every disk write. This generally provides a better performance.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_hot_restart_configuration_examples"><a class="anchor" href="#_hot_restart_configuration_examples"></a>Hot Restart Configuration Examples</h5>
<div class="paragraph">
<p>The following are example configurations for a Hazelcast map and JCache implementation.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration</strong>:</p>
</div>
<div class="paragraph">
<p>An example configuration is shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;hot-restart-persistence enabled="true"&gt;
        &lt;base-dir&gt;/mnt/hot-restart&lt;/base-dir&gt;
        &lt;backup-dir&gt;/mnt/hot-backup&lt;/backup-dir&gt;
        &lt;validation-timeout-seconds&gt;120&lt;/validation-timeout-seconds&gt;
        &lt;data-load-timeout-seconds&gt;900&lt;/data-load-timeout-seconds&gt;
        &lt;cluster-data-recovery-policy&gt;FULL_RECOVERY_ONLY&lt;/cluster-data-recovery-policy&gt;
    &lt;/hot-restart-persistence&gt;
    ...
    &lt;map name="test-map"&gt;
        &lt;hot-restart enabled="true"&gt;
            &lt;fsync&gt;false&lt;/fsync&gt;
        &lt;/hot-restart&gt;
    &lt;/map&gt;
    ...
    &lt;cache name="test-cache"&gt;
        &lt;hot-restart enabled="true"&gt;
            &lt;fsync&gt;false&lt;/fsync&gt;
        &lt;/hot-restart&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  hot-restart-persistence:
    enabled: true
    base-dir: /mnt/hot-restart
    backup-dir: /mnt/hot-backup
    validation-timeout-seconds: 120
    data-load-timeout-seconds: 900
    cluster-data-recovery-policy: FULL_RECOVERY_ONLY
  map:
    test-map:
      hot-restart:
        enabled: true
        fsync: false
  cache:
    test-cache:
      hot-restart:
        enabled: true
        fsync: false</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration</strong>:</p>
</div>
<div class="paragraph">
<p>The programmatic equivalent of the above declarative configuration is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        HotRestartPersistenceConfig hotRestartPersistenceConfig = new HotRestartPersistenceConfig()
        .setEnabled(true)
        .setBaseDir(new File("/mnt/hot-restart"))
        .setParallelism(1)
        .setValidationTimeoutSeconds(120)
        .setDataLoadTimeoutSeconds(900)
        .setClusterDataRecoveryPolicy(HotRestartClusterDataRecoveryPolicy.FULL_RECOVERY_ONLY)
        .setAutoRemoveStaleData(true);
        config.setHotRestartPersistenceConfig(hotRestartPersistenceConfig);

        MapConfig mapConfig = config.getMapConfig("test-map");
        mapConfig.getHotRestartConfig().setEnabled(true);

        CacheSimpleConfig cacheConfig = config.getCacheConfig("test-cache");
        cacheConfig.getHotRestartConfig().setEnabled(true);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_hot_restart_store_on_intel_optane_dc_persistent_memory"><a class="anchor" href="#_configuring_hot_restart_store_on_intel_optane_dc_persistent_memory"></a>Configuring Hot Restart Store on Intel Optane DC Persistent Memory</h5>
<div class="paragraph">
<p>Hazelcast can be configured to use Intel Optane DC Persistent Memory as
the Hot Restart directory. For this, you need to perform the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Configure the Persistent Memory as a File System</p>
</li>
<li>
<p>Configure the Hot Restart Store to Use Persistent Memory</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Using Persistent Memory, Hot Restart times can be drastically improved.
You can find the configuration steps in the Hot Restart Store section
of the <a href="https://hazelcast.com/resources/hazelcast-deployment-operations-guide/" target="_blank" rel="noopener">Hazelcast IMDG Operations and Deployment Guide</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_movingcopying_hot_restart_data"><a class="anchor" href="#_movingcopying_hot_restart_data"></a>16.3.7. Moving/Copying Hot Restart Data</h4>
<div class="paragraph">
<p>After Hazelcast member owning the Hot Restart data is shutdown, Hot Restart
<code>base-dir</code> can be copied/moved to a different server (which may have different
IP address and/or different number of CPU cores) and Hazelcast member can be
restarted using the existing Hot Restart data on that new server. Having a new
IP address does not affect Hot Restart, since it does not rely on the IP address
of the server but instead uses <code>Member</code> UUID as a unique identifier.</p>
</div>
<div class="paragraph">
<p>This flexibility provides the following abilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Replacing one or more faulty servers with the new ones easily without
touching remaining cluster.</p>
</li>
<li>
<p>Using Hot Restart on the cloud environments easily. Sometimes cloud providers
do not preserve the IP addresses on restart or after shutdown. Also it is
possible to startup the whole cluster on a different set of machines.</p>
</li>
<li>
<p>Copying production data to the test environment, so that a more functional
test cluster can bet setup.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unfortunately having different number of CPU cores is not that straightforward.
Hazelcast partition threads, by default, uses a heuristic from the number of
cores, e.g., <code># of partition threads = # of CPU cores</code>. When a Hazelcast member
is started on a server with a different CPU core count, number of Hazelcast
partition threads changes and that makes Hot Restart fail during the startup.
Solution is to explicitly set number of Hazelcast partition threads
(<code>hazelcast.operation.thread.count</code> system property) and Hot Restart <code>parallelism</code>
configuration and use the same parameters on the new server. For setting system
properties see the <a href="#system-properties">System Properties appendix</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hot_restart_persistence_design_details"><a class="anchor" href="#_hot_restart_persistence_design_details"></a>16.3.8. Hot Restart Persistence Design Details</h4>
<div class="paragraph">
<p>Hazelcast&#8217;s Hot Restart Persistence uses the log-structured
storage approach. The following is a top-level design description:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The only kind of update operation on persistent data is <em>appending</em>.</p>
</li>
<li>
<p>What is appended are facts about events that happened to the data model
represented by the store; either a new value was assigned to a key or a key was removed.</p>
</li>
<li>
<p>Each record associated with a key makes stale the previous record
that was associated with that key.</p>
</li>
<li>
<p>Stale records contribute to the amount of <em>garbage</em> present in
the persistent storage.</p>
</li>
<li>
<p>Measures are taken to remove garbage from the storage.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This kind of design focuses almost all of the system&#8217;s complexity
into the garbage collection (GC) process, stripping down the client&#8217;s
operation to the bare necessity of guaranteeing persistent behavior: a
simple file append operation. Consequently, the latency of operations is
close to the theoretical minimum in almost all cases. Complications arise
only during prolonged periods of maximum load; this is where the details of
the GC process begin to matter.</p>
</div>
</div>
<div class="sect3">
<h4 id="_concurrent_incremental_generational_gc"><a class="anchor" href="#_concurrent_incremental_generational_gc"></a>16.3.9. Concurrent, Incremental, Generational GC</h4>
<div class="paragraph">
<p>In order to maintain the lowest possible footprint in the update operation
latency, the following properties are built into the garbage collection process:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A dedicated thread performs the GC. In Hazelcast terms, this thread
is called the Collector and the application thread is called the Mutator.</p>
</li>
<li>
<p>On each update there is metadata to be maintained; this is done asynchronously
by the Collector thread. The Mutator enqueues update events to the Collector&#8217;s work queue.</p>
</li>
<li>
<p>The Collector keeps draining its work queue at all times, including the time
it goes through the GC cycle. Updates are taken into account at each stage in the
GC cycle, preventing the copying of already dead records into compacted files.</p>
</li>
<li>
<p>All GC-induced I/O competes for the same resources as the Mutator&#8217;s update operations.
Therefore, measures are taken to minimize the impact of I/O done during GC:</p>
<div class="ulist">
<ul>
<li>
<p>data is never read from files, but from RAM</p>
</li>
<li>
<p>a heuristic scheme is employed which minimizes the number of bytes written
to the disk for each kilobyte of the reclaimed garbage</p>
</li>
<li>
<p>measures are also taken to achieve a good interleaving of Collector and
Mutator operations, minimizing latency outliers perceived by the Mutator</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_io_minimization_scheme"><a class="anchor" href="#_io_minimization_scheme"></a>I/O Minimization Scheme</h5>
<div class="paragraph">
<p>The success of this scheme is subject to a bet on the Weak Generational Garbage Hypothesis,
which states that a new record entering the system is likely to become garbage soon.
In other words, a key updated now is more likely than average to be updated again soon.</p>
</div>
<div class="paragraph">
<p>The scheme was taken from the seminal Sprite LFS paper,
<a href="http://www.cs.berkeley.edu/~brewer/cs262/LFS.pdf" target="_blank" rel="noopener">Rosenblum, Ousterhout, <em>The Design and Implementation of a Log-Structured File System</em></a>.
The following is an outline of the paper:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Data is not written to one huge file, but to many files of moderate size (8 MB) called "chunks".</p>
</li>
<li>
<p>Garbage is collected incrementally, i.e. by choosing several chunks, then
copying all their live data to new chunks, then deleting the old ones.</p>
</li>
<li>
<p>I/O is minimized using a collection technique which results in a bimodal
distribution of chunks with respect to their garbage content: most files
are either almost all live data or they are all garbage.</p>
</li>
<li>
<p>The technique consists of two main principles:</p>
<div class="ulist">
<ul>
<li>
<p>Chunks are selected based on their <em>Cost-Benefit factor</em> (see below).</p>
</li>
<li>
<p>Records are sorted by age before copying to new chunks.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_cost_benefit_factor"><a class="anchor" href="#_cost_benefit_factor"></a>Cost-Benefit Factor</h5>
<div class="paragraph">
<p>The Cost-Benefit factor of a chunk consists of two components multiplied together:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The ratio of benefit (amount of garbage that can be collected) to
I/O cost (amount of live data to be written).</p>
</li>
<li>
<p>The age of the data in the chunk, measured as the age of the
youngest record it contains.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The essence is in the second component: given equal amount of garbage in all chunks,
it makes the young ones less attractive to the Collector.
Assuming the generational garbage hypothesis, this allows the young chunks to
quickly accumulate more garbage. On the flip side, it also ensures that even
files with little garbage are eventually garbage collected. This removes garbage
which would otherwise linger on, thinly spread across many chunk files.</p>
</div>
<div class="paragraph">
<p>Sorting records by age groups the young records together in a single chunk and
does the same for older records. Therefore the chunks are either tend to keep
their data live for a longer time, or quickly become full of garbage.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hot_restart_performance_considerations"><a class="anchor" href="#_hot_restart_performance_considerations"></a>16.3.10. Hot Restart Performance Considerations</h4>
<div class="paragraph">
<p>In this section you can find performance test summaries which are results of
benchmark tests performed with a single Hazelcast member running on a physical server and on AWS R3.</p>
</div>
<div class="sect4">
<h5 id="_performance_on_a_physical_server"><a class="anchor" href="#_performance_on_a_physical_server"></a>Performance on a Physical Server</h5>
<div class="paragraph">
<p>We have tested a member which has an IMap with High-Density Data Store.
Its data size is changed for each test, started from 10 GB to 500 GB
(each map entry has a value of 1 KB).</p>
</div>
<div class="paragraph">
<p>The tests investigate the write and read performance of Hot Restart Persistence and
are performed on HP ProLiant servers with RHEL 7 operating system using Hazelcast Simulator.</p>
</div>
<div class="paragraph">
<p>The following are the specifications of the server hardware used for the test:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CPU: 2x Intel&#174; Xeon&#174; CPU E5-2687W v3 @ 3.10GHz  with 10 cores per processor.
Total 20 cores, 40 with hyper threading enabled.</p>
</li>
<li>
<p>Memory: 768GB 2133 MHz memory 24x HP 32GB 4Rx4 PC4-2133P-L Kit</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following are the storage media used for the test:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A hot-pluggable 2.5 inch HDD with 1 TB capacity and 10K RPM.</p>
</li>
<li>
<p>An SSD, Light Endurance PCle Workload Accelerator.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The below table shows the test results.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/HotRestartPerf.png" alt="Hot Restart Perf">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_performance_on_aws_r3"><a class="anchor" href="#_performance_on_aws_r3"></a>Performance on AWS R3</h5>
<div class="paragraph">
<p>We have tested a member which has an IMap with High-Density Data Store:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This map has 40 million distinct keys, each map entry is 1 KB.</p>
</li>
<li>
<p>High-Density Memory Store is 59 GiB whose 19% is metadata.</p>
</li>
<li>
<p>Hot Restart is configured with <code>fsync</code> turned off.</p>
</li>
<li>
<p>Data size reloaded on restart is 38 GB.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The tests investigate the write and read performance of Hot Restart Persistence
and are performed on R3.2xlarge and R3.4xlarge EC2 instances using Hazelcast Simulator.</p>
</div>
<div class="paragraph">
<p>The following are the AWS storage types used for the test:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Elastic Block Storage (EBS) General Purpose SSD (GP2)</p>
</li>
<li>
<p>Elastic Block Storage with Provisioned IOPS (IO1) (Provisioned 10,000 IOPS on a
340 GiB volume, enabled EBS-optimized on instance)</p>
</li>
<li>
<p>SSD-backed instance store</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The below table shows the test results.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/HotRestartPerf2.png" alt="Hot Restart Perf2">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hot_backup"><a class="anchor" href="#_hot_backup"></a>16.3.11. Hot Backup</h4>
<div class="paragraph">
<p>During Hot Restart operations you can take a snapshot of the Hot Restart Store
at a certain point in time. This is useful when you wish to bring up a new cluster
with the same data or parts of the data. The new cluster can then be used to share
load with the original cluster, to perform testing, QA or reproduce an issue on production data.</p>
</div>
<div class="paragraph">
<p>Simple file copying of a currently running cluster does not suffice and can produce
inconsistent snapshots with problems such as resurrection of deleted values or missing values.</p>
</div>
<div class="sect4">
<h5 id="_configuring_hot_backup"><a class="anchor" href="#_configuring_hot_backup"></a>Configuring Hot Backup</h5>
<div class="paragraph">
<p>To create snapshots you must first configure the Hot Restart backup directory.
You can configure the directory programmatically or declaratively using the following configuration element:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>backup-dir</code>: This element is included in the <code>hot-restart-persistence</code> and
denotes the destination under which backups are stored. If this element is not defined,
hot backup is disabled. If a directory is defined which does not exist, it is created on
the first backup. To avoid clashing data on multiple backups, each backup has a unique
sequence ID which determines the name of the directory which contains all Hot Restart data.
This unique directory is created as a subdirectory of the configured <code>backup-dir</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following are the example configurations for Hot backup.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration</strong>:</p>
</div>
<div class="paragraph">
<p>An example configuration is shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;hot-restart-persistence enabled="true"&gt;
        &lt;backup-dir&gt;/mnt/hot-backup&lt;/backup-dir&gt;
	...
    &lt;/hot-restart-persistence&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  hot-restart-persistence:
    enabled: true
    backup-dir: /mnt/hot-backup</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration</strong>:</p>
</div>
<div class="paragraph">
<p>The programmatic equivalent of the above declarative configuration is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HotRestartPersistenceConfig hotRestartPersistenceConfig = new HotRestartPersistenceConfig();
hotRestartPersistenceConfig.setBackupDir(new File("/mnt/hot-backup"));
...
config.setHotRestartPersistenceConfig(hotRestartPersistenceConfig);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_using_hot_backup"><a class="anchor" href="#_using_hot_backup"></a>Using Hot Backup</h5>
<div class="paragraph">
<p>Once configured, you can initiate a new backup via API or from the Management Center.
The backup is started transactionally and cluster-wide. This means that either
all or none of the members start the same backup. The member which receives the backup
request determines a new backup sequence ID and send that information to all members.
If all members respond that no other backup is currently in progress and that
no other backup request has already been made, then the coordinating member commands
the other members to start the actual backup process. This creates a directory under
the configured <code>backup-dir</code> with the name <code>backup-&lt;backupSeq&gt;</code> and start copying the
data from the original store.</p>
</div>
<div class="paragraph">
<p>The backup process is initiated nearly instantaneously on all members. Note that
since there is no limitation as to when the backup process is initiated, it may be
initiated during membership changes, partition table changes or during normal data update.
Some of these operations may not be completed fully yet, which means that some members
will backup some data while some members will backup a previous version of the same data.
This is usually solved by the anti-entropy mechanism on the new cluster which
reconciles different versions of the same data. Please check the
<a href="#achieving-high-consistency-of-backup-data">Achieving High Consistency of Backup Data section</a>
for more information.</p>
</div>
<div class="paragraph">
<p>The duration of the backup process and the disk data usage drastically depends on
what is supported by the system and the configuration. Please check the
<a href="#achieving-high-performance-of-backup-process">Achieving high performance of backup process section</a>
for more information on achieving better resource usage of the backup process.</p>
</div>
<div class="paragraph">
<p>Following is an example of how to trigger the Hot Backup via API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HotRestartService service = instance.getCluster().getHotRestartService();
service.backup();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>backupSeq</code> is generated by the hot backup process, but you can define
your own backup sequences as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HotRestartService service = instance.getCluster().getHotRestartService();
long backupSeq = ...
service.backup(backupSeq);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that the backup fails if any member contains a backup directory
with the name <code>backup-&lt;backupSeq&gt;</code>, where <code>backupSeq</code> is the given sequence.</p>
</div>
</div>
<div class="sect4">
<h5 id="_starting_the_cluster_from_a_hot_backup"><a class="anchor" href="#_starting_the_cluster_from_a_hot_backup"></a>Starting the Cluster From a Hot Backup</h5>
<div class="paragraph">
<p>As mentioned in the previous section, hot backup process creates subdirectories
named <code>backup-&lt;backupSeq&gt;</code> under the configured <a href="#configuring-hot-backup">hot backup directory</a>
(i.e., <code>backup-dir</code>). When starting your cluster with data from a hot backup, you need to set
the <a href="#global-hot-restart-configuration">base directory</a> (i.e., <code>base-dir</code>) to the desired backup subdirectory.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you have configured your hot backup directory as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;hot-restart-persistence enabled="true"&gt;
        &lt;backup-dir&gt;/mnt/hot-backup&lt;/backup-dir&gt;
	...
    &lt;/hot-restart-persistence&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  hot-restart-persistence:
    enabled: true
    backup-dir: /mnt/hot-backup</code></pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s say you have a subdirectory named <code>backup-2018Oct24</code> under the
backup directory <code>/mnt/hot-backup</code>. When you want to start your cluster with data
from this backup (<code>backup-2018Oct24</code>), here is the configuration you should have
for the <code>base-dir</code> while starting the cluster:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;hot-restart-persistence enabled="true"&gt;
        &lt;base-dir&gt;backup-2018Oct24&lt;/base-dir&gt;
        &lt;parallelism&gt;1&lt;/parallelism&gt;
    &lt;/hot-restart-persistence&gt;
    ...
    &lt;map name="test-map"&gt;
        &lt;hot-restart enabled="true"&gt;
            &lt;fsync&gt;false&lt;/fsync&gt;
        &lt;/hot-restart&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  hot-restart-persistence:
    enabled: true
    base-dir: backup-2018Oct24
    parallelism: 1
  map:
    test-map:
      hot-restart:
        enabled: true
        fsync: false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_achieving_high_consistency_of_backup_data"><a class="anchor" href="#_achieving_high_consistency_of_backup_data"></a>Achieving High Consistency of Backup Data</h5>
<div class="paragraph">
<p>The backup is initiated nearly simultaneously on all members but you can
encounter some inconsistencies in the data. This is because some members might have
and some might not have received updated values yet from executed operations,
because the system could be undergoing partition and membership changes or
because there are some transactions which have not yet been committed.</p>
</div>
<div class="paragraph">
<p>To achieve a high consistency of data on all members, the cluster should be
put to <code>PASSIVE</code> state for the duration of the call to the backup method.
See the <a href="#cluster-member-states">Cluster Member States section</a> on information on how to do this.
The cluster does not need to be in <code>PASSIVE</code> state for the entire
duration of the backup process, though. Because of the design, only partition metadata
is copied synchronously during the invocation of the backup method. Once the backup method has returned,
all cluster metadata is copied and the exact partition data which needs to be copied is marked.
After that, the backup process continues asynchronously and you can return the cluster to the
<code>ACTIVE</code> state and resume operations.</p>
</div>
</div>
<div class="sect4">
<h5 id="_achieving_high_performance_of_backup_process"><a class="anchor" href="#_achieving_high_performance_of_backup_process"></a>Achieving High Performance of Backup Process</h5>
<div class="paragraph">
<p>Because of the design of Hot Restart Store, we can use hard links to achieve
backups/snapshots of the store. The hot backup process uses hard links
whenever possible because they provide big performance benefits and because
the backups share disk usage.</p>
</div>
<div class="paragraph">
<p>The performance benefit comes from the fact that Hot Restart file contents are
not being duplicated (thus using disk and I/O resources) but rather a new file name
is created for the same contents on disk (another pointer to the same inode).
Since all backups and stores share the same inode, disk usage drops.</p>
</div>
<div class="paragraph">
<p>The bigger the percentage of stable data in the Hot Restart Store
(data not undergoing changes), the more files each backup shares with the operational
Hot Restart Store and the less disk space it uses. For the hot backup to use hard links,
you must be running Hazelcast members on JDK 7 or higher and must satisfy all requirements for the
<a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createLink(java.nio.file.Path,%20java.nio.file.Path)" target="_blank" rel="noopener">Files.createLink() method</a> to be supported.</p>
</div>
<div class="paragraph">
<p>The backup process initially attempts to create a new hard link and
if that fails for any reason it continues by copying the data.
Subsequent backups also attempt to use hard links.</p>
</div>
</div>
<div class="sect4">
<h5 id="_backup_process_progress_and_completion"><a class="anchor" href="#_backup_process_progress_and_completion"></a>Backup Process Progress and Completion</h5>
<div class="paragraph">
<p>Only cluster and distributed object metadata is copied synchronously
during the invocation of the backup method. The rest of the
Hot Restart Store containing partition data is copied asynchronously
after the method call has ended. You can track the progress by API or
view it from the Management Center.</p>
</div>
<div class="paragraph">
<p>An example of how to track the progress via API is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HotRestartService service = instance.getCluster().getHotRestartService();
BackupTaskStatus status = service.getBackupTaskStatus();
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned object contains the local member&#8217;s backup status:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the backup state (NOT_STARTED, IN_PROGRESS, FAILURE, SUCCESS)</p>
</li>
<li>
<p>the completed count</p>
</li>
<li>
<p>the total count</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The completed and total count can provide you a way to track the
percentage of the copied data. Currently the count defines the
number of copied and total local member Hot Restart Stores
(defined by <code>HotRestartPersistenceConfig.setParallelism()</code>)
but this can change at a later point to provide greater resolution.</p>
</div>
<div class="paragraph">
<p>Besides tracking the Hot Restart status by API, you can view the status in the
Management Center and you can inspect the on-disk files for each member.
Each member creates an <code>inprogress</code> file which is created in each of the copied Hot Restart Stores.
This means that the backup is currently in progress. When the backup task completes
the backup operation, this file is removed. If an error occurs during the backup task,
the <code>inprogress</code> file is renamed to <code>failure</code> which contains a stack trace of the exception.</p>
</div>
</div>
<div class="sect4">
<h5 id="_backup_task_interruption_and_cancellation"><a class="anchor" href="#_backup_task_interruption_and_cancellation"></a>Backup Task Interruption and Cancellation</h5>
<div class="paragraph">
<p>Once the backup method call has returned and asynchronous copying of the
partition data has started, the backup task can be interrupted.
This is helpful in situations where the backup task has started at an inconvenient time.
For instance, the backup task could be automatized and it could be accidentally triggered
during high load on the Hazelcast instances, causing the performance of the Hazelcast instances to drop.</p>
</div>
<div class="paragraph">
<p>The backup task mainly uses disk IO, consumes little CPU and it generally
does not last for a long time (although you should test it with your environment
to determine the exact impact). Nevertheless, you can abort the backup tasks
on all members via a cluster-wide interrupt operation.
This operation can be triggered programmatically or from the Management Center.</p>
</div>
<div class="paragraph">
<p>An example of programmatic interruption is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HotRestartService service = instance.getCluster().getHotRestartService();
service.interruptBackupTask();
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method sends an interrupt to all members.
The interrupt is ignored if the backup task is currently not in progress
so you can safely call this method even though it has previously been
called or when some members have already completed their local backup tasks.</p>
</div>
<div class="paragraph">
<p>You can also interrupt the local member backup task as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HotRestartService service = instance.getCluster().getHotRestartService();
service.interruptLocalBackupTask();
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The backup task stops as soon as possible and it does not remove the
disk contents of the backup directory meaning that you must remove it manually.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="encryption-at-rest"><a class="anchor" href="#encryption-at-rest"></a>16.3.12. Encryption at Rest</h4>
<div class="paragraph">
<p>Records stored in the Hot Restart Store may contain sensitive information. This sensitive
information may be present in the keys, in the values, or in both. In Hot Restart terms,
Encryption at Rest concerns with encryption on the chunk file level. Since complete chunk
files are encrypted, all data stored in the Hot Restart Store is protected when
Encryption at Rest is enabled.</p>
</div>
<div class="paragraph">
<p>Data persisted in the Hot Restart Store is encrypted using symmetric encryption. The
implementation is based on
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html" target="_blank" rel="noopener">Java Cryptography Architecture</a> (JCA).
The encryption scheme uses two levels of encryption keys: auto-generated Hot Restart
Store-level encryption keys (one per configured parallelism) that are used to encrypt
the chunk files and a master encryption key that is used to encrypt the store-specific
encryption keys. The master encryption key is sourced from an external system called Secure
Store and, in contrast to the Hot Restart Store-level encryption keys, it is not persisted
anywhere within the Hot Restart Store.</p>
</div>
<div class="paragraph">
<p>When Hot Restart with Encryption at Rest is first enabled on a member, the member contacts
the Secure Store during the startup and retrieves the master encryption key. Then it generates
the Hot Restart Store-level encryption keys for the parallel Stores and stores them (encrypted
using the master key) under the Hot Restart Store&#8217;s directory. The subsequent writes to Hot
Restart chunk files will be encrypted using the Store-level encryption key. During Hot Restart,
the member retrieves the master encryption key from the Secure Store, decrypts the Store-level
encryption keys and uses those to decrypt the chunk files.</p>
</div>
<div class="paragraph">
<p>Master key rotation is supported. If the master encryption key changes in the Secure Store,
the Hot Restart subsystem will detect it and retrieve the new master encryption key. During
this process, it will also re-encrypt the Hot Restart Store-level encryption keys using
the new master encryption key.</p>
</div>
<div class="paragraph">
<p>The <a href="#configuring-secure-store">Configuring a Secure Store section</a> provides information
about the supported Secure Store types.</p>
</div>
<div class="sect4">
<h5 id="_configuring_encryption_at_rest"><a class="anchor" href="#_configuring_encryption_at_rest"></a>Configuring Encryption at Rest</h5>
<div class="paragraph">
<p>Encryption at Rest can be enabled and configured programmatically or declaratively using the
<code>encryption-at-rest</code> sub-element of <code>hot-restart-persistence</code>. The <code>encryption-at-rest</code>
element has the following attributes and sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Attribute that specifies whether Encryption at Rest is enabled; <code>false</code>
by default.</p>
</li>
<li>
<p><code>algorithm</code>: Specifies the symmetric cipher to use (such as <code>AES/CBC/PKCS5Padding</code>).</p>
</li>
<li>
<p><code>salt</code>: The encryption salt.</p>
</li>
<li>
<p><code>key-size</code>: The size of the auto-generated Hot Restart Store-level encryption key.</p>
</li>
<li>
<p><code>secure-store</code>: Specifies the Secure Store to use for the retrieval of master
encryption keys. See the <a href="#configuring-secure-store">Configuring a Secure Store section</a>
for more details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following are the example configurations for Encryption at Rest.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration</strong>:</p>
</div>
<div class="paragraph">
<p>An example configuration is shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;hot-restart-persistence enabled="true"&gt;
        ...
        &lt;encryption-at-rest enabled="true"&gt;
            &lt;algorithm&gt;AEC/CBC/PKCS5Padding&lt;/algorithm&gt;
            &lt;salt&gt;thesalt&lt;/salt&gt;
            &lt;key-size&gt;128&lt;/key-size&gt;
            &lt;secure-store&gt;...&lt;/secure-store&gt;
        &lt;/encryption-at-rest&gt;
        ...
    &lt;/hot-restart-persistence&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  hot-restart-persistence:
    enabled: true
    encryption-at-rest:
      enabled: true
      algorithm: AES/CBC/PKCS5Padding
      salt: thesalt
      key-size: 128
      secure-store:
         ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration</strong>:</p>
</div>
<div class="paragraph">
<p>The programmatic equivalent of the above declarative configuration is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HotRestartPersistenceConfig hotRestartPersistenceConfig = new HotRestartPersistenceConfig();
        EncryptionAtRestConfig encryptionAtRestConfig =
                hotRestartPersistenceConfig.getEncryptionAtRestConfig();
        encryptionAtRestConfig.setEnabled(true)
                .setAlgorithm("AES/CBC/PKCS5Padding")
                .setSalt("thesalt")
                .setKeySize(128)
                .setSecureStoreConfig(secureStore());</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="configuring-secure-store"><a class="anchor" href="#configuring-secure-store"></a>Configuring a Secure Store</h5>
<div class="paragraph">
<p>A Secure Store represents a (secure) source of master encryption keys and
is required for using Encryption at Rest.</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG Enterprise provides Secure Store implementations for the
<a href="https://docs.oracle.com/javase/8/docs/api/java/security/KeyStore.html" target="_blank" rel="noopener">Java KeyStore</a>
and for <a href="https://www.vaultproject.io/" target="_blank" rel="noopener">HashiCorp Vault</a>.</p>
</div>
<div class="paragraph">
<p><strong>Java KeyStore Secure Store</strong></p>
</div>
<div class="paragraph">
<p>The Java KeyStore Secure Store provides integration with the <a href="https://docs.oracle.com/javase/8/docs/api/java/security/KeyStore.html" target="_blank" rel="noopener">Java KeyStore</a>.
It can be configured programmatically or declaratively using the
<code>keystore</code> sub-element of <code>secure-store</code>. The <code>keystore</code> element has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>path</code>: The path to the KeyStore file.</p>
</li>
<li>
<p><code>type</code>: The type of the KeyStore (<code>PKCS12</code>, <code>JCEKS</code>, etc.).</p>
</li>
<li>
<p><code>password</code>: The KeyStore password.</p>
</li>
<li>
<p><code>current-key-alias</code>: The alias for the current encryption key entry (optional).</p>
</li>
<li>
<p><code>polling-interval</code>: The polling interval (in seconds) for checking for changes in the KeyStore.
Disabled by default.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Sensitive configuration properties such as <code>password</code> should be protected using
<a href="#variable-replacers">encryption replacers</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Java KeyStore Secure treats all <code>KeyStore.SecretKeyEntry</code> entries stored in the KeyStore as
encryption keys. It expects that these entries use the same protection password as the KeyStore
itself. Entries of other types (private key entries, certificate entries) are ignored. If
<code>current-key-alias</code> is set, the corresponding entry will be treated as the current encryption key;
otherwise, the highest entry in the alphabetical order will be used. The remaining entries will
represent historical versions of the encryption key.</p>
</div>
<div class="paragraph">
<p>An example declarative configuration is shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;secure-store&gt;
    &lt;keystore&gt;
        &lt;path&gt;/path/to/keystore.file&lt;/path&gt;
        &lt;type&gt;PKCS12&lt;/type&gt;
        &lt;password&gt;password&lt;/password&gt;
        &lt;current-key-alias&gt;current&lt;/current-key-alias&gt;
        &lt;polling-interval&gt;60&lt;/polling-interval&gt;
    &lt;/keystore&gt;
&lt;/secure-store&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">secure-store:
  keystore:
    path: /path/to/keystore.file
    type: PKCS12
    password: password
    current-key-alias: current
    polling-interval: 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an equivalent programmatic configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        JavaKeyStoreSecureStoreConfig keyStoreConfig =
                new JavaKeyStoreSecureStoreConfig(new File("/path/to/keystore.file"))
                        .setType("PKCS12")
                        .setPassword("password")
                        .setCurrentKeyAlias("current")
                        .setPollingInterval(60);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>HashiCorp Vault Secure Store</strong></p>
</div>
<div class="paragraph">
<p>The HashiCorp Vault Secure Store provides integration with <a href="https://www.vaultproject.io/" target="_blank" rel="noopener">HashiCorp Vault</a>.
It can be configured programmatically or declaratively using the
<code>vault</code> sub-element of <code>secure-store</code>. The <code>vault</code> element has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>address</code>: The address of the Vault server.</p>
</li>
<li>
<p><code>secret-path</code>: The secret path under which the encryption keys are stored.</p>
</li>
<li>
<p><code>token</code>: The Vault authentication token.</p>
</li>
<li>
<p><code>polling-interval</code>: The polling interval (in seconds) for checking for changes in Vault. Disabled
by default.</p>
</li>
<li>
<p><code>ssl</code>: The TLS/SSL configuration for HTTPS support. See the <a href="#tlsssl">TLS/SSL section</a> for more
information about how to use the <code>ssl</code> element.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Sensitive configuration properties such as <code>token</code> should be protected using
<a href="#variable-replacers">encryption replacers</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The HashiCorp Vault Secure Store implementation uses the official REST API to integrate with
HashiCorp Vault. Only for the <a href="https://www.vaultproject.io/docs/secrets/kv/index.html" target="_blank" rel="noopener">KV secrets engine</a>,
both KV V1 and KV V2 can be used, but since only V2 provides secrets versioning, this is
the recommended option. With KV V1 (no versioning support), only one version of the encryption
key can be kept, whereas with KV V2, the HashiCorp Vault Secure Store is able to retrieve
also the historical encryption keys. (Note that the size of the version history is configurable
on the Vault side.) Having access to the previous encryption keys may be critical to avoid
scenarios where the Hot Restart data becomes undecryptable because the master encryption key
is no longer usable (for instance, when the original master encryption key got rotated out
in the Secure Store while the cluster was down).</p>
</div>
<div class="paragraph">
<p>The encryption key is expected to be stored at the specified secret path and represented as a
single key/value pair in the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>name=Base64-encoded-data</code></pre>
</div>
</div>
<div class="paragraph">
<p>where name can be an arbitrary string. Multiple key/value pairs under the same secret path are not
supported. Here is an example of how such a key/value pair can be stored using the HashiCorp
Vault command-line client (under the secret path <code>hz/cluster</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>vault kv put hz/cluster value=HEzO124Vz...</code></pre>
</div>
</div>
<div class="paragraph">
<p>With KV V2, a second <code>put</code> to the same secret path creates a new version of the encryption key.
With KV V1, it simply overwrites the current encryption key, discarding the old value.</p>
</div>
<div class="paragraph">
<p>An example declarative configuration is shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;secure-store&gt;
    &lt;vault&gt;
        &lt;address&gt;http://localhost:1234&lt;/address&gt;
        &lt;secret-path&gt;secret/path&lt;/secret-path&gt;
        &lt;token&gt;token&lt;/token&gt;
        &lt;polling-interval&gt;60&lt;/polling-interval&gt;
        &lt;ssl&gt;...&lt;/ssl&gt;
    &lt;/vault&gt;
&lt;/secure-store&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">secure-store:
  vault:
    address: http://localhost:1234
    secret-path: secret/path
    token: token
    polling-interval: 60
    ssl:
      ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an equivalent programmatic configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        VaultSecureStoreConfig vaultConfig =
                new VaultSecureStoreConfig("http://localhost:1234", "secret/path", "token")
                        .setPollingInterval(60);
        configureSSL(vaultConfig.getSSLConfig());</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hazelcast-striim-hot-cache"><a class="anchor" href="#hazelcast-striim-hot-cache"></a>17. Database CDC Integration using Striim Hot Cache</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise</strong></p>
</div>
<div class="paragraph">
<p>Change Data Capture (CDC) refers to the technology for identifying and capturing
changes made to a data source. These changes can then be applied to
another data repository or made available in a format supported by
data integration tools.</p>
</div>
<div class="paragraph">
<p><a href="https://www.striim.com/" target="_blank" rel="noopener">Striim</a> is a real-time data integration
and streaming analytics software platform. It uses
CDC (Change Data Capture) mechanism to detect changes performed on
a data source.</p>
</div>
<div class="paragraph">
<p>Hazelcast Striim Hot Cache, the integration solution of Hazelcast and Striim,
enables real-time, push-based propagation of changes from the database to the cache.
The following sections describe this integration.</p>
</div>
<div class="sect2">
<h3 id="striim-cdc-introduction"><a class="anchor" href="#striim-cdc-introduction"></a>17.1. Introduction</h3>
<div class="paragraph">
<p>Through CDC, Striim is able to recognize which tables and key values have changed.
It immediately captures these changes with their table and key, and pushes the changes
into a cache. Supported databases are Oracle, My SQL and Microsoft SQL Server.</p>
</div>
<div class="paragraph">
<p>When it comes to Hazelcast, you can get the changes in a database and
put them into your Hazelcast IMDG member
using a "writer" developed by Striim, i.e., Hazelcast Writer. This writer
creates a Hazelcast client once you start Striim, to connect to your IMDG member.</p>
</div>
</div>
<div class="sect2">
<h3 id="striim-cdc-supported-versions"><a class="anchor" href="#striim-cdc-supported-versions"></a>17.2. Supported Versions</h3>
<div class="paragraph">
<p>This integration only works with Hazelcast IMDG <strong>3.x versions</strong>. Support for 4.x will be added in the near future.</p>
</div>
</div>
<div class="sect2">
<h3 id="striim-cdc-logging"><a class="anchor" href="#striim-cdc-logging"></a>17.3. Logging</h3>
<div class="paragraph">
<p>You can enable logging to see the status of the Hazelcast client created by the Hazelcast Writer.
For this, you need to add the following line to the <code>server.sh</code> file
on the machine where Striim is running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.logging.type=log4j</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>server.sh</code> file is typically located at the <code>/opt/striim/bin</code> directory.</p>
</div>
<div class="paragraph">
<p>You can also set the logging level by adding the following
line to the <code>log4j.server.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>log4j.logger.com.hazelcast=debug</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>log4j.server.properties</code> file is typically located at the <code>/opt/striim/conf</code> directory.</p>
</div>
<div class="paragraph">
<p>In the above example line, the logging level is set as <code>DEBUG</code>. The
following lists all the available levels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TRACE</code></p>
</li>
<li>
<p><code>DEBUG</code></p>
</li>
<li>
<p><code>INFO</code></p>
</li>
<li>
<p><code>WARN</code></p>
</li>
<li>
<p><code>ERROR</code></p>
</li>
<li>
<p><code>OFF</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The logs are written into the <code>striim.server.log</code> which is typically located
at the <code>/opt/striim/logs</code> directory.</p>
</div>
<div class="paragraph">
<p>The above settings are for the Hazelcast Client created by the writer.
You can also change the logging level dynamically for Hazelcast Writer. Follow the
below instructions for this:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open the Striim console using the <code>console.sh</code> command.
See <a href="https://www.striim.com/docs/en/console-commands.html" target="_blank" rel="noopener">here</a>
for the usage of this command.</p>
</li>
<li>
<p>While in the console, run the following command:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>set loglevel = {com.webaction.proc.HazelcastWriter_1_0:debug};</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_full_worked_example_application"><a class="anchor" href="#_full_worked_example_application"></a>17.4. Full Worked Example Application</h3>
<div class="paragraph">
<p>We have created a <a href="https://github.com/hazelcast-guides/striim-hazelcast-cdc" target="_blank" rel="noopener">full example application</a> with step-by-step instructions which guides you through using Striim to load data from an Oracle database using the Striim Hazelcast Writer. We recommend you start here before applying this to your own application.</p>
</div>
</div>
<div class="sect2">
<h3 id="striim-cdc-resources"><a class="anchor" href="#striim-cdc-resources"></a>17.5. Further Resources</h3>
<div class="paragraph">
<p>You can refer to <a href="https://www.striim.com/docs/en/hazelcast-writer.html" target="_blank" rel="noopener">here</a>
for more information on Hazelcast Writer.</p>
</div>
<div class="paragraph">
<p>Download a fully loaded evaluation copy of
<a href="http://www.striim.com/download-striim-for-hazelcast-hot-cache/" target="_blank" rel="noopener">Striim for Hazelcast Hot Cache</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hazelcast_clients"><a class="anchor" href="#_hazelcast_clients"></a>18. Hazelcast Clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides information about Hazelcast&#8217;s client and language implementations,
which are listed below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#java-client">Java</a></p>
</li>
<li>
<p><a href="#c-client">C++</a></p>
</li>
<li>
<p><a href="#net-client">.NET</a></p>
</li>
<li>
<p><a href="#memcache-client">Memcache</a></p>
</li>
<li>
<p><a href="#rest-client">REST</a></p>
</li>
<li>
<p><a href="#node-js-client">Node.js</a></p>
</li>
<li>
<p><a href="#go-client">Go</a></p>
</li>
<li>
<p><a href="#python-client">Python</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Feature Comparison for Hazelcast Clients:</strong></p>
</div>
<div class="paragraph">
<p>See the <a href="https://hazelcast.org/clients-languages/" target="_blank" rel="noopener">feature comparison matrix</a>
to learn about the features implemented across the clients and language APIs.</p>
</div>
<div class="paragraph">
<p><strong>Code Samples:</strong></p>
</div>
<div class="paragraph">
<p>In the following client sections, you will find links to each client&#8217;s code samples.</p>
</div>
<div class="sect2">
<h3 id="java-client"><a class="anchor" href="#java-client"></a>18.1. Java Client</h3>
<div class="paragraph">
<p>The Java client is the most full featured Hazelcast native client.
It is offered both with Hazelcast IMDG and Hazelcast IMDG Enterprise.
The main idea behind the Java client is to provide the same Hazelcast
functionality by proxying each operation through a Hazelcast member.
It can access and change distributed data and it can listen to distributed
events of an already established Hazelcast cluster from another Java application.</p>
</div>
<div class="paragraph">
<p>Hundreds or even thousands of clients can be connected to the cluster.
By default, there are <code>core count * 20</code> threads on the server side that
handle all the requests, e.g., if the server has 4 cores, there will be 80 threads.</p>
</div>
<div class="paragraph">
<p>Imagine a trading application where all the trading data are stored and
managed in a Hazelcast cluster with tens of members. Swing/Web applications
at the traders' desktops can use clients to access and modify the data in the Hazelcast cluster.</p>
</div>
<div class="sect3">
<h4 id="_getting_started_with_java_client"><a class="anchor" href="#_getting_started_with_java_client"></a>18.1.1. Getting Started with Java Client</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You do not need to set a license key for your Java clients for which you want to
use Hazelcast IMDG Enterprise features. Hazelcast IMDG Enterprise license keys are
required only for members.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Simply include the <code>hazelcast.jar</code> dependency in your classpath to start using
the Hazelcast Java client. Once included, you can start using this client as if
you are using the Hazelcast API. The differences are discussed in the below sections.</p>
</div>
<div class="paragraph">
<p>If you prefer to use Maven, simply add the <code>hazelcast</code> dependency
to your <code>pom.xml</code>, which you may already have done to start using
Hazelcast IMDG:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;
    &lt;version&gt;4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can find Hazelcast Java client&#8217;s code samples <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/clients" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="sect4">
<h5 id="_client_api"><a class="anchor" href="#_client_api"></a>Client API</h5>
<div class="paragraph">
<p>The first step is the configuration. You can configure the Java client declaratively or
programmatically. We use the programmatic approach for this section, as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
clientConfig.setClusterName("dev");
clientConfig.getNetworkConfig().addAddress("10.90.0.1", "10.90.0.2:5702");</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#configuring-java-client">Configuring Java Client section</a> for more information.</p>
</div>
<div class="paragraph">
<p>The second step is initializing the <code>HazelcastInstance</code> to be connected to the cluster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>This client interface is your gateway to access all Hazelcast distributed objects.</strong></p>
</div>
<div class="paragraph">
<p>Let&#8217;s create a map and populate it with some data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;String, Customer&gt; mapCustomers = client.getMap("customers"); //creates the map proxy

mapCustomers.put("1", new Customer("Joe", "Smith"));
mapCustomers.put("2", new Customer("Ali", "Selam"));
mapCustomers.put("3", new Customer("Avi", "Noyan"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the final step, if and when you are done with your client, you can shut it down as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>client.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code line releases all the used resources and closes connections to the cluster.</p>
</div>
</div>
<div class="sect4">
<h5 id="_java_client_operation_modes"><a class="anchor" href="#_java_client_operation_modes"></a>Java Client Operation Modes</h5>
<div class="paragraph">
<p>The client has two operation modes because of the distributed nature of the data and cluster.</p>
</div>
<div class="paragraph">
<p><strong>Smart Client</strong>: In the smart mode, the clients connect to each cluster member.
Since each data partition uses the well known and consistent hashing algorithm,
each client can send an operation to the relevant cluster member,
which increases the overall throughput and efficiency. Smart mode is the default mode.</p>
</div>
<div class="paragraph">
<p><strong>Unisocket Client</strong>: For some cases, the clients can be required to connect to
a single member instead of to each member in the cluster. Firewalls, security, or
some custom networking issues can be the reason for these cases.</p>
</div>
<div class="paragraph">
<p>In the unisocket client mode, the clients only connect to one of the configured addresses.
This single member behaves as a gateway to the other members.
For any operation requested from the client, it redirects the request to the relevant member and
returns the response back to the client returned from that member.</p>
</div>
</div>
<div class="sect4">
<h5 id="_handling_failures"><a class="anchor" href="#_handling_failures"></a>Handling Failures</h5>
<div class="paragraph">
<p>There are two main failure cases and configurations you can perform to achieve proper behavior.</p>
</div>
<div class="paragraph">
<p><strong>Handling Client Connection Failure:</strong></p>
</div>
<div class="paragraph">
<p>While the client is trying to connect initially to one of the members in the
<code>ClientNetworkConfig.addressList</code>, all the members might be not available.
Instead of giving up, throwing an exception and stopping the client,
the client retries to connect as configured which is described in the
<a href="#configuring-client-connection-retry">Configuring Client Connection Retry section</a>.</p>
</div>
<div class="paragraph">
<p>The client executes each operation through the already established connection to the cluster.
If this connection(s) disconnects or drops, the client tries to reconnect as configured.</p>
</div>
<div class="paragraph">
<p><strong>Handling Retry-able Operation Failure:</strong></p>
</div>
<div class="paragraph">
<p>While sending the requests to related members, operations can fail due to various reasons.
Read-only operations are retried by default. If you want to enable retry for the other operations,
you can set the <code>redoOperation</code> to <code>true</code>. See the <a href="#enabling-redo-operation">Enabling Redo Operation section</a>.</p>
</div>
<div class="paragraph">
<p>You can set a timeout for retrying the operations sent to a member.
This can be provided by using the property <code>hazelcast.client.invocation.timeout.seconds</code> in <code>ClientProperties</code>.
The client retries an operation within this given period, of course, if it is a read-only operation or
you enabled the <code>redoOperation</code> as stated in the above paragraph.
This timeout value is important when there is a failure resulted by either of the following causes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Member throws an exception.</p>
</li>
<li>
<p>Connection between the client and member is closed.</p>
</li>
<li>
<p>Client&#8217;s heartbeat requests are timed out.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#client-system-properties">Client System Properties section</a>
for the description of the <code>hazelcast.client.invocation.timeout.seconds</code> property.</p>
</div>
<div class="paragraph">
<p>When any failure happens between a client and member
(such as an exception on the member side or connection issues), an operation is retried if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is certain that it has not run on the member yet</p>
</li>
<li>
<p>or if it is idempotent such as a read-only operation, i.e., retrying does not have a side effect.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If it is not certain whether the operation has run on the member,
then the non-idempotent operations are not retried.
However, as explained in the first paragraph of this section,
you can force all client operations to be retried (<code>redoOperation</code>)
when there is a failure between the client and member.
But in this case, you should know that some operations may run multiple times causing conflicts.
For example, assume that your client sent a <code>queue.offer</code> operation to the member and
then the connection is lost. Since there will be no respond for this operation,
you will not know whether it has run on the member or not. If you enabled <code>redoOperation</code>,
that <code>queue.offer</code> operation may rerun and this causes the same objects to be offered twice in the member&#8217;s queue.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_supported_distributed_data_structures"><a class="anchor" href="#_using_supported_distributed_data_structures"></a>Using Supported Distributed Data Structures</h5>
<div class="paragraph">
<p>Most of the Distributed Data Structures are supported by the Java client.
When you use clients in other languages, you should check for the exceptions.</p>
</div>
<div class="paragraph">
<p>As a general rule, you configure these data structures on the server side and
access them through a proxy on the client side.</p>
</div>
<div class="sect5">
<h6 id="_using_map_with_java_client"><a class="anchor" href="#_using_map_with_java_client"></a>Using Map with Java Client</h6>
<div class="paragraph">
<p>You can use any <a href="#map">Distributed Map</a> object with the client, as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Imap&lt;Integer, String&gt; map = client.getMap("myMap");

map.put(1, "John");
String value= map.get(1);
map.remove(1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Locality is ambiguous for the client, so <code>addLocalEntryListener</code> and
<code>localKeySet</code> are not supported. See the <a href="#map">Distributed Map section</a>
for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_using_multimap_with_java_client"><a class="anchor" href="#_using_multimap_with_java_client"></a>Using MultiMap with Java Client</h6>
<div class="paragraph">
<p>A MultiMap usage example is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MultiMap&lt;Integer, String&gt; multiMap = client.getMultiMap("myMultiMap");

multiMap.put(1,"John");
multiMap.put(1,"Mary");

Collection&lt;String&gt; values = multiMap.get(1);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>addLocalEntryListener</code>, <code>localKeySet</code> and <code>getLocalMultiMapStats</code> are not
supported because locality is ambiguous for the client.
See the <a href="#multimap">Distributed MultiMap section</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_using_queue_with_java_client"><a class="anchor" href="#_using_queue_with_java_client"></a>Using Queue with Java Client</h6>
<div class="paragraph">
<p>An example usage is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IQueue&lt;String&gt; myQueue = client.getQueue("theQueue");
myQueue.offer("John")</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getLocalQueueStats</code> is not supported because locality is ambiguous for the client.
See the <a href="#queue">Distributed Queue section</a> for more information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_using_topic_with_java_client"><a class="anchor" href="#_using_topic_with_java_client"></a>Using Topic with Java Client</h6>
<div class="paragraph">
<p><code>getLocalTopicStats</code> is not supported because locality is ambiguous for the client.</p>
</div>
</div>
<div class="sect5">
<h6 id="_using_other_supported_distributed_structures"><a class="anchor" href="#_using_other_supported_distributed_structures"></a>Using Other Supported Distributed Structures</h6>
<div class="paragraph">
<p>The distributed data structures listed below are also supported by the client.
Since their logic is the same in both the member side and client side, you can see
their sections as listed below.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#replicated-map">Replicated Map</a></p>
</li>
<li>
<p><a href="#list">List</a></p>
</li>
<li>
<p><a href="#set">Set</a></p>
</li>
<li>
<p><a href="#iatomiclong">IAtomicLong</a></p>
</li>
<li>
<p><a href="#iatomicreference">IAtomicReference</a></p>
</li>
<li>
<p><a href="#icountdownlatch">ICountDownLatch</a></p>
</li>
<li>
<p><a href="#isemaphore">ISemaphore</a></p>
</li>
<li>
<p><a href="#flakeidgenerator">FlakeIdGenerator</a></p>
</li>
<li>
<p><a href="#lock">Lock</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_using_client_services"><a class="anchor" href="#_using_client_services"></a>Using Client Services</h5>
<div class="paragraph">
<p>Hazelcast provides the services discussed below for some common functionalities on the client side.</p>
</div>
<div class="sect5">
<h6 id="_using_distributed_executor_service"><a class="anchor" href="#_using_distributed_executor_service"></a>Using Distributed Executor Service</h6>
<div class="paragraph">
<p>The distributed executor service is for distributed computing.
It can be used to execute tasks on the cluster on a designated partition or on all the partitions.
It can also be used to process entries. See the <a href="#executor-service">Distributed Executor Service section</a> for more information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IExecutorService executorService = client.getExecutorService("default");</code></pre>
</div>
</div>
<div class="paragraph">
<p>After getting an instance of <code>IExecutorService</code>, you can use the instance as
the interface with the one provided on the server side. See the
<a href="#distributed-computing">Distributed Computing chapter</a> for detailed usage.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This service is only supported by the Java client.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_listening_to_client_connection"><a class="anchor" href="#_listening_to_client_connection"></a>Listening to Client Connection</h6>
<div class="paragraph">
<p>If you need to track clients and you want to listen to their connection events,
you can use the <code>clientConnected</code> and <code>clientDisconnected</code> methods of the <code>ClientService</code> class.
This class must be run on the <strong>member</strong> side. The following is an example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        ClientConfig clientConfig = new ClientConfig();
        //clientConfig.setClusterName("dev");
        clientConfig.getNetworkConfig().addAddress("10.90.0.1", "10.90.0.2:5702");

        HazelcastInstance instance = Hazelcast.newHazelcastInstance();

        final ClientService clientService = instance.getClientService();

        clientService.addClientListener(new ClientListener() {
            @Override
            public void clientConnected(Client client) {
                //Handle client connected event
            }

            @Override
            public void clientDisconnected(Client client) {
                //Handle client disconnected event
            }
        });

        //this will trigger `clientConnected` event
        HazelcastInstance client = HazelcastClient.newHazelcastClient();

        final Collection&lt;Client&gt; connectedClients = clientService.getConnectedClients();

        //this will trigger `clientDisconnected` event
        client.shutdown();</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_finding_the_partition_of_a_key"><a class="anchor" href="#_finding_the_partition_of_a_key"></a>Finding the Partition of a Key</h6>
<div class="paragraph">
<p>You use partition service to find the partition of a key.
It returns all partitions. See the example code below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PartitionService partitionService = client.getPartitionService();

//partition of a key
Partition partition = partitionService.getPartition(key);

//all partitions
Set&lt;Partition&gt; partitions = partitionService.getPartitions();</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_handling_lifecycle"><a class="anchor" href="#_handling_lifecycle"></a>Handling Lifecycle</h6>
<div class="paragraph">
<p>Lifecycle handling performs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>checking if the client is running</p>
</li>
<li>
<p>shutting down the client gracefully</p>
</li>
<li>
<p>terminating the client ungracefully (forced shutdown)</p>
</li>
<li>
<p>adding/removing lifecycle listeners.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">LifecycleService lifecycleService = client.getLifecycleService();

if(lifecycleService.isRunning()){
    //it is running
}

//shutdown client gracefully
lifecycleService.shutdown();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_defining_client_labels"><a class="anchor" href="#_defining_client_labels"></a>Defining Client Labels</h5>
<div class="paragraph">
<p>You can define labels in your Java client, similar to the way it can
be done for the <a href="#defining-member-attributes">members</a>.
Through the client labels, you can assign special roles for your clients and
use these roles to perform some actions specific to those client connections.</p>
</div>
<div class="paragraph">
<p>You can also group your clients using the client labels.
These client groups can be blacklisted in the Hazelcast Management Center so that
they can be prevented from connecting to a cluster. See the related section in the
Hazelcast Management Center Reference Manual for more information on this topic.</p>
</div>
<div class="paragraph">
<p>Declaratively, you can define the client labels using the <code>client-labels</code>
configuration element. See the below example.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;instance-name&gt;barClient&lt;/instance-name&gt;
    &lt;client-labels&gt;
        &lt;label&gt;user&lt;/label&gt;
        &lt;label&gt;bar&lt;/label&gt;
    &lt;/client-labels&gt;
    ....
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  instance-name: barClient
  client-labels:
    - user
    - bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>The equivalent programmatic approach is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
clientConfig.setInstanceName("ExampleClientName");
clientConfig.addLabel("user");
clientConfig.addLabel("bar");

HazelcastClient.newHazelcastClient(clientConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/clients/client-labels" target="_blank" rel="noopener">code sample</a>
for the client labels to see them in action.</p>
</div>
</div>
<div class="sect4">
<h5 id="_client_listeners"><a class="anchor" href="#_client_listeners"></a>Client Listeners</h5>
<div class="paragraph">
<p>You can configure listeners to listen to various event types on the client side.
You can configure global events not relating to any distributed object through
<a href="#configuring-client-listeners">Client ListenerConfig</a>.
You should configure distributed object listeners like map entry listeners or
list item listeners through their proxies. See the related sections under
each distributed data structure in this Reference Manual.</p>
</div>
</div>
<div class="sect4">
<h5 id="_client_transactions"><a class="anchor" href="#_client_transactions"></a>Client Transactions</h5>
<div class="paragraph">
<p>Transactional distributed objects are supported on the client side.
See the <a href="#transactions">Transactions chapter</a> on how to use them.</p>
</div>
</div>
<div class="sect4">
<h5 id="_async_start_and_reconnect_modes"><a class="anchor" href="#_async_start_and_reconnect_modes"></a>Async Start and Reconnect Modes</h5>
<div class="paragraph">
<p>Java client can be configured to connect to a cluster in an async manner during the
client start and reconnecting after a cluster disconnect.
Both of these options are configured via <code>ClientConnectionStrategyConfig</code>.</p>
</div>
<div class="paragraph">
<p>Async client start is configured by setting the configuration element <code>async-start</code> to <code>true</code>.
This configuration changes the behavior of <code>HazelcastClient.newHazelcastClient()</code> call.
It returns a client instance without waiting to establish a cluster connection.
Until the client connects to cluster, it throws <code>HazelcastClientOfflineException</code>
on any network dependent operations hence they won&#8217;t block.
If you want to check or wait the client to complete its cluster connection,
you can use the built-in lifecycle listener:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientStateListener clientStateListener = new ClientStateListener(clientConfig);
HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);

//Client started but may not be connected to cluster yet.

//check connection status
clientStateListener.isConnected();

//blocks until client completes connect to cluster
if (clientStateListener.awaitConnected()) {
	//connected successfully
} else {
	//client failed to connect to cluster
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Java client can also be configured to specify
how it reconnects after a cluster disconnection.
The following are the options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A client can reject to reconnect to the cluster and trigger the client shutdown process.</p>
</li>
<li>
<p>Client can open a connection to the cluster by blocking all waiting invocations.</p>
</li>
<li>
<p>Client can open a connection to the cluster without blocking the waiting invocations.
All invocations receive <code>HazelcastClientOfflineException</code> during the establishment of cluster connection.
If cluster connection is failed to connect, then client shutdown is triggered.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#java-client-connection-strategy">[java-client-connection-strategy]</a> section to learn how to configure
these.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_java_client"><a class="anchor" href="#_configuring_java_client"></a>18.1.2. Configuring Java Client</h4>
<div class="paragraph">
<p>You can configure Hazelcast Java Client declaratively (XML), programmatically (API), or
using client system properties.</p>
</div>
<div class="paragraph">
<p>For declarative configuration, the Hazelcast client looks at
the following places for the client configuration file:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>System property</strong>: The client first checks if <code>hazelcast.client.config</code> system property is
set to a file path, e.g., <code>-Dhazelcast.client.config=C:/myhazelcast.xml</code>.</p>
</li>
<li>
<p><strong>Classpath</strong>: If config file is not set as a system property,
the client checks the classpath for <code>hazelcast-client.xml</code> file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the client does not find any configuration file, it starts with the default configuration
(<code>hazelcast-client-default.xml</code>) located in the <code>hazelcast.jar</code> library.
Before configuring the client, please try to work with the default configuration to see if
it works for you. The default should be just fine for most users.
If not, then consider custom configuration for your environment.</p>
</div>
<div class="paragraph">
<p>If you want to specify your own configuration file to create a <code>Config</code> object,
the Hazelcast client supports the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Config cfg = new XmlClientConfigBuilder(xmlFileName).build();</code></p>
</li>
<li>
<p><code>Config cfg = new XmlClientConfigBuilder(inputStream).build();</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For programmatic configuration of the Hazelcast Java Client, just instantiate a <code>ClientConfig</code> object and configure the desired aspects. An example is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
clientConfig.setClusterName("dev");
clientConfig.setLoadBalancer(yourLoadBalancer);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_client_network"><a class="anchor" href="#_client_network"></a>Client Network</h5>
<div class="paragraph">
<p>All network related configuration of Hazelcast Java Client is performed via the
<code>network</code> element in the declarative configuration file, or in the class
<code>ClientNetworkConfig</code> when using programmatic configuration.
Let&#8217;s first give the examples for these two approaches.
Then we will look at its sub-elements and attributes.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="paragraph">
<p>Here is an example declarative configuration of <code>network</code> for Java Client,
which includes all the parent configuration elements.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;cluster-members&gt;
            &lt;address&gt;127.0.0.1&lt;/address&gt;
            &lt;address&gt;127.0.0.2&lt;/address&gt;
        &lt;/cluster-members&gt;
        &lt;outbound-ports&gt;
            &lt;ports&gt;34600&lt;/ports&gt;
            &lt;ports&gt;34700-34710&lt;/ports&gt;
        &lt;/outbound-ports&gt;
        &lt;smart-routing&gt;true&lt;/smart-routing&gt;
        &lt;redo-operation&gt;true&lt;/redo-operation&gt;
        &lt;connection-timeout&gt;60000&lt;/connection-timeout&gt;
        &lt;socket-options&gt;
            ...
        &lt;/socket-options&gt;
        &lt;socket-interceptor enabled="true"&gt;
            ...
        &lt;/socket-interceptor&gt;

        &lt;ssl enabled="false"&gt;
            ...
        &lt;/ssl&gt;
        &lt;aws enabled="true" connection-timeout-seconds="11"&gt;
            ...
        &lt;/aws&gt;
        &lt;gcp enabled="false"&gt;
            ...
        &lt;/gcp&gt;
        &lt;azure enabled="false"&gt;
            ...
        &lt;/azure&gt;
        &lt;kubernetes enabled="false"&gt;
            ...
        &lt;/kubernetes&gt;
        &lt;eureka enabled="false"&gt;
            ...
        &lt;/eureka&gt;
        &lt;icmp-ping enabled="false"&gt;
            ...
        &lt;/icmp-ping&gt;
        &lt;hazelcast-cloud enabled="false"&gt;
            &lt;discovery-token&gt;EXAMPLE_TOKEN&lt;/discovery-token&gt;
        &lt;/hazelcast-cloud&gt;
        &lt;discovery-strategies&gt;
            &lt;node-filter class="DummyFilterClass" /&gt;
            &lt;discovery-strategy class="DummyDiscoveryStrategy1" enabled="true"&gt;
                &lt;properties&gt;
                    &lt;property name="key-string"&gt;foo&lt;/property&gt;
                    &lt;property name="key-int"&gt;123&lt;/property&gt;
                    &lt;property name="key-boolean"&gt;true&lt;/property&gt;
                &lt;/properties&gt;
            &lt;/discovery-strategy&gt;
        &lt;/discovery-strategies&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">network:
    cluster-members:
      - 127.0.0.1
      - 127.0.0.2
    outbound-ports:
      - 34600
      - 34700-34710
    smart-routing: true
    redo-operation: true
    connection-timeout: 60000
    socket-options:
      ...
    socket-interceptor:
      ...
    ssl:
      enabled: false
      ...
    aws:
      enabled: true
      connection-timeout-seconds: 11
      ...
    gcp:
      enabled: false
      ...
    azure:
      enabled: false
      ...
    kubernetes:
      enabled: false
      ...
    eureka:
      enabled: false
      ...
    icmp-ping:
      enabled: false
      ...
    hazelcast-cloud:
      enabled: false
      discovery-token: EXAMPLE_TOKEN
    discovery-strategies:
      node-filter:
        class: DummyFilterClass
      discovery-strategies:
        - class: DummyDiscoveryStrategy1
          enabled: true
          properties:
            key-string: foo
            key-int: 123
            key-boolean: true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="paragraph">
<p>Here is an example of configuring network for Java Client programmatically.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        ClientConfig clientConfig = new ClientConfig();
        clientConfig.getConnectionStrategyConfig().getConnectionRetryConfig().setMaxBackoffMillis(5000);
        ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
        networkConfig.addAddress("10.1.1.21", "10.1.1.22:5703")
                .setSmartRouting(true)
                .addOutboundPortDefinition("34700-34710")
                .setRedoOperation(true)
                .setConnectionTimeout(5000);

        AwsConfig clientAwsConfig = new AwsConfig();
        clientAwsConfig.setProperty("access-key", "my-access-key")
                .setProperty("secret-key", "my-secret-key")
                .setProperty("region", "us-west-1")
                .setProperty("host-header", "ec2.amazonaws.com")
                .setProperty("security-group-name", "&gt;hazelcast-sg")
                .setProperty("tag-key", "type")
                .setProperty("tag-value", "hz-members")
                .setProperty("iam-role", "s3access")
                .setEnabled(true);
        clientConfig.getNetworkConfig().setAwsConfig(clientAwsConfig);
        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_configuring_backup_acknowledgment"><a class="anchor" href="#_configuring_backup_acknowledgment"></a>Configuring Backup Acknowledgment</h6>
<div class="paragraph">
<p>When an operation with sync backup is sent by a client to the Hazelcast member(s),
the acknowledgment of the operation&#8217;s backup is sent to the client by the backup
replica member(s). This improves the performance of the client operations.</p>
</div>
<div class="paragraph">
<p>By default, backup acknowledgement to the client is enabled for smart clients
(unisocket clients do not support it).</p>
</div>
<div class="paragraph">
<p>Here is an example of configuring the backup acknowledgement for Java Client declaratively.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client ... &gt;
       &lt;backup-ack-to-client-enabled&gt;false&lt;/backup-ack-to-client-enabled&gt;
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  backup-ack-to-client: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is its equivalent programmatical configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">clientConfig.setBackupAckToClientEnabled(boolean enabled)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also fine tune this feature using the following system properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.client.operation.backup.timeout.millis</code>: If an operation has
backups, this property specifies how long (in milliseconds) the invocation waits
for acks from the backup replicas. If acks are not received from some
of the backups, there will not be any rollback on the other successful replicas.
Its default value is <code>5000</code> milliseconds.</p>
</li>
<li>
<p><code>hazelcast.client.operation.fail.on.indeterminate.state</code>: When it is <code>true</code>,
if an operation has sync backups and acks are not received from backup replicas
in time, or the member which owns primary replica of the target partition leaves
the cluster, then the invocation fails. However, even if the invocation fails,
there will not be any rollback on other successful replicas. It is default
value is <code>false</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_configuring_address_list"><a class="anchor" href="#_configuring_address_list"></a>Configuring Address List</h6>
<div class="paragraph">
<p>Address List is the initial list of cluster addresses to which the client will connect.
The client uses this list to find an alive member. Although it may be enough to give
only one address of a member in the cluster (since all members communicate with each other),
it is recommended that you give the addresses for all the members.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;cluster-members&gt;
            &lt;address&gt;10.1.1.21&lt;/address&gt;
            &lt;address&gt;10.1.1.22:5703&lt;/address&gt;
        &lt;/cluster-members&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    cluster-members:
      - 10.1.1.21
      - 10.1.1.22:5703</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
networkConfig.addAddress("10.1.1.21", "10.1.1.22:5703");</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the port part is omitted, then 5701, 5702 and 5703 are tried in a random order.</p>
</div>
<div class="paragraph">
<p>You can provide multiple addresses with ports provided or not, as seen above.
The provided list is shuffled and tried in random order.
Its default value is <strong>localhost</strong>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you have multiple members on a single machine and you are using
<a href="#java-client-operation-modes">unisocket clients</a>, we recommend you to set explicit
<a href="#port">ports</a> for each member. Then you should provide those ports in your client configuration
when you give the member addresses (using the <code>address</code> configuration element or
<code>addAddress</code> method as exemplified above). This provides faster connections between clients and members. Otherwise,
all the load coming from your clients may go through a single member.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_setting_outbound_ports"><a class="anchor" href="#_setting_outbound_ports"></a>Setting Outbound Ports</h6>
<div class="paragraph">
<p>You may want to restrict outbound ports to be used by Hazelcast-enabled applications.
To fulfill this requirement, you can configure Hazelcast Java client to use only defined outbound ports.
The following are example configurations.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;outbound-ports&gt;
            &lt;!-- ports between 34700 and 34710 --&gt;
            &lt;ports&gt;34700-34710&lt;/ports&gt;
            &lt;!-- comma separated ports --&gt;
            &lt;ports&gt;34700,34701,34702,34703&lt;/ports&gt;
            &lt;ports&gt;34700,34705-34710&lt;/ports&gt;
        &lt;/outbound-ports&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    outbound-ports:
      - 34700-34710
      - 34700,34701,34702,34703
      - 34700,34705-34710</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
NetworkConfig networkConfig = config.getNetworkConfig();
// ports between 34700 and 34710
networkConfig.addOutboundPortDefinition("34700-34710");
// comma separated ports
networkConfig.addOutboundPortDefinition("34700,34701,34702,34703");
networkConfig.addOutboundPort(34705);
...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can use port ranges and/or comma separated ports.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As shown in the programmatic configuration, you use the method <code>addOutboundPort</code> to
add only one port. If you need to add a group of ports, then use the method <code>addOutboundPortDefinition</code>.</p>
</div>
<div class="paragraph">
<p>In the declarative configuration, the element <code>ports</code> can be used for
both single and multiple port definitions.</p>
</div>
</div>
<div class="sect5">
<h6 id="_setting_smart_routing"><a class="anchor" href="#_setting_smart_routing"></a>Setting Smart Routing</h6>
<div class="paragraph">
<p>Smart routing defines whether the client operation mode is smart or unisocket.
See <a href="#java-client-operation-modes">Java Client Operation Modes</a> to learn about these modes.</p>
</div>
<div class="paragraph">
<p>The following are example configurations.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;smart-routing&gt;true&lt;/smart-routing&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    smart-routing: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
networkConfig().setSmartRouting(true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Its default value is <code>true</code> (smart client mode).</p>
</div>
<div class="paragraph">
<p>Note that you need to disable smart routing (<code>false</code>) for the clients which
want to use temporary permissions defined in a member.
See the <a href="#handling-permissions-when-a-new-member-joins">Handling Permissions section</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_enabling_redo_operation"><a class="anchor" href="#_enabling_redo_operation"></a>Enabling Redo Operation</h6>
<div class="paragraph">
<p>It enables/disables redo-able operations as described in
<a href="#handling-failures">Handling Retry-able Operation Failure</a>.
The following are the example configurations.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;redo-operation&gt;true&lt;/redo-operation&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    redo-operation: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
networkConfig().setRedoOperation(true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Its default value is <code>false</code> (disabled).</p>
</div>
</div>
<div class="sect5">
<h6 id="_setting_connection_timeout"><a class="anchor" href="#_setting_connection_timeout"></a>Setting Connection Timeout</h6>
<div class="paragraph">
<p>Connection timeout is the timeout value in milliseconds for members to
accept client connection requests. The following are the example configurations.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;connection-timeout&gt;5000&lt;/connection-timeout&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    connection-timeout: 5000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
clientConfig.getNetworkConfig().setConnectionTimeout(5000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Its default value is <strong>5000</strong> milliseconds.</p>
</div>
</div>
<div class="sect5">
<h6 id="_setting_a_socket_interceptor"><a class="anchor" href="#_setting_a_socket_interceptor"></a>Setting a Socket Interceptor</h6>
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise</strong></p>
</div>
<div class="paragraph">
<p>Following is a client configuration to set a socket intercepter.
Any class implementing <code>com.hazelcast.nio.SocketInterceptor</code> is a socket interceptor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SocketInterceptor {
    void init(Properties properties);
    void onConnect(Socket connectedSocket) throws IOException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SocketInterceptor</code> has two steps. First, it is initialized by the configured properties.
Second, it is informed just after the socket is connected using the <code>onConnect</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SocketInterceptorConfig socketInterceptorConfig = clientConfig
               .getNetworkConfig().getSocketInterceptorConfig();

MyClientSocketInterceptor myClientSocketInterceptor = new MyClientSocketInterceptor();

socketInterceptorConfig.setEnabled(true);
socketInterceptorConfig.setImplementation(myClientSocketInterceptor);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to configure the socket interceptor with a class name instead of an instance,
see the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SocketInterceptorConfig socketInterceptorConfig = clientConfig
            .getNetworkConfig().getSocketInterceptorConfig();

socketInterceptorConfig.setEnabled(true);

//These properties are provided to interceptor during init
socketInterceptorConfig.setProperty("kerberos-host","kerb-host-name");
socketInterceptorConfig.setProperty("kerberos-config-file","kerb.conf");

socketInterceptorConfig.setClassName(MyClientSocketInterceptor.class.getName());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#socket-interceptor">Socket Interceptor section</a> for more information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_configuring_network_socket_options"><a class="anchor" href="#_configuring_network_socket_options"></a>Configuring Network Socket Options</h6>
<div class="paragraph">
<p>You can configure the network socket options using <code>SocketOptions</code>. It has the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>socketOptions.setKeepAlive(x)</code>: Enables/disables the <strong>SO_KEEPALIVE</strong> socket option.
Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>socketOptions.setTcpNoDelay(x)</code>: Enables/disables the <strong>TCP_NODELAY</strong> socket option.
Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>socketOptions.setReuseAddress(x)</code>: Enables/disables the <strong>SO_REUSEADDR</strong> socket option.
Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>socketOptions.setLingerSeconds(x)</code>: Enables/disables <strong>SO_LINGER</strong> with the specified linger time in seconds.
Its default value is <code>3</code>.</p>
</li>
<li>
<p><code>socketOptions.setBufferSize(x)</code>: Sets the <strong>SO_SNDBUF</strong> and <strong>SO_RCVBUF</strong> options to the specified value in KB for this Socket.
Its default value is <code>32</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SocketOptions socketOptions = clientConfig.getNetworkConfig().getSocketOptions();
socketOptions.setBufferSize(32)
             .setKeepAlive(true)
             .setTcpNoDelay(true)
             .setReuseAddress(true)
             .setLingerSeconds(3);</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_enabling_client_tlsssl"><a class="anchor" href="#_enabling_client_tlsssl"></a>Enabling Client TLS/SSL</h6>
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise</strong></p>
</div>
<div class="paragraph">
<p>You can use TLS/SSL to secure the connection between the client and the members.
If you want TLS/SSL enabled for the client-cluster connection, you should set <code>SSLConfig</code>.
Once set, the connection (socket) is established out of an TLS/SSL factory defined either by
a factory class name or factory implementation. See the <a href="#tlsssl">TLS/SSL section</a>.</p>
</div>
<div class="paragraph">
<p>As explained in the <a href="#tlsssl">TLS/SSL section</a>, Hazelcast members have keyStores used to
identify themselves (to other members) and Hazelcast clients have trustStore used to
define which members they can trust. The clients also have their keyStores and
members have their trustStores so that the members can
know which clients they can trust: see the <a href="#mutual-authentication">Mutual Authentication section</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_configuring_hazelcast_cloud"><a class="anchor" href="#_configuring_hazelcast_cloud"></a>Configuring Hazelcast Cloud</h6>
<div class="paragraph">
<p>You can connect your Java client to a Hazelcast cluster which is hosted on
<a href="https://hazelcast.com/products/cloud/" target="_blank" rel="noopener">Hazelcast Cloud</a>.
For this, you simply enable the Hazelcast Cloud and specify the cluster&#8217;s discovery token provided by
Hazelcast Cloud while creating the cluster; this allows the Hazelcast cluster to discover your clients.
See the following example configurations.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;ssl enabled="true"/&gt;
        &lt;hazelcast-cloud enabled="true"&gt;
            &lt;discovery-token&gt;YOUR_TOKEN&lt;/discovery-token&gt;
        &lt;/hazelcast-cloud&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    ssl:
      enabled: true
    hazelcast-cloud:
      enabled: true
      discovery-token: YOUR_TOKEN</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig config = new ClientConfig();
ClientNetworkConfig networkConfig = config.getNetworkConfig();
networkConfig.getCloudConfig().setDiscoveryToken("TOKEN").setEnabled(true);
networkConfig.setSSLConfig(new SSLConfig().setEnabled(true));
HazelcastInstance client = HazelcastClient.newHazelcastClient(config);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast Cloud is disabled for the Java client, by default (<code>enabled</code> attribute is <code>false</code>).</p>
</div>
<div class="paragraph">
<p>See this Hazelcast Cloud <a href="https://hazelcast.com/products/cloud/" target="_blank" rel="noopener">web page</a>
for more information on Hazelcast Cloud.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since this is a REST based discovery, you need to enable the REST listener service.
See the <a href="#using-the-rest-endpoint-groups">Using the REST Endpoint Groups section</a> on how to enable REST endpoints.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is advised to enable certificate revocation status JRE-wide, for security reasons.
You need to set the following Java system properties to <code>true</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.sun.net.ssl.checkRevocation</code></p>
</li>
<li>
<p><code>com.sun.security.enableCRLDP</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And you need to set the Java security property as follows:</p>
</div>
<div class="paragraph">
<p><code>Security.setProperty("ocsp.enable", "true")</code></p>
</div>
<div class="paragraph">
<p>You can find more details on the related security topics
<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html#CERTPATH" target="_blank" rel="noopener">here</a> and
<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/certpath/CertPathProgGuide.html#AppC" target="_blank" rel="noopener">here</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_configuring_client_for_aws"><a class="anchor" href="#_configuring_client_for_aws"></a>Configuring Client for AWS</h6>
<div class="paragraph">
<p>The example declarative and programmatic configurations below show
how to configure a Java client for connecting to a Hazelcast cluster in AWS.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;aws enabled="true"&gt;
            &lt;use-public-ip&gt;true&lt;/use-public-ip&gt;
            &lt;access-key&gt;my-access-key&lt;/access-key&gt;
            &lt;secret-key&gt;my-secret-key&lt;/secret-key&gt;
            &lt;region&gt;us-west-1&lt;/region&gt;
            &lt;host-header&gt;ec2.amazonaws.com&lt;/host-header&gt;
            &lt;security-group-name&gt;hazelcast-sg&lt;/security-group-name&gt;
            &lt;tag-key&gt;type&lt;/tag-key&gt;
            &lt;tag-value&gt;hz-members&lt;/tag-value&gt;
        &lt;/aws&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    aws:
      enabled: true
      use-public-ip: true
      access-key: my-access-key
      secret-key: my-secret-key
      region: us-west-1
      host-header: ec2.amazonaws.com
      security-group-name: hazelcast-sg
      tag-key: type
      tag-value: hz-members</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        ClientConfig clientConfig = new ClientConfig();
        AwsConfig clientAwsConfig = new AwsConfig();
        clientAwsConfig.setProperty("access-key", "my-access-key")
                .setProperty("secret-key", "my-secret-key")
                .setProperty("region", "us-west-1")
                .setProperty("host-header", "ec2.amazonaws.com")
                .setProperty("security-group-name", "&gt;hazelcast-sg")
                .setProperty("tag-key", "type")
                .setProperty("tag-value", "hz-members")
                .setProperty("iam-role", "s3access")
                .setEnabled(true);
        clientConfig.getNetworkConfig().setAwsConfig(clientAwsConfig);
        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#aws-element">aws element section</a> for the descriptions of
the above AWS configuration elements except <code>use-public-ip</code>.</p>
</div>
<div class="paragraph">
<p>If the <code>use-public-ip</code> element is set to <code>true</code>, the private addresses of cluster members
are always converted to public addresses. Also, the client uses public addresses to
connect to the members. In order to use private addresses, set the <code>use-public-ip</code> parameter to <code>false</code>.
Also note that, when connecting outside from AWS, setting the <code>use-public-ip</code> parameter to <code>false</code> causes
the client to not be able to reach the members.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_client_load_balancer"><a class="anchor" href="#_configuring_client_load_balancer"></a>Configuring Client Load Balancer</h5>
<div class="paragraph">
<p><code>LoadBalancer</code> allows you to send operations to one of a number of endpoints (Members).
Its main purpose is to determine the next <code>Member</code> if queried.
It is up to your implementation to use different load balancing policies.
You should implement the interface <code>com.hazelcast.client.LoadBalancer</code> for that purpose.</p>
</div>
<div class="paragraph">
<p>If it is a <a href="#java-client-operation-modes">smart client</a>, only the operations that are not
key-based are routed to the endpoint that is returned by the <code>LoadBalancer</code>.
If it is not a smart client, <code>LoadBalancer</code> is ignored.</p>
</div>
<div class="paragraph">
<p>The following are example configurations.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;load-balancer type=random/&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  load-balancer:
    type: random</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
clientConfig.setLoadBalancer(yourLoadBalancer);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_client_listeners"><a class="anchor" href="#_configuring_client_listeners"></a>Configuring Client Listeners</h5>
<div class="paragraph">
<p>You can configure global event listeners using <code>ListenerConfig</code> as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
ListenerConfig listenerConfig = new ListenerConfig(LifecycleListenerImpl);
clientConfig.addListenerConfig(listenerConfig);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
ListenerConfig listenerConfig = new ListenerConfig("com.hazelcast.example.MembershipListenerImpl");
clientConfig.addListenerConfig(listenerConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add the following types of event listeners:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LifecycleListener</p>
</li>
<li>
<p>MembershipListener</p>
</li>
<li>
<p>DistributedObjectListener</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_client_near_cache"><a class="anchor" href="#_configuring_client_near_cache"></a>Configuring Client Near Cache</h5>
<div class="paragraph">
<p>The Hazelcast distributed map supports a local Near Cache for remotely stored entries to
increase the performance of local read operations. Since the client always requests data from
the cluster members, it can be helpful in some use cases to configure a Near Cache on the client side.
See the <a href="#near-cache">Near Cache section</a> for a detailed explanation of the Near Cache feature and its configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="client-cluster-configuration"><a class="anchor" href="#client-cluster-configuration"></a>Configuring Client Cluster</h5>
<div class="paragraph">
<p>Clients should provide a cluster name in order to connect to the cluster.
You can configure it using <code>ClientConfig</code>, as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>clientConfig.setClusterName("dev");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="client-security-configuration"><a class="anchor" href="#client-security-configuration"></a>Configuring Client Security</h5>
<div class="paragraph">
<p>In the cases where the security established with <code>Config</code> is not enough and
you want your clients connecting securely to the cluster, you can use <code>ClientSecurityConfig</code>.
This configuration has a <code>credentials</code> parameter to set the IP address and UID.
See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/client/config/ClientSecurityConfig.html" target="_blank" rel="noopener">ClientSecurityConfig Javadoc</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="client-serialization-configuration"><a class="anchor" href="#client-serialization-configuration"></a>Client Serialization Configuration</h5>
<div class="paragraph">
<p>For the client side serialization, use the Hazelcast configuration.
See the <a href="#serialization">Serialization chapter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="classloader"><a class="anchor" href="#classloader"></a>Configuring ClassLoader</h5>
<div class="paragraph">
<p>You can configure a custom <code>classLoader</code>.
It is used by the serialization service and to load any class configured in configuration, such as
event listeners or ProxyFactories.</p>
</div>
</div>
<div class="sect4">
<h5 id="configuring-reliable-topic-at-client-side"><a class="anchor" href="#configuring-reliable-topic-at-client-side"></a>Configuring Reliable Topic on the Client Side</h5>
<div class="paragraph">
<p>Normally when a client uses a Hazelcast data structure,
that structure is configured on the member side and the client makes use of that configuration.
For the Reliable Topic structure, this is not the case; since it is backed by Ringbuffer,
you should configure it on the client side. The class used for this configuration is <code>ClientReliableTopicConfig</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example programmatic configuration snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        RingbufferConfig ringbufferConfig = new RingbufferConfig("default");
        ringbufferConfig.setCapacity(10000000)
                .setTimeToLiveSeconds(5);
        config.addRingBufferConfig(ringbufferConfig);

        ClientConfig clientConfig = new ClientConfig();
        ClientReliableTopicConfig topicConfig = new ClientReliableTopicConfig("default");
        topicConfig.setTopicOverloadPolicy( TopicOverloadPolicy.BLOCK )
                            .setReadBatchSize( 10 );
        clientConfig.addReliableTopicConfig(topicConfig);

        HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);
        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
        ITopic topic = client.getReliableTopic(topicConfig.getName());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, when you create a Reliable Topic structure on your client, a Ringbuffer
(with the same name as the Reliable Topic) is automatically created on the member side,
with its default configuration. See the <a href="#ringbuffer">Configuring Ringbuffer section</a> for the defaults.
You can edit that configuration according to your needs.</p>
</div>
<div class="paragraph">
<p>You can configure a Reliable Topic structure on the client side also declaratively.
The following is the declarative configuration equivalent to the above example:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;ringbuffer name="default"&gt;
        &lt;capacity&gt;10000000&lt;/capacity&gt;
        &lt;time-to-live-seconds&gt;5&lt;/time-to-live-seconds&gt;
    &lt;/ringbuffer&gt;
    &lt;reliable-topic name="default"&gt;
        &lt;topic-overload-policy&gt;BLOCK&lt;/topic-overload-policy&gt;
        &lt;read-batch-size&gt;10&lt;/read-batch-size&gt;
    &lt;/reliable-topic&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  ringbuffer:
    default:
      capacity: 10000000
      time-to-live-seconds: 5
  reliable-topic:
    default:
      topic-overload-policy: BLOCK
      read-batch-size: 10</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_java_client_connection_strategy"><a class="anchor" href="#_java_client_connection_strategy"></a>18.1.3. Java Client Connection Strategy</h4>
<div class="paragraph">
<p>You can configure the client&#8217;s starting mode as async or sync using
the configuration element <code>async-start</code>. When it is set to <code>true</code> (async),
Hazelcast creates the client without waiting a connection to the cluster.
In this case, the client instance throws an exception until it connects to the cluster.
If it is <code>false</code>, the client is not created until the cluster is ready to use clients and
a connection with the cluster is established. Its default value is <code>false</code> (sync)</p>
</div>
<div class="paragraph">
<p>You can also configure how the client reconnects to the cluster after a disconnection.
This is configured using the configuration element <code>reconnect-mode</code>; it has three options
(<code>OFF</code>, <code>ON</code> or <code>ASYNC</code>). The option <code>OFF</code> disables the reconnection.
<code>ON</code> enables reconnection in a blocking manner where all the waiting invocations are blocked until
a cluster connection is established or failed.
The option <code>ASYNC</code> enables reconnection in a non-blocking manner where
all the waiting invocations receive a <code>HazelcastClientOfflineException</code>.
Its default value is <code>ON</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you have <code>ASYNC</code>  as the <code>reconnect-mode</code> and defined a Near Cache for your client,
the client functions <a id="non-stop-client"></a>without interruptions/downtime by communicating the data from its Near Cache,
provided that there is non-expired data in it. See <a href="#configuring-client-near-cache">here</a> to
learn how you can add a Near Cache to your client.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The example declarative and programmatic configurations below show how to configure
a Java client&#8217;s starting and reconnecting modes.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;connection-strategy async-start="true" reconnect-mode="ASYNC" /&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  connection-strategy:
    async-start: true
    reconnect-mode: ASYNC</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
clientConfig.getConnectionStrategyConfig()
            .setAsyncStart(true)
            .setReconnectMode(ClientConnectionStrategyConfig.ReconnectMode.ASYNC);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_client_connection_retry"><a class="anchor" href="#_configuring_client_connection_retry"></a>Configuring Client Connection Retry</h5>
<div class="paragraph">
<p>When client is disconnected from the cluster, it searches for new connections
to reconnect. You can configure the frequency of the reconnection attempts and
client shutdown behavior using <code>ConnectionRetryConfig</code> (programmatical approach)/
<code>connection-retry</code> (declarative approach).</p>
</div>
<div class="paragraph">
<p>Below are the example configurations for each.</p>
</div>
<div class="paragraph">
<p>Declarative Configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;connection-strategy async-start="false" reconnect-mode="ON"&gt;
        &lt;connection-retry&gt;
            &lt;initial-backoff-millis&gt;1000&lt;/initial-backoff-millis&gt;
            &lt;max-backoff-millis&gt;60000&lt;/max-backoff-millis&gt;
            &lt;multiplier&gt;2&lt;/multiplier&gt;
            &lt;cluster-connect-timeout-millis&gt;50000&lt;/cluster-connect-timeout-millis&gt;
            &lt;jitter&gt;0.2&lt;/jitter&gt;
        &lt;/connection-retry&gt;
    &lt;/connection-strategy&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  connection-strategy:
    async-start: false
    reconnect-mode: ON
    connection-retry:
      initial-backoff-millis: 1000
      max-backoff-millis: 60000
      multiplier: 2
      cluster-connect-timeout-millis: 50000
      jitter: 0.2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programmatic Configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig config = new ClientConfig();
ClientConnectionStrategyConfig connectionStrategyConfig = config.getConnectionStrategyConfig();
ConnectionRetryConfig connectionRetryConfig = connectionStrategyConfig.getConnectionRetryConfig();
connectionRetryConfig.setInitialBackoffMillis(1000)
                     .setMaxBackoffMillis(60000)
                     .setMultiplier(2)
                     .setClusterConnectTimeoutMillis(50000)
                     .setJitter(0.2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are configuration element descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>initial-backoff-millis</code>: Specifies how long to wait (backoff), in milliseconds, after the first failure before retrying.
Its default value is 1000 ms.</p>
</li>
<li>
<p><code>max-backoff-millis</code>: Specifies the upper limit for the backoff in milliseconds.
Its default value is 30000 ms.</p>
</li>
<li>
<p><code>multiplier</code>: Factor to multiply the backoff after a failed retry.
Its default value is 1.</p>
</li>
<li>
<p><code>cluster-connect-timeout-millis</code>: Timeout value in milliseconds for the client to give up to connect to the current cluster
Its default value is 20000.</p>
</li>
<li>
<p><code>jitter</code>: Specifies by how much to randomize backoffs. Its default value is 0.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A pseudo-code is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain"> begin_time = getCurrentTime()
 current_backoff_millis = INITIAL_BACKOFF_MILLIS
 while (TryConnect(connectionTimeout)) != SUCCESS) {
    if (getCurrentTime() - begin_time &gt;= CLUSTER_CONNECT_TIMEOUT_MILLIS) {
         //Give up to connecting to the current cluster and switch to another if exists.
    }
    Sleep(current_backoff_millis + UniformRandom(-JITTER * current_backoff_millis, JITTER * current_backoff_millis))
    current_backoff = Min(current_backoff_millis * MULTIPLIER, MAX_BACKOFF_MILLIS)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, <code>TryConnect</code> above tries to connect to any member that the client knows,
and for each connection we have a connection timeout; see the
<a href="#setting-connection-timeout">Setting Connection Timeout section</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_blue_green_deployment_and_disaster_recovery"><a class="anchor" href="#_blue_green_deployment_and_disaster_recovery"></a>18.1.4. Blue-Green Deployment and Disaster Recovery</h4>
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast provides disaster recovery for the client-cluster connections and
can use the well-known blue-green mechanism, so that a Java client is automatically
diverted to another cluster on demand or when the intended cluster becomes unavailable.</p>
</div>
<div class="paragraph">
<p>Using the blue-green system, the clients can connect to another cluster automatically
when they are blacklisted from their currently connected cluster.
See the <a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#changing-cluster-client-filtering" target="_blank" rel="noopener">Hazelcast Management Center Reference Manual</a> for information on blacklisting the clients.</p>
</div>
<div class="sect4">
<h5 id="_blue_green_mechanism"><a class="anchor" href="#_blue_green_mechanism"></a>Blue-Green Mechanism</h5>
<div class="paragraph">
<p>You can make your clients connect to another cluster by blacklisting them
in a cluster and using the blue-green mechanism. This is basically having two alive clusters,
one of which is active (blue) and the other one is idle (green).</p>
</div>
<div class="paragraph">
<p>When you blacklist a client in a cluster, the client which is disconnected from the cluster
due to this blacklisting, first tries to connect to another member of the same cluster.
This is because the client is not aware if this is a blacklisting or a normal disconnection.</p>
</div>
<div class="paragraph">
<p>The client&#8217;s behavior after this disconnection depends on its
<a href="#java-client-connection-strategy"><code>reconnect-mode</code></a>.
The following are the options when you are using the blue-green mechanism, i.e.,
you have alternative clusters for your clients to connect:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>reconnect-mode</code> is set to <code>ON</code>, the client changes the cluster and
blocks the invocations while doing so.</p>
</li>
<li>
<p>If <code>reconnect-mode</code> is set to <code>ASYNC</code>, the client changes the cluster
in the background and throws <code>ClientOfflineException</code> while doing so.</p>
</li>
<li>
<p>If <code>reconnect-mode</code> is set to <code>OFF</code>, the client does not change the cluster; it shuts down immediately.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Here it could be the case that the whole cluster is restarted.
In this case, the owner member of the client connection in the restarted cluster
rejects the client&#8217;s connection request, since the client is trying to connect to the old cluster.
So, the client needs to search for a new cluster, if available and
according to the blue-green configuration (see the following configuration related sections in this section).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider the following notes for the blue-green mechanism (also valid for the disaster
recovery mechanism described in the next section):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a client disconnects from a cluster and
connects to a new one the <code>InitialMemberEvent</code> and <code>CLIENT_CHANGED_CLUSTER</code> events are fired.</p>
</li>
<li>
<p>When switching clusters, the client reuses its UUID.</p>
</li>
<li>
<p>The client&#8217;s listener service re-registers its listeners to the new cluster;
the listener service opens a new connection to all members in the current
<a href="#client-network">member list</a> and registers the listeners for each connection.</p>
</li>
<li>
<p>The client&#8217;s Near Caches and Continuous Query Caches are cleared when
the client joins a new cluster successfully.</p>
</li>
<li>
<p>If the new cluster&#8217;s partition size is different, the client is rejected by the cluster.
The client is not able to connect to a cluster with different partition count.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_disaster_recovery_mechanism"><a class="anchor" href="#_disaster_recovery_mechanism"></a>Disaster Recovery Mechanism</h5>
<div class="paragraph">
<p>When one of your clusters is gone due to a failure, the connection between
your clients and owner member in that cluster is gone, too.
When a client is disconnected because of a failure in the cluster,
it first tries to connect to another member of that same cluster.</p>
</div>
<div class="paragraph">
<p>The client&#8217;s behavior after this disconnection depends on its
<a href="#java-client-connection-strategy"><code>reconnect-mode</code></a>, and it has the same options
that are described in the above section (Blue-Green Mechanism).</p>
</div>
<div class="paragraph">
<p>If you have provided alternative clusters for your clients to connect,
the client tries to connect to those alternative clusters (depending on the <code>reconnect-mode</code>).</p>
</div>
<div class="paragraph">
<p>When a failover starts, i.e., the client is disconnected and was configured
to connect to alternative clusters, the current <a href="#client-network">member list</a> is not considered;
the client cuts all the connections before attempting to connect to a new cluster and tries the clusters as configured.
See the below configuration related sections.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ordering_of_clusters_when_clients_try_to_connect"><a class="anchor" href="#_ordering_of_clusters_when_clients_try_to_connect"></a>Ordering of Clusters When Clients Try to Connect</h5>
<div class="paragraph">
<p>The order of the clusters, that the client will try to connect
in a blue-green or disaster recovery scenario, is decided by
the order of these cluster declarations as given in the client configuration.</p>
</div>
<div class="paragraph">
<p>Each time the client is disconnected from a cluster and it cannot connect back to the same one,
the configured list is iterated over. Count of these iterations before
the client decides to shut down is provided using the <code>try-count</code> configuration element.
See the following configuration related sections.</p>
</div>
<div class="paragraph">
<p>We didn&#8217;t go over the configuration yet (see the following configuration related sections),
but for the sake of explaining the ordering, assume that you have
<code>client-config1</code>, <code>client-config2</code> and <code>client-config3</code>
in the given order as shown below (in your <code>hazelcast-client-failover</code> XML or YAML file).
This means you have three alternative clusters.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client-failover&gt;
    &lt;try-count&gt;4&lt;/try-count&gt;
    &lt;clients&gt;
        &lt;client&gt;client-config1.xml&lt;/client&gt;
        &lt;client&gt;client-config2.xml&lt;/client&gt;
        &lt;client&gt;client-config3.xml&lt;/client&gt;
    &lt;/clients&gt;
&lt;/hazelcast-client-failover&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client-failover:
  try-count: 4
  clients:
    - client-config1.yaml
    - client-config2.yaml
    - client-config3.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s say the client is disconnected from the cluster
whose configuration is given by <code>client-config2.xml</code>.
Then, the client tries to connect to the next cluster in this list,
whose configuration is given by <code>client-config3.xml</code>. When the end of the list is reached,
which is so in this example, and the client could not connect to <code>client-config3</code>,
then <code>try-count</code> is incremented and the client continues to try to connect starting with <code>client-config1</code>.</p>
</div>
<div class="paragraph">
<p>This iteration continues until the client connects to a cluster or <code>try-count</code> is reached to the configured value.
When the iteration reaches this value and the client still could not connect to a cluster,
it shuts down. Note that, if <code>try-count</code> was set to <code>1</code> in the above example,
and the client could not connect to <code>client-config3</code>, it would shut down since
it already tried once to connect to an alternative cluster.</p>
</div>
<div class="paragraph">
<p>The following sections describe how you can configure the Java client for
blue-green and disaster recovery scenarios.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_using_cname"><a class="anchor" href="#_configuring_using_cname"></a>Configuring Using CNAME</h5>
<div class="paragraph">
<p>Using CNAME, you can change the hostname resolutions and use them dynamically.
Let&#8217;s describe the configuration with examples.</p>
</div>
<div class="paragraph">
<p>Assume that you have two clusters, Cluster A and Cluster B, and two Java clients.</p>
</div>
<div class="paragraph">
<p>First configure the Cluster A members as shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;tcp-ip enabled="true"&gt;
                &lt;member&gt;clusterA.member1&lt;/member&gt;
                &lt;member&gt;clusterA.member2&lt;/member&gt;
            &lt;/tcp-ip&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    join:
      tcp-ip:
        enabled: true
        members: clusterA.member1,clusterA.member2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, configure the Cluster B members as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;tcp-ip enabled="true"&gt;
                &lt;member&gt;clusterB.member1&lt;/member&gt;
                &lt;member&gt;clusterB.member2&lt;/member&gt;
            &lt;/tcp-ip&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    join:
      tcp-ip:
        enabled: true
        members: clusterB.member1,clusterB.member2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Configure the two clients as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">Client 1 XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;cluster-name&gt;cluster-a&lt;/cluster-name&gt;
    &lt;network&gt;
        &lt;cluster-members&gt;
            &lt;address&gt;production1.myproject&lt;/address&gt;
            &lt;address&gt;production2.myproject&lt;/address&gt;
        &lt;/cluster-members&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  cluster-name: cluster-a
  network:
    cluster-members:
      - production1.myproject
      - production2.myproject</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Client 2 XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;cluster-name&gt;cluster-b&lt;/cluster-name&gt;
    &lt;network&gt;
        &lt;cluster-members&gt;
            &lt;address&gt;production1.myproject&lt;/address&gt;
            &lt;address&gt;production2.myproject&lt;/address&gt;
        &lt;/cluster-members&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  cluster-name: cluster-b
  network:
    cluster-members:
      - production1.myproject
      - production2.myproject</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming that the client configuration file names of the above example clients are
<code>hazelcast-client-c1.xml/yaml</code> and <code>hazelcast-client-c1.xml/yaml</code>, you should configure the
client failover for a blue-green deployment scenario as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client-failover&gt;
    &lt;try-count&gt;4&lt;/try-count&gt;
    &lt;clients&gt;
        &lt;client&gt;hazelcast-client-c1.xml&lt;/client&gt;
        &lt;client&gt;hazelcast-client-c2.xml&lt;/client&gt;
    &lt;/clients&gt;
&lt;/hazelcast-client-failover&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client-failover:
  try-count: 4
  clients:
    - hazelcast-client-c1.yaml
    - hazelcast-client-c2.yaml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can find the complete Hazelcast client failover
example configuration file (<code>hazelcast-client-failover-full-example</code>)
both in XML and YAML formats including the descriptions of elements and attributes,
in the <code>/bin</code> folder of your Hazelcast download directory.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You should also configure your clients to forget DNS lookups using the
<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/net/properties.html" target="_blank" rel="noopener">networkaddress.cache.ttl</a> JVM parameter.</p>
</div>
<div class="paragraph">
<p>Configure the addresses in your clients' configuration to resolve to hostnames of
Cluster A via CNAME so that the clients will connect to Cluster A when it starts:</p>
</div>
<div class="paragraph">
<p><code>production1.myproject</code>  <code>clusterA.member1</code></p>
</div>
<div class="paragraph">
<p><code>production2.myproject</code>  <code>clusterA.member2</code></p>
</div>
<div class="paragraph">
<p>When you want the clients to switch to the other cluster, change the mapping as follows:</p>
</div>
<div class="paragraph">
<p><code>production1.myproject</code>  <code>clusterB.member1</code></p>
</div>
<div class="paragraph">
<p><code>production2.myproject</code>  <code>clusterB.member2</code></p>
</div>
<div class="paragraph">
<p>Wait for the time you configured using the <code>networkaddress.cache.ttl</code> JVM parameter for
the client JVM to forget the old mapping.</p>
</div>
<div class="paragraph">
<p>Blacklist the clients in Cluster A using the Hazelcast Management Center.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_without_cname"><a class="anchor" href="#_configuring_without_cname"></a>Configuring Without CNAME</h5>
<div class="paragraph">
<p>Let&#8217;s first give example configurations and describe the configuration elements.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client-failover&gt;
    &lt;try-count&gt;4&lt;/try-count&gt;
    &lt;clients&gt;
        &lt;client&gt;hazelcast-client-c1.xml&lt;/client&gt;
        &lt;client&gt;hazelcast-client-c2.xml&lt;/client&gt;
    &lt;/clients&gt;
&lt;/hazelcast-client-failover&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client-failover:
  try-count: 4
  clients:
    - hazelcast-client-c1.yaml
    - hazelcast-client-c2.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
clientConfig.setClusterName("cluster-a");
ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
networkConfig.addAddress("10.216.1.18", "10.216.1.19");

ClientConfig clientConfig2 = new ClientConfig();
clientConfig2.setClusterName("cluster-b");
ClientNetworkConfig networkConfig2 = clientConfig2.getNetworkConfig();
networkConfig2.addAddress( "10.214.2.10", "10.214.2.11");

ClientFailoverConfig clientFailoverConfig = new ClientFailoverConfig();
clientFailoverConfig.addClientConfig(clientConfig).addClientConfig(clientConfig2).setTryCount(10)
HazelcastInstance client = HazelcastClient.newHazelcastFailoverClient(clientFailoverConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions for the configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>try-count</code>: Count of connection retries by the client to the alternative clusters.
When this value is reached and the client still could not connect to a cluster, the client
shuts down. Note that this value applies to the alternative clusters whose configurations are provided
with the <code>client</code> element. For the above example, two alternative clusters are given
with the <code>try-count</code> set as <code>4</code>. This means the number of connection attempts is
4 x 2 = 8.</p>
</li>
<li>
<p><code>client</code>: Path to the client configuration that corresponds to an alternative cluster that the client will try to connect.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The client configurations must be exactly the same except the following configuration options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SecurityConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.Addresses</code></p>
</li>
<li>
<p><code>NetworkConfig.SocketInterceptorConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.SSLConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.AwsConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.GcpConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.AzureConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.KubernetesConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.EurekaConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.CloudConfig</code></p>
</li>
<li>
<p><code>NetworkConfig.DiscoveryConfig</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also configure it within the Spring context, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans&gt;
    &lt;hz:client-failover id="blueGreenClient" try-count="5"&gt;
        &lt;hz:client&gt;
            &lt;hz:cluster-name name="dev"/&gt;
            &lt;hz:network&gt;
                &lt;hz:member&gt;127.0.0.1:5700&lt;/hz:member&gt;
                &lt;hz:member&gt;127.0.0.1:5701&lt;/hz:member&gt;
            &lt;/hz:network&gt;
        &lt;/hz:client&gt;

        &lt;hz:client&gt;
            &lt;hz:cluster-name name="alternativeClusterName"/&gt;
            &lt;hz:network&gt;
                &lt;hz:member&gt;127.0.0.1:5702&lt;/hz:member&gt;
                &lt;hz:member&gt;127.0.0.1:5703&lt;/hz:member&gt;
            &lt;/hz:network&gt;
        &lt;/hz:client&gt;

    &lt;/hz:client-failover&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_java_client_failure_detectors"><a class="anchor" href="#_java_client_failure_detectors"></a>18.1.5. Java Client Failure Detectors</h4>
<div class="paragraph">
<p>The client failure detectors are responsible to determine if a member in the cluster is unreachable or crashed.
The most important problem in the failure detection is to distinguish
whether a member is still alive but slow, or has crashed.
But according to the famous <a href="http://dl.acm.org/citation.cfm?doid=3149.214121" target="_blank" rel="noopener">FLP result</a>,
it is impossible to distinguish a crashed member from a slow one in an asynchronous system.
A workaround to this limitation is to use unreliable failure detectors.
An unreliable failure detector allows a member to suspect that others have failed,
usually based on liveness criteria but it can make mistakes to a certain degree.</p>
</div>
<div class="paragraph">
<p>Hazelcast Java client has two built-in failure detectors: Deadline Failure Detector and
Ping Failure Detector. These client failure detectors work independently from
the member failure detectors, e.g., you do not need to enable the member failure detectors
to benefit from the client ones.</p>
</div>
<div class="sect4">
<h5 id="_client_deadline_failure_detector"><a class="anchor" href="#_client_deadline_failure_detector"></a>Client Deadline Failure Detector</h5>
<div class="paragraph">
<p><em>Deadline Failure Detector</em> uses an absolute timeout for missing/lost heartbeats.
After timeout, a member is considered as crashed/unavailable and marked as suspected.</p>
</div>
<div class="paragraph">
<p><em>Deadline Failure Detector</em> has two configuration properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.client.heartbeat.interval</code>: This is the interval at which client sends
heartbeat messages to members.</p>
</li>
<li>
<p><code>hazelcast.client.heartbeat.timeout</code>: This is the timeout which defines when
a cluster member is suspected, because it has not sent any response back to client requests.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The value of <code>hazelcast.client.heartbeat.interval</code> should be smaller than
that of <code>hazelcast.client.heartbeat.timeout</code>. In addition, the value of system property
<a href="#client-max-no">hazelcast.client.max.no.heartbeat.seconds</a>, which is set on the member side,
should be larger than that of <code>hazelcast.client.heartbeat.interval</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is a declarative example showing how you can configure the Deadline Failure Detector
for your client (in the client&#8217;s configuration XML file, e.g., <code>hazelcast-client.xml</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.client.heartbeat.timeout"&gt;60000&lt;/property&gt;
        &lt;property name="hazelcast.client.heartbeat.interval"&gt;5000&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  properties
    hazelcast.client.heartbeat.timeout: 60000
    hazelcast.client.heartbeat.interval: 5000</code></pre>
</div>
</div>
<div class="paragraph">
<p>And, the following is the equivalent programmatic configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig config = ...;
config.setProperty("hazelcast.client.heartbeat.timeout", "60000");
config.setProperty("hazelcast.client.heartbeat.interval", "5000");
[...]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_client_ping_failure_detector"><a class="anchor" href="#_client_ping_failure_detector"></a>Client Ping Failure Detector</h5>
<div class="paragraph">
<p>In addition to the Deadline Failure Detector, the Ping Failure Detector may be configured on your client.
Please note that this detector is disabled by default. The Ping Failure Detector
operates at Layer 3 of the OSI protocol and provides much quicker and more deterministic
detection of hardware and other lower level events.
When the JVM process has enough permissions to create RAW sockets, the implementation
chooses to rely on ICMP Echo requests. This is preferred.</p>
</div>
<div class="paragraph">
<p>If there are not enough permissions, it can be configured to fallback on attempting
a TCP Echo on port 7. In the latter case, both a successful connection or an explicit rejection
is treated as "Host is Reachable". Or, it can be forced to use only RAW sockets.
This is not preferred as each call creates a heavy weight socket and moreover the Echo service is typically disabled.</p>
</div>
<div class="paragraph">
<p>For the Ping Failure Detector to rely <strong>only</strong> on the ICMP Echo requests,
the following criteria need to be met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Supported OS: as of Java 1.8 only Linux/Unix environments are supported.</p>
</li>
<li>
<p>The Java executable must have the <code>cap_net_raw</code> capability.</p>
</li>
<li>
<p>The file <code>ld.conf</code> must be edited to overcome the rejection by the dynamic
linker when loading libs from untrusted paths.</p>
</li>
<li>
<p>ICMP Echo Requests must not be blocked by the receiving hosts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The details of these requirements are explained in the
<a href="#requirements-and-linuxunix-configuration">Requirements section</a> of
Hazelcast members' <a href="#ping-failure-detector">Ping Failure Detector</a>.</p>
</div>
<div class="paragraph">
<p>If any of the above criteria isn&#8217;t met, then <code>isReachable</code> will always
fallback on TCP Echo attempts on port 7.</p>
</div>
<div class="paragraph">
<p>An example declarative configuration to use the Ping Failure Detector is
as follows (in the client&#8217;s configuration XML file, e.g., <code>hazelcast-client.xml</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;icmp-ping enabled="true"&gt;
            &lt;timeout-milliseconds&gt;1000&lt;/timeout-milliseconds&gt;
            &lt;interval-milliseconds&gt;1000&lt;/interval-milliseconds&gt;
            &lt;ttl&gt;255&lt;ttl&gt;
            &lt;echo-fail-fast-on-startup&gt;false&lt;/echo-fail-fast-on-startup&gt;
            &lt;max-attempts&gt;2&lt;/max-attempts&gt;
        &lt;/icmp-ping&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    icmp-ping:
      enabled: false
      timeout-milliseconds: 1000
      interval-milliseconds: 1000
      ttl: 255
      echo-fail-fast-on-startup: false
      max-attempts: 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>And, the equivalent programmatic configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig config = ...;

ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
ClientIcmpPingConfig clientIcmpPingConfig = networkConfig.getClientIcmpPingConfig();
clientIcmpPingConfig.setIntervalMilliseconds(1000)
        .setTimeoutMilliseconds(1000)
        .setTtl(255)
        .setMaxAttempts(2)
        .setEchoFailFastOnStartup(false)
        .setEnabled(true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions of configuration elements and attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Enables the legacy ICMP detection mode, works cooperatively with
the existing failure detector and only kicks-in after a pre-defined period
has passed with no heartbeats from a member. Its default value is <code>false</code>.</p>
</li>
<li>
<p><code>timeout-milliseconds</code>: Number of milliseconds until a ping attempt is
considered failed if there was no reply. Its default value is <strong>1000</strong> milliseconds.</p>
</li>
<li>
<p><code>max-attempts</code>: Maximum number of ping attempts before the member gets
suspected by the detector. Its default value is <strong>3</strong>.</p>
</li>
<li>
<p><code>interval-milliseconds</code>: Interval, in milliseconds, between each ping attempt.
1000ms (1 sec) is also the minimum interval allowed. Its default value is <strong>1000</strong> milliseconds.</p>
</li>
<li>
<p><code>ttl</code>: Maximum number of hops the packets should go through.
Its default value is <strong>255</strong>. You can set to <strong>0</strong> to use your system&#8217;s default TTL.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the above example configuration, the Ping Failure Detector attempts 2 pings,
one every second, and waits up to 1 second for each to complete.
If there is no successful ping after 2 seconds, the member gets suspected.</p>
</div>
<div class="paragraph">
<p>To enforce the <a href="#requirements-and-linuxunix-configuration">Requirements</a>,
the property <code>echo-fail-fast-on-startup</code> can also be set to <code>true</code>, in which case Hazelcast fails to start if any of the requirements
isn&#8217;t met.</p>
</div>
<div class="paragraph">
<p>Unlike the Hazelcast members, Ping Failure Detector works always in parallel with
Deadline Failure Detector on the clients.
Below is a summary table of all possible configuration combinations of the Ping Failure Detector.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ICMP</th>
<th class="tableblock halign-left valign-top">Fail-Fast</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Linux</th>
<th class="tableblock halign-left valign-top">Windows</th>
<th class="tableblock halign-left valign-top">macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parallel ping detector, works in parallel with the configured failure detector.
Checks periodically if members are live (OSI Layer 3) and suspects them immediately,
regardless of the other detectors.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parallel ping detector, works in parallel with the configured failure detector.
Checks periodically if members are live (OSI Layer 3) and suspects them immediately,
regardless of the other detectors.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported - Requires OS Configuration Enforcing ICMP Echo if available - No start up if not available</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not Supported</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not Supported - Requires root privileges</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_client_system_properties"><a class="anchor" href="#_client_system_properties"></a>18.1.6. Client System Properties</h4>
<div class="paragraph">
<p>There are some advanced client configuration properties to tune some aspects of Hazelcast Client.
You can set them as property name and value pairs through declarative configuration,
programmatic configuration, or JVM system property. See the <a href="#system-properties">System Properties appendix</a>
to learn how to set these properties.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you want to reconfigure a system property, you need to restart the clients for
which the property is modified.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The table below lists the client configuration properties with their descriptions.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. Client System Properties</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 50.0002%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property Name</th>
<th class="tableblock halign-left valign-top">Default Value</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.cloud.discovery.token</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Token to use when discovering the cluster via Hazelcast Cloud.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.concurrent.window.ms</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property needed for concurrency detection so that write through and dynamic response handling
can be done correctly. This property sets the window for a concurrency detection (duration when it signals
that a concurrency has been detected), even if there are no further updates in that window.
Normally in a concurrent system the windows keeps sliding forward so it always remains concurrent.
Setting it too high effectively disables the optimization because once concurrency has been detected
it will keep that way. Setting it too low could lead to suboptimal performance because the system
will try write through and other optimizations even though the system is concurrent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.discovery.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables/disables the Discovery SPI lookup over the old native implementations.
See <a href="#discovery-spi">[discovery-spi]</a> for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.discovery.public.ip.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables the discovery joiner to use public IPs from <code>DiscoveredNode</code>.
See <a href="#discovery-spi">[discovery-spi]</a> for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.event.queue.capacity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default value of the capacity of executor that handles the incoming event packets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.event.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thread count for handling the incoming event packets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.heartbeat.interval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Frequency of the heartbeat messages sent by the clients to members.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.heartbeat.timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout for the heartbeat messages sent by the client to members.
If no messages pass between the client and member within the given time via
this property in milliseconds, the connection will be closed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.invocation.backoff.timeout.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls the maximum timeout, in milliseconds, to wait for an invocation space to be available.
If an invocation cannot be made because there are too many pending invocations,
then an exponential backoff is done to give the system time to deal with
the backlog of invocations. This property controls how long an invocation is
allowed to wait before getting a <code>HazelcastOverloadException</code>.
When set to -1 then <code>HazelcastOverloadException</code> is thrown immediately without any waiting.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.invocation.retry.pause.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pause time between each retry cycle of an invocation in milliseconds.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.invocation.timeout.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Period, in seconds, to give up the invocation when a member in the member list is not reachable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.io.balancer.interval.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interval in seconds between each <code>IOBalancer</code>
execution. By default Hazelcast uses 3 threads to read
data from TCP connections and 3 threads to write data to connections.
<code>IOBalancer</code> detects and fixes the fluctuations when these threads are not
utilized equally. The shorter intervals catch I/O imbalances faster, but they cause higher overhead.
A value smaller than 1 disables the balancer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.io.input.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls the number of I/O input threads. Defaults to -1, i.e., the system decides.
If the client is a smart client, it defaults to 3, otherwise it defaults to 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.io.output.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls the number of I/O output threads. Defaults to -1, i.e., the system decides.
If the client is a smart client, it defaults to 3, otherwise it defaults to 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.io.write.through</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optimization that allows sending of packets over the network to be done on the calling thread if the
conditions are right. This can reduce the latency and increase the performance for low threaded environments.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.max.concurrent.invocations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer.MAX_VALUE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum allowed number of concurrent invocations. You can apply a constraint on
the number of concurrent invocations in order to prevent the system from overloading.
If the maximum number of concurrent invocations is exceeded and a new invocation comes in,
Hazelcast throws <code>HazelcastOverloadException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.metrics.collection.frequency</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Frequency, in seconds, of the <a href="#metrics">metrics</a> collection cycle. Note that
the preferred way for controlling this setting is <a href="#metrics-configuration">Metrics Configuration</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.metrics.debug.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables collecting debug metrics if set to <code>true</code>, disables it otherwise.
Note that this is meant to be enabled only if diagnostics is enabled, since currently only diagnostics consumes the debug metrics.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.metrics.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables the <a href="#metrics">metrics collection</a> if set to <code>true</code>, disables it otherwise. Note that the preferred way for
controlling this setting is <a href="#metrics-configuration">Metrics Configuration</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.metrics.jmx.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables exposing the collected <a href="#metrics">metrics</a> over JMX if set to <code>true</code>, disables it otherwise. Note that
the preferred way for controlling this setting is <a href="#metrics-configuration">Metrics Configuration</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.operation.backup.timeout.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If an operation has backups, this property specifies how long the invocation will wait for acks from the backup replicas.
If acks are not received from some backups, there will not be any rollback on other successful replicas.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.operation.fail.on.indeterminate.state</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When this configuration is enabled, if an operation has sync backups and acks are not received from backup replicas
in time, or the member which owns primary replica of the target partition leaves the cluster, then the invocation fails
with <code>IndeterminateOperationStateException</code>. However, even if the invocation fails,
there will not be any rollback on other successful replicas.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.response.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of the response threads.
By default, there are two response threads; this gives stable and good performance.
If set to 0, the response threads are bypassed and the response handling is done
on the I/O threads. Under certain conditions this can give a higher throughput, but
setting to 0 should be regarded as an experimental feature.
If set to 0, the IO_OUTPUT_THREAD_COUNT is really going to matter because the
inbound thread will have more work to do. By default when TLS is not enabled,
there is just one inbound thread.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.response.thread.dynamic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables dynamic switching between processing the responses on the I/O threads and offloading the response threads.
Under certain conditions (single threaded clients) processing on the I/O
thread can increase the performance because useless handover to the response
thread is removed. Also the response thread is not created until it is needed.
Especially for ephemeral clients, reducing the threads can lead to
increased performance and reduced memory usage.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.shuffle.member.list</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The client shuffles the given member list to prevent all the clients to connect
to the same member when this property is <code>true</code>. When it is set to <code>false</code>,
the client tries to connect to the members in the given order.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.statistics.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to <code>true</code>, it enables collecting the client statistics and sending them to the cluster.
When it is <code>true</code> you can monitor the clients that are connected to your Hazelcast cluster,
using Hazelcast Management Center. See the
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-clients" target="_blank" rel="noopener">Monitoring Clients section</a>
in the Hazelcast Management Center Reference Manual for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.statistics.period.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Period in seconds the client statistics are collected and sent to the cluster.
See the <a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-clients" target="_blank" rel="noopener">Monitoring Clients section</a>
in the Hazelcast Management Center Reference Manual for more information on the client statistics.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_using_high_density_memory_store_with_java_client"><a class="anchor" href="#_using_high_density_memory_store_with_java_client"></a>18.1.7. Using High-Density Memory Store with Java Client</h4>
<div class="paragraph">
<p><strong class="navy">Hazelcast IMDG Enterprise HD</strong></p>
</div>
<div class="paragraph">
<p>If you have <strong class="navy">Hazelcast IMDG Enterprise HD</strong>, your Hazelcast Java client&#8217;s Near Cache
can benefit from the High-Density Memory Store.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s recall the Java client&#8217;s Near Cache configuration
(see the <a href="#configuring-client-near-cache">Configuring Client Near Cache section</a>)
<strong>without</strong> High-Density Memory Store:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;near-cache name="MENU"&gt;
        &lt;eviction size="2000" eviction-policy="LFU"/&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;max-idle-seconds&gt;0&lt;/max-idle-seconds&gt;
        &lt;invalidate-on-change&gt;true&lt;/invalidate-on-change&gt;
        &lt;in-memory-format&gt;OBJECT&lt;/in-memory-format&gt;
    &lt;/near-cache&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can configure this Near Cache to use Hazelcast&#8217;s High-Density Memory Store
by setting the in-memory format to NATIVE. See the following configuration example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;near-cache&gt;
        &lt;eviction size="1000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU"/&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;max-idle-seconds&gt;0&lt;/max-idle-seconds&gt;
        &lt;invalidate-on-change&gt;true&lt;/invalidate-on-change&gt;
        &lt;in-memory-format&gt;NATIVE&lt;/in-memory-format&gt;
    &lt;/near-cache&gt;
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;eviction&gt;</code> element has the following attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>size</code>: Maximum size (entry count) of the Near Cache.</p>
</li>
<li>
<p><code>max-size-policy</code>: Maximum size policy for eviction of the Near Cache.
Available values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p>ENTRY_COUNT: Maximum entry count per member.</p>
</li>
<li>
<p>USED_NATIVE_MEMORY_SIZE: Maximum used native memory size in megabytes.</p>
</li>
<li>
<p>USED_NATIVE_MEMORY_PERCENTAGE: Maximum used native memory percentage.</p>
</li>
<li>
<p>FREE_NATIVE_MEMORY_SIZE: Minimum free native memory size to trigger cleanup.</p>
</li>
<li>
<p>FREE_NATIVE_MEMORY_PERCENTAGE: Minimum free native memory percentage to trigger cleanup.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>eviction-policy</code>: Eviction policy configuration. Its default values is NONE.
Available values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p>NONE: No items are evicted and the <code>size</code> property is ignored.
You still can combine it with time-to-live-seconds.</p>
</li>
<li>
<p>LRU: Least Recently Used.</p>
</li>
<li>
<p>LFU: Least Frequently Used.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Keep in mind that you should have already enabled the High-Density Memory Store
usage for your client, using the <code>&lt;native-memory&gt;</code> element in the client&#8217;s configuration.</p>
</div>
<div class="paragraph">
<p>See the <a href="#high-density-memory-store">High-Density Memory Store section</a>
for more information on Hazelcast&#8217;s High-Density Memory Store feature.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="c-client"><a class="anchor" href="#c-client"></a>18.2. C++ Client</h3>
<div class="paragraph">
<p>You can use the native C&#43;&#43; client to connect to Hazelcast cluster members and
perform almost all operations that a member can perform.
Clients differ from members in that clients do not hold data. The C&#43;&#43; client is
by default a smart client, i.e., it knows where the data is and asks directly for the correct member.
You can disable this feature (using the <code>ClientConfig::setSmart</code> method) if you do not want
the clients to connect to every member.</p>
</div>
<div class="paragraph">
<p>The features of C&#43;&#43; clients are listed below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access to distributed data structures (IMap, IQueue, MultiMap, ITopic, etc.).</p>
</li>
<li>
<p>Access to transactional distributed data structures (TransactionalMap, TransactionalQueue, etc.).</p>
</li>
<li>
<p>Ability to add cluster listeners to a cluster and entry/item listeners to distributed data structures.</p>
</li>
<li>
<p>Distributed synchronization mechanisms with ILock, ISemaphore and ICountDownLatch.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See Hazelcast C++ client&#8217;s own GitHub <a href="https://github.com/hazelcast/hazelcast-cpp-client" target="_blank" rel="noopener">repo</a>
for information on setting the client up, installing and compiling it,
its serialization support and APIs such as raw pointer and query.
You can also find <a href="https://github.com/hazelcast/hazelcast-cpp-client/tree/master/examples" target="_blank" rel="noopener">code samples</a>
for this client in this repo.</p>
</div>
</div>
<div class="sect2">
<h3 id="net-client"><a class="anchor" href="#net-client"></a>18.3. .NET Client</h3>
<div class="paragraph">
<p>You can use the native .NET client to connect to Hazelcast client members.
You need to add <code>HazelcastClient3x.dll</code> into your .NET project references.
The API is very similar to the Java native client.</p>
</div>
<div class="paragraph">
<p>See Hazelcast .NET client&#8217;s own GitHub <a href="https://github.com/hazelcast/hazelcast-csharp-client" target="_blank" rel="noopener">repo</a>
for information on configuring and starting the client.
You can also find <a href="https://github.com/hazelcast/hazelcast-csharp-client/tree/master/Hazelcast.Examples" target="_blank" rel="noopener">code samples</a>
for this client in this repo.</p>
</div>
</div>
<div class="sect2">
<h3 id="rest-client"><a class="anchor" href="#rest-client"></a>18.4. REST Client</h3>
<div class="paragraph">
<p>Hazelcast provides a REST interface: it provides an HTTP service
in each cluster member so that you can access your data
structures and cluster using the HTTP protocol.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>REST service is disabled in the configuration by default.
You should enable it on your cluster members to use the REST client
as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;rest-api enabled="true"&gt;
        ...
        &lt;/rest-api&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    rest-api:
      enabled: true</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast uses grouped endpoints to provide the communication
via REST interface. In this section, as an example, we show various operations
that are performed on the <strong>data structures</strong> in a cluster using the REST calls.
For these operations to work, in addition to enabling the REST service as shown above,
you also need to enable the <code>DATA</code> endpoint group which allows accessing the data structures,
as shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;rest-api enabled="true"&gt;
            &lt;endpoint-group name="DATA" enabled="true"/&gt;
        &lt;/rest-api&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    rest-api:
      enabled: true
      endpoint-groups:
        DATA:
          enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#using-the-rest-endpoint-groups">Using the REST Endpoint Groups section</a> for details
and to learn about the other endpoint groups Hazelcast offers.</p>
</div>
<div class="paragraph">
<p>In terms of data structures, currently maps and queues are supported.
Assuming <code>mapName</code> and <code>queueName</code> are already configured in your Hazelcast,
the structure of REST calls is shown below:</p>
</div>
<div class="paragraph">
<p><code>http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/key</code></p>
</div>
<div class="paragraph">
<p><code>http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/queues/queueName</code></p>
</div>
<div class="paragraph">
<p>For the operations to be performed, standard REST conventions for HTTP calls are used.</p>
</div>
<div class="paragraph">
<p>All parameters that are used in REST API URLs, such as
the distributed data structure and key names, must be
<a href="https://en.wikipedia.org/wiki/Percent-encoding" target="_blank" rel="noopener">URL encoded</a>
when composing a call. As an example, <code>name.with/special@chars</code>
parameter value would be encoded as <code>name.with%2Fspecial%40chars</code>.</p>
</div>
<div class="sect3">
<h4 id="_rest_client_getpostdelete_examples"><a class="anchor" href="#_rest_client_getpostdelete_examples"></a>18.4.1. REST Client GET/POST/DELETE Examples</h4>
<div class="paragraph">
<p>All of the requests below can return one of the following responses in case of a failure.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the HTTP request syntax is not known, the following response is returned.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>HTTP/1.1 400 Bad Request
Content-Length: 0</code></pre>
</div>
</div>
</li>
<li>
<p>In case of an unexpected exception, the following response is returned.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt; HTTP/1.1 500 Internal Server Error
&lt; Content-Length: 0</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_creatingupdating_entries_in_a_map_for_rest_client"><a class="anchor" href="#_creatingupdating_entries_in_a_map_for_rest_client"></a>Creating/Updating Entries in a Map for REST Client</h5>
<div class="paragraph">
<p>You can put a new <code>key1/value1</code> entry into a map by using <code>POST</code> call to
<code>http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/key1</code> URL.
This call&#8217;s content body should contain the value of the key.
Also, if the call contains the MIME type, Hazelcast stores this information, too.</p>
</div>
<div class="paragraph">
<p>An example <code>POST</code> call is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v -H "Content-Type: text/plain" -d "bar"
    http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>It returns the following response if successful:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 200 OK
&lt; Content-Length: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>If your <code>POST</code> call has a trailing slash, Hazelcast will strip it so that it is not appended to the key string. So if you send this <code>POST</code> call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v -H "Content-Type: text/plain" -d "bar"
    http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/foo/</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>POST</code> call will instead be processed as below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v -H "Content-Type: text/plain" -d "bar"
    http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/foo</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_retrieving_entries_from_a_map_for_rest_client"><a class="anchor" href="#_retrieving_entries_from_a_map_for_rest_client"></a>Retrieving Entries from a Map for REST Client</h5>
<div class="paragraph">
<p>If you want to retrieve an entry, you can use a <code>GET</code> call
to <code>http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/key1</code>.
You can also retrieve this entry from another member of your cluster, such as
<code>http://&lt;another member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/key1</code>.</p>
</div>
<div class="paragraph">
<p>An example of a <code>GET</code> call is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ curl -X GET http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>It returns the following response if there is a corresponding value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 3
bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <code>GET</code> call returned a value, its length and also the MIME type
(<code>text/plain</code>) since the POST call example shown above included the MIME type.</p>
</div>
<div class="paragraph">
<p>It returns the following if there is no mapping for the given key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 204 No Content
&lt; Content-Length: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly to the <code>POST</code> call, Hazelcast will strip the trailing slash from your <code>GET</code> call.</p>
</div>
</div>
<div class="sect4">
<h5 id="_removing_entries_from_a_map_for_rest_client"><a class="anchor" href="#_removing_entries_from_a_map_for_rest_client"></a>Removing Entries from a Map for REST Client</h5>
<div class="paragraph">
<p>You can use a <code>DELETE</code> call to remove an entry. An example <code>DELETE</code> call is shown below with its response.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v -X DELETE http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName/foo</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt; HTTP/1.1 200 OK
&lt; Content-Length: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you leave the key empty as follows, the <code>DELETE</code> call deletes all entries from the map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v -X DELETE http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/maps/mapName</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 200 OK
&lt; Content-Length: 0</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_offering_items_on_a_queue_for_rest_client"><a class="anchor" href="#_offering_items_on_a_queue_for_rest_client"></a>Offering Items on a Queue for REST Client</h5>
<div class="paragraph">
<p>You can use a <code>POST</code> call to create an item on the queue. An example is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v -H "Content-Type: text/plain" -d "foo"
    http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/queues/myEvents</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above call is equivalent to <code>HazelcastInstance.getQueue("myEvents").offer("foo");</code>.</p>
</div>
<div class="paragraph">
<p>It returns the following if successful:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 200 OK
&lt; Content-Length: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>It returns the following if the queue is full and the item is not able to be offered to the queue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 503 Service Unavailable
&lt; Content-Length: 0</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_retrieving_items_from_a_queue_for_rest_client"><a class="anchor" href="#_retrieving_items_from_a_queue_for_rest_client"></a>Retrieving Items from a Queue for REST Client</h5>
<div class="paragraph">
<p>You can use a <code>DELETE</code> call for retrieving items from a queue.
Note that you should state the poll timeout while polling for queue events by an extra path parameter.</p>
</div>
<div class="paragraph">
<p>An example is shown below (<strong>10</strong> being the timeout value).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v -X DELETE \http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/queues/myEvents/10</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above call is equivalent to <code>HazelcastInstance.getQueue("myEvents").poll(10, SECONDS);</code>.
Below is the response.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 3
foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the timeout is reached, the response is <code>No Content</code> success, i.e.,
there is no item on the queue to be returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 204 No Content
&lt; Content-Length: 0</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_getting_the_size_of_the_queue_for_rest_client"><a class="anchor" href="#_getting_the_size_of_the_queue_for_rest_client"></a>Getting the size of the queue for REST Client</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v -X GET \http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/queues/myEvents/size</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above call is equivalent to <code>HazelcastInstance.getQueue("myEvents").size();</code>.
Below is an example response.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 1
5</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_checking_the_status_of_the_cluster_for_rest_client"><a class="anchor" href="#_checking_the_status_of_the_cluster_for_rest_client"></a>18.4.2. Checking the Status of the Cluster for REST Client</h4>
<div class="paragraph">
<p>Besides the above operations, you can check the status of your cluster,
an example of which is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/cluster</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 200 OK

{
  "members": [
    {
      "address": "&lt;member IP address&gt;:&lt;port&gt;",
      "liteMember": false,
      "localMember": true,
      "uuid": "73f5d6ad-7b51-4e74-bd74-15b2e7de7edd",
      "memberVersion": "4.0.0"
    },
    {
      "address": "&lt;another member IP address&gt;:&lt;port&gt;",
      "liteMember": false,
      "localMember": false,
      "uuid": "e8b41ac6-9db9-43f1-9e98-8b0392891560",
      "memberVersion": "4.0.0"
    },
    {
      "address": "&lt;another member IP address&gt;:&lt;port&gt;",
      "liteMember": false,
      "localMember": false,
      "uuid": "c6929312-d4d3-4527-83bc-474c229394d6",
      "memberVersion": "4.0.0"
    }
  ],
  "connectionCount": 1,
  "allConnectionCount": 3
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_checking_the_name_of_the_instance_for_rest_client"><a class="anchor" href="#_checking_the_name_of_the_instance_for_rest_client"></a>18.4.3. Checking the Name of the Instance for REST Client</h4>
<div class="paragraph">
<p>Additionally, you can check the name of any instance of your cluster.
An example is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">$ curl -v http://&lt;member IP address&gt;:&lt;port&gt;/hazelcast/rest/instance</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">&lt; HTTP/1.1 200 OK
&lt; Content-Length: 27

{"name":"adoring_brattain"}</code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>RESTful access is provided through any member of your cluster.
You can even put an HTTP load-balancer in front of your cluster members for load balancing and fault tolerance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You need to handle the failures on REST polls as there is no transactional guarantee.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_memcache_client"><a class="anchor" href="#_memcache_client"></a>18.5. Memcache Client</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hazelcast Memcache Client only supports ASCII protocol. Binary Protocol is not supported.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A Memcache client written in any language can talk directly to a Hazelcast cluster.
No additional configuration is required.</p>
</div>
<div class="paragraph">
<p>To be able to use a Memcache client, you must enable
the Memcache client request listener service using either one of the following configuration options:</p>
</div>
<div class="paragraph">
<p>1 - Using the <code>network</code> configuration element:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;memcache-protocol enabled="true"/&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    memcache-protocol:
      enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>2 - Using the <code>advanced-network</code> configuration element:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network&gt;
        &lt;memcache-server-socket-endpoint-config name="memcache"&gt;
            &lt;port auto-increment="false" port-count="10"&gt;6000&lt;/port&gt;
        &lt;/memcache-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    memcache-server-socket-endpoint-config:
      name: memcache
      port:
        auto-increment: false
        port-count: 10
        port: 6000</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_memcache_client_code_examples"><a class="anchor" href="#_memcache_client_code_examples"></a>18.5.1. Memcache Client Code Examples</h4>
<div class="paragraph">
<p>Assume that your cluster members are as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">Members [5] {
  Member [10.20.17.1:5701]
  Member [10.20.17.2:5701]
  Member [10.20.17.4:5701]
  Member [10.20.17.3:5701]
  Member [10.20.17.5:5701]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assume that you have a PHP application that uses PHP Memcache client to cache things in Hazelcast.
All you need to do is have your PHP Memcache client connect to one of these members.
It does not matter which member the client connects to because
the Hazelcast cluster looks like one giant machine (Single System Image).
Here is a PHP client code example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-php hljs" data-lang="php">&lt;?php
    $memcache = new Memcache;
    $memcache-&gt;connect( '10.20.17.1', 5701 ) or die ( "Could not connect" );
    $memcache-&gt;set( 'key1', 'value1', 0, 3600 );
    $get_result = $memcache-&gt;get( 'key1' ); // retrieve your data
    var_dump( $get_result ); // show it
?&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that Memcache client connects to <code>10.20.17.1</code> and uses port <code>5701</code>.
Here is a Java client code example with SpyMemcached client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MemcachedClient client = new MemcachedClient(
    AddrUtil.getAddresses( "10.20.17.1:5701 10.20.17.2:5701" ) );
client.set( "key1", 3600, "value1" );
System.out.println( client.get( "key1" ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want your data to be stored in different maps, for example
to utilize per map configuration, you can do that with a map name prefix as in the following example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MemcachedClient client = new MemcachedClient(
    AddrUtil.getAddresses( "10.20.17.1:5701 10.20.17.2:5701" ) );
client.set( "map1:key1", 3600, "value1" ); // store to *hz_memcache_map1
client.set( "map2:key1", 3600, "value1" ); // store to hz_memcache_map2
System.out.println( client.get( "key1" ) ); // get from hz_memcache_map1
System.out.println( client.get( "key2" ) ); // get from hz_memcache_map2</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>hz_memcache prefix\_</strong> separates Memcache maps from Hazelcast maps.
If no map name is given, it is stored
in a default map named <strong>hz_memcache_default</strong>.</p>
</div>
<div class="paragraph">
<p>An entry written with a Memcache client can be read by another Memcache client written in another language.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unsupported_operations_for_memcache"><a class="anchor" href="#_unsupported_operations_for_memcache"></a>18.5.2. Unsupported Operations for Memcache</h4>
<div class="ulist">
<ul>
<li>
<p>CAS operations are not supported. In operations that get CAS parameters, such as append, CAS values are ignored.</p>
</li>
<li>
<p>Only a subset of statistics are supported. Below is the list of supported statistic values.</p>
<div class="ulist">
<ul>
<li>
<p>cmd_set</p>
</li>
<li>
<p>cmd_get</p>
</li>
<li>
<p>incr_hits</p>
</li>
<li>
<p>incr_misses</p>
</li>
<li>
<p>decr_hits</p>
</li>
<li>
<p>decr_misses</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_python_client"><a class="anchor" href="#_python_client"></a>18.6. Python Client</h3>
<div class="paragraph">
<p>Python Client implementation for Hazelcast. It is implemented using the Hazelcast Open Binary Client Protocol.</p>
</div>
<div class="paragraph">
<p>See Hazelcast Python client&#8217;s GitHub <a href="https://github.com/hazelcast/hazelcast-python-client" target="_blank" rel="noopener">repo</a>
for its documentation and <a href="https://github.com/hazelcast/hazelcast-python-client/tree/master/examples" target="_blank" rel="noopener">code samples</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_node_js_client"><a class="anchor" href="#_node_js_client"></a>18.7. Node.js Client</h3>
<div class="paragraph">
<p>Node.js Client implementation for Hazelcast. It is implemented using the Hazelcast Open Binary Client Protocol.</p>
</div>
<div class="paragraph">
<p>See Hazelcast Node.js client&#8217;s GitHub <a href="https://github.com/hazelcast/hazelcast-nodejs-client" target="_blank" rel="noopener">repo</a>
for its documentation and <a href="https://github.com/hazelcast/hazelcast-nodejs-client/tree/master/code_samples" target="_blank" rel="noopener">code samples</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_go_client"><a class="anchor" href="#_go_client"></a>18.8. Go Client</h3>
<div class="paragraph">
<p>Go Client implementation for Hazelcast. It is implemented using the Hazelcast Open Binary Client Protocol.</p>
</div>
<div class="paragraph">
<p>See Hazelcast Go client&#8217;s GitHub <a href="https://github.com/hazelcast/hazelcast-go-client" target="_blank" rel="noopener">repo</a>
for its documentation and <a href="https://github.com/hazelcast/hazelcast-go-client/tree/master/sample" target="_blank" rel="noopener">code samples</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serialization"><a class="anchor" href="#_serialization"></a>19. Serialization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast needs to serialize the Java objects that you put into Hazelcast because
Hazelcast is a distributed system. The data and its replicas are
stored in different partitions on multiple cluster members.
The data you need may not be present on the local member, and in that case,
Hazelcast retrieves that data from another member. This requires serialization.</p>
</div>
<div class="paragraph">
<p>Serialization is used in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adding key/value objects to a map</p>
</li>
<li>
<p>Putting items in a queue/set/list</p>
</li>
<li>
<p>Sending a runnable using an executor service</p>
</li>
<li>
<p>Processing an entry within a map</p>
</li>
<li>
<p>Locking an object</p>
</li>
<li>
<p>Sending a message to a topic</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hazelcast optimizes the serialization for the basic types and their array types.
You cannot override this behavior.</p>
</div>
<div class="paragraph">
<p>The following are the default types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Byte</code>, <code>Boolean</code>, <code>Character</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>String</code></p>
</li>
<li>
<p><code>byte[]</code>, <code>boolean[]</code>, <code>char[]</code>, <code>short[]</code>, <code>int[]</code>, <code>long[]</code>, <code>float[]</code>, <code>double[]</code>, <code>String[]</code></p>
</li>
<li>
<p><code>java.util.Date</code>, <code>java.math.BigInteger</code>, <code>java.math.BigDecimal</code>, <code>java.lang.Class</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hazelcast optimizes all of the above object types. You do not need to worry about their (de)serializations.</p>
</div>
<div class="sect2">
<h3 id="_serialization_interface_types"><a class="anchor" href="#_serialization_interface_types"></a>19.1. Serialization Interface Types</h3>
<div class="paragraph">
<p>For complex objects, use the following interfaces for serialization and deserialization:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.io.Serializable</code>: See the <a href="#implementing-java-serializable-and-externalizable">Implementing Java Serializable and Externalizable section</a>.</p>
</li>
<li>
<p><code>java.io.Externalizable</code>: See the <a href="#implementing-java-externalizable">Implementing Java Externalizable section</a>.</p>
</li>
<li>
<p><code>com.hazelcast.nio.serialization.DataSerializable</code>: See the <a href="#implementing-dataserializable">Implementing DataSerializable section</a>.</p>
</li>
<li>
<p><code>com.hazelcast.nio.serialization.IdentifiedDataSerializable</code>: See the <a href="#identifieddataserializable">IdentifiedDataSerializable section</a>.</p>
</li>
<li>
<p><code>com.hazelcast.nio.serialization.Portable</code>: See the <a href="#implementing-portable-serialization">Implementing Portable Serialization section</a>.</p>
</li>
<li>
<p>Custom Serialization (using <a href="#implementing-streamserializer">StreamSerializer</a> and <a href="#implementing-bytearrayserializer">ByteArraySerializer</a>).</p>
</li>
<li>
<p>Global Serializer: See the <a href="#global-serializer">Global Serializer section</a> for details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When Hazelcast serializes an object:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It first checks whether the object is <code>null</code>.</p>
</li>
<li>
<p>If the above check fails, then Hazelcast checks if it is an instance of <code>com.hazelcast.nio.serialization.DataSerializable</code> or <code>com.hazelcast.nio.serialization.IdentifiedDataSerializable</code>.</p>
</li>
<li>
<p>If the above check fails, then Hazelcast checks if it is an instance of <code>com.hazelcast.nio.serialization.Portable</code>.</p>
</li>
<li>
<p>If the above check fails, then Hazelcast checks if it is an instance of one of
the default types (see the <a href="#serialization">Serialization chapter introduction</a> for default types).</p>
</li>
<li>
<p>If the above check fails, then Hazelcast looks for a user-specified <a href="#custom-serialization">Custom Serializer</a>,
i.e. an implementation of <code>ByteArraySerializer</code> or <code>StreamSerializer</code>.
Custom serializer is searched using the input Object&#8217;s Class and its parent class up to Object.
If parent class search fails, all interfaces implemented by the class are also checked (excluding <code>java.io.Serializable</code> and <code>java.io.Externalizable</code>).</p>
</li>
<li>
<p>If the above check fails, then Hazelcast checks if it is an instance of <code>java.io.Serializable</code> or
<code>java.io.Externalizable</code> and a Global Serializer is not registered with Java Serialization Override feature.</p>
</li>
<li>
<p>If the above check fails, Hazelcast uses the registered Global Serializer if one exists.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If all of the above checks fail, then serialization fails.
When a class implements multiple interfaces, the above steps are important
to determine the serialization mechanism that Hazelcast uses.
When a class definition is required for any of these serializations, you need to have
all the classes needed by the application on your classpath because Hazelcast does not
download them automatically, unless you are using <a href="#member-user-code-deployment">user code deployment</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_comparing_serialization_interfaces"><a class="anchor" href="#_comparing_serialization_interfaces"></a>19.2. Comparing Serialization Interfaces</h3>
<div class="paragraph">
<p>The table below provides a comparison between the interfaces listed in the previous section
to help you in deciding which interface to use in your applications.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 10%;">
<col style="width: 40%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Serialization Interface</th>
<th class="tableblock halign-left valign-top">Advantages</th>
<th class="tableblock halign-left valign-top">Drawbacks</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Serializable</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>A standard and basic Java interface</p>
</li>
<li>
<p>Requires no implementation</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>More time and CPU usage</p>
</li>
<li>
<p>More space occupancy</p>
</li>
<li>
<p>Not supported by Native clients</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Externalizable</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>A standard Java interface</p>
</li>
<li>
<p>More CPU and memory usage efficient than Serializable</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Serialization interface must be implemented</p>
</li>
<li>
<p>Not supported by Native clients</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DataSerializable</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>More CPU and memory usage efficient than Serializable</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Specific to Hazelcast</p>
</li>
<li>
<p>Not supported by Native clients</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IdentifiedDataSerializable</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>More CPU and memory usage efficient than Serializable</p>
</li>
<li>
<p>Reflection is not used during deserialization</p>
</li>
<li>
<p>Supported by all Native Clients</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Specific to Hazelcast</p>
</li>
<li>
<p>Serialization interface must be implemented</p>
</li>
<li>
<p>A Factory and configuration must be implemented</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Portable</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>More CPU and memory usage efficient than Serializable</p>
</li>
<li>
<p>Reflection is not used during deserialization</p>
</li>
<li>
<p>Versioning is supported</p>
</li>
<li>
<p>Partial deserialization is supported during Queries</p>
</li>
<li>
<p>Supported by all Native Clients</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Specific to Hazelcast</p>
</li>
<li>
<p>Serialization interface must be implemented</p>
</li>
<li>
<p>A Factory and configuration must be implemented</p>
</li>
<li>
<p>Class definition is also sent with data but stored only once per class</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom Serialization</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Does not require class to implement an interface</p>
</li>
<li>
<p>Convenient and flexible</p>
</li>
<li>
<p>Can be based on StreamSerializer ByteArraySerializer</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Serialization interface must be implemented</p>
</li>
<li>
<p>Plug in and configuration is required</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Let&#8217;s dig into the details of the above serialization mechanisms in the following sections.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_java_serializable_and_externalizable"><a class="anchor" href="#_implementing_java_serializable_and_externalizable"></a>19.3. Implementing Java Serializable and Externalizable</h3>
<div class="paragraph">
<p>A class often needs to implement the <code>java.io.Serializable</code> interface; native Java serialization is the easiest way to do serialization.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at the example code below for Java Serializable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee implements Serializable {
    private static final long serialVersionUID = 1L;
    private String surname;

    public Employee( String surname ) {
        this.surname = surname;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the fields that are non-static and non-transient are automatically serialized.
To eliminate class compatibility issues, it is recommended that you add a <code>serialVersionUID</code>, as shown above.
Also, when you are using methods that perform byte-content comparisons, such as <code>IMap.replace()</code>,
and if byte-content of equal objects is different, you may face unexpected behaviors.
For example, if the class relies on a hash map, the <code>replace</code> method may fail.
The reason for this is the hash map is a serialized data structure with unreliable byte-content.</p>
</div>
<div class="sect3">
<h4 id="_implementing_java_externalizable"><a class="anchor" href="#_implementing_java_externalizable"></a>19.3.1. Implementing Java Externalizable</h4>
<div class="paragraph">
<p>Hazelcast also supports <code>java.io.Externalizable</code>. This interface offers more control
on the way fields are serialized or deserialized. Compared to native Java serialization,
it also can have a positive effect on performance. With <code>java.io.Externalizable</code>, there is no need to add <code>serialVersionUID</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at the example code below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee implements Externalizable {
    private String surname;
    public Employee(String surname) {
        this.surname = surname;
    }

    @Override
    public void readExternal( ObjectInput in )
      throws IOException, ClassNotFoundException {
        this.surname = in.readUTF();
    }

    @Override
    public void writeExternal( ObjectOutput out )
      throws IOException {
        out.writeUTF(surname);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You explicitly perform writing and reading of fields. Perform reading in the same order as writing.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_dataserializable"><a class="anchor" href="#_implementing_dataserializable"></a>19.4. Implementing DataSerializable</h3>
<div class="paragraph">
<p>As mentioned in <a href="#implementing-java-serializable-and-externalizable">Implementing Java Serializable &amp; Externalizable</a>,
Java serialization is an easy mechanism.
However, it does not control how fields are serialized or deserialized.
Moreover, Java serialization can lead to excessive CPU loads since it keeps track of
objects to handle the cycles and streams class descriptors. These are performance decreasing factors;
thus, serialized data may not have an optimal size.</p>
</div>
<div class="paragraph">
<p>The <code>DataSerializable</code> interface of Hazelcast overcomes these issues.
Here is an example of a class implementing the <code>com.hazelcast.nio.serialization.DataSerializable</code> interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Address implements DataSerializable {
    private String street;
    private int zipCode;
    private String city;
    private String state;

    public Address() {}

    //getters setters..

    public void writeData( ObjectDataOutput out ) throws IOException {
        out.writeUTF(street);
        out.writeInt(zipCode);
        out.writeUTF(city);
        out.writeUTF(state);
    }

    public void readData( ObjectDataInput in ) throws IOException {
        street = in.readUTF();
        zipCode = in.readInt();
        city = in.readUTF();
        state = in.readUTF();
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_reading_and_writing_and_dataserializable"><a class="anchor" href="#_reading_and_writing_and_dataserializable"></a>19.4.1. Reading and Writing and DataSerializable</h4>
<div class="paragraph">
<p>Let&#8217;s take a look at another example which encapsulates a <code>DataSerializable</code> field.</p>
</div>
<div class="paragraph">
<p>Since the <code>address</code> field itself is <code>DataSerializable</code>, it calls <code>address.writeData(out)</code>
when writing and <code>address.readData(in)</code> when reading. Also note that you should have writing and reading of the fields occur
in the same order. When Hazelcast serializes a <code>DataSerializable</code>, it writes the <code>className</code> first.
When Hazelcast deserializes it, <code>className</code> is used to instantiate the object using reflection.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee implements DataSerializable {
    private String firstName;
    private String lastName;
    private int age;
    private double salary;
    private Address address; //address itself is DataSerializable

    public Employee() {}

    //getters setters..

    public void writeData( ObjectDataOutput out ) throws IOException {
        out.writeUTF(firstName);
        out.writeUTF(lastName);
        out.writeInt(age);
        out.writeDouble (salary);
        address.writeData (out);
    }

    public void readData( ObjectDataInput in ) throws IOException {
        firstName = in.readUTF();
        lastName = in.readUTF();
        age = in.readInt();
        salary = in.readDouble();
        address = new Address();
        // since Address is DataSerializable let it read its own internal state
        address.readData(in);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, since the <code>address</code> field itself is <code>DataSerializable</code>,
it calls <code>address.writeData(out)</code> when writing and <code>address.readData(in)</code> when reading.
Also note that you should have writing and reading of the fields occur in the same order.
While Hazelcast serializes a <code>DataSerializable</code>, it writes the <code>className</code> first.
When Hazelcast deserializes it, <code>className</code> is used to instantiate the object using reflection.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since Hazelcast needs to create an instance during the deserialization,<code>DataSerializable</code> class has a no-arg constructor.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>DataSerializable</code> is a good option if serialization is only needed for in-cluster communication.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>DataSerializable</code> is not supported by non-Java clients as it uses Java reflection.
If you need non-Java clients, please use <a href="#identifieddataserializable">IdentifiedDataSerializable</a> or
<a href="#implementing-portable-serialization">Portable</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_identifieddataserializable"><a class="anchor" href="#_identifieddataserializable"></a>19.4.2. IdentifiedDataSerializable</h4>
<div class="paragraph">
<p>For a faster serialization of objects, avoiding reflection and long class names,
Hazelcast recommends you implement <code>com.hazelcast.nio.serialization.IdentifiedDataSerializable</code>
which is a slightly better version of <code>DataSerializable</code>.</p>
</div>
<div class="paragraph">
<p><code>DataSerializable</code> uses reflection to create a class instance, as mentioned in
<a href="#implementing-dataserializable">Implementing DataSerializable</a>.
But <code>IdentifiedDataSerializable</code> uses a factory for this purpose and
it is faster during deserialization, which requires new instance creations.</p>
</div>
<div class="sect4">
<h5 id="_getclassid_and_getfactoryid_methods"><a class="anchor" href="#_getclassid_and_getfactoryid_methods"></a>getClassId and getFactoryId Methods</h5>
<div class="paragraph">
<p><code>IdentifiedDataSerializable</code> extends <code>DataSerializable</code> and introduces the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>int getClassId();</code></p>
</li>
<li>
<p><code>int getFactoryId();</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>IdentifiedDataSerializable</code> uses <code>getClassId()</code> instead of class name and it uses
<code>getFactoryId()</code> to load the class when given the id. To complete the implementation,
you should also implement  <code>com.hazelcast.nio.serialization.DataSerializableFactory</code> and
register it into <code>SerializationConfig</code>, which can be accessed from <code>Config.getSerializationConfig()</code>.
Factory&#8217;s responsibility is to return an instance of the right <code>IdentifiedDataSerializable</code> object, given the id.
This is currently the most efficient way of Serialization that Hazelcast supports off the shelf.</p>
</div>
</div>
<div class="sect4">
<h5 id="_implementing_identifieddataserializable"><a class="anchor" href="#_implementing_identifieddataserializable"></a>Implementing IdentifiedDataSerializable</h5>
<div class="paragraph">
<p>Let&#8217;s take a look at the following example code and configuration to see <code>IdentifiedDataSerializable</code> in action.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee
    implements IdentifiedDataSerializable {

    private String surname;

    public Employee() {}

    public Employee( String surname ) {
        this.surname = surname;
    }

    @Override
    public void readData( ObjectDataInput in )
      throws IOException {
        this.surname = in.readUTF();
    }

    @Override
    public void writeData( ObjectDataOutput out )
      throws IOException {
        out.writeUTF( surname );
    }

    @Override
    public int getFactoryId() {
        return EmployeeDataSerializableFactory.FACTORY_ID;
    }

    @Override
    public int getClassId() {
        return EmployeeDataSerializableFactory.EMPLOYEE_TYPE;
    }

    @Override
    public String toString() {
        return String.format( "Employee(surname=%s)", surname );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The methods <code>getClassId</code> and <code>getFactoryId</code> return a unique positive number within
the <code>EmployeeDataSerializableFactory</code>.
Now, let&#8217;s create an instance of this <code>EmployeeDataSerializableFactory</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class EmployeeDataSerializableFactory
    implements DataSerializableFactory{

    public static final int FACTORY_ID = 1;

    public static final int EMPLOYEE_TYPE = 1;

    @Override
    public IdentifiedDataSerializable create(int typeId) {
        if ( typeId == EMPLOYEE_TYPE ) {
            return new Employee();
        } else {
            return null;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only method you should implement is <code>create</code>, as seen in the above example.
It is recommended that you use a <code>switch-case</code> statement instead of
multiple <code>if-else</code> blocks if you have a lot of subclasses.
Hazelcast throws an exception if null is returned for <code>typeId</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_registering_employeedataserializablefactory"><a class="anchor" href="#_registering_employeedataserializablefactory"></a>Registering EmployeeDataSerializableFactory</h5>
<div class="paragraph">
<p>As the last step, you need to register <code>EmployeeDataSerializableFactory</code> declaratively
(declare in the configuration file <code>hazelcast.xml/yaml</code>) as shown below.
Note that <code>factory-id</code> has the same value of <code>FACTORY_ID</code> in the above code.
This is crucial to enable Hazelcast to find the correct factory.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;serialization&gt;
        &lt;data-serializable-factories&gt;
            &lt;data-serializable-factory factory-id="1"&gt;
                EmployeeDataSerializableFactory
            &lt;/data-serializable-factory&gt;
        &lt;/data-serializable-factories&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    data-serializable-factories:
      - factory-id: 1
        class-name: EmployeeDataSerializableFactory</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#serialization-configuration-wrap-up">Serialization Configuration Wrap-Up section</a>
for a full description of Hazelcast Serialization configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using a client/server deployment, you also need to register the implemented factory on
the client side. For a Java client, the process is the same as described above to be performed
in the client configuration, e.g., <code>hazelcast-client.xml/yaml</code>.
For the other Hazelcast clients, see the following for details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-csharp-client#41-identifieddataserializable-serialization" target="_blank" rel="noopener">.NET</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-cpp-client#41-identifieddataserializable-serialization" target="_blank" rel="noopener">C++</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-nodejs-client#41-identifieddataserializable-serialization" target="_blank" rel="noopener">Node.js</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-python-client#41-identifieddataserializable-serialization" target="_blank" rel="noopener">Python</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-go-client#41-identifieddataserializable-serialization" target="_blank" rel="noopener">Go</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_portable_serialization"><a class="anchor" href="#_implementing_portable_serialization"></a>19.5. Implementing Portable Serialization</h3>
<div class="paragraph">
<p>As an alternative to the existing serialization methods, Hazelcast offers
a language/platform independent Portable serialization that has the following advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>support for multi-version of the same object type</p>
</li>
<li>
<p>fetching individual fields without having to rely on reflection</p>
</li>
<li>
<p>queries and indexing support without deserialization and/or reflection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to support these features, a serialized Portable object contains
meta information like the version and the concrete location of the each field in the binary data.
This way, Hazelcast navigates in the <code>byte[]</code> and deserializes only
the required field without actually deserializing the whole object.
This improves the Query performance.</p>
</div>
<div class="paragraph">
<p>With multi-version support, you can have two cluster members where
each has different versions of the same object. Hazelcast stores both
meta information and uses the correct one to serialize and deserialize Portable objects depending on the member.
This is very helpful when you are doing a rolling upgrade without shutting down the cluster.</p>
</div>
<div class="paragraph">
<p>Portable serialization is totally language independent and is used as
the binary protocol between Hazelcast server and clients.</p>
</div>
<div class="sect3">
<h4 id="_portable_serialization_example_code"><a class="anchor" href="#_portable_serialization_example_code"></a>19.5.1. Portable Serialization Example Code</h4>
<div class="paragraph">
<p>Here is example code for Portable implementation of a Foo class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Foo implements Portable {
    final static int ID = 5;

    private String foo;

    public String getFoo() {
        return foo;
    }

    public void setFoo( String foo ) {
        this.foo = foo;
    }

    @Override
    public int getFactoryId() {
        return 1;
    }

    @Override
    public int getClassId() {
        return ID;
    }

    @Override
    public void writePortable( PortableWriter writer ) throws IOException {
        writer.writeUTF( "foo", foo );
    }

    @Override
    public void readPortable( PortableReader reader ) throws IOException {
        foo = reader.readUTF( "foo" );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar to <code>IdentifiedDataSerializable</code>, a Portable Class must provide <code>classId</code> and <code>factoryId</code>.
The Factory object creates the Portable object given the <code>classId</code>.</p>
</div>
<div class="paragraph">
<p>An example <code>Factory</code> could be implemented as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyPortableFactory implements PortableFactory {

    @Override
    public Portable create( int classId ) {
        if ( Foo.ID == classId )
        return new Foo();
        else
        return null;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_registering_the_portable_factory"><a class="anchor" href="#_registering_the_portable_factory"></a>19.5.2. Registering the Portable Factory</h4>
<div class="paragraph">
<p>The last step is to register the <code>Factory</code> to the <code>SerializationConfig</code>.
Below are the programmatic and declarative configurations for this step.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.getSerializationConfig().addPortableFactory( 1, new MyPortableFactory() );</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;serialization&gt;
        &lt;portable-version&gt;0&lt;/portable-version&gt;
        &lt;portable-factories&gt;
            &lt;portable-factory factory-id="1"&gt;
                com.hazelcast.examples.PortableFactory
            &lt;/portable-factory&gt;
        &lt;/portable-factories&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    portable-version: 0
    portable-factories:
      - factory-id: 1
        class-name: com.hazelcast.examples.PortableFactory</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>id</code> that is passed to the <code>SerializationConfig</code> is the same
as the <code>factoryId</code> that the <code>Foo</code> class returns.</p>
</div>
<div class="paragraph">
<p>When using a client/server deployment, you also need to register the implemented factory on
the client side. For a Java client, the process is the same as described above to be performed
in the client configuration, e.g., <code>hazelcast-client.xml/yaml</code>.
For the other Hazelcast clients, see the following for details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-csharp-client#42-portable-serialization" target="_blank" rel="noopener">.NET</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-cpp-client#42-portable-serialization" target="_blank" rel="noopener">C++</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-nodejs-client#42-portable-serialization" target="_blank" rel="noopener">Node.js</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-python-client#42-portable-serialization" target="_blank" rel="noopener">Python</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-go-client#42-portable-serialization" target="_blank" rel="noopener">Go</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_versioning_for_portable_serialization"><a class="anchor" href="#_versioning_for_portable_serialization"></a>19.5.3. Versioning for Portable Serialization</h4>
<div class="paragraph">
<p>More than one version of the same class may need to be serialized and deserialized.
For example, a client may have an older version of a class and the member to which
it is connected may have a newer version of the same class.</p>
</div>
<div class="paragraph">
<p>Portable serialization supports versioning.
It is a global versioning, meaning that all portable classes that
are serialized through a member get the globally configured portable version.</p>
</div>
<div class="paragraph">
<p>You can declare the version in the XML or YAML configuration file using
the <code>portable-version</code> element, as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;serialization&gt;
        &lt;portable-version&gt;1&lt;/portable-version&gt;
        &lt;portable-factories&gt;
            &lt;portable-factory factory-id="1"&gt;
                PortableFactoryImpl
            &lt;/portable-factory&gt;
        &lt;/portable-factories&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    portable-version: 1
    portable-factories:
      - factory-id: 1
        class-name: PortableFactoryImpl</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the interface
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/nio/serialization/VersionedPortable.html" target="_blank" rel="noopener">VersionedPortable</a>
which enables to upgrade the version per class, instead of global versioning.
If you need to update only one class, you can use this interface.
In this case, your class should implement <code>VersionedPortable</code> instead of <code>Portable</code>,
and you can give the desired version using the method <code>VersionedPortable.getClassVersion()</code>.</p>
</div>
<div class="paragraph">
<p>You should consider the following when you perform versioning:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is important to change the version whenever an update is performed
in the serialized fields of a class, for example by incrementing the version.</p>
</li>
<li>
<p>If a client performs a Portable deserialization on a field and then
that Portable is updated by removing that field on the cluster side, this may lead to a problem.</p>
</li>
<li>
<p>Portable serialization does not use reflection and hence,
fields in the class and in the serialized content are not automatically mapped.
Field renaming is a simpler process. Also, since the class ID is stored,
renaming the Portable does not lead to problems.</p>
</li>
<li>
<p>Types of fields need to be updated carefully.
Hazelcast performs basic type upgradings, such as <code>int</code> to <code>float</code>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_example_portable_versioning_scenarios"><a class="anchor" href="#_example_portable_versioning_scenarios"></a>Example Portable Versioning Scenarios</h5>
<div class="paragraph">
<p>Assume that a new member joins to the cluster with a class that
has been modified and class' version has been upgraded due to this modification.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you modified the class by adding a new field, the new member&#8217;s <code>put</code>
operations include that new field. If this new member tries to get an object that
was put from the older members, it gets <code>null</code> for the newly added field.</p>
</li>
<li>
<p>If you modified the class by removing a field, the old members get <code>null</code> for the objects that are put by the new member.</p>
</li>
<li>
<p>If you modified the class by changing the type of a field, the error <code>IncompatibleClassChangeError</code>
is generated unless the change was made on a built-in type or
the byte size of the new type is less than or equal to the old one.
The following are examples of allowed type conversions:</p>
<div class="ulist">
<ul>
<li>
<p><code>long</code> &#8594; <code>int</code>, <code>byte</code>, <code>char</code>, <code>short</code></p>
</li>
<li>
<p><code>int</code>&#8594; <code>byte</code>, <code>char</code>, <code>short</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you have not modify a class at all, it works as usual.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ordering_consistency_for_writeportable"><a class="anchor" href="#_ordering_consistency_for_writeportable"></a>19.5.4. Ordering Consistency for <code>writePortable</code></h4>
<div class="paragraph">
<p>Independent of the member-member or member-client communications, the method <code>writePortable()</code> of
the classes that implement <code>Portable</code> should be consistent.
This means, the fields listed under the method <code>writePortable()</code> should be
in the same order for all involved members and/or clients.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following <code>Employee</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class EmployeePortable implements Portable {

    private String name;
    private int age;

    public EmployeePortable() {
    }

    public EmployeePortable(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getFactoryId() {
        return 666;
    }

    public int getClassId() {
        return 2;
    }

    public void writePortable(PortableWriter writer) throws IOException {
        writer.writeUTF("n", name);
        writer.writeInt("a", age);
    }

    public void readPortable(PortableReader reader) throws IOException {
        name = reader.readUTF("n");
        age = reader.readInt("a");
    }

    public int getAge() {
        return age;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see in the above example, first the <code>name</code> and then the <code>age</code> is written.
This order should be preserved in other members or clients.</p>
</div>
</div>
<div class="sect3">
<h4 id="_null_portable_serialization"><a class="anchor" href="#_null_portable_serialization"></a>19.5.5. Null Portable Serialization</h4>
<div class="paragraph">
<p>Be careful with serializing null portables. Hazelcast lazily creates a class definition of portable internally
when the user first serializes. This class definition is stored and used later for deserializing that portable class. When
the user tries to serialize a null portable when there is no class definition at the moment, Hazelcast throws an
exception saying that <code>com.hazelcast.nio.serialization.HazelcastSerializationException: Cannot write null portable
without explicitly registering class definition!</code>.</p>
</div>
<div class="paragraph">
<p>There are two solutions to get rid of this exception. Either put
a non-null portable class of the same type before any other operation,
or manually register a class definition in serialization configuration as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
final ClassDefinition classDefinition = new ClassDefinitionBuilder(Foo.factoryId, Foo.getClassId)
                       .addUTFField("foo").build();
config.getSerializationConfig().addClassDefinition(classDefinition);
Hazelcast.newHazelcastInstance(config);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_distributedobject_serialization"><a class="anchor" href="#_distributedobject_serialization"></a>19.5.6. DistributedObject Serialization</h4>
<div class="paragraph">
<p>Putting a <code>DistributedObject</code> (Hazelcast Semaphore, Queue, etc.) in a cluster member and
getting it from another one is not a straightforward operation.
Passing the ID and type of the <code>DistributedObject</code> can be a solution.
For deserialization, you can get the object from HazelcastInstance.
For instance, if your object is an instance of <code>IQueue</code>, you can either use
<code>HazelcastInstance.getQueue(id)</code> or <code>Hazelcast.getDistributedObject</code>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>HazelcastInstanceAware</code> interface in the case of
a deserialization of a Portable <code>DistributedObject</code> if it gets an ID to be looked up.
HazelcastInstance is set after deserialization, so you first need to store the ID and
then retrieve the <code>DistributedObject</code> using the <code>setHazelcastInstance</code> method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#serialization-configuration-wrap-up">Serialization Configuration Wrap-Up section</a>
for a full description of Hazelcast Serialization configuration elements.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_serialization"><a class="anchor" href="#_custom_serialization"></a>19.6. Custom Serialization</h3>
<div class="paragraph">
<p>Hazelcast lets you plug in a custom serializer for serializing your objects.
You can use <a href="#implementing-streamserializer">StreamSerializer</a> and
<a href="#implementing-bytearrayserializer">ByteArraySerializer</a> interfaces for this purpose.</p>
</div>
<div class="sect3">
<h4 id="_implementing_streamserializer"><a class="anchor" href="#_implementing_streamserializer"></a>19.6.1. Implementing StreamSerializer</h4>
<div class="paragraph">
<p>You can use a stream to serialize and deserialize data by using <code>StreamSerializer</code>.
This is a good option for your own implementations.
It can also be adapted to external serialization libraries like Kryo, JSON and protocol buffers.</p>
</div>
<div class="sect4">
<h5 id="_streamserializer_example_code_1"><a class="anchor" href="#_streamserializer_example_code_1"></a>StreamSerializer Example Code 1</h5>
<div class="paragraph">
<p>First, let&#8217;s create a simple object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class EmployeeSS {
    private String surname;
    private String name;

    public EmployeeSS( String surname ) {
        this.surname = surname;
    }

    public String getSurname() {
        return surname;
    }
    public String getName() {
        return name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s implement StreamSerializer for <code>Employee</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class EmployeeStreamSerializer
        implements StreamSerializer&lt;EmployeeSS&gt; {

    @Override
    public int getTypeId () {
        return 1;
    }

    @Override
    public void write( ObjectDataOutput out, EmployeeSS employee )
            throws IOException {
        out.writeUTF(employee.getSurname());
    }

    @Override
    public EmployeeSS read( ObjectDataInput in )
            throws IOException {
        String surname = in.readUTF();
        return new EmployeeSS(surname);
    }

    @Override
    public void destroy () {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In practice, classes may have many fields.
Just make sure the fields are read in the same order as they are written.
The type ID must be unique and greater than or equal to <strong>1</strong>.
Uniqueness of the type ID enables Hazelcast to determine which serializer is used during deserialization.</p>
</div>
<div class="paragraph">
<p>As the last step, let&#8217;s register the <code>EmployeeStreamSerializer</code> in
the configuration file <code>hazelcast.xml/yaml</code>, as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;serialization&gt;
        &lt;serializers&gt;
            &lt;serializer type-class="EmployeeSS" class-name="EmployeeStreamSerializer" /&gt;
        &lt;/serializers&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    serializers:
      - type-class: EmployeeSS
        class-name: EmployeeStreamSerializer</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>StreamSerializer</code> cannot be created for well-known types, such as Long and String and primitive arrays.
Hazelcast already registers these types.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_streamserializer_example_code_2"><a class="anchor" href="#_streamserializer_example_code_2"></a>StreamSerializer Example Code 2</h5>
<div class="paragraph">
<p>Let&#8217;s take a look at another example implementing <code>StreamSerializer</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Foo {
    private String foo;

    public String getFoo() {
        return foo;
    }

    public void setFoo( String foo ) {
        this.foo = foo;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assume that our custom serialization serializes
Foo into XML. First you need to implement a
<code>com.hazelcast.nio.serialization.StreamSerializer</code>.
A very simple one that uses XMLEncoder and XMLDecoder could look like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class FooXmlSerializer implements StreamSerializer&lt;Foo&gt; {

    @Override
    public int getTypeId() {
        return 10;
    }

    public void write( ObjectDataOutput out, Foo object ) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        XMLEncoder encoder = new XMLEncoder( bos );
        encoder.writeObject( object );
        encoder.close();
        out.write( bos.toByteArray() );
    }

    public Foo read( ObjectDataInput in ) throws IOException {
        InputStream inputStream = (InputStream) in;
        XMLDecoder decoder = new XMLDecoder( inputStream );
        return (Foo) decoder.readObject();
    }

    public void destroy() {
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_streamserializer"><a class="anchor" href="#_configuring_streamserializer"></a>Configuring StreamSerializer</h5>
<div class="paragraph">
<p>Note that <code>typeId</code> must be unique because Hazelcast uses it to
look up the <code>StreamSerializer</code> while it deserializes the object.
The last required step is to register the <code>StreamSerializer</code> in your Hazelcast configuration.
Below are the programmatic and declarative configurations for this step.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SerializerConfig sc = new SerializerConfig()
    .setImplementation(new FooXmlSerializer())
    .setTypeClass(Foo.class);
Config config = new Config();
config.getSerializationConfig().addSerializerConfig(sc);</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;serialization&gt;
        &lt;serializers&gt;
            &lt;serializer type-class="com.www.Foo" class-name="com.www.FooXmlSerializer" /&gt;
        &lt;/serializers&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    serializers:
      - type-class: com.www.Foo
        class-name: com.www.FooXmlSerializer</code></pre>
</div>
</div>
<div class="paragraph">
<p>From now on, this Hazelcast example will use <code>FooXmlSerializer</code>
to serialize Foo objects. In this way, you can write an adapter (StreamSerializer) for any
Serialization framework and plug it into Hazelcast.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#serialization-configuration-wrap-up">Serialization Configuration Wrap-Up section</a>
for a full description of Hazelcast Serialization configuration elements.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_bytearrayserializer"><a class="anchor" href="#_implementing_bytearrayserializer"></a>19.6.2. Implementing ByteArraySerializer</h4>
<div class="paragraph">
<p><code>ByteArraySerializer</code> exposes the raw ByteArray used internally by Hazelcast.
It is a good option if the serialization library you are using deals with ByteArrays instead of streams.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s implement <code>ByteArraySerializer</code> for the <code>Employee</code> class mentioned in
<a href="#implementing-streamserializer">Implementing StreamSerializer</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class EmployeeByteArraySerializer
        implements ByteArraySerializer&lt;EmployeeSS&gt; {

    @Override
    public void destroy () {
    }

    @Override
    public int getTypeId () {
        return 1;
    }

    @Override
    public byte[] write( EmployeeSS object )
            throws IOException {
        return object.getName().getBytes();
    }

    @Override
    public EmployeeSS read( byte[] buffer )
            throws IOException {
        String surname = new String( buffer );
        return new EmployeeSS( surname );
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_bytearrayserializer"><a class="anchor" href="#_configuring_bytearrayserializer"></a>Configuring ByteArraySerializer</h5>
<div class="paragraph">
<p>As usual, let&#8217;s register the <code>EmployeeByteArraySerializer</code> in the configuration file <code>hazelcast.xml/yaml</code>, as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;serialization&gt;
        &lt;serializers&gt;
            &lt;serializer type-class="Employee"&gt;EmployeeByteArraySerializer&lt;/serializer&gt;
        &lt;/serializers&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    serializers:
      - type-class: Employee
        class-name: EmployeeByteArraySerializer</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#serialization-configuration-wrap-up">Serialization Configuration Wrap-Up section</a>
for a full description of Hazelcast Serialization configuration elements.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_global_serializer"><a class="anchor" href="#_global_serializer"></a>19.7. Global Serializer</h3>
<div class="paragraph">
<p>The global serializer is identical to
<a href="#custom-serialization">custom serializers</a> from the implementation perspective.
The global serializer is registered as a fallback serializer to handle all other objects if a serializer cannot be located for them.</p>
</div>
<div class="paragraph">
<p>By default, the global serializer does not handle <code>java.io.Serializable</code> and <code>java.io.Externalizable</code> instances.
However, you can configure it to be responsible for those instances.</p>
</div>
<div class="paragraph">
<p>A custom serializer should be registered for a specific class type.
The global serializer handles all class types if all the steps in searching for
a serializer fail as described in <a href="#serialization-interface-types">Serialization Interface Types</a>.</p>
</div>
<div class="paragraph">
<p>The following are some use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Third party serialization frameworks can be integrated using the global serializer.</p>
</li>
<li>
<p>For your custom objects, you can implement a single serializer to handle all of them.</p>
</li>
<li>
<p>You can replace the internal Java serialization by enabling the
<code>overrideJavaSerialization</code> option of the global serializer configuration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any custom serializer can be used as the global serializer.
See the <a href="#custom-serialization">Custom Serialization section</a> for implementation details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To function properly, Hazelcast needs the Java serializable objects to be handled correctly.
If the global serializer is configured to handle the Java serialization, the global serializer must
properly serialize/deserialize the <code>java.io.Serializable</code> instances. Otherwise, it causes Hazelcast to malfunction.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="sample-global-serializer"><a class="anchor" href="#sample-global-serializer"></a>19.7.1. Example Global Serializer</h4>
<div class="paragraph">
<p>An example global serializer that integrates with a third party serializer is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class GlobalStreamSerializer
    implements StreamSerializer&lt;Object&gt; {

    private SomeThirdPartySerializer someThirdPartySerializer;

    private init() {
        //someThirdPartySerializer  = ...
    }

    @Override
    public int getTypeId () {
        return 123;
    }

    @Override
    public void write( ObjectDataOutput out, Object object ) throws IOException {
        byte[] bytes = someThirdPartySerializer.encode(object);
        out.writeByteArray(bytes);
    }

    @Override
    public Object read( ObjectDataInput in ) throws IOException {
        byte[] bytes = in.readByteArray();
        return someThirdPartySerializer.decode(bytes);
    }

    @Override
    public void destroy () {
        someThirdPartySerializer.destroy();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we can register the global serializer in the configuration file <code>hazelcast.xml/yaml</code>, as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;serialization&gt;
        &lt;serializers&gt;
            &lt;global-serializer override-java-serialization="true"&gt;GlobalStreamSerializer&lt;/global-serializer&gt;
        &lt;/serializers&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    global-serializer:
      override-java-serialization: true
      class-name: GlobalStreamSerializer</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_hazelcastinstanceaware"><a class="anchor" href="#_implementing_hazelcastinstanceaware"></a>19.8. Implementing HazelcastInstanceAware</h3>
<div class="paragraph">
<p>You can implement the <code>HazelcastInstanceAware</code> interface to access
distributed objects for cases where an object is deserialized and needs access to HazelcastInstance.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s implement it for the <code>Employee</code> class mentioned in the
<a href="#custom-serialization">Custom Serialization section</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonAwr implements Serializable, HazelcastInstanceAware {

    private static final long serialVersionUID = 1L;

    private String name;

    private transient HazelcastInstance hazelcastInstance;

    PersonAwr(String name) {
        this.name = name;
    }

    public HazelcastInstance getHazelcastInstance() {
        return hazelcastInstance;
    }

    @Override
    public void setHazelcastInstance(HazelcastInstance hz) {
        this.hazelcastInstance = hz;
        System.out.println("hazelcastInstance set");
    }

    @Override
    public String toString() {
        return String.format("Person(name=%s)", name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After deserialization, the object is checked to see if it implements
<code>HazelcastInstanceAware</code> and the method <code>setHazelcastInstance</code> is called.
Notice the <code>hazelcastInstance</code> is <code>transient</code>. This is because this field should not be serialized.</p>
</div>
<div class="paragraph">
<p>It may be a good practice to inject a HazelcastInstance into a domain object,
e.g., <code>Employee</code> in the above example, when used together with <code>Runnable</code>/<code>Callable</code> implementations.
These runnables/callables are executed by <code>IExecutorService</code> which sends them to another machine.
And after a task is deserialized, run/call method implementations need to access HazelcastInstance.</p>
</div>
<div class="paragraph">
<p>We recommend you only set the HazelcastInstance field while using
<code>setHazelcastInstance</code> method and you not execute operations on the HazelcastInstance.
The reason is that when HazelcastInstance is injected for a <code>HazelcastInstanceAware</code> implementation,
it may not be up and running at the injection time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_untrusted_deserialization_protection"><a class="anchor" href="#_untrusted_deserialization_protection"></a>19.9. Untrusted Deserialization Protection</h3>
<div class="paragraph">
<p>Hazelcast offers a Java deserialization protection based on whitelisting and blacklisting the class/package names.
These listings support prefixes.</p>
</div>
<div class="paragraph">
<p>This protection is controlled using the configuration element <code>java-serialization-filter</code> under <code>serialization</code>,
as shown in the example below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;serialization&gt;
        &lt;java-serialization-filter defaults-disabled="true"&gt;
            &lt;whitelist&gt;
		&lt;class&gt;example.Foo&lt;/class&gt;
		&lt;package&gt;com.acme.app&lt;/package&gt;
		&lt;prefix&gt;com.hazelcast.&lt;/prefix&gt;
		&lt;prefix&gt;java.&lt;/prefix&gt;
		&lt;prefix&gt;javax.&lt;/prefix&gt;
		&lt;prefix&gt;[&lt;/prefix&gt;
            &lt;/whitelist&gt;
            &lt;blacklist&gt;
                &lt;class&gt;com.acme.app.BeanComparator&lt;/class&gt;
            &lt;/blacklist&gt;
        &lt;/java-serialization-filter&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    java-serialization-filter:
      defaults-disabled: true
      whitelist:
        class:
          - example.Foo
        package:
          - com.acme.app
        prefix:
          - com.hazelcast.
          - java.
          - javax.
          - [
      blacklist:
        class:
          - com.acme.app.BeanComparator</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative, you can also configure it programmatically using
the <code>JavaSerializationFilterConfig</code> object, as shown in the below example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
JavaSerializationFilterConfig javaSerializationFilterConfig = new JavaSerializationFilterConfig();
javaSerializationFilterConfig.getWhitelist().addClasses(SomeDeserialized.class.getName());
config.getSerializationConfig().setJavaSerializationFilterConfig(javaSerializationFilterConfig);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Untrusted deserialization protection is not enabled by default.
You can enable it simply by setting the element <code>java-serialization-filter</code> or
using a non-null <code>JavaSerializationFilterConfig</code> object.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The protection uses a whitelist as the default configuration.
When this list is not explicitly provided, the following default prefixes are used for the whitelist:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java</code></p>
</li>
<li>
<p><code>com.hazelcast.</code></p>
</li>
<li>
<p><code>[</code> (for primitives and arrays)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you do not want to use the default whitelist prefixes, you must set the <code>defaults-disabled</code> attribute to true.</p>
</div>
<div class="paragraph">
<p>Once the protection is enabled, the following filtering rules are used when the objects are deserialized:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When whitelist is not provided:</p>
<div class="ulist">
<ul>
<li>
<p>if the deserialized object&#8217;s <code>getClass().getName()</code> is blacklisted or
<code>getClass().getPackage().getName()</code> is blacklisted, then deserialization fails</p>
</li>
<li>
<p>deserialization is allowed otherwise.</p>
</li>
</ul>
</div>
</li>
<li>
<p>When whitelist is provided:</p>
<div class="ulist">
<ul>
<li>
<p>if the deserialized object&#8217;s <code>getClass().getName()</code> or
<code>getClass().getPackage().getName()</code> is blacklisted, then deserialization fails</p>
</li>
<li>
<p>if the deserialized object&#8217;s <code>getClass().getName()</code> or
<code>getClass().getPackage().getName()</code> is whitelisted, then deserialization is allowed</p>
</li>
<li>
<p>deserialization fails otherwise.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When deserialization fails, a <code>SecurityException</code> is thrown.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that the safest way to provide a protection against
untrusted deserialization is using whitelisting (also keep in mind that maintaining such a whitelist can be difficult).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_serialization_configuration_wrap_up"><a class="anchor" href="#_serialization_configuration_wrap_up"></a>19.10. Serialization Configuration Wrap-Up</h3>
<div class="paragraph">
<p>This section summarizes the configuration of serialization options, explained in the above sections,
into all-in-one examples. The following are example serialization configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;serialization&gt;
        &lt;portable-version&gt;0&lt;/portable-version&gt;
        &lt;use-native-byte-order&gt;false&lt;/use-native-byte-order&gt;
        &lt;byte-order&gt;BIG_ENDIAN&lt;/byte-order&gt;
        &lt;data-serializable-factories&gt;
            &lt;data-serializable-factory factory-id="1"&gt;com.hazelcast.examples.DataSerializableFactory
            &lt;/data-serializable-factory&gt;
        &lt;/data-serializable-factories&gt;
        &lt;portable-factories&gt;
            &lt;portable-factory factory-id="1"&gt;com.hazelcast.examples.PortableFactory&lt;/portable-factory&gt;
        &lt;/portable-factories&gt;
        &lt;serializers&gt;
            &lt;global-serializer&gt;com.hazelcast.examples.GlobalSerializerFactory&lt;/global-serializer&gt;
            &lt;serializer type-class="com.hazelcast.examples.DummyType"
                        class-name="com.hazelcast.examples.SerializerFactory"/&gt;
        &lt;/serializers&gt;
        &lt;check-class-def-errors&gt;true&lt;/check-class-def-errors&gt;
        &lt;java-serialization-filter defaults-disabled="true"&gt;
            &lt;blacklist&gt;
                &lt;class&gt;com.acme.app.BeanComparator&lt;/class&gt;
            &lt;/blacklist&gt;
            &lt;whitelist&gt;
                &lt;class&gt;java.lang.String&lt;/class&gt;
                &lt;class&gt;example.Foo&lt;/class&gt;
                &lt;package&gt;com.acme.app&lt;/package&gt;
                &lt;package&gt;com.acme.app.subpkg&lt;/package&gt;
                &lt;prefix&gt;com.hazelcast.&lt;/prefix&gt;
                &lt;prefix&gt;java&lt;/prefix&gt;
            &lt;/whitelist&gt;
        &lt;/java-serialization-filter&gt;
    &lt;/serialization&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    portable-version: 0
    use-native-byte-order: false
    byte-order: BIG_ENDIAN
    data-serializable-factories:
      - factory-id: 1
        class-name: com.hazelcast.examples.DataSerializableFactory
    portable-factories:
      - factory-id: 1
        class-name: com.hazelcast.examples.PortableFactory
    global-serializer:
      class-name: com.hazelcast.examples.GlobalSerializerFactory
    serializers:
      - type-class: com.hazelcast.examples.DummyType
        class-name: com.hazelcast.examples.SerializerFactory
    check-class-def-errors: true
    java-serialization-filter:
      defaults-disabled: true
      blacklist:
        class:
          - com.acme.app.BeanComparator
      whitelist:
        class:
          - java.lang.String
          - example.Foo
        package:
          - com.acme.app
          - com.acme.app.subpkg
        prefix:
          - com.hazelcast.
          - java</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
SerializationConfig srzConfig = config.getSerializationConfig();
srzConfig.setPortableVersion( "2" ).setUseNativeByteOrder( true );
srzConfig.setAllowUnsafe( true ).setEnableCompression( true );
srzConfig.setCheckClassDefErrors( true );

GlobalSerializerConfig globSrzConfig = srzConfig.getGlobalSerializerConfig();
globSrzConfig.setClassName( "abc.Class" );

SerializerConfig serializerConfig = srzConfig.getSerializerConfig();
serializerConfig.setTypeClass( "Employee" )
                .setClassName( "com.EmployeeSerializer" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Serialization configuration has the following elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>portable-version</code>: Defines versioning of the portable serialization.
Portable version differentiates two of the same classes that have changes, such as adding/removing field or
changing a type of a field.</p>
</li>
<li>
<p><code>use-native-byte-order</code>: Set to <code>true</code> to use native byte order for the underlying platform.
Its default value is <code>false</code>.</p>
</li>
<li>
<p><code>byte-order</code>: Defines the byte order that the serialization uses: <code>BIG_ENDIAN</code> or <code>LITTLE_ENDIAN</code>.
Its default value is <code>BIG_ENDIAN</code>.</p>
</li>
<li>
<p><code>enable-compression</code>: Enables compression if default Java serialization is used.
Its default value is <code>false</code>.</p>
</li>
<li>
<p><code>enable-shared-object</code>: Enables shared object if default Java serialization is used.
Its default value is <code>false</code>.</p>
</li>
<li>
<p><code>allow-unsafe</code>: Set to <code>true</code> to allow <code>unsafe</code> to be used.
Its default value is <code>false</code>.</p>
</li>
<li>
<p><code>data-serializable-factory</code>: Custom classes implementing
<code>com.hazelcast.nio.serialization.DataSerializableFactory</code> to be registered.
These can be used to speed up serialization/deserialization of objects.</p>
</li>
<li>
<p><code>portable-factory</code>: The <code>PortableFactory</code> class to be registered.</p>
</li>
<li>
<p><code>global-serializer</code>: The global serializer class to be registered if no other serializer is applicable.
This element has the optional boolean attribute <code>override-java-serialization</code>.
If set to <code>true</code>, the Java serialization step is assumed to be handled by the global serializer.
Java Serializable and Externalizable is prior to global serializer by default (<code>false</code>).</p>
</li>
<li>
<p><code>serializer</code>: The class name of the serializer implementation.</p>
</li>
<li>
<p><code>check-class-def-errors</code>: When set to <code>true</code>, the serialization system checks for
class definitions error at start and throws a Serialization Exception with an error definition.</p>
</li>
<li>
<p><code>java-serialization-filter</code>: Provides deserialization protection based on
whitelisting and blacklisting the class/package names.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_management"><a class="anchor" href="#_management"></a>20. Management</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides information on managing and monitoring your Hazelcast cluster.
It gives detailed instructions related to gathering statistics, monitoring via JMX protocol and
managing the cluster with useful utilities.</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:member_statistics.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:jmx_api.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:jmx_monitoring.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:rest_endpoint_groups.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:cluster_utilities.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:metrics.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:diagnostics.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:health_check_monitoring.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:management_center.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:license_info.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/management.adoc - include::deploy:instance_tracking.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="security"><a class="anchor" href="#security"></a>21. Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise Feature</strong></p>
</div>
<div class="paragraph">
<p>This chapter describes the security features of Hazelcast.
These features allow you to perform security activities, such as
intercepting socket connections and remote operations executed by
the clients, encrypting the communications between the members at socket
level and using SSL socket communication. All of the Security features
explained in this chapter are the features of <span class="blue">Hazelcast IMDG Enterprise</span>
edition.</p>
</div>
<div class="sect2">
<h3 id="_enabling_jaas_security"><a class="anchor" href="#_enabling_jaas_security"></a>21.1. Enabling JAAS Security</h3>
<div class="paragraph">
<p>With Hazelcast&#8217;s extensible, JAAS based security feature, you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>authenticate both cluster members and clients</p>
</li>
<li>
<p>and perform access control checks on client operations.
Access control can be done according to endpoint principal
and/or endpoint address.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can enable security declaratively or programmatically,
as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;security enabled="true"&gt;
    ...
    &lt;/security&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  security:
    enabled: true</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config cfg = new Config();
SecurityConfig securityCfg = cfg.getSecurityConfig();
securityCfg.setEnabled( true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, see the <a href="#setting-the-license-key">Setting License Key section</a>
for information on how to set your <span class="blue">Hazelcast IMDG Enterprise</span>
license.</p>
</div>
</div>
<div class="sect2">
<h3 id="_socket_interceptor"><a class="anchor" href="#_socket_interceptor"></a>21.2. Socket Interceptor</h3>
<div class="paragraph">
<p>Hazelcast allows you to intercept socket connections before a member
joins a cluster or a client connects to a member of a cluster.
This allow you to add custom hooks to join and perform connection
procedures (like identity checking using a
custom network authentication protocol, etc.).</p>
</div>
<div class="paragraph">
<p>To use the socket interceptor, implement <code>com.hazelcast.nio.MemberSocketInterceptor</code>
for members and <code>com.hazelcast.nio.SocketInterceptor</code> for clients.</p>
</div>
<div class="paragraph">
<p>The following is an example socket interceptor implementation for the member side.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    public static class MySocketInterceptor implements MemberSocketInterceptor {

        private String memberId;

        public MySocketInterceptor() {
        }

        @Override
        public void onAccept(Socket socket) throws IOException {
            socket.getOutputStream().write(memberId.getBytes());
            byte[] bytes = new byte[1024];
            int len = socket.getInputStream().read(bytes);
            String otherMemberId = new String(bytes, 0, len);
            if (!otherMemberId.equals("secondMember")) {
                throw new RuntimeException("Not a known member!!!");
            }
        }

        @Override
        public void init(Properties properties) {
            memberId = properties.getProperty("member-id");
        }

        @Override
        public void onConnect(Socket socket) throws IOException {
            socket.getOutputStream().write(memberId.getBytes());
            byte[] bytes = new byte[1024];
            int len = socket.getInputStream().read(bytes);
            String otherMemberId = new String(bytes, 0, len);
            if (!otherMemberId.equals("firstMember")) {
                throw new RuntimeException("Not a known member!!!");
            }
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can declaratively configure this socket interceptor as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;socket-interceptor enabled="true"&gt;
            &lt;class-name&gt;com.hazelcast.examples.MySocketInterceptor&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="property1"&gt;value1&lt;/property&gt;
                &lt;property name="property2"&gt;value2&lt;/property&gt;
                &lt;property name=foo&gt;bar&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/socket-interceptor&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    socket-interceptor:
        enabled: true
        class-name: com.hazelcast.examples.MySocketInterceptor
        properties:
          property1: value1
          property2: value2
          foo: bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example configuration of the above socket
interceptor for the client side.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    public static void main(String[] args) {

        Config config = createConfig();
        Hazelcast.newHazelcastInstance(config);

        ClientConfig clientConfig = createClientConfig();
        HazelcastClient.newHazelcastClient(clientConfig);
    }

    private static Config createConfig() {
        Config config = new Config();
        //config.setLicenseKey(ENTERPRISE_LICENSE_KEY);
        config.setProperty("hazelcast.wait.seconds.before.join", "0");

        SocketInterceptorConfig interceptorConfig = new SocketInterceptorConfig();
        interceptorConfig.setEnabled(true).setClassName(MySocketInterceptor.class.getName());
        config.getNetworkConfig().setSocketInterceptorConfig(interceptorConfig);

        return config;
    }

    private static ClientConfig createClientConfig() {
        ClientConfig clientConfig = new ClientConfig();
        //clientConfig.setLicenseKey(ENTERPRISE_LICENSE_KEY);
        SocketInterceptorConfig interceptorConfig = new SocketInterceptorConfig();
        interceptorConfig.setEnabled(true).setClassName(MySocketInterceptor.class.getName());
        clientConfig.getNetworkConfig().setSocketInterceptorConfig(interceptorConfig);
        return clientConfig;
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_security_interceptor"><a class="anchor" href="#_security_interceptor"></a>21.3. Security Interceptor</h3>
<div class="paragraph">
<p>Hazelcast allows you to intercept every remote operation executed
by the client. This lets you add a very flexible custom security logic.
To do this, implement <code>com.hazelcast.security.SecurityInterceptor</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    private static class MySecurityInterceptor implements SecurityInterceptor {

        @Override
        public void before(Credentials credentials, String objectType, String objectName, String methodName,
                           Parameters parameters) throws AccessControlException {
            if (objectName.equals(DENIED_MAP_NAME)) {
                throw new RuntimeException("Denied Map!!!");
            }
            if (methodName.equals(DENIED_METHOD)) {
                throw new RuntimeException("Denied Method!!!");
            }
            Object firstParam = parameters.get(0);
            Object secondParam = parameters.get(1);
            if (firstParam.equals(DENIED_KEY)) {
                throw new RuntimeException("Denied Key!!!");
            }
            if (secondParam.equals(DENIED_VALUE)) {
                throw new RuntimeException("Denied Value!!!");
            }
        }

        @Override
        public void after(Credentials credentials, String objectType, String objectName, String methodName,
                          Parameters parameters) {
            System.err.println("qwe c: " + credentials + "\t\tt: " + objectType + "\t\tn: " + objectName
                    + "\t\tm: " + methodName + "\t\tp1: " + parameters.get(0) + "\t\tp2: " + parameters.get(1));
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>before</code> method is called before processing the request on the
remote server. The <code>after</code> method is called after the processing.
Exceptions thrown while executing the <code>before</code> method are propagated
to the client, but exceptions thrown while executing the <code>after</code> method
are suppressed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_encryption"><a class="anchor" href="#_encryption"></a>21.4. Encryption</h3>
<div class="paragraph">
<p>Hazelcast offers features which allow to reach a required privacy on
communication level by enabling encryption. Encryption is based on
<a href="http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html" target="_blank" rel="noopener">Java Cryptography Architecture</a> (JCA).</p>
</div>
<div class="paragraph">
<p>There are two different encryption features:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>TLS protocol</p>
<div class="ulist">
<ul>
<li>
<p>transport level encryption</p>
</li>
<li>
<p>supported by members and clients</p>
</li>
<li>
<p>TCP-only, i.e., multicast join messages are not encrypted</p>
<div class="paragraph">
<p>More details in the <a href="#tlsssl">TLS/SSL section</a></p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Symmetric encryption for Hazelcast member protocol</p>
<div class="ulist">
<ul>
<li>
<p>only supported by the members; communication with clients is not encrypted</p>
</li>
<li>
<p>multicast join messages are encrypted, too</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The preferred and recommended feature is the TLS protocol as it&#8217;s a
standard way how to protect communication on transport level:
Both TLS and symmetric encryption are for encrypting the network traffic.
TLS is already superior to symmetric encryption on more than one aspects as seen
above. Symmetric encryption is only supported in member-member communication while
TLS can encrypt client communications as well. When there is no specific reason to use
symmetric encryption, we recommend you to use the TLS protocol.</p>
</div>
<div class="paragraph">
<p>Symmetric encryption for Hazelcast member protocol can be configured
with cipher algorithms implemented by security providers and accessed
through Java Cryptography Architecture.
Check documentation of your Java version to learn about supported algorithm
names. The following are some examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AES</code></p>
</li>
<li>
<p><code>PBEWithMD5AndDES</code></p>
</li>
<li>
<p><code>DES/ECB/PKCS5Padding</code></p>
</li>
<li>
<p><code>Blowfish</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hazelcast uses <code>MD5</code> message-digest algorithm as the cryptographic
hash function. You can also use the salting process by giving a salt
and password which are then concatenated and processed with <code>MD5</code>, and
the resulting output is stored with the salt.</p>
</div>
<div class="paragraph">
<p>In symmetric encryption, each member uses the same key, so the key is
shared. Here is an example configuration for symmetric encryption.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;symmetric-encryption enabled="true"&gt;
            &lt;algorithm&gt;AES&lt;/algorithm&gt;
            &lt;salt&gt;thesalt&lt;/salt&gt;
            &lt;password&gt;thepass&lt;/password&gt;
            &lt;iteration-count&gt;175&lt;/iteration-count&gt;
        &lt;/symmetric-encryption&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    symmetric-encryption:
      enabled: true
      algorithm: AES
      salt: thesalt
      password: thepass
      iteration-count: 175</code></pre>
</div>
</div>
<div class="paragraph">
<p>You set the encryption algorithm, the salt, password and the iteration count to be used
for generating the secret key. You also need to set the <code>enabled</code> attribute to <code>true</code>.
Note that all members should have the same encryption configuration.</p>
</div>
<div class="paragraph">
<p>Since symmetric encryption relies on JCA, you can additionally benefit from the
algorithms provided by the Bouncy Castle Crypto APIs. For this,
you need to set the <code>hazelcast.security.bouncy.enabled</code> property to <code>true</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="tlsssl"><a class="anchor" href="#tlsssl"></a>21.5. TLS/SSL</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot use TLS/SSL when <a href="#encryption">Hazelcast Encryption</a>
is enabled.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use the SSL (Secure Sockets Layer)
protocol to establish an encrypted communication
across your Hazelcast cluster with key stores and trust stores. Note that, if
you are developing applications using Java 8, you will be using its
successor TLS (Transport Layer Security).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is NOT recommended to reuse the key stores and trust stores
for external applications.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tlsssl_for_hazelcast_members"><a class="anchor" href="#_tlsssl_for_hazelcast_members"></a>21.5.1. TLS/SSL for Hazelcast Members</h4>
<div class="paragraph">
<p>Hazelcast allows you to encrypt socket level communication between
Hazelcast members and between Hazelcast clients and members, for end
to end encryption. To use it, you need to implement
<code>com.hazelcast.nio.ssl.SSLContextFactory</code> and configure the SSL section
in the network configuration.</p>
</div>
<div class="paragraph">
<p>The following is the implementation code snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MySSLContextFactory implements SSLContextFactory {
    public void init( Properties properties ) throws Exception {
    }

    public SSLContext getSSLContext() {
        ...
        SSLContext sslCtx = SSLContext.getInstance( "the protocol to be used" );
        return sslCtx;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the base declarative configuration for the
implemented <code>SSLContextFactory</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;ssl enabled="true"&gt;
            &lt;factory-class-name&gt;
                com.hazelcast.examples.MySSLContextFactory
            &lt;/factory-class-name&gt;
            &lt;properties&gt;
                &lt;property name="foo"&gt;bar&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/ssl&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    ssl:
      enabled: true
      factory-class-name: com.hazelcast.examples.MySSLContextFactory
      properties:
        foo: bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast provides a default SSLContextFactory,
<code>com.hazelcast.nio.ssl.BasicSSLContextFactory</code>, which uses the configured
keystore to initialize <code>SSLContext</code>; see the following example configuration
for TLS/SSL.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;ssl enabled="true"&gt;
            &lt;factory-class-name&gt;
                com.hazelcast.nio.ssl.BasicSSLContextFactory
            &lt;/factory-class-name&gt;
            &lt;properties&gt;
                &lt;property name="protocol"&gt;TLSv1.2&lt;/property&gt;
                &lt;property name="mutualAuthentication"&gt;REQUIRED&lt;/property&gt;
                &lt;property name="keyStore"&gt;/opt/hazelcast-keystore.p12&lt;/property&gt;
                &lt;property name="keyStorePassword"&gt;secret.123&lt;/property&gt;
                &lt;property name="keyStoreType"&gt;PKCS12&lt;/property&gt;
                &lt;property name="trustStore"&gt;/opt/hazelcast-truststore.p12&lt;/property&gt;
                &lt;property name="trustStorePassword"&gt;changeit&lt;/property&gt;
                &lt;property name="trustStoreType"&gt;PKCS12&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/ssl&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    ssl:
      enabled: true
      factory-class-name: com.hazelcast.nio.ssl.BasicSSLContextFactory
      properties:
        protocol: TLSv1.2
        mutualAuthentication: REQUIRED
        keyStore: /opt/hazelcast-keystore.p12
        keyStorePassword: secret.123
        keyStoreType: PKCS12
        trustStore: /opt/hazelcast-truststore.p12
        trustStorePassword: changeit
        trustStoreType: PKCS12</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions of the properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>keyStore</code>: Path of your keystore file.</p>
</li>
<li>
<p><code>keyStorePassword</code>: Password to access the key from your
keystore file.</p>
</li>
<li>
<p><code>keyManagerAlgorithm</code>: Name of the algorithm based on which
the authentication keys are provided.</p>
</li>
<li>
<p><code>keyStoreType</code>: Type of the keystore. Its default value is <code>JKS</code>.
Another commonly used type is the <code>PKCS12</code>. Available keystore/truststore
types depend on your Operating system and the Java runtime.</p>
</li>
<li>
<p><code>trustStore</code>: Path of your truststore file. The file truststore is a
keystore file that contains a collection of certificates trusted by your
application.</p>
</li>
<li>
<p><code>trustStorePassword</code>: Password to unlock the truststore file.</p>
</li>
<li>
<p><code>trustManagerAlgorithm</code>: Name of the algorithm based on which the
trust managers are provided.</p>
</li>
<li>
<p><code>trustStoreType</code>: Type of the truststore. Its default value is <code>JKS</code>.
Another commonly used type is the <code>PKCS12</code>. Available keystore/truststore
types depend on your Operating system and the Java runtime.</p>
</li>
<li>
<p><code>mutualAuthentication</code>: Mutual authentication configuration. It&#8217;s empty
by default which means the client side of connection is not authenticated.
Available values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>REQUIRED</code> - server forces usage of a trusted client certificate</p>
</li>
<li>
<p><code>OPTIONAL</code> - server asks for a client certificate, but it doesn&#8217;t
require it</p>
<div class="paragraph">
<p>See the <a href="#mutual-authentication">Mutual Authentication section</a>.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>ciphersuites</code>: Comma-separated list of cipher suite names allowed
to be used. Its default value are all supported suites in your Java runtime.</p>
</li>
<li>
<p><code>protocol</code>: Name of the algorithm which is used in your TLS/SSL. Its
default value is <code>TLS</code>. Available values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>TLS</code></p>
</li>
<li>
<p><code>TLSv1</code></p>
</li>
<li>
<p><code>TLSv1.1</code></p>
</li>
<li>
<p><code>TLSv1.2</code></p>
</li>
<li>
<p><code>TLSv1.3</code></p>
<div class="paragraph">
<p>For the <code>protocol</code> property, we recommend you to provide TLS with its
version information, e.g., <code>TLSv1.2</code>. Note that if you write only <code>TLS</code>,
your application chooses the TLS version according to your Java version.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>validateIdentity</code>: Flag which allows enabling endpoint identity validation. It means, during the TLS handshake client verifies if the server&#8217;s hostname (or IP address) matches the information in X.509 certificate (Subject Alternative Name extension). Possible values are <code>"true"</code> and <code>"false"</code> (default).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_tlsssl_for_hazelcast_clients"><a class="anchor" href="#_tlsssl_for_hazelcast_clients"></a>21.5.2. TLS/SSL for Hazelcast Clients</h4>
<div class="paragraph">
<p>The TLS configuration in Hazelcast clients is very similar to member configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;network&gt;
        &lt;ssl enabled="true"&gt;
            &lt;factory-class-name&gt;
                com.hazelcast.nio.ssl.BasicSSLContextFactory
            &lt;/factory-class-name&gt;
            &lt;properties&gt;
                &lt;property name="protocol"&gt;TLSv1.2&lt;/property&gt;
                &lt;property name="trustStore"&gt;/opt/hazelcast-client.truststore&lt;/property&gt;
                &lt;property name="trustStorePassword"&gt;changeit&lt;/property&gt;
                &lt;property name="trustStoreType"&gt;JKS&lt;/property&gt;

                &lt;!-- Following properties are only needed when the mutual authentication is used. --&gt;
                &lt;property name="keyStore"&gt;/opt/hazelcast-client.keystore&lt;/property&gt;
                &lt;property name="keyStorePassword"&gt;clientsSecret&lt;/property&gt;
                &lt;property name="keyStoreType"&gt;JKS&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/ssl&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  network:
    ssl:
      enabled: true
      factory-class-name: com.hazelcast.nio.ssl.BasicSSLContextFactory
      properties:
        protocol: TLSv1.2

        trustStore: /opt/hazelcast-client.truststore
        trustStorePassword: changeit
        trustStoreType: JKS

        # Following properties are only needed when the mutual authentication is used.
        keyStore: /opt/hazelcast-client.keystore
        keyStorePassword: clientsSecret
        keyStoreType: JKS</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same <code>BasicSSLContextFactory</code> properties used for members are available
on clients.
Clients don&#8217;t need to set <code>mutualAuthentication</code> property as it&#8217;s used in
configuring the server side of TLS connections.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mutual_authentication"><a class="anchor" href="#_mutual_authentication"></a>21.5.3. Mutual Authentication</h4>
<div class="paragraph">
<p>TLS connections have two sides: the one opening the connection (TLS client)
and the one accepting the connection (TLS server).
By default only the TLS server proves its identity by presenting a certificate
to the TLS client.
The mutual authentication means that also the TLS clients prove their identity
to the TLS servers.</p>
</div>
<div class="paragraph">
<p>Hazelcast members can be on both sides of TLS connection - TLS servers
and TLS clients.
Hazelcast clients are always on the client side of a TLS connection.</p>
</div>
<div class="paragraph">
<p>By default Hazelcast members have keyStore used to identify themselves
to the clients and other members.
Both Hazelcast members and Hazelcast clients have trustStore used to define
which members they can trust.</p>
</div>
<div class="paragraph">
<p>When the mutual authentication feature is enabled, Hazelcast clients
need to provide keyStore.
A client proves its identity by providing its certificate to the Hazelcast
member it&#8217;s connecting to.
The member only accepts the connection if the client&#8217;s certificate is
present in the member&#8217;s trustStore.</p>
</div>
<div class="paragraph">
<p>To enable the mutual authentication, set the <code>mutualAuthentication</code> property
value to <code>REQUIRED</code> on the member side, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Config cfg = new Config();
Properties props = new Properties();

props.setProperty("mutualAuthentication", "REQUIRED");
props.setProperty("keyStore", "/opt/hazelcast.keystore");
props.setProperty("keyStorePassword", "123456");
props.setProperty("trustStore", "/opt/hazelcast.truststore");
props.setProperty("trustStorePassword", "123456");

cfg.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(props));
Hazelcast.newHazelcastInstance(cfg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>And on the client side, you need to set client identity
by providing the keystore:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">clientSslProps.setProperty("keyStore", "/opt/client.keystore");
clientSslProps.setProperty("keyStorePassword", "123456");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The property <code>mutualAuthentication</code> has the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REQUIRED</code>: Server asks for client certificate. If the client
does not provide a keystore or the provided keystore is not verified
against member&#8217;s truststore, the client is not authenticated.</p>
</li>
<li>
<p><code>OPTIONAL</code>: Server asks for client certificate, but client is not
required to provide any valid certificate.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When a new client is introduced with a new keystore, the
truststore on the member side should be updated accordingly to
include new clients' information to be able to accept it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See the below example snippet to see the full configuration on the
client side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">ClientConfig config = new ClientConfig();
Properties clientSslProps = new Properties();
clientSslProps.setProperty("keyStore", "/opt/client.keystore");
clientSslProps.setProperty("keyStorePassword", "123456");
clientSslProps.setProperty("trustStore", "/opt/client.truststore");
clientSslProps.setProperty("trustStorePassword", "123456");

config.getNetworkConfig().setSSLConfig(new SSLConfig().setEnabled(true).setProperties(clientSslProps));
HazelcastClient.newHazelcastClient(config);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the mutual authentication is not required, the Hazelcast members accept all
incoming TLS connections without verifying if the connecting side is trusted.
Therefore it&#8217;s recommended to require the mutual authentication in Hazelcast
members configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tlsssl_performance_improvements_for_java"><a class="anchor" href="#_tlsssl_performance_improvements_for_java"></a>21.5.4. TLS/SSL Performance Improvements for Java</h4>
<div class="paragraph">
<p>TLS/SSL can have a significant impact on performance. There are a few ways to
increase the performance.</p>
</div>
<div class="paragraph">
<p>The first thing that can be done is making sure that AES intrinsics are used.
Modern CPUs (2010 or newer Westmere) have hardware support for AES encryption/decryption
and if a Java 8 or newer JVM is
used, the JIT automatically makes use of these AES intrinsics. They can also be
explicitly enabled using <code>-XX:+UseAES -XX:+UseAESIntrinsics</code>,
or disabled using <code>-XX:-UseAES -XX:-UseAESIntrinsics</code>.</p>
</div>
<div class="paragraph">
<p>A lot of encryption algorithms make use of padding because they encrypt/decrypt in
fixed sized blocks. If there is no enough data
for a block, the algorithm relies on random number generation to pad. Under Linux,
the JVM automatically makes use of <code>/dev/random</code> for
the generation of random numbers. <code>/dev/random</code> relies on entropy to be able to
generate random numbers. However, if this entropy is
insufficient to keep up with the rate requiring random numbers, it can slow down
the encryption/decryption since <code>/dev/random</code> will
block; it could block for minutes waiting for sufficient entropy . This can be fixed
by setting the <code>-Djava.security.egd=file:/dev/./urandom</code> system property.
For a more permanent solution, modify the
<code>&lt;JAVA_HOME&gt;/jre/lib/security/java.security</code> file, look for the
<code>securerandom.source=/dev/urandom</code> and change it
to <code>securerandom.source=file:/dev/./urandom</code>. Switching to <code>/dev/urandom</code> could
be controversial because <code>/dev/urandom</code> will not
block if there is a shortage of entropy and the returned random values could
theoretically be vulnerable to a cryptographic attack.
If this is a concern in your application, use <code>/dev/random</code> instead.</p>
</div>
<div class="paragraph">
<p>Hazelcast&#8217;s Java smart client automatically makes use of extra I/O threads
for encryption/decryption and this have a significant impact on the performance.
This can be changed using the <code>hazelcast.client.io.input.thread.count</code> and
<code>hazelcast.client.io.output.thread.count</code> client system properties.
By default it is 1 input thread and 1 output thread. If TLS/SSL is enabled,
it defaults to 3 input threads and 3 output threads.
Having more client I/O threads than members in the cluster does not lead to
an increased performance. So with a 2-member cluster,
2 in and 2 out threads give the best performance.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_integrating_openssl_boringssl"><a class="anchor" href="#_integrating_openssl_boringssl"></a>21.6. Integrating OpenSSL / BoringSSL</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot integrate OpenSSL into Hazelcast when <a href="#encryption">Hazelcast Encryption</a>
is enabled.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TLS/SSL in Java is normally provided by the JRE. However, the performance overhead can be
significant; even with AES intrinsics
enabled. If you are using a x86_64 system (Linux, Mac, Windows), Hazelcast supports native
integration for TLS/SSL which can provide significant performance
improvements. There are two supported native TLS/SSL libraries available through
<a href="https://netty.io/wiki/forked-tomcat-native.html" target="_blank" rel="noopener">netty-tcnative</a> libraries:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OpenSSL</p>
<div class="ulist">
<ul>
<li>
<p>dynamically linked</p>
</li>
<li>
<p>prerequisites: <code>libapr</code>, <code>openssl</code> packages installed on your system</p>
</li>
</ul>
</div>
</li>
<li>
<p>BoringSSL - Google managed fork of the OpenSSL</p>
<div class="ulist">
<ul>
<li>
<p>statically linked</p>
</li>
<li>
<p>easier to get started with</p>
</li>
<li>
<p>benefits: reduced code footprint, additional features</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The native TLS integration can be used on clients and/or members. For best performance, it
is recommended to install on a client and member and
configure the appropriate cipher suite(s).</p>
</div>
<div class="paragraph">
<p>Check the <a href="https://netty.io/wiki/forked-tomcat-native.html" target="_blank" rel="noopener">netty-tcnative</a> page
for installation details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the Java version is
less than 11 and OpenSSL capabilities are detected
(also the appropriate Java libraries are included) and if no
explicit <code>SSLEngineFactory</code> is set, Hazelcast IMDG defaults to use OpenSSL.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_netty_libraries"><a class="anchor" href="#_netty_libraries"></a>21.6.1. Netty Libraries</h4>
<div class="paragraph">
<p>For the native TLS/SSL integration in Java, the <a href="https://netty.io/" target="_blank" rel="noopener">Netty</a> library is used.</p>
</div>
<div class="paragraph">
<p>Make sure the following libraries from the Netty framework are on the classpath:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>netty-handler</code> and its dependencies</p>
</li>
<li>
<p>one of <code>tc-native</code> implementations</p>
<div class="ulist">
<ul>
<li>
<p>either BoringSSL: <code>netty-tcnative-boringssl-static-{tcnative_version}.jar</code></p>
</li>
<li>
<p>or OpenSSL: <code>netty-tcnative-{tcnative_version}-{os_arch}.jar</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is very important that the version of Netty JAR(s) corresponds to
a very specific version of <code>netty-tcnative</code>. In case of doubt, the
simplest thing to do is to download the <code>netty-&lt;version&gt;.tar.bz2</code> file
from the <a href="https://netty.io/downloads.html" target="_blank" rel="noopener">Netty</a> website and check which
<code>netty-tcnative</code> version is used for that Netty release.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_using_boringssl"><a class="anchor" href="#_using_boringssl"></a>21.6.2. Using BoringSSL</h4>
<div class="paragraph">
<p>The statically linked BoringSSL binaries are included within the <code>netty-tcnative</code>
libraries. There is no need to install additional software on supported systems.</p>
</div>
<div class="paragraph">
<p>Example Maven dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.netty&lt;/groupId&gt;
        &lt;artifactId&gt;netty-tcnative-boringssl-static&lt;/artifactId&gt;
        &lt;version&gt;2.0.12.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.netty&lt;/groupId&gt;
        &lt;artifactId&gt;netty-handler&lt;/artifactId&gt;
        &lt;version&gt;4.1.27.Final&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_openssl"><a class="anchor" href="#_using_openssl"></a>21.6.3. Using OpenSSL</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Install OpenSSL. Make sure that you are installing 1.0.1 or newer release.
See its documentation at
<a href="https://github.com/openssl/openssl/blob/master/INSTALL.md" target="_blank" rel="noopener">github.com/openssl</a>.</p>
</li>
<li>
<p>Install Apache Portable Runtime (APR) library. See <a href="https://apr.apache.org/download.cgi" target="_blank" rel="noopener">apr.apache.org</a>.</p>
<div class="paragraph">
<p>For RHEL: <code>sudo yum -y install apr openssl</code></p>
</div>
<div class="paragraph">
<p>For Ubuntu: <code>sudo apt-get -y install libapr1 openssl</code></p>
</div>
<div class="paragraph">
<p>For Alpine Linux: <code>apk add --update apr openssl</code></p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Example Maven dependencies (for Linux):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.netty&lt;/groupId&gt;
        &lt;artifactId&gt;netty-tcnative&lt;/artifactId&gt;
        &lt;version&gt;2.0.12.Final&lt;/version&gt;
        &lt;classifier&gt;linux-x86_64&lt;/classifier&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.netty&lt;/groupId&gt;
        &lt;artifactId&gt;netty-handler&lt;/artifactId&gt;
        &lt;version&gt;4.1.27.Final&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_hazelcast_for_openssl"><a class="anchor" href="#_configuring_hazelcast_for_openssl"></a>21.6.4. Configuring Hazelcast for OpenSSL</h4>
<div class="paragraph">
<p>Configuring OpenSSL in Hazelcast is straight forward. On the client and/or
member side, the following snippet enables TLS/SSL
using OpenSSL:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;ssl enabled="true"&gt;
            &lt;factory-class-name&gt;com.hazelcast.nio.ssl.OpenSSLEngineFactory&lt;/factory-class-name&gt;
            &lt;properties&gt;
                &lt;property name="protocol"&gt;TLSv1.2&lt;/property&gt;
                &lt;property name="trustCertCollectionFile"&gt;trusted-certs.pem&lt;/property&gt;
                 &lt;!-- If the TLS mutual authentication is not used,
                     then the key configuration is not needed on the client side. --&gt;
                &lt;property name="keyFile"&gt;privkey.pem&lt;/property&gt;
                &lt;property name="keyCertChainFile"&gt;chain.pem&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/ssl&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    ssl:
      enabled: true
      factory-class-name: com.hazelcast.nio.ssl.OpenSSLEngineFactory
      properties:
        protocol: TLSv1.2
        trustCertCollectionFile: trusted-certs.pem

        # If the TLS mutual authentication is not used, following lines (key configuration) are not needed on the client side.
        keyFile: privkey.pem
        keyCertChainFile: chain.pem</code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration is similar to a regular TLS/SSL integration. The main differences
are the <code>OpenSSLEngineFactory</code> factory class and the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>keyFile</code>: Path of your PKCS#8 key file in PEM format.</p>
</li>
<li>
<p><code>keyPassword</code>: Password to access the key file when it&#8217;s encrypted.</p>
</li>
<li>
<p><code>keyCertChainFile</code>: Path to an X.509 certificate chain file in PEM format.</p>
</li>
<li>
<p><code>trustCertCollectionFile</code>: Path to an X.509 certificate collection file in PEM format.</p>
</li>
<li>
<p><code>fipsMode</code>: Boolean flag to switch OpenSSL into the FIPS mode. See the <a href="#fips-140-2">FIPS 140-2 section</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The key and certificate related properties take precedence over keyStore and
trustStore configurations.
Using keyStores and trustStores together with OpenSSL causes problems on some
Java versions, therefore we recommend to use the OpenSSL native way.</p>
</div>
<div class="paragraph">
<p>The following are the other supported properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>keyStore</code>: Path of your keystore file.</p>
<div class="ulist">
<ul>
<li>
<p><em>Using the <code>keyStore</code> property is not recommended, use <code>keyFile</code> and
<code>keyCertChainFile</code> instead</em></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>keyStorePassword</code>: Password to access the key from your keystore file.</p>
</li>
<li>
<p><code>keyStoreType</code>: Type of the keystore. Its default value is <code>JKS</code>. Another
commonly used type is the <code>PKCS12</code>. Available keystore/truststore types depend
on your Operating system and the Java runtime.</p>
</li>
<li>
<p><code>keyManagerAlgorithm</code>: Name of the algorithm based on which the authentication
keys are provided.</p>
</li>
<li>
<p><code>trustManagerAlgorithm</code>: Name of the algorithm based on which the trust managers
are provided.</p>
</li>
<li>
<p><code>trustStore</code>: Path of your truststore file. The file truststore is a keystore file
that contains a collection of certificates
 trusted by your application. Its type should be <code>JKS</code>.</p>
<div class="ulist">
<ul>
<li>
<p><em>Using the <code>trustStore</code> property is not recommended, use <code>trustCertCollectionFile</code> instead</em></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>trustStorePassword</code>: Password to unlock the truststore file.</p>
</li>
<li>
<p><code>trustStoreType</code>: Type of the truststore. Its default value is <code>JKS</code>. Another
commonly used type is the <code>PKCS12</code>. Available keystore/truststore types depend on
your operating system and the Java runtime.</p>
</li>
<li>
<p><code>ciphersuites</code>: Comma-separated list of cipher suite names allowed to be used.</p>
</li>
<li>
<p><code>protocol</code>: Name of the algorithm which is used in your TLS/SSL. Its default
value is <code>TLSv1.2</code>. Available values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>TLS</code></p>
</li>
<li>
<p><code>TLSv1</code></p>
</li>
<li>
<p><code>TLSv1.1</code></p>
</li>
<li>
<p><code>TLSv1.2</code></p>
</li>
<li>
<p><code>SSL</code> <em>(insecure!)</em></p>
</li>
<li>
<p><code>SSLv2</code> <em>(insecure!)</em></p>
</li>
<li>
<p><code>SSLv3</code> <em>(insecure!)</em></p>
<div class="paragraph">
<p>All of the algorithms listed above support Java 8 and higher versions. For the
<code>protocol</code> property, we recommend you to provide SSL or TLS with its version
information, e.g., <code>TLSv1.2</code>. Note that if you
provide only <code>SSL</code> or <code>TLS</code> as a value for the <code>protocol</code> property, they are
converted to <code>SSLv3</code> and <code>TLSv1.2</code>, respectively. We strongly recommend to avoid
SSL protocols.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>validateIdentity</code>: Flag which allows enabling endpoint identity validation. It means, during the TLS handshake client verifies if the server&#8217;s hostname (or IP address) matches the information in X.509 certificate (Subject Alternative Name extension). Possible values are <code>"true"</code> and <code>"false"</code> (default).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_other_tls_related_configuration"><a class="anchor" href="#_other_tls_related_configuration"></a>21.7. Other TLS related configuration</h3>
<div class="sect3">
<h4 id="_tlsssl_for_hazelcast_management_center"><a class="anchor" href="#_tlsssl_for_hazelcast_management_center"></a>21.7.1. TLS/SSL for Hazelcast Management Center</h4>
<div class="paragraph">
<p>In order to use a secured communication between the Hazelcast cluster and Management Center,
you have to configure Management Center as explained in the
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#connecting-hazelcast-members-to-management-center" target="_blank" rel="noopener">Connecting Hazelcast members to Management Center section</a> in the Hazelcast
Management Center Reference Manual.</p>
</div>
</div>
<div class="sect3">
<h4 id="_updating_certificates_in_the_running_cluster"><a class="anchor" href="#_updating_certificates_in_the_running_cluster"></a>21.7.2. Updating Certificates in the Running Cluster</h4>
<div class="paragraph">
<p>Hazelcast allows updating TLS certificates on the members
without fully stopping the cluster. You can stop the cluster members
one by one and replace the certificates gradually. We can
distinguish two cases based on the fact if the new certificate
is already trusted:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>New certificates are not trusted on the members.</p>
<div class="paragraph">
<p>This is usually a case when self-signed certificates are used on the members.</p>
</div>
<div class="paragraph">
<p>Before we can deploy new member certificates, we have to
update the list of trusted certificates on all members.
Complete the following steps on each member (one by one) in the cluster:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gracefully shutdown the member</p>
</li>
<li>
<p>Wait for the cluster safe state (rebalance)</p>
</li>
<li>
<p>Import all new certificates to the member&#8217;s truststore,
so it contains both old and new ones.</p>
<div class="paragraph">
<p>You can use the <code>keytool</code> executable from Java installation
to import the new certificates. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">keytool -import -noprompt \
  -keystore member.truststore -storepass s3crEt \
  -alias new-cert-1 -file member-new-cert.crt</code></pre>
</div>
</div>
</li>
<li>
<p>Start the member with the updated truststore</p>
</li>
<li>
<p>Wait for the cluster safe state (rebalance)</p>
<div class="paragraph">
<p>After completing the above steps, follow the steps
described in the next point (certificates trusted).</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>New certificates are already trusted on the members</p>
<div class="paragraph">
<p>Switch certificate on each member one by one:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gracefully shutdown the member</p>
</li>
<li>
<p>Wait for the cluster safe state (rebalance)</p>
</li>
<li>
<p>Replace the private key and certificate in the member&#8217;s keystore</p>
</li>
<li>
<p>Start the member with the updated keystore</p>
</li>
<li>
<p>Wait for the cluster safe state (rebalance)</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_cipher_suites"><a class="anchor" href="#_configuring_cipher_suites"></a>21.7.3. Configuring Cipher Suites</h4>
<div class="paragraph">
<p>To get the best performance, the correct <a href="https://en.wikipedia.org/wiki/Cipher_suite" target="_blank" rel="noopener">cipher suites</a>
need to be configured.
Each cipher suite has different performance and security characteristics and depending on the
hardware and selected cipher suite, the overhead of TLS can range from dramatic to almost
negligible.</p>
</div>
<div class="paragraph">
<p>The cipher suites are configured using the <code>ciphersuites</code> property as shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;ssl enabled="true"&gt;
            &lt;factory-class-name&gt;...&lt;/factory-class-name&gt;
            &lt;properties&gt;
                &lt;property name="keyStore"&gt;upload/hazelcast.keystore&lt;/property&gt;
                &lt;property name="ciphersuites"&gt;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
                                      TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA&lt;/property&gt;
           &lt;/properties&gt;
       &lt;/ssl&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    ssl:
      enabled: true
      factory-class-name: ...
      properties:
        keyStore: upload/hazelcast.keystore
        ciphersuites: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
                                      TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ciphersuites</code> property accepts a comma separated list (spaces, enters, tabs are
filtered out) of cipher suites in the order
of preference.</p>
</div>
<div class="paragraph">
<p>You can configure a member and client with different cipher suites; but there should be
at least one shared cipher suite.</p>
</div>
<div class="paragraph">
<p>One of the cipher suites that gave very low overhead but still provides solid security
is <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>.
However in our measurements this cipher suite only performs well using OpenSSL; using
the regular Java TLS integration, it performs
badly. So keep that in mind when configuring a client using regular SSL and a member
using OpenSSL.</p>
</div>
<div class="paragraph">
<p>Please check with your security expert to determine which cipher suites are appropriate
and run performance tests to see which ones perform
well in your environment.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t configure the cipher suites, then both client and/or member determine a cipher
suite by themselves during the TLS/SSL
handshake. This can lead to suboptimal performance and lower security than required.</p>
</div>
</div>
<div class="sect3">
<h4 id="_other_ways_of_configuring_properties"><a class="anchor" href="#_other_ways_of_configuring_properties"></a>21.7.4. Other Ways of Configuring Properties</h4>
<div class="paragraph">
<p>You can set all the properties presented in this section using the <code>javax.net.ssl</code> prefix,
e.g., <code>javax.net.ssl.keyStore</code>
and <code>javax.net.ssl.keyStorePassword</code>.</p>
</div>
<div class="paragraph">
<p>Also note that these properties can be specified using the related Java system properties and
also Java&#8217;s <code>-D</code> command line
option. This is very useful if you require a more flexible configuration, e.g., when doing
performance tests.</p>
</div>
<div class="paragraph">
<p>See below examples equivalent to each other:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>System.setProperty("javax.net.ssl.trustStore", "/user/home/hazelcast.ts");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Djavax.net.ssl.trustStore=/user/home/hazelcast.ts</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another two examples equivalent to each other:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>System.setProperty("javax.net.ssl.ciphersuites", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Djavax.net.ssl.ciphersuites=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_validating_secrets_using_strength_policy"><a class="anchor" href="#_validating_secrets_using_strength_policy"></a>21.8. Validating Secrets Using Strength Policy</h3>
<div class="paragraph">
<p>Hazelcast IMDG Enterprise offers a secret validation mechanism including a strength
policy. The term "secret" here refers to the symmetric encryption password,
salt and other passwords and keys.</p>
</div>
<div class="paragraph">
<p>For this validation, Hazelcast IMDG Enterprise comes with the <code>DefaultSecretStrengthPolicy</code>
class to identify all possible weaknesses of secrets and to display a warning
in the system logger. Note that, by default, no matter how weak the secrets are, the
cluster members still start after logging this warning; however, this is
configurable (see the <a href="#enforcing-the-secret-strength-policy">Enforcing the Secret Strength Policy</a> section).</p>
</div>
<div class="paragraph">
<p>The following are the requirements (rules) for the secrets:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Minimum length of eight characters; and</p>
</li>
<li>
<p>Large keyspace use, ensuring the use of at least three of the following:</p>
<div class="ulist">
<ul>
<li>
<p>mixed case</p>
</li>
<li>
<p>alpha</p>
</li>
<li>
<p>numerals</p>
</li>
<li>
<p>special characters</p>
</li>
<li>
<p>no dictionary words</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The rules "Minimum length of eight characters" and "no dictionary words" can
be configured using the following system properties:</p>
</div>
<div class="paragraph">
<p><code>hazelcast.security.secret.policy.min.length</code>: Set the minimum secret
length. The default is 8 characters.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.security.secret.policy.min.length=10</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hazelcast.security.dictionary.policy.wordlist.path</code>: Set the path of a wordlist
available in the file system. The default is <code>/usr/share/dict/words</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.security.dictionary.policy.wordlist.path=/Desktop/myWordList</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_using_a_custom_secret_strength_policy"><a class="anchor" href="#_using_a_custom_secret_strength_policy"></a>21.8.1. Using a Custom Secret Strength Policy</h4>
<div class="paragraph">
<p>You can implement SecretStrengthPolicy to develop your custom strength policy
for a more flexible or strict security. After you implement it, you can use the
following system property to point to your custom class:</p>
</div>
<div class="paragraph">
<p><code>hazelcast.security.secret.strength.default.policy.class</code>: Set the full name of
the custom class.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.security.secret.strength.default.policy.class=com.impl.myStrengthPolicy</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_enforcing_the_secret_strength_policy"><a class="anchor" href="#_enforcing_the_secret_strength_policy"></a>21.8.2. Enforcing the Secret Strength Policy</h4>
<div class="paragraph">
<p>By default, secret strength policy is NOT enforced. This means, if a weak
secret is detected, an informative warning is shown in the system logger and
the members continue to initialize. However, you can enforce the policy using
the following system property so that the members are not started until the
weak secret errors are fixed:</p>
</div>
<div class="paragraph">
<p><code>hazelcast.security.secret.strength.policy.enforced</code>: Set to true to enforce
the secret strength policy. The default is false. To enforce:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.security.secret.strength.policy.enforced=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example warning when secret strength policy is NOT enforced,
i.e., the above system property is set to false:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ SECURITY WARNING @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Group password does not meet the current policy and complexity requirements.
*Must not be set to the default.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example warning when secret strength policy is enforced, i.e., the
above system property is set to true:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-plain hljs" data-lang="plain">WARNING: [192.168.2.112]:5701 [dev] [4.0-SNAPSHOT]
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ SECURITY WARNING @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Symmetric Encryption Password does not meet the current policy and complexity requirements.
*Must contain at least 1 number.
*Must contain at least 1 special character.
Group Password does not meet the current policy and complexity requirements.
*Must not be set to the default.
*Must have at least 1 lower and 1 upper case characters.
*Must contain at least 1 number.
*Must contain at least 1 special character.
Symmetric Encryption Salt does not meet the current policy and complexity requirements.
*Must contain 8 or more characters.
*Must contain at least 1 number.
*Must contain at least 1 special character.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Exception in thread "main" com.hazelcast.security.WeakSecretException: Weak secrets found in configuration, check output above for more details.
at com.hazelcast.security.impl.WeakSecretsConfigChecker.evaluateAndReport(WeakSecretsConfigChecker.java:49)
at com.hazelcast.instance.EnterpriseNodeExtension.printNodeInfo(EnterpriseNodeExtension.java:197)
at com.hazelcast.instance.Node.&lt;init&gt;(Node.java:194)
at com.hazelcast.instance.HazelcastInstanceImpl.createNode(HazelcastInstanceImpl.java:163)
at com.hazelcast.instance.HazelcastInstanceImpl.&lt;init&gt;(HazelcastInstanceImpl.java:130)
at com.hazelcast.instance.HazelcastInstanceFactory.constructHazelcastInstance(HazelcastInstanceFactory.java:195)
at com.hazelcast.instance.HazelcastInstanceFactory.newHazelcastInstance(HazelcastInstanceFactory.java:174)
at com.hazelcast.instance.HazelcastInstanceFactory.newHazelcastInstance(HazelcastInstanceFactory.java:124)
at com.hazelcast.core.Hazelcast.newHazelcastInstance(Hazelcast.java:58)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-realms"><a class="anchor" href="#security-realms"></a>21.9. Security Realms</h3>
<div class="paragraph">
<p>Hazelcast IMDG 4.0 introduces a new security configuration: security realms.
Realms allow configuring JAAS authentication and/or own identity
independently on the module which consumes this configuration.
The realm is a named configuration and other modules just reference it by name.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">security:
  enabled: true
  realms:
    - name: realm1
      authentication:
        jaas:
          - class-name: com.hazelcast.examples.MyRequiredLoginModule
            usage: REQUIRED
            properties:
              property: value
      identity:
        credentials-factory:
          class-name: com.hazelcast.examples.MyCredentialsFactory
          properties:
            property: value
  member-authentication:
    realm: realm1
  client-authentication:
    realm: realm1</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_authentication_configuration"><a class="anchor" href="#_authentication_configuration"></a>21.9.1. Authentication Configuration</h4>
<div class="paragraph">
<p>There are several types of authentication configuration available in a security realm.
The realm cannot have more than one authentication method specified.</p>
</div>
<div class="paragraph">
<p>The following are the available authentication types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jaas</code>: It allows defining JAAS login module stacks.</p>
</li>
<li>
<p><code>ldap</code>: It verifies <code>PasswordCredentials</code> against an LDAP server.</p>
</li>
<li>
<p><code>kerberos</code>: It verifies the Kerberos token provided in <code>TokenCredentials</code>.</p>
</li>
<li>
<p><code>tls</code>: It verifies that the TLS mutual authentication was used
in the incoming connection and the peer&#8217;s certificate chain is available.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_jaas_authentication_type"><a class="anchor" href="#_jaas_authentication_type"></a>JAAS Authentication Type</h5>
<div class="paragraph">
<p>The <code>&lt;jaas&gt;</code> authentication configuration is the most flexible
form of the authentication configuration, but it requires knowledge
of JAAS login modules and related concepts. It allows using
custom login modules and ordering them in a login module stack.</p>
</div>
<div class="paragraph">
<p>The following is a sample configuration which authenticates against an LDAP server or
database as a fallback:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">realms:
  - name: jaasRealm
    authentication:
      jaas:
        - class-name: com.examples.LdapLoginModule
          usage: SUFFICIENT
          properties:
            url: ldap://corp-ldap
        - class-name: com.examples.DatabaseLoginModule
          usage: SUFFICIENT
          properties:
            type: ora18
            host: corp-db
            table: USERS</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more details, see the <a href="#jaas-authentication">JAAS authentication section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ldap_authentication_type"><a class="anchor" href="#_ldap_authentication_type"></a>LDAP Authentication Type</h5>
<div class="paragraph">
<p>LDAP servers are one of the most popular identity stores in companies.
They can track information about the organization structure,
users, groups, servers and configurations.</p>
</div>
<div class="paragraph">
<p>Hazelcast supports authentication and authorization against LDAP servers.
The authentication verifies the provided name and password.
The authorization part allows to map roles to the authenticated user.</p>
</div>
<div class="paragraph">
<p>The password verification during the authentication is possible by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>making a new LDAP bind operation with the given name and password</p>
</li>
<li>
<p>using a separate "admin connection" to verify the provided password
against an LDAP object attribute.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The LDAP authentication allows also a role mapping.
As there are more ways how roles can be mapped in the LDAP,
Hazelcast provides several approaches to retrieve them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>attribute</code>: The role name is stored as an attribute in the object representing the identity.</p>
</li>
<li>
<p><code>direct</code> mapping: The identity object contains an attribute with reference to the role object(s).</p>
</li>
<li>
<p><code>reverse</code> mapping: The role objects having a reference to the identity object are searched.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>direct</code> and <code>reverse</code> mapping modes also allow a role search recursion.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. LDAP Configuration Options</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL of the LDAP server. The value is configured as the JNDI environment
property, i.e., <code>java.naming.provider.url</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>socket-factory-class-name</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Socket factory class name. The factory can be used for fine grained
configuration of the TLS protocol on top of the LDAP protocol, i.e., <code>ldaps</code> scheme.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>parse-dn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to <code>true</code>, it treats the value of <code>role-mapping-attribute</code> as a DN and
extracts only the <code>role-name-attribute</code> values as role names. If set to <code>false</code>,
the whole value of <code>role-mapping-attribute</code> is used as a role name.</p>
<p class="tableblock">This option is only used when the <code>role-mapping-mode</code> option has the value <code>attribute</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>role-context</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP Context in which assigned roles are searched, e.g., <code>ou=Roles,dc=hazelcast,dc=com</code>.</p>
<p class="tableblock">This option is only used when the <code>role-mapping-mode</code> option has the value <code>reverse</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>role-filter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>([role-mapping-attribute]={memberDN})</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP search string which usually contains a placeholder <code>{memberDN}</code> to be
replaced by the provided login name, e.g., <code>(member={memberDN})</code>.</p>
<p class="tableblock">If the role search recursion is enabled (see <code>role-recursion-max-depth</code>), the <code>{memberDN}</code>
is replaced by role DNs in the recurrent searches.</p>
<p class="tableblock">This option is only used when the <code>role-mapping-mode</code> option has the value <code>reverse</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>role-mapping-attribute</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the LDAP attribute which contains either the role name or role DN.</p>
<p class="tableblock">This option is  used when the <code>role-mapping-mode</code> option has the value <code>attribute</code> or <code>direct</code>.
If the mapping mode is <code>reverse</code>, the value is used in <code>role-filter</code> default value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>role-mapping-mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>attribute</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Role mapping mode. It can have one of the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>attribute</code>: The user object in the LDAP contains directly role name in the
given attribute. Role name can be parsed from a DN string when <code>parse-dn=true</code>
No additional LDAP query is done to find assigned roles.</p>
</li>
<li>
<p><code>direct</code>: The user object contains an attribute with DN(s) of assigned
role(s). Role object(s) is/are loaded from the LDAP and the role name is
retrieved from its attributes. Role search recursion can be enabled for this mode.</p>
</li>
<li>
<p><code>reverse</code>: The role objects are located by executing an LDAP search query
with the given <code>role-filter</code>. In this case, the role object usually contains
attributes with DNs of the assigned users. Role search recursion can be enabled for this mode.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>role-name-attribute</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This option may refer to a name of LDAP attribute within the role object which
contains the role name in case of <code>direct</code> and <code>reverse</code> role mapping mode. It may also refer
to the attribute name within X.500 name stored in <code>role-mapping-attribute</code> when
<code>role-mapping-mode=attribute</code> and <code>parse-dn=true</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>role-recursion-max-depth</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the maximum depth of role search recursion. The default value 1 means
the role search recursion is disabled.</p>
<p class="tableblock">This option is only used when the <code>role-mapping-mode</code> option has value <code>direct</code> or <code>reverse</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>role-search-scope</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>subtree</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>LDAP search scope used for <code>role-filter</code> search. It can have one of the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subtree</code>: Searches for objects in the given context and its subtree.</p>
</li>
<li>
<p><code>one-level</code>: Searches just one-level under the given context.</p>
</li>
<li>
<p><code>object</code>: Searches (or tests) just for the context object itself (if it matches the filter criteria).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This option is only used when the <code>role-mapping-mode</code> option has the value <code>reverse</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>user-name-attribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>uid</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP attribute name whose value is used as a name in
<code>ClusterIdentityPrincipal</code> added to the JAAS Subject.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>system-user-dn</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Admin account DN. If configured, then the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For the user and role object, search queries are used an admin connection instead
of the "user" one created by LDAP bind with provided credentials.</p>
</li>
<li>
<p>LDAP authentication doesn&#8217;t expect the full user DN to be provided as a login name.
It rather expects names like <code>"jduke"</code> than <code>"uid=jduke,ou=Engineering,o=Hazelcast,dc=com"</code>;</p>
</li>
<li>
<p>The admin connection allows verifying the provided user credentials against a
value defined in the <code>password-attribute</code> option.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>system-user-password</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Admin&#8217;s password (for <code>system-user-dn</code> account).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>system-authentication</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>simple</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the authentication mechanism used for the admin LDAP connection.
It&#8217;s used as a value for JNDI environment property <code>Context#SECURITY_AUTHENTICATION</code>.
You can specify <code>GSSAPI</code> to authenticate with the Kerberos protocol.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>password-attribute</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Credentials verification is done by the new LDAP binds by default.
Nevertheless, the password can be stored in a non-default LDAP attribute,
and in this case use <code>password-attribute</code> to configure against which
LDAP attribute (within the user object) is the provided password compared
during the login. As a result, if the <code>password-attribute</code> option is provided,
then the extra LDAP bind to verify credentials is not done and passwords
are just compared within the Hazelcast code after retrieving the user object from LDAP server.</p>
<p class="tableblock">This option is only used when the admin connection is configured, i.e., when <code>system-user-dn</code> or <code>system-authentication</code> is defined.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>user-context</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP context in which the user objects are searched, e.g., <code>ou=Users,dc=hazelcast,dc=com</code>.</p>
<p class="tableblock">This option is only used when the admin connection is configured, i.e., when <code>system-user-dn</code> or <code>system-authentication</code> is defined.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>user-filter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(uid={login})</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP search string for retrieving the user objects based on the provided login name.
It usually contains a placeholder substring <code>{login}</code> which is replaced by the provided login name.</p>
<p class="tableblock">This option is only used when the admin connection is configured, i.e., when <code>system-user-dn</code> or <code>system-authentication</code> is defined.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>user-search-scope</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>subtree</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>LDAP search scope used for <code>user-filter</code> search. It can have one of the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subtree</code>: Searches for objects in the given context and its subtree.</p>
</li>
<li>
<p><code>one-level</code>: Searches just one-level under the given context.</p>
</li>
<li>
<p><code>object</code>: Searches (or tests) just for the context object itself (if it matches the filter criteria).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This option is only used when the admin connection is configured, i.e., when <code>system-user-dn</code> or <code>system-authentication</code> is defined.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>skip-authentication</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Flag which allows disabling password verification and
only takes care about filling <code>HazelcastPrincipal</code> instances into the
Subject.</p>
</div>
<div class="paragraph">
<p>This option is only used when the admin connection is configured, i.e., when <code>system-user-dn</code> or <code>system-authentication</code> is defined.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>security-realm</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If specified, given realm name is used for authentication of
a (temporary) Subject which is then used for doing LDAP queries.</p>
</div>
<div class="paragraph">
<p>This option is only used when the admin connection is configured, i.e., when <code>system-user-dn</code> or <code>system-authentication</code> is defined.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Detailed logging for LDAP authentication can be enabled by
configuring a more verbose logger level for the <code>com.hazelcast.security</code>
package as described in the <a href="#security-debugging">Security Debugging section</a>.</p>
</div>
<div class="sect5">
<h6 id="_tls_protected_ldap_server_connections"><a class="anchor" href="#_tls_protected_ldap_server_connections"></a>TLS Protected LDAP Server Connections</h6>
<div class="paragraph">
<p>The LDAP authentication type supports TLS protected connections
to LDAP servers, i.e., the <code>ldaps</code> protocol scheme. The TLS is
handled on the Java runtime side (JNDI API and URL handlers).</p>
</div>
<div class="paragraph">
<p>When using TLS, the LDAP provider will, by default, use the socket factory,
<code>javax.net.ssl.SSLSocketFactory</code> for creating a TLS socket to communicate
with the server, using the default JSSE configuration. By default, the server&#8217;s
certificate is validated against Java default CA certificate store and hostname
in LDAPs URL is verified against the name(s) in the server certificate. The behavior
can be controlled globally by using <code>javax.net.ssl.*</code> properties. Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">java -Djavax.net.ssl.trustStore=/opt/hazelcast.truststore \
  -Djavax.net.ssl.trustStorePassword=123456 \
  -Djavax.net.ssl.keyStore=/opt/hazelcast.keystore \
  -Djavax.net.ssl.keyStorePassword=123456 \
  ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>There can be also properties specific to vendor or Java version allowing more
fine-grained control. Here is an example on disabling host name validation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">-Dcom.sun.jndi.ldap.object.disableEndpointIdentification=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>When even more control is necessary, you can implement your own
<code>SSLSocketFactory</code> and use its class name as the value in the <code>ldap</code>
authentication option <code>socket-factory-class-name</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example custom socket factory class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package security.ldap;

import java.io.FileInputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.security.KeyStore;
import java.security.SecureRandom;

import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManagerFactory;

public class CustomSSLSocketFactory extends SSLSocketFactory {

    private static final SocketFactory INSTANCE = new CustomSSLSocketFactory();

    /**
     * JNDI uses this method when creating {@code ldaps} connections.
     */
    public static SocketFactory getDefault() {
        return INSTANCE;
    }

    private SSLSocketFactory delegate;

    public CustomSSLSocketFactory() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            try (FileInputStream fis = new FileInputStream("/opt/ldap.truststore")) {
                trustStore.load(fis, "S3cr3t".toCharArray());
            }
            TrustManagerFactory tmFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmFactory.init(trustStore);
            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, tmFactory.getTrustManagers(), new SecureRandom());
            delegate = sc.getSocketFactory();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return delegate.getDefaultCipherSuites();
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return delegate.getSupportedCipherSuites();
    }

    @Override
    public Socket createSocket(Socket arg0, String arg1, int arg2, boolean arg3) throws IOException {
        return delegate.createSocket(arg0, arg1, arg2, arg3);
    }

    @Override
    public Socket createSocket(String arg0, int arg1) throws IOException {
        return delegate.createSocket(arg0, arg1);
    }

    @Override
    public Socket createSocket(InetAddress arg0, int arg1) throws IOException {
        return delegate.createSocket(arg0, arg1);
    }

    @Override
    public Socket createSocket(String arg0, int arg1, InetAddress arg2, int arg3) throws IOException {
        return delegate.createSocket(arg0, arg1, arg2, arg3);
    }

    @Override
    public Socket createSocket(InetAddress arg0, int arg1, InetAddress arg2, int arg3) throws IOException {
        return delegate.createSocket(arg0, arg1, arg2, arg3);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The authentication configuration could look like as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">realms:
  - name: ldapsRealm
    authentication:
      ldap:
         url: ldaps://ldapserver.acme.com
         socket-factory-class-name: security.ldap.CustomSSLSocketFactory
         role-mapping-attribute: cn</code></pre>
</div>
</div>
<div class="paragraph">
<p>The LDAP authentication is backed by the JNDI API in Java.
It has also the failover support. You can configure multiple space-separated
URLs in the <code>&lt;url&gt;</code> option:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">realms:
  - name: ldapFallbackRealm
    authentication:
      ldap:
         url: ldap://ldap-master.example.com ldap://ldap-backup.example.com</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kerberos-authentication"><a class="anchor" href="#kerberos-authentication"></a>Kerberos Authentication Type</h5>
<div class="paragraph">
<p>The Kerberos authentication protocol is one of the standard solutions
for single sign-on (SSO). It&#8217;s well established in many companies. Hazelcast
supports Kerberos authentication as an Enterprise feature and it also
provides Kerberos integration to LDAP-based authorization.</p>
</div>
<div class="paragraph">
<p>The Kerberos support in Hazelcast has 2 configuration parts: identity
and authentication. The identity part is responsible for retrieving the service
ticket from Kerberos KDC (Key Distribution Center).
The authentication part verifies the service tickets.</p>
</div>
<div class="paragraph">
<p>Default Service principal names for Hazelcast members are in the form
<code>hz/address@REALM</code>, e.g., <code>hz/192.168.1.1@ACME.COM</code>.</p>
</div>
<div class="paragraph">
<p>Before a service ticket is issued, the client side of the connection has to be
authenticated, which means the TGT (Ticket Granting Ticket) is present in the Subject.</p>
</div>
<div class="paragraph">
<p>Hazelcast delegates the TGT retrieval to vendor specific <code>Krb5LoginModule</code>
implementations (find the correct login module and its options in your Java
documentation). On the Hazelcast side, the <code>security-ream</code> property allows
referencing another realm with <code>Krb5LoginModule</code> configured.</p>
</div>
<div class="listingblock primary">
<div class="title">Sample Kerberos Identity Configuration XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;realm name="kerberosRealm"&gt;
    &lt;identity&gt;
        &lt;kerberos&gt;
            &lt;realm&gt;ACME.COM&lt;/realm&gt;
            &lt;security-realm&gt;krb5Initiator&lt;/security-realm&gt;
        &lt;/kerberos&gt;
    &lt;/identity&gt;
&lt;/realm&gt;
&lt;realm name="krb5Initiator"&gt;
    &lt;authentication&gt;
        &lt;jaas&gt;
            &lt;login-module class-name="com.sun.security.auth.module.Krb5LoginModule" usage="REQUIRED"&gt;
                &lt;properties&gt;
                    &lt;property name="useTicketCache"&gt;true&lt;/property&gt;
                    &lt;property name="doNotPrompt"&gt;true&lt;/property&gt;
                &lt;/properties&gt;
            &lt;/login-module&gt;
        &lt;/jaas&gt;
    &lt;/authentication&gt;
&lt;/realm&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">realms:
  - name: kerberosRealm
      identity:
        kerberos:
          realm: ACME.COM
          security-realm: krb5Initiator
  - name: krb5Initiator
      authentication:
        jaas:
          class-name: com.sun.security.auth.module.Krb5LoginModule
            properties:
              useTicketCache: true
              doNotPrompt: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;kerberos&gt;</code> identity configuration has the following properties:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 16. The &lt;kerberos&gt; Identity Configuration Options</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property name</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spn</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows configuring static Service Principal Name (SPN). It&#8217;s
meant for use cases where all the members share a single Kerberos identity.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>service-name-prefix</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"hz/"</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the prefix of SPN. By default the member&#8217;s
principal name (for which this credentials
factory asks the service ticket) is in the form
<code>"[servicePrefix][memberIpAddress]@[REALM]"</code>, e.g.,
<code>"hz/192.168.1.1@ACME.COM"</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>realm</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kerberos realm name, e.g., <code>"ACME.COM"</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>security-realm</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Security realm name in the Hazelcast configuration used
for Kerberos authentication. The authentication configuration in the
referenced security realm will be used to fill the Subject with the Kerberos
credentials, e.g., TGT.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>use-canonical-hostname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flag which controls if canonical hostnames should be used instead of IP addresses
in generated Service Principal names.
This property is only used when Service Principal name is not static, i.e., when <code>spn</code> option
is not configured).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>principal</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kerberos principal name. This is a helper option which can be used together
with the <code>keytabFile</code> to replace the <code>security-realm</code> configuration.</p>
<p class="tableblock"><em>We don&#8217;t recommend using this property in production!</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>keytabFile</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Path to a keytab file with the current principal&#8217;s secrets.
This is a helper option which can be used together
with the <code>principal</code> to replace the <code>security-realm</code> configuration.</p>
<p class="tableblock"><em>We don&#8217;t recommend using this property in production!</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The authenticating part on the server side is able to
accept the Kerberos tickets and verify them. Again the Kerberos
authentication is delegated to another realm with the Kerberos login module
configured.</p>
</div>
<div class="listingblock primary">
<div class="title">Sample Kerberos Authentication Configuration XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;realm name="kerberosRealm"&gt;
    &lt;authentication&gt;
        &lt;kerberos&gt;
            &lt;security-realm&gt;krb5Acceptor&lt;/security-realm&gt;
        &lt;/kerberos&gt;
    &lt;/authentication&gt;
&lt;/realm&gt;
&lt;realm name="krb5Acceptor"&gt;
    &lt;authentication&gt;
        &lt;jaas&gt;
            &lt;login-module class-name="com.sun.security.auth.module.Krb5LoginModule" usage="REQUIRED"&gt;
                &lt;properties&gt;
                    &lt;property name="isInitiator"&gt;false&lt;/property&gt;
                    &lt;property name="useTicketCache"&gt;false&lt;/property&gt;
                    &lt;property name="doNotPrompt"&gt;true&lt;/property&gt;
                    &lt;property name="useKeyTab"&gt;true&lt;/property&gt;
                    &lt;property name="storeKey"&gt;true&lt;/property&gt;
                    &lt;property name="principal"&gt;hz/192.168.1.1@ACME.COM&lt;/property&gt;
                    &lt;property name="keyTab"&gt;/opt/member1.keytab&lt;/property&gt;
                &lt;/properties&gt;
            &lt;/login-module&gt;
        &lt;/jaas&gt;
    &lt;/authentication&gt;
&lt;/realm&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">realms:
  name: kerberosRealm
    authentication:
      kerberos:
        security-realm: krb5Acceptor
  name: krb5Acceptor
    authentication:
      jaas:
        - class-name: com.sun.security.auth.module.Krb5LoginModule
          usage: REQUIRED
          properties:
            isInitiator: false
            useTicketCache: false
            doNotPrompt: true
            useKeyTab: true
            storeKey: true
            principal: hz/192.168.1.1@ACME.COM
            keyTab: /opt/member1.keytab</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>krb5Acceptor</code> realm configuration in the snippet only loads the Kerberos secrets from
a keytab file and it doesn&#8217;t authenticate against a KDC.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 17. The &lt;kerberos&gt; Authentication Configuration Options</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property name</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>relax-flags-check</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows disabling some of the checks on the
incoming token, e.g., passes authentication even if the mutual
authentication is required by the token.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>use-name-without-realm</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When set to <code>true</code>, then the Kerberos realm part is removed from the
authenticated name, e.g., <code>"<a href="mailto:jduke@ACME.COM">jduke@ACME.COM</a>"</code> becomes just <code>"jduke"</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>security-realm</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Security realm name in the Hazelcast configuration used
for Kerberos authentication. The authentication configuration in the
referenced security realm will be used to fill the Subject with the Kerberos
credentials, e.g., Keytab.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>principal</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kerberos principal name. This is a helper option which can be used together
with the <code>keytabFile</code> to replace the <code>security-realm</code> configuration.</p>
<p class="tableblock"><em>We don&#8217;t recommend using this property in production!</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>keytabFile</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Path to a keytab file with the current principal&#8217;s secrets.
This is a helper option which can be used together
with the <code>principal</code> to replace the <code>security-realm</code> configuration.</p>
<p class="tableblock"><em>We don&#8217;t recommend using this property in production!</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>GssApiLoginModule</code> (implementing Kerberos authentication)
derives from the abstract <code>ClusterLoginModule</code>. As a result the <code>&lt;kerberos&gt;</code>
configuration supports the common options, too: <code>skip-identity</code>, <code>skip-endpoint</code> and
<code>skip-role</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>The Kerberos authentication in Hazelcast is only able to validate connections on
the server side. It doesn&#8217;t support mutual authentication.</p>
</li>
<li>
<p>The Generic Security Services API (GSS-API) is not used for protecting (wrapping)
the messages after the authentication, e.g., encryption, integrity checks. It&#8217;s only used for
accepting tokens.</p>
</li>
<li>
<p>The token itself is not protected against Man-in-the-Middle (MITM) attacks.
If an attacker is able to eavesdrop the token and use it before the
original sender, then the attacker succeeds with the authentication but
the original sender won&#8217;t.</p>
<div class="ulist">
<ul>
<li>
<p>There is a replay protection in Java which caches the already used tokens.</p>
</li>
<li>
<p>Java Kerberos implementation accepts the token for 5 minutes (by default)
from its creation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Time has to be synchronized on the machines where the Kerberos is
used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you are running Hazelcast in an untrusted network with a MITM attack
risk, then enable encryption on Hazelcast protocols to prevent stealing
the token.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_kerberos_and_ldap_integration"><a class="anchor" href="#_kerberos_and_ldap_integration"></a>Kerberos and LDAP integration</h5>
<div class="paragraph">
<p>The Kerberos authentication allows loading role mapping information from
an LDAP server (usually the one backing the Kerberos KDC server, too).
Therefore the <code>&lt;ldap&gt;</code> authentication configuration is also available as
sub-configuration of the <code>&lt;kerberos&gt;</code> authentication.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;realm name="kerberosRealm"&gt;
    &lt;authentication&gt;
        &lt;kerberos&gt;
            &lt;skip-role&gt;true&lt;/skip-role&gt;
            &lt;security-realm&gt;krb5Acceptor&lt;/security-realm&gt;
            &lt;ldap&gt;
                &lt;url&gt;ldap://ldap.hazelcast.com&lt;/url&gt;
                &lt;system-authentication&gt;GSSAPI&lt;/system-authentication&gt;
                &lt;role-mapping-attribute&gt;memberOf&lt;/role-mapping-attribute&gt;
                &lt;security-realm&gt;krb5Initiator&lt;/security-realm&gt;
                &lt;user-filter&gt;(krb5PrincipalName={login})&lt;/user-filter&gt;
                &lt;skip-authentication&gt;true&lt;/skip-authentication&gt;
            &lt;/ldap&gt;
        &lt;/kerberos&gt;
    &lt;/authentication&gt;
&lt;/realm&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">realms:
  - name: kerberosRealm
    authentication:
      kerberos:
        skip-role: true
        security-realm: krb5Acceptor
        ldap:
          url: ldap://ldap.hazelcast.com
          system-authentication: GSSAPI
          security-realm: krb5Initiator
          skip-authentication: true
          user-filter: "(krb5PrincipalName={login})"
          role-mapping-attribute: memberOf</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Kerberos-LDAP integration doesn&#8217;t support credentials delegation,
i.e., reusing client&#8217;s ticket for accessing the LDAP. It only allows using
the member&#8217;s Kerberos credentials to authenticate into the LDAP.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_simplified_kerberos_configuration"><a class="anchor" href="#_simplified_kerberos_configuration"></a>Simplified Kerberos Configuration</h5>
<div class="paragraph">
<p>To simplify the Kerberos configuration process for new users, Hazelcast allows
skipping <code>Krb5LoginModule</code> JAAS configuration within separate security realms.
Instead it&#8217;s possible to define the <code>principal</code> and <code>keytabFile</code> options in the
<code>kerberos</code> identity and authentication configurations.
If these options are used instead of the <code>security-realm</code>, then a new temporary
realm is generated on the fly during the authentication.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:realm name="simpleKerberosRealm"&gt;
    &lt;hz:authentication&gt;
        &lt;hz:kerberos&gt;
            &lt;hz:principal&gt;hz/127.0.0.1@HAZELCAST.COM&lt;/hz:principal&gt;
            &lt;hz:keytab-file&gt;/opt/localhost.keytab&lt;/hz:keytab-file&gt;
        &lt;/hz:kerberos&gt;
    &lt;/hz:authentication&gt;
    &lt;hz:identity&gt;
        &lt;hz:kerberos&gt;
            &lt;hz:realm&gt;HAZELCAST.COM&lt;/hz:realm&gt;
            &lt;hz:principal&gt;hz/127.0.0.1@HAZELCAST.COM&lt;/hz:principal&gt;
            &lt;hz:keytab-file&gt;/opt/localhost.keytab&lt;/hz:keytab-file&gt;
        &lt;/hz:kerberos&gt;
    &lt;/hz:identity&gt;
&lt;/hz:realm&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">realms:
  - name: simpleKerberosRealm
    authentication:
      kerberos:
        principal: hz/127.0.0.1@HAZELCAST.COM
        keytab-file: /opt/localhost.keytab
    identity:
      kerberos:
        realm: HAZELCAST.COM
        principal: hz/127.0.0.1@HAZELCAST.COM
        keytab-file: /opt/localhost.keytab</code></pre>
</div>
</div>
<div class="paragraph">
<p>A warning is logged during the first usage of the simplified configuration form.
It includes the generated configuration, so you can use it as a starting point
to define the full Kerberos configuration. An example warning log is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>12:37:41,187  WARN [KerberosCredentialsFactory] Using generated Kerberos initiator
realm configuration is not intended for production use. It's recommended
to properly configure the Krb5LoginModule manually to fit your needs.
Following configuration was generated from provided keytab and principal properties:
&lt;realm name="krb5Initiator"&gt;
  &lt;authentication&gt;
    &lt;jaas&gt;
      &lt;login-module class-name="com.sun.security.auth.module.Krb5LoginModule" usage="REQUIRED"&gt;
        &lt;properties&gt;
          &lt;property name="isInitiator"&gt;true&lt;/property&gt;
          &lt;property name="useKeyTab"&gt;true&lt;/property&gt;
          &lt;property name="refreshKrb5Config"&gt;true&lt;/property&gt;
          &lt;property name="doNotPrompt"&gt;true&lt;/property&gt;
          &lt;property name="storeKey"&gt;true&lt;/property&gt;
          &lt;property name="keyTab"&gt;/opt/localhost.keytab&lt;/property&gt;
          &lt;property name="principal"&gt;hz/127.0.0.1@HAZELCAST.COM&lt;/property&gt;
        &lt;/properties&gt;
      &lt;/login-module&gt;
    &lt;/jaas&gt;
  &lt;/authentication&gt;
&lt;/realm&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tls_authentication_type"><a class="anchor" href="#_tls_authentication_type"></a>TLS Authentication Type</h5>
<div class="paragraph">
<p>Hazelcast is able to protect network communication using TLS.
The TLS mutual authentication is also supported. It means not only the
server side identifies itself to a client side (member, client, REST client, etc.),
but also the client side needs to prove its identity by using a TLS (X.509) certificate.</p>
</div>
<div class="paragraph">
<p>The <code>tls</code> authentication type verifies within the JAAS authentication
that the incoming connection already authenticated the client&#8217;s TLS certificate.
A <code>ClusterIdentityPrincipal</code> uses the subject DN (distinguished name)
from the client&#8217;s TLS certificate.</p>
</div>
<div class="paragraph">
<p>This authentication type is able to parse a role name from the client&#8217;s certificate
subject DN. The <code>&lt;tls&gt;</code> element has an attribute, <code>roleAttribute</code>, which specifies
a part of DN to be used as a role name.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">realms:
  name: tlsRealm
    authentication:
      tls:
        roleAttribute: cn</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <code>tls</code> authentication  uses <code>cn</code> attribute from the subject DN as the role name.
If the subject DN in the certificate is <code>cn=admin,ou=Devs,o=Hazelcast</code> for instance,
then the following <code>Principals</code> are added:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ClusterIdentityPrincipal: CN=admin,OU=Devs,O=Hazelcast</code></p>
</li>
<li>
<p><code>ClusterRolePrincipal: admin</code></p>
</li>
<li>
<p><code>ClusterEndpointPrincipal: [remote address of the connecting party]</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_identity_configuration"><a class="anchor" href="#_identity_configuration"></a>21.9.2. Identity Configuration</h4>
<div class="paragraph">
<p>The Identity configuration allows defining own <a href="#credentials">Credentials</a>.
These Credentials are used to authenticate to other systems.</p>
</div>
<div class="paragraph">
<p>Available identity configuration types are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>username-password</code>: Defines a new <code>PasswordCredentials</code> object.</p>
</li>
<li>
<p><code>token</code>: Defines a new <code>TokenCredentials</code> object.</p>
</li>
<li>
<p><code>kerberos</code>: Defines the Kerberos identity which uses the
service tickets stored in the <code>TokenCredentials</code> object.</p>
</li>
<li>
<p><code>credentials-factory</code>: Configures the factory class which creates the <code>Credentials</code> objects.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="credentials"><a class="anchor" href="#credentials"></a>Credentials</h5>
<div class="paragraph">
<p>One of the key elements in Hazelcast security is the <code>Credentials</code> object, which
represents evidence of the identity (member or client).
The content of <code>Credentials</code> object is verified during the authentication.
Credentials is an interface which extends <code>Serializable</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Credentials extends Serializable {
    String getName();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two subtype interfaces which simplify the <code>Credentials</code> usage.
The subtypes reflect data provided in the client authentication messages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Name and password (<code>com.hazelcast.security.PasswordCredentials</code>)</p>
</li>
<li>
<p>Byte array token (<code>com.hazelcast.security.TokenCredentials</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The interfaces have the following forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface PasswordCredentials extends Credentials {
    String getPassword();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface TokenCredentials extends Credentials {
  byte[] getToken();

  default Data asData() {
      return new HeapData(getToken());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Credentials</code> instance can be retrieved in the login modules
by handling a <code>CredentialsCallback</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_password_credentials"><a class="anchor" href="#_password_credentials"></a>Password Credentials</h5>
<div class="paragraph">
<p>A <code>PasswordCredentials</code> implementation can be configured as a
simple identity representation. It is configured by the <code>&lt;username-password/&gt;</code>
XML configuration element as shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">realms:
  name: passwordRealm
    identity:
      username-password:
        username: member1
        password: s3crEt
member-authentication:
  realm: passwordRealm</code></pre>
</div>
</div>
<div class="paragraph">
<p>The equivalent programmatic configuration is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_token_credentials"><a class="anchor" href="#_token_credentials"></a>Token Credentials</h5>
<div class="paragraph">
<p><code>TokenCredentials</code> instances are also simply configurable for
identity representation. The <code>&lt;token/&gt;</code> XML configuration element
allows using either plain ASCII tokens or Base64 encoded values.
Its optional argument <code>encoding</code> can have either <code>base64</code> or <code>none</code> (default)
as its value.</p>
</div>
<div class="paragraph">
<p>The following two realms define the same token value - bytes of the "Hazelcast" string:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">realms:
  name: tokenRealm1
    identity:
      token: Hazelcast
  name: tokenRealm2
    identity:
      token:
        encoding: base64
        value: SGF6ZWxjYXN0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The equivalent programmatic configuration is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_kerberos_identity"><a class="anchor" href="#_kerberos_identity"></a>Kerberos Identity</h5>
<div class="paragraph">
<p>The <code>kerberos</code> identity type is used to retrieve Kerberos service tickets to access
a member with the <code>kerberos</code> authentication type configured. The resulting tickets
are <code>TokenCredentials</code> instances. Read more about <code>kerberos</code> identity in
the <a href="#kerberos-authentication">Kerberos authentication section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_credentials_factory"><a class="anchor" href="#_credentials_factory"></a>Credentials Factory</h5>
<div class="paragraph">
<p>The most flexible way to define the <code>Credentials</code> objects
is using a custom credential factory. It is an implementation
of <code>com.hazelcast.security.ICredentialsFactory</code>
interface. Its <code>newCredentials()</code> method is the one which provides credentials.</p>
</div>
<div class="paragraph">
<p>The XML configuration uses <code>&lt;credentials-factory&gt;</code> element to define the factory class.</p>
</div>
<div class="paragraph">
<p>The behavior of credential factories can be controlled by specifying factory properties.
The properties are provided in the <code>init(Properties)</code> method.</p>
</div>
<div class="paragraph">
<p>A sample configuration is shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">realms:
  name: credentialsFactoryRealm
    identity:
      credentials-factory:
        class-name: com.examples.TOTPCredentialsFactory
        properties:
          seed: 3132333435363738393031323334353637383930</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_security_realms_on_the_client_side"><a class="anchor" href="#_security_realms_on_the_client_side"></a>21.9.3. Security Realms on the Client Side</h4>
<div class="paragraph">
<p>Hazelcast IMDG 4.1 introduces a limited support of security realms in native clients.
The configuration allows specifying JAAS login modules which can be referenced from
the Kerberos identity configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;security&gt;
    &lt;kerberos&gt;
        &lt;realm&gt;ACME.COM&lt;/realm&gt;
        &lt;security-realm&gt;krb5Initiator&lt;/security-realm&gt;
    &lt;/kerberos&gt;
    &lt;realms&gt;
        &lt;realm name="krb5Initiator"&gt;
            &lt;authentication&gt;
                &lt;jaas&gt;
                    &lt;login-module class-name="com.sun.security.auth.module.Krb5LoginModule" usage="REQUIRED"&gt;
                        &lt;properties&gt;
                            &lt;property name="useTicketCache"&gt;true&lt;/property&gt;
                            &lt;property name="doNotPrompt"&gt;true&lt;/property&gt;
                        &lt;/properties&gt;
                    &lt;/login-module&gt;
                &lt;/jaas&gt;
            &lt;/authentication&gt;
        &lt;/realm&gt;
    &lt;/realms&gt;
&lt;/security&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">security:
  kerberos:
    realm: ACME.COM
    security-realm: krb5Initiator
    realms:
      name: krb5Initiator
        authentication:
          jaas:
            class-name: com.sun.security.auth.module.Krb5LoginModule
            usage: REQUIRED
            properties:
              useTicketCache: true
              doNotPrompt: true</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jaas-authentication"><a class="anchor" href="#jaas-authentication"></a>21.10. JAAS authentication</h3>
<div class="sect3">
<h4 id="_jaas_principals_used_in_hazelcast"><a class="anchor" href="#_jaas_principals_used_in_hazelcast"></a>21.10.1. JAAS Principals used in Hazelcast</h4>
<div class="paragraph">
<p>Hazelcast works with the following JAAS <a href="https://docs.oracle.com/javase/8/docs/api/java/security/Principal.html" target="_blank" rel="noopener">Principal</a>
implementations added to the <a href="https://docs.oracle.com/javase/8/docs/api/javax/security/auth/Subject.html" target="_blank" rel="noopener">Subject</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ClusterIdentityPrincipal</code>: Represents the name of authenticated party (usually
one instance in the <code>Subject</code>).</p>
</li>
<li>
<p><code>ClusterRolePrincipal</code>: Represents the role assigned to the authenticated party
(usually zero or more instances in the <code>Subject</code>).</p>
</li>
<li>
<p><code>ClusterEndpointPrincipal</code>: Represents the remote address of the authenticated
party (usually one instance in the <code>Subject</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These implementations share a common abstract parent class <code>HazelcastPrincipal</code>,
so it is simple to find them in the JAAS <code>Subject</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Set&lt;HazelcastPrincipal&gt; hazelcastPrincipals =
            subject.getPrincipals(HazelcastPrincipal.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_callbacks_supported_in_login_modules"><a class="anchor" href="#_callbacks_supported_in_login_modules"></a>21.10.2. Callbacks Supported in Login Modules</h4>
<div class="paragraph">
<p>JAAS <a href="https://docs.oracle.com/javase/8/docs/api/javax/security/auth/callback/Callback.html" target="_blank" rel="noopener">Callback</a>
instances are used for accessing different kinds of data from the
<a href="http://docs.oracle.com/javase/8/docs/api/javax/security/auth/spi/LoginModule.html" target="_blank" rel="noopener">LoginModule</a>
implementations. Hazelcast supports the following <code>Callback</code> types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>javax.security.auth.callback.NameCallback</code>: Retrieves a name from <code>Credentials</code> object.</p>
</li>
<li>
<p><code>javax.security.auth.callback.PasswordCallback</code>: Retrieves a password from <code>PasswordCredentials</code> object.</p>
</li>
<li>
<p><code>com.hazelcast.security.CertificatesCallback</code>: Retrieves the TLS certificate chain (if any) of the connecting party.</p>
</li>
<li>
<p><code>com.hazelcast.security.ClusterNameCallback</code>: Retrieves the cluster name used for the authentication.</p>
</li>
<li>
<p><code>com.hazelcast.security.CredentialsCallback</code>: Retrieves <code>Credentials</code> used for authentication.</p>
</li>
<li>
<p><code>com.hazelcast.security.ConfigCallback</code>: Retrieves the <code>Config</code> object of current Hazelcast member.</p>
</li>
<li>
<p><code>com.hazelcast.security.EndpointCallback</code>: Retrieves the remote address of the connecting party.</p>
</li>
<li>
<p><code>com.hazelcast.security.SerializationServiceCallback</code>: Retrieves <code>SerializationService</code> of current Hazelcast member.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The callbacks are usually used in the <code>login()</code> method of a login module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_clusterloginmodule"><a class="anchor" href="#_clusterloginmodule"></a>21.10.3. ClusterLoginModule</h4>
<div class="paragraph">
<p>Hazelcast has an abstract implementation of <code>LoginModule</code> that contains
shared logic and cleanup operations. It automatically creates the
<code>ClusterEndpointPrincipal</code> instance and it also provides the <code>addRole(String)</code>
method which simplifies adding the <code>ClusterRolePrincipal</code> instances.</p>
</div>
<div class="paragraph">
<p><code>ClusterLoginModule</code> implements all methods from the <code>LoginModule</code>
interface and makes them final. It provides protected methods with empty
implementations, e.g., <code>onCommit()</code>, to align the logic to user needs.
The module comes also with the following abstract methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getName()</code>: It is used to retrieve the name of <code>ClusterIdentityPrincipal</code>.</p>
</li>
<li>
<p><code>onLogin()</code>: Logic of the login method which needs to be provided.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Extending the <code>ClusterLoginModule</code> is recommended instead of implementing
all the required stuff from scratch.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public abstract class ClusterLoginModule implements LoginModule {

  protected abstract boolean onLogin() throws LoginException;
  protected abstract String getName();

  protected void onInitialize() {
  }

  protected boolean onCommit() throws LoginException {
      return true;
  }

  protected boolean onAbort() throws LoginException {
      return true;
  }

  protected boolean onLogout() throws LoginException {
      return true;
  }
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ClusterLoginModule</code> supports a basic set of login module options,
which allow skipping adding principals of a given type to the JAAS Subject.
It allows, for instance, to have just one <code>ClusterIdentityPrincipal</code> in
the <code>Subject</code> even if there are more login modules in the chain:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 18. ClusterLoginModule options</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>skipIdentity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Don&#8217;t add any <code>ClusterIdentityPrincipal</code> to the Subject.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>skipRole</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Don&#8217;t add any <code>ClusterRolePrincipal</code> to the Subject.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>skipEndpoint</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Don&#8217;t add any <code>ClusterEndpointPrincipal</code> to the Subject.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_enterprise_integration"><a class="anchor" href="#_enterprise_integration"></a>21.10.4. Enterprise Integration</h4>
<div class="paragraph">
<p>Using the above API, you can implement a <code>LoginModule</code> that performs
authentication against the security system of your choice,
such databases, directory services or some other corporate standard you might have.
For example, you may wish to have your clients send an identification
token in the <code>Credentials</code> object.
This token can then be sent to your backend security system via the
<code>LoginModule</code> that runs on the cluster side.</p>
</div>
<div class="paragraph">
<p>Additionally, the same system may authenticate the user and also then
return the roles that are attributed to the user. These roles can then
be used for data structure authorization.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASRefGuide.html" target="_blank" rel="noopener">JAAS Reference Guide</a>
for further information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cluster_member_security"><a class="anchor" href="#_cluster_member_security"></a>21.11. Cluster Member Security</h3>
<div class="paragraph">
<p>Hazelcast supports the standard Java Security (JAAS) based authentication
between the cluster members. A <a href="#security-realms">Security Realm</a> can
be referenced by <code>&lt;member-authentication/&gt;</code> element to define authentication
between the member and identity of the current member.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;security enabled="true"&gt;
      &lt;realms&gt;
          &lt;realm name="memberRealm"&gt;
              &lt;authentication&gt;
                &lt;ldap&gt;
                    &lt;url&gt;ldap://corp-ldap.example.com/&lt;/url&gt;
                &lt;/ldap&gt;
              &lt;/authentication&gt;
              &lt;identity&gt;
                &lt;username-password username="uid=member1,dc=example,dc=com" password="s3crEt"/&gt;
              &lt;/identity&gt;
          &lt;/realm&gt;
      &lt;/realms&gt;
      &lt;member-authentication realm="memberRealm"/&gt;
    &lt;/security&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  security:
    enabled: true
    realms:
      name: memberRealm
      authentication:
        ldap:
          url: ldap://corp-ldap.example.com
      identity:
        username-password:
          username: uid=member1,dc=example,dc=com
          password: s3crEt
    member-authentication:
      realm: memberRealm</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="default-authentication"><a class="anchor" href="#default-authentication"></a>21.12. Default authentication</h3>
<div class="paragraph">
<p>The Default Authentication is used when security is enabled and no explicit
authentication configuration is provided. It can happen when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>member-authentication</code> is not configured</p>
</li>
<li>
<p>the security realm referenced by <code>member-authentication</code> doesn&#8217;t contain the <code>authentication</code> configuration</p>
</li>
<li>
<p><code>client-authentication</code> is not configured</p>
</li>
<li>
<p>the security realm referenced by <code>client-authentication</code> doesn&#8217;t contain the <code>authentication</code> configuration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The behavior of the default authentication mechanism depends on <strong>member&#8217;s identity configuration</strong>
(i.e., <code>identity</code> configuration in the security realm referenced from <code>member-authentication</code>).
If the <code>identity</code> is configured as a <code>username-password</code>, then the authenticated username and password
credentials are checked for equality with these configured ones. In all other cases, only the incoming
cluster name is checked for equality with the one configured on the authenticating member.</p>
</div>
</div>
<div class="sect2">
<h3 id="_native_client_security"><a class="anchor" href="#_native_client_security"></a>21.13. Native Client Security</h3>
<div class="paragraph">
<p>Hazelcast&#8217;s Client security includes both authentication and authorization.</p>
</div>
<div class="sect3">
<h4 id="_authentication"><a class="anchor" href="#_authentication"></a>21.13.1. Authentication</h4>
<div class="paragraph">
<p>The authentication mechanism works in similar way as the cluster member authentication.</p>
</div>
<div class="paragraph">
<p>To implement the client authentication, you reference a <a href="#security-realms">Security Realm</a>
with the <code>authentication</code> section defined in the <code>&lt;client-authentication/&gt;</code> element
of a cluster member configuration.</p>
</div>
<div class="paragraph">
<p>The <code>authentication</code> configuration defines a method used to verify the client&#8217;s identity
and assign its roles.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;security enabled="true"&gt;
      &lt;realms&gt;
          &lt;realm name="clientRealm"&gt;
              &lt;authentication&gt;
                &lt;ldap&gt;
                    &lt;url&gt;ldap://corp-ldap.example.com/&lt;/url&gt;
                    &lt;role-mapping-attribute&gt;cn&lt;/role-mapping-attribute&gt;
                &lt;/ldap&gt;
              &lt;/authentication&gt;
          &lt;/realm&gt;
      &lt;/realms&gt;
      &lt;member-authentication realm="clientRealm"/&gt;
    &lt;/security&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">hazelcast:
  security:
    enabled: true
    realms:
      name: clientRealm
      authentication:
        ldap:
          url: ldap://corp-ldap.example.com/
          role-mapping-attribute: cn
    member-authentication:
      realm: clientRealm</code></pre>
</div>
</div>
<div class="paragraph">
<p>The identity of the connecting client is defined on the client side.
Usually, there are no security realms on the clients, but just identity
defined directly in the security configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;security&gt;
      &lt;username-password username="uid=member1,dc=example,dc=com" password="s3crEt"/&gt;
    &lt;/security&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  security:
    username-password:
      username: uid=member1,dc=example,dc=com
      password: s3crEt</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the clients, You can use the same identity types as in security realms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>username-password</code></p>
</li>
<li>
<p><code>token</code></p>
</li>
<li>
<p><code>kerberos</code> <em>(may require an additional security realm definition)</em></p>
</li>
<li>
<p><code>credentials-factory</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_authorization"><a class="anchor" href="#_authorization"></a>21.13.2. Authorization</h4>
<div class="paragraph">
<p>Hazelcast client authorization is configured by a client permission
policy. Hazelcast has a default permission policy implementation that uses
permission configurations defined in the Hazelcast security configuration.
Default policy permission checks are done against instance types (map, queue, etc.),
instance names (map, queue, name, etc.), instance actions (put, read, remove, add, etc.),
the client endpoint address (<code>ClusterEndpointPrincipal</code>) and client roles (<code>ClusterRolePrincipal</code>).</p>
</div>
<div class="paragraph">
<p>The default permission policy allows to use comma separated names in the <code>principal</code>
attribute configuration.</p>
</div>
<div class="paragraph">
<p>You can define the instance and principal names as wildcards using the <code>"*"</code> character.
See the <a href="#using-wildcards">Using Wildcards</a> section for details.</p>
</div>
<div class="paragraph">
<p>The endpoint names can use range characters <code>"-"</code> and <code>"*"</code> as described
in the <a href="#interfaces">Interfaces</a> section.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;security enabled="true"&gt;
        &lt;client-permissions&gt;
            &lt;!-- Principals 'admin' and 'root' from endpoint '127.0.0.1' have all permissions. --&gt;
            &lt;all-permissions principal="admin,root"&gt;
                &lt;endpoints&gt;
                    &lt;endpoint&gt;127.0.0.1&lt;/endpoint&gt;
                &lt;/endpoints&gt;
            &lt;/all-permissions&gt;

            &lt;!-- Principals named 'dev' from all endpoints have 'create', 'destroy',
            'put', 'read' permissions for map named 'myMap'. --&gt;
            &lt;map-permission name="myMap" principal="dev"&gt;
                &lt;actions&gt;
                    &lt;action&gt;create&lt;/action&gt;
                    &lt;action&gt;destroy&lt;/action&gt;
                    &lt;action&gt;put&lt;/action&gt;
                    &lt;action&gt;read&lt;/action&gt;
                &lt;/actions&gt;
            &lt;/map-permission&gt;

            &lt;!-- All principals from endpoints '127.0.0.1' or matching to '10.10.*.*'
            have 'put', 'read', 'remove' permissions for map
            whose name matches to 'com.foo.entity.*'. --&gt;
            &lt;map-permission name="com.foo.entity.*"&gt;
                &lt;endpoints&gt;
                    &lt;endpoint&gt;10.10.*.*&lt;/endpoint&gt;
                    &lt;endpoint&gt;127.0.0.1&lt;/endpoint&gt;
                &lt;/endpoints&gt;
                &lt;actions&gt;
                    &lt;action&gt;put&lt;/action&gt;
                    &lt;action&gt;read&lt;/action&gt;
                    &lt;action&gt;remove&lt;/action&gt;
                &lt;/actions&gt;
            &lt;/map-permission&gt;

            &lt;!-- Principals named 'dev' from endpoints matching to either
            '192.168.1.1-100' or '192.168.2.*'
            have 'create', 'add', 'remove' permissions for all queues. --&gt;
            &lt;queue-permission name="*" principal="dev"&gt;
                &lt;endpoints&gt;
                    &lt;endpoint&gt;192.168.1.1-100&lt;/endpoint&gt;
                    &lt;endpoint&gt;192.168.2.*&lt;/endpoint&gt;
                &lt;/endpoints&gt;
                &lt;actions&gt;
                    &lt;action&gt;create&lt;/action&gt;
                    &lt;action&gt;add&lt;/action&gt;
                    &lt;action&gt;remove&lt;/action&gt;
                &lt;/actions&gt;
            &lt;/queue-permission&gt;

           &lt;!-- All principals from all endpoints have transaction permission.--&gt;
           &lt;transaction-permission /&gt;
       &lt;/client-permissions&gt;
    &lt;/security&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">hazelcast:
  security:
    enabled: true
    client-permissions:
      on-join-operation: RECEIVE
      all:
        principal: admin,root
        endpoints:
          - 127.0.0.1
      map:
        - name: myMap
          principal: dev
          endpoints:
            - 127.0.0.1
          actions:
            - create
            - destroy
            - put
            - read
      map:
        - name: com.foo.entity
          principal: dev
          endpoints:
            - 10.10.*.*
            - 127.0.0.1
          actions:
            - put
            - read
            - remove
      queue:
        - name: "*"
          principal: dev
          endpoints:
            - 192.168.1.1-100
            - 192.168.2.*
          actions:
            - create
            - add
            - remove
      transaction:</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also define your own policy by implementing <code>com.hazelcast.security.IPermissionPolicy</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.hazelcast.security;
/**
 * IPermissionPolicy is used to determine any Subject's
 * permissions to perform a security sensitive Hazelcast operation.
 *
 */
public interface IPermissionPolicy {
  void configure( SecurityConfig securityConfig, Properties properties );

  PermissionCollection getPermissions( Subject subject,
                                       Class&lt;? extends Permission&gt; type );

  void destroy();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Permission policy implementations can access client-permissions that are in the
configuration by using <code>SecurityConfig.getClientPermissionConfigs()</code> when
Hazelcast calls the <code>configure(SecurityConfig securityConfig, Properties properties)</code> method.</p>
</div>
<div class="paragraph">
<p>The <code>IPermissionPolicy.getPermissions(Subject subject, Class&lt;? extends Permission&gt; type)</code>
method is used to determine a client request that has been granted permission to
perform a security-sensitive operation.</p>
</div>
<div class="paragraph">
<p>Permission policy should return a <code>PermissionCollection</code> containing permissions
of the given type for the given <code>Subject</code>. The Hazelcast access controller calls
<code>PermissionCollection.implies(Permission)</code> on returning <code>PermissionCollection</code> and
it decides whether the current <code>Subject</code> has permission to access the requested resources.</p>
</div>
</div>
<div class="sect3">
<h4 id="_permissions"><a class="anchor" href="#_permissions"></a>21.13.3. Permissions</h4>
<div class="paragraph">
<p>The following is the list of client permissions that can be configured on the member:</p>
</div>
<div class="paragraph">
<p><strong>All Permission:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;all-permissions principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
&lt;/all-permissions&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">all:
  principal: principal
  endpoints:
    - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Map Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, put, read, remove, lock, intercept, index, listen</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;map-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/map-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">map:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Queue Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, add, remove, read, listen</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;queue-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/queue-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">queue:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Multimap Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, put, read, remove, listen, lock</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;multimap-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
     &lt;/actions&gt;
&lt;/multimap-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">multimap:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Topic Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: create, destroy, publish, listen</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;topic-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/topic-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">topic:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>List Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, add, read, remove, listen</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;list-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/list-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">list:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Set Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, add, read, remove, listen</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;set-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/set-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">set:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Lock Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, lock, read</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;lock-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/lock-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">lock:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>AtomicLong Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, read, modify</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;atomic-long-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/atomic-long-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">atomic-long:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>CountDownLatch Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, read, modify</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;countdown-latch-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/countdown-latch-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">countdown-latch:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>FlakeIdGenerator Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, read, modify</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;flake-id-generator-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/flake-id-generator-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">flake-id-generator:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Semaphore Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, acquire, release, read</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;semaphore-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/semaphore-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">semaphore:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Executor Service Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;executor-service-permission name="name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/executor-service-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">executor-service:
  - name: name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Transaction Permission:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;transaction-permission principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
&lt;/transaction-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">transaction:
  principal: principal
  endpoints:
    - ..</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cache Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, create, destroy, put, read, remove, listen</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;cache-permission name="/hz/cache-name" principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/cache-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">cache:
  - name: /hz/cache-name
    principal: principal
    endpoints:
      - ..
    actions:
      - ..</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The name provided in <code>cache-permission</code> must be the Hazelcast distributed
object name corresponding to the <code>Cache</code> as described in
the <a href="#jcache-hazelcast-instance-integration">JCache - Hazelcast Instance Integration section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>User Code Deployment Permission:</strong></p>
</div>
<div class="paragraph">
<p>Actions: all, deploy</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;user-code-deployment-permission principal="principal"&gt;
    &lt;endpoints&gt;
        ...
    &lt;/endpoints&gt;
    &lt;actions&gt;
        ...
    &lt;/actions&gt;
&lt;/user-code-deployment-permission&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">user-code-deployment:
  principal: principal
  endpoints:
    - ..
  actions:
    - ..</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_handling_permissions_when_a_new_member_joins"><a class="anchor" href="#_handling_permissions_when_a_new_member_joins"></a>Handling Permissions When a New Member Joins</h5>
<div class="paragraph">
<p>By default, the set of permissions defined in the leader member of a cluster is
distributed to the newly joining members, overriding their own permission
configurations, if any. However, you can configure a new member to be joined, so that
it keeps its own set of permissions and even send these to the existing members in
the cluster. This can be done dynamically, i.e., without needing to restart the
cluster, using either one of the following configuration options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>on-join-operation</code> configuration attribute</p>
</li>
<li>
<p>the <code>setOnJoinPermissionOperation()</code> method</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using the above, you can choose whether a new member joining to a cluster will
apply the client permissions stored in its own configuration, or use the ones
defined in the cluster. The behaviors that you can specify with the configuration
are <code>RECEIVE</code>, <code>SEND</code> and <code>NONE</code>, which are described after the examples below.</p>
</div>
<div class="paragraph">
<p>The following are the examples for both approaches on how to use them:</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;security enabled="true"&gt;
        &lt;client-permissions on-join-operation="SEND"&gt;
            &lt;!-- ... --&gt;
        &lt;/client-permissions&gt;
    &lt;/security&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  security:
    enabled: true
    client-permissions:
      on-join-operation: SEND</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.getSecurityConfig()
    .setEnabled(true)
    .setOnJoinPermissionOperation(OnJoinPermissionOperationName.SEND);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The behaviors are explained below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RECEIVE</code>: Applies the permissions from the leader member in the
cluster before join. This is the default value.</p>
</li>
<li>
<p><code>SEND</code>: Doesn&#8217;t apply the permissions from the leader member before join.
If the security is enabled, then it refreshes or replaces the cluster wide
permissions with the ones in the new member after the join is complete.
This option is suitable for the scenarios where you need to replace the
cluster wide permissions without restarting the cluster.</p>
</li>
<li>
<p><code>NONE</code>: Neither applies pre-join permissions, nor sends the local permissions
to the other members. It means that the new member does not send its own
permission definitions to the cluster, but keeps them when it joins. However,
after the join, when you update the permissions in the other cluster members,
those updates are also sent to the newly joining member. Therefore, this option
is suitable for the scenarios where you need to elevate privileges temporarily
on a single member (preferably a <a href="#enabling-lite-members">lite member</a>) for a
limited time period. The clients which want to use these temporary permissions
have to access the cluster through this single new member, meaning that you need
to disable <a href="#setting-smart-routing">smart routing</a> for such clients.</p>
<div class="paragraph">
<p>Note that, the <code>create</code> and <code>destroy</code> permissions will not work when using
the <code>NONE</code> option, since the distributed objects need to be created/destroyed on all the members.</p>
</div>
<div class="paragraph">
<p>The following is an example for a scenario where <code>NONE</code> is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">// temporary member, in the below case a lite member
Config config = new Config().setLiteMember(true);
PermissionConfig allPermission = new PermissionConfig(PermissionType.ALL, "*", null);
config.getSecurityConfig()
  .setEnabled(true)
  .setOnJoinPermissionOperation(OnJoinPermissionOperationName.NONE)
  .addClientPermissionConfig(allPermission);
HazelcastInstance hzLite = Hazelcast.newHazelcastInstance(config);

// temporary client connecting only to the lite member
String memberAddr = ...;
ClientConfig clientConfig = new ClientConfig();
clientConfig.getNetworkConfig().setSmartRouting(false)
  .addAddress(memberAddr);
HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);

// do operations with escalated privileges:
client.getMap("protectedConfig").put("master.resolution", "1920");

// shutdown the client and lite member
client.shutdown();
hzLite.shutdown();</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="auditlog"><a class="anchor" href="#auditlog"></a>21.14. Logging Auditable Events</h3>
<div class="paragraph">
<p>Hazelcast IMDG Enterprise allows observing some important cluster events
using the Auditlog feature. Auditable events have a unique type ID;
they contain a timestamp and importance level.
The events may also contain a message and parameters.
Supported event type identifiers are listed in <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/auditlog/AuditlogTypeIds.html" target="_blank" rel="noopener"><code>AuditlogTypeIds</code></a>.</p>
</div>
<div class="paragraph">
<p>You can enable the auditlog feature in the configuration as follows:</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;auditlog enabled="true" /&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  auditlog:
    enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.getAuditLogConfig().setEnabled(true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default auditlog implementation uses Hazelcast logging configuration and writes the events
as log entries with the category name <code>"hazelcast.auditlog"</code>.</p>
</div>
<div class="paragraph">
<p><strong>Sample Log4j2 configuration writing auditable events to a Syslog:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Configuration&gt;
    &lt;Appenders&gt;
        &lt;Syslog name="Syslog" format="RFC5424"
            host="syslog.acme.com" port="514" protocol="TCP"
            appName="Hazelcast" newLine="true" messageId="Audit" id="hz" /&gt;
    &lt;/Appenders&gt;

     &lt;Loggers&gt;
        &lt;Logger name="hazelcast.auditlog" level="debug"&gt;
            &lt;AppenderRef ref="Syslog" /&gt;
        &lt;/Logger&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_auditlog_spi"><a class="anchor" href="#_auditlog_spi"></a>21.14.1. Auditlog SPI</h4>
<div class="paragraph">
<p>The auditlog has its own SPI allowing you to provide your implementations.
Relevant classes and interfaces are located
in the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/auditlog/package-summary.html" target="_blank" rel="noopener"><code>com.hazelcast.auditlog</code> package</a>.</p>
</div>
<div class="paragraph">
<p>The central point of auditlog SPI is the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/auditlog/AuditlogService.html" target="_blank" rel="noopener"><code>AuditlogService</code> interface</a>
and its <code>log(&#8230;&#8203;)</code> methods. Their implementations are responsible for
processing auditable events, e.g., writing them to a database.</p>
</div>
<div class="paragraph">
<p><code>AuditlogService</code> also creates the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/auditlog/EventBuilder.html" target="_blank" rel="noopener"><code>EventBuilder</code></a>
instances which are used to build
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/auditlog/AuditableEvent.html" target="_blank" rel="noopener"><code>AuditableEvents</code></a>.</p>
</div>
<div class="paragraph">
<p>Another important piece in the SPI is the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/auditlog/AuditlogServiceFactory.html" target="_blank" rel="noopener"><code>AuditlogServiceFactory</code> interface</a>.
The factory class allows the <code>AuditlogService</code> initialization based on parameters.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-debugging"><a class="anchor" href="#security-debugging"></a>21.15. Security Debugging</h3>
<div class="paragraph">
<p>The biggest part of business logic related to security
in Hazelcast is located in the <code>com.hazelcast.security</code> Java package.
You can investigate the issues by printing more debug info from this package.</p>
</div>
<div class="paragraph">
<p>An example Log4J2 configuration is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Configuration&gt;
    &lt;Loggers&gt;
        &lt;Logger name="com.hazelcast.security" level="ALL"/&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_java_security_debugging"><a class="anchor" href="#_java_security_debugging"></a>21.15.1. Java Security Debugging</h4>
<div class="paragraph">
<p>Java is able to print the debug information about using the security components.
During the security troubleshooting, it&#8217;s often helpful to print the additional
information by using the following system property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Djava.security.debug=all</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/troubleshooting-security.html" target="_blank" rel="noopener">Troubleshooting Security</a>
Java guide for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tls_debugging"><a class="anchor" href="#_tls_debugging"></a>21.15.2. TLS debugging</h4>
<div class="paragraph">
<p>To assist with the TLS/SSL issues, you can use the following
system property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Djavax.net.debug=all</code></pre>
</div>
</div>
<div class="paragraph">
<p>This property provides a lot of logging output including the TLS/SSL
handshake, that can be used to determine the cause of the problem. See the
<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/ReadDebug.html" target="_blank" rel="noopener">Debugging TSL/SSL Connections</a>
guide for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fips_140_2"><a class="anchor" href="#_fips_140_2"></a>21.16. FIPS 140-2</h3>
<div class="paragraph">
<p>The Federal Information Processing Standard (FIPS) 140-2 is a US government
computer security standard published by National Institute of Standards and
Technology (NIST). It specifies the security requirements for cryptographic
modules. FIPS 140-2 compliance is often a requirement of the software systems
used by the US government agencies.</p>
</div>
<div class="paragraph">
<p>The NIST manages a list of FIPS certified cryptographic modules. These modules
are certified under the Cryptographic Module Validation Program. The list can
be searched online <a href="https://csrc.nist.gov/projects/cryptographic-module-validation-program/validated-modules/search" target="_blank" rel="noopener">here</a>.</p>
</div>
<div class="paragraph">
<p>Hazelcast uses external modules for cryptographic tasks and it can be configured
to use a FIPS 140-2 validated module. It means most of the configuration
required for FIPS is outside of the Hazelcast configuration. To run
Hazelcast in the FIPS compliant mode you have to set the underlying Java
runtime into FIPS mode. It may also require switching the underlying
Operating System into the FIPS mode. We consider using a FIPS enabled OS as
a recommended approach even in cases when it&#8217;s not asked for explicitly.</p>
</div>
<div class="paragraph">
<p>Hazelcast is not an authority which should document switching different Java
runtimes into the FIPS mode. Please consult the documentation of your Java
version to learn how to enable the FIPS mode. Usually it means changing the
list of security providers in the <code>java.security</code> JREconfigurationfile.</p>
</div>
<div class="paragraph">
<p>Hazelcast is only responsible for enabling the OpenSSL native library into
FIPS mode (see the <a href="#integrating-openssl-boringssl">Integrating OpenSSL section</a>).
If the Hazelcast cluster configuration enables TLS communication using the
native OpenSSL library, you have to enable its FIPS mode in the Hazelcast
<code>OpenSSLEngineFactory</code> configuration.
The FIPS mode is controlled by an optional <code>true</code>/<code>false</code> property called
<code>fipsMode</code>. It is disabled by default.</p>
</div>
<div class="paragraph">
<p><strong>Example OpenSSL configuration in the FIPS mode:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;ssl enabled="true"&gt;
            &lt;factory-class-name&gt;com.hazelcast.nio.ssl.OpenSSLEngineFactory&lt;/factory-class-name&gt;

            &lt;properties&gt;
                &lt;property name="fipsMode"&gt;true&lt;/property&gt;
                &lt;property name="protocol"&gt;TLSv1.2&lt;/property&gt;
                &lt;property name="trustCertCollectionFile"&gt;trusted-certs.pem&lt;/property&gt;
                &lt;property name="keyFile"&gt;privkey.pem&lt;/property&gt;
                &lt;property name="keyCertChainFile"&gt;chain.pem&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/ssl&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    ssl:
      enabled: true
      factory-class-name: com.hazelcast.nio.ssl.OpenSSLEngineFactory
      properties:
        fipsMode: true
        protocol: TLSv1.2
        trustCertCollectionFile: trusted-certs.pem
        keyFile: privkey.pem
        keyCertChainFile: chain.pem</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>fipsMode</code> property is set to <code>true</code>, the native OpenSSL engine is
either set to the FIPS mode or an exception is thrown, e.g., in the cases when
OpenSSL is compiled without the FIPS support.</p>
</div>
<div class="paragraph">
<p>If there is more Hazelcast instances (members or clients) with TLS enabled
employing the OpenSSL, then all of them must have the <code>fipsMode</code> property
configured in the same way, either enabled or disabled.</p>
</div>
<div class="paragraph">
<p>When the FIPS mode is successfully enabled, you will see the following
<code>INFO</code> level message in the log files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>OpenSSL is enabled in FIPS mode.</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
BoringSSL libraries don&#8217;t support the FIPS mode.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_example_fips_140_2_environment"><a class="anchor" href="#_example_fips_140_2_environment"></a>21.16.1. Example FIPS 140-2 environment</h4>
<div class="paragraph">
<p>The FIPS environment configuration steps depend on the used operating system
and Java version. You should consult with their documentation for the specific configurations.</p>
</div>
<div class="paragraph">
<p>We will describe a sample configuration which uses Red Hat Enterprise Linux
(RHEL) version 7 and IBM Java SDK 8. If you find any difference between the
sample configuration described here and the documentation of the OS and Java
vendors, use the vendor&#8217;s up-to-date instructions instead.</p>
</div>
<div class="paragraph">
<p><strong>Switching RHEL 7 into the FIPS mode</strong></p>
</div>
<div class="paragraph">
<p>The steps on how to configure RHEL 7 in FIPS 140-2 mode are described in the
<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-federal_standards_and_regulations" target="_blank" rel="noopener">Security guide</a> on the Red Hat customer portal.</p>
</div>
<div class="paragraph">
<p>Perform the following steps for the already installed systems:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Install the <code>dracut-fips</code> package using the YUM package manager.</p>
</li>
<li>
<p>Run the <code>dracut</code>command to regenerate the <code>initramfs</code>file.</p>
</li>
<li>
<p>Add the <code>fips=1</code>option to the kernel command line of the boot loader.</p>
</li>
<li>
<p>Disable prelinking (if it was enabled before.</p>
</li>
<li>
<p>Reboot the system.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After finishing these steps, check if the FIPS mode is enabled by running
the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-bash hljs" data-lang="bash"># Following command should print "crypto.fips_enabled = 1" (value 1 means the FIPS mode is enabled)
sysctl crypto.fips_enabled</code></pre>
</div>
</div>
<div class="paragraph">
<p>To automate theFIPS mode enablement on RHEL 7, you can check the script
which is shared in the <a href="https://access.redhat.com/discussions/3487481" target="_blank" rel="noopener">Red Hat discussion forum</a>.</p>
</div>
<div class="paragraph">
<p><strong>Switching IBM Java SDK into the FIPS mode</strong></p>
</div>
<div class="paragraph">
<p>IBM Java 8 provides the FIPS mode itself without any third party
dependencies.</p>
</div>
<div class="paragraph">
<p>Details on how to enable the FIPS 140-2 validated configuration can be
found in the <a href="https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.security.component.80.doc/security-component/security-overview.html" target="_blank" rel="noopener">Security guide</a> in the Java 8 documentation.</p>
</div>
<div class="paragraph">
<p>First, it&#8217;s necessary to edit the<code>jre/lib/security/java.security</code> file and
do the following changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Put <code>IBMJCEFIPS</code> as the first security provider. It will be the first provider
to be selected when a JCA API call is made without specifying an explicit security provider.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">security.provider.1=com.ibm.crypto.fips.provider.IBMJCEFIPS</code></pre>
</div>
</div>
<div class="paragraph">
<p>And re-number the original set of security providers by increasing the priority
of provider by one, i.e., the old <code>security.provider.1</code> becomes <code>security.provider.2</code> and so on.</p>
</div>
</li>
<li>
<p>Add the new security properties (related to handling TLS protected communication):</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">ssl.SocketFactory.provider=com.ibm.jsse2.SSLSocketFactoryImpl
ssl.ServerSocketFactory.provider=com.ibm.jsse2.SSLServerSocketFactoryImpl</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Security provider covering the TLS implementation in IBM Java is <code>IBMJSSE2</code>.
To instruct this provider about using the FIPS validated security primitives
(from<code>IBMJCEFIPS</code>), use additional system properties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dcom.ibm.jsse2.usefipsprovider=true -Dcom.ibm.jsse2.usefipsProviderName=IBMJCEFIPS</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance"><a class="anchor" href="#_performance"></a>22. Performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides information on the performance features of
Hazelcast including near cache, slow operations detector, back pressure and
data affinity. Moreover, the chapter describes the best performance practices for
Hazelcast deployed on Amazon EC2. It also describes the threading models for I/O, events, executors and operations.</p>
</div>
<div class="sect2">
<h3 id="_pipelining"><a class="anchor" href="#_pipelining"></a>22.1. Pipelining</h3>
<div class="paragraph">
<p>With the pipelining, you can send multiple
requests in parallel using a single thread  and therefore can increase throughput.
As an example, suppose that the round trip time for a request/response
is 1 millisecond. If synchronous requests are used, e.g., <code>IMap.get()</code>, then the maximum throughput out of these requests from
a single thread is 1/001 = 1000 operations/second. One way to solve this problem is to introduce multithreading to make
the requests in parallel. For the same example, if we would use 2 threads, then the maximum throughput doubles from 1000
operations/second, to 2000 operations/second.</p>
</div>
<div class="paragraph">
<p>However, introducing threads for the sake of executing requests isn&#8217;t always convenient and doesn&#8217;t always lead to an optimal
performance; this is where the pipelining can be used. Instead of using multiple threads to have concurrent invocations,
you can use asynchronous method calls such as <code>IMap.getAsync()</code>. If you would use 2 asynchronous calls from a single thread,
then the maximum throughput is 2*(1/001) = 2000 operations/second. Therefore, to benefit from the pipelining, asynchronous calls need to
be made from a single thread. The pipelining is a convenience implementation to provide back pressure, i.e., controlling
the number of inflight operations, and it provides a convenient way to wait for all the results.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Pipelining&lt;String&gt; pipelining = new Pipelining&lt;String&gt;(10);
for (long k = 0; k &lt; 100; k++) {
    int key = random.nextInt(keyDomain);
    pipelining.add(map.getAsync(key));
}
// wait for completion
List&lt;String&gt; results = pipelining.results();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we make 100 asynchronous <code>map.getAsync()</code> calls, but the maximum number of inflight calls is 10.</p>
</div>
<div class="paragraph">
<p>By increasing the depth of the pipelining, throughput can be increased. The pipelining has its own back pressure, you do not
need to enable the <a href="#back-pressure">back pressure</a> on the client or member to have this feature on the pipelining. However, if you have many
pipelines, you may still need to enable the client/member back pressure because it is possible to overwhelm the system
with requests in that situation. See the <a href="#back-pressure">Back Pressure section</a> to learn how to enable it on the client or member.</p>
</div>
<div class="paragraph">
<p>You can use the pipelining both on the clients and members. You do not need a special configuration, it works out-of-the-box.</p>
</div>
<div class="paragraph">
<p>The pipelining can be used for any asynchronous call. You can use it for IMap asynchronous get/put methods as well as for
ICache, IAtomicLong, etc. It cannot be used as a transaction mechanism though. So you cannot do some calls and throw away the pipeline and expect that
none of the requests are executed. If you want to use an atomic behavior, see the <a href="#transactions">Transactions chapter</a>.
The pipelining is just a performance optimization, not a mechanism for atomic behavior.</p>
</div>
<div class="paragraph">
<p>The pipelines are cheap and should frequently be replaced because they accumulate results. It is fine to have a few hundred or
even a few thousand calls being processed with the pipelining. However, all the responses to all requests are stored in the pipeline
as long as the pipeline is referenced. So if you want to process a huge number of requests, then every few hundred or few
thousand calls wait for the pipelining results and just create a new instance.</p>
</div>
<div class="paragraph">
<p>Note that the pipelines are not thread-safe. They must be used by a single thread.</p>
</div>
</div>
<div class="sect2">
<h3 id="_data_affinity"><a class="anchor" href="#_data_affinity"></a>22.2. Data Affinity</h3>
<div class="paragraph">
<p>Data affinity ensures that related entries exist on the same member. If related data is on the same member, operations can
be executed without the cost of extra network calls and extra wire data. This feature is provided by using the same partition keys for related data.</p>
</div>
<div class="sect3">
<h4 id="_partitionaware"><a class="anchor" href="#_partitionaware"></a>22.2.1. PartitionAware</h4>
<div class="paragraph">
<p><strong>Co-location of related data and computation</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast has a standard way of finding out which member owns/manages each key object.
The following operations are routed to the same member, since all of them are operating based on the same key <code>"key1"</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Map mapA = hazelcastInstance.getMap( "mapA" );
Map mapB = hazelcastInstance.getMap( "mapB" );
Map mapC = hazelcastInstance.getMap( "mapC" );

// since map names are different, operation will be manipulating
// different entries, but the operation will take place on the
// same member since the keys ("key1") are the same
mapA.put( "key1", value );
mapB.get( "key1" );
mapC.remove( "key1" );

// lock operation will still execute on the same member
// of the cluster since the key ("key1") is same
hazelcastInstance.getLock( "key1" ).lock();

// distributed execution will execute the 'runnable' on the
// same member since "key1" is passed as the key.
hazelcastInstance.getExecutorService().executeOnKeyOwner( runnable, "key1" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the keys are the same, entries are stored on the same member.
But we sometimes want to have related entries stored on the same member, such as a customer and his/her order entries.
We would have a customers map with customerId as the key and an orders map with orderId as the key.
Since customerId and orderId are different keys, a customer and
his/her orders may fall into different members in your cluster. So how can we have them stored on the same member?
We create an affinity between customer and orders. If we make them part of the same partition then
these entries will be co-located. We achieve this by making <code>orderKey</code> s <code>PartitionAware</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final class OrderKey implements PartitionAware, Serializable {

    private final long orderId;
    private final long customerId;

    OrderKey(long orderId, long customerId) {
        this.orderId = orderId;
        this.customerId = customerId;
    }

    @Override
    public Object getPartitionKey() {
        return customerId;
    }

    @Override
    public String toString() {
        return "OrderKey{"
                + "orderId=" + orderId
                + ", customerId=" + customerId
                + '}';</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that OrderKey implements <code>PartitionAware</code> and that <code>getPartitionKey()</code> returns the <code>customerId</code>.
These make sure that the <code>Customer</code> entry and its <code>Order</code>s are stored on the same member.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Map mapCustomers = hazelcastInstance.getMap( "customers" );
Map mapOrders = hazelcastInstance.getMap( "orders" );

// create the customer entry with customer id = 1
mapCustomers.put( 1, customer );

// now create the orders for this customer
mapOrders.put( new OrderKey( 21, 1 ), order );
mapOrders.put( new OrderKey( 22, 1 ), order );
mapOrders.put( new OrderKey( 23, 1 ), order );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assume that you have a customers map where <code>customerId</code> is the key and the customer object is the value.
You want to remove one of the customer orders and return the number of remaining orders.
Here is how you would normally do it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static int removeOrder( long customerId, long orderId ) throws Exception {
    IMap&lt;Long, Customer&gt; mapCustomers = instance.getMap( "customers" );
    IMap mapOrders = hazelcastInstance.getMap( "orders" );

    mapCustomers.lock( customerId );
    mapOrders.remove( new OrderKey(orderId, customerId) );
    Set orders = orderMap.keySet(Predicates.equal( "customerId", customerId ));
    mapCustomers.unlock( customerId );

    return orders.size();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are couple of things you should consider.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are four distributed operations there: lock, remove, keySet, unlock. Can you reduce
the number of distributed operations?</p>
</li>
<li>
<p>The customer object may not be that big, but can you not have to pass that object through the
wire? Think about a scenario where you set order count to the customer object for fast access, so you
should do a get and a put, and as a result, the customer object is passed through the wire twice.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Instead, why not move the computation over to the member (JVM) where your customer data resides.
Here is how you can do this with distributed executor service.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Send a <code>PartitionAware</code> <code>Callable</code> task.</p>
</li>
<li>
<p><code>Callable</code> does the deletion of the order right there and returns with the remaining
order count.</p>
</li>
<li>
<p>Upon completion of the <code>Callable</code> task, return the result (remaining order count). You
do not have to wait until the task is completed; since distributed executions are asynchronous,
you can do other things in the meantime.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here is an example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

    public int removeOrder(long customerId, long orderId) throws Exception {
        IExecutorService executorService = hazelcastInstance.getExecutorService("ExecutorService");

        OrderDeletionTask task = new OrderDeletionTask(customerId, orderId);
        Future&lt;Integer&gt; future = executorService.submit(task);
        int remainingOrders = future.get();

        return remainingOrders;
    }

    public static class OrderDeletionTask
            implements Callable&lt;Integer&gt;, PartitionAware, Serializable, HazelcastInstanceAware {

        private long orderId;
        private long customerId;
        private HazelcastInstance hazelcastInstance;

        public OrderDeletionTask() {
        }

        public OrderDeletionTask(long customerId, long orderId) {
            this.customerId = customerId;
            this.orderId = orderId;
        }

        @Override
        public Integer call() {
            IMap&lt;Long, Customer&gt; customerMap = hazelcastInstance.getMap("customers");
            IMap&lt;OrderKey, Order&gt; orderMap = hazelcastInstance.getMap("orders");

            customerMap.lock(customerId);

            Predicate predicate = Predicates.equal("customerId", customerId);
            Set&lt;OrderKey&gt; orderKeys = orderMap.localKeySet(predicate);
            int orderCount = orderKeys.size();
            for (OrderKey key : orderKeys) {
                if (key.orderId == orderId) {
                    orderCount--;
                    orderMap.delete(key);
                }
            }

            customerMap.unlock(customerId);

            return orderCount;
        }

        @Override
        public Object getPartitionKey() {
            return customerId;
        }

        @Override
        public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {
            this.hazelcastInstance = hazelcastInstance;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the benefits of doing the same operation with distributed <code>ExecutorService</code> based on the key:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>only one distributed execution (<code>executorService.submit(task)</code>), instead of four</p>
</li>
<li>
<p>less data is sent over the wire</p>
</li>
<li>
<p>less lock duration, i.e., higher concurrency, for the <code>Customer</code> entry since
lock/update/unlock cycle is done locally (local to the customer data)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_partitioningstrategy"><a class="anchor" href="#_partitioningstrategy"></a>22.2.2. PartitioningStrategy</h4>
<div class="paragraph">
<p>Another way of storing the related data on the same location is using/implementing
the class <code>PartitioningStrategy</code>. Normally (if no partitioning strategy is defined),
Hazelcast finds the partition of a key first by converting the object to binary and then by hashing this binary.
If a partitioning strategy is defined, Hazelcast injects the key to the strategy and
the strategy returns an object out of which the partition is calculated by hashing it.</p>
</div>
<div class="paragraph">
<p>Hazelcast offers the following out-of-the-box partitioning strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DefaultPartitioningStrategy</code>: Default strategy. It checks whether the key implements <code>PartitionAware</code>.
If it implements, the object is converted to binary and then hashed, to find the partition of the key.</p>
</li>
<li>
<p><code>StringPartitioningStrategy</code>: Works only for string keys. It uses the string after <code>@</code> character as the partition ID.
For example, if you have two keys <code>ordergroup1@region1</code> and <code>customergroup1@region1</code>,
both <code>ordergroup1</code> and <code>customergroup1</code> fall into the partition where <code>region1</code> is located.</p>
</li>
<li>
<p><code>StringAndPartitionAwarePartitioningStrategy</code>: Works as the combination of the above two strategies.
If the key implements <code>PartitionAware</code>, it works like the <code>DefaultPartitioningStrategy</code>.
If it is a string key, it works like the <code>StringPartitioningStrategy</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following are the example configuration snippets. Note that these strategy configurations are <strong>per map</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="name-of-the-map"&gt;
        &lt;partition-strategy&gt;
             com.hazelcast.partition.strategy.StringAndPartitionAwarePartitioningStrategy
        &lt;/partition-strategy&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    name-of-the-map:
      partition-strategy: com.hazelcast.partition.strategy.StringAndPartitionAwarePartitioningStrategy</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
MapConfig mapConfig = config.getMapConfig("name-of-the-map");
PartitioningStrategyConfig psConfig = mapConfig.getPartitioningStrategyConfig();
psConfig.setPartitioningStrategyClass( "StringAndPartitionAwarePartitioningStrategy" );

// OR
psConfig.setPartitioningStrategy(YourCustomPartitioningStrategy);
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also define your own partition strategy by implementing the class <code>PartitioningStrategy</code>.
To enable your implementation, add the full class name to your Hazelcast configuration using either
the declarative or programmatic approach, as exemplified above.</p>
</div>
<div class="paragraph">
<p>The examples above show how to define a partitioning strategy per map.
Note that all the members of your cluster must have the same
partitioning strategy configurations.</p>
</div>
<div class="paragraph">
<p>You can also change a global strategy which is applied to all the data structures in your cluster.
This can be done by defining the <code>hazelcast.partitioning.strategy.class</code> system property.
An example declarative way of configuring this property is shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.partitioning.strategy.class"&gt;
            com.hazelcast.partition.strategy.StringAndPartitionAwarePartitioningStrategy
        &lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.partitioning.strategy.class: com.hazelcast.partition.strategy.StringAndPartitionAwarePartitioningStrategy</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify the aforementioned out-of-the-box strategies or your custom
partitioning strategy.</p>
</div>
<div class="paragraph">
<p>You can also use other system property configuring options as explained in the
<a href="#configuring-with-system-properties">Configuring with System Properties section</a>.</p>
</div>
<div class="paragraph">
<p>The per map and global (cluster) partitioning strategies are supported on the member side.
Hazelcast IMDG Java clients only support the global strategy and it is configured
via the same system property used in the members (`hazelcast.partitioning.strategy.class `).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cpu_thread_affinity"><a class="anchor" href="#_cpu_thread_affinity"></a>22.3. CPU Thread Affinity</h3>
<div class="paragraph">
<p>Hazelcast offers configuring CPU threads so that you have a lot better control
on the latency and a better throughput. This configuration provides you
with the CPU thread affinity, where certain threads can have affinity for particular CPUs.</p>
</div>
<div class="paragraph">
<p>The following affinity configurations are available for a member:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.io.input.thread.affinity=1-3
-Dhazelcast.io.output.thread.affinity=3-5
-Dhazelcast.operation.thread.affinity=7-10,13
-Dhazelcast.operation.response.thread.affinity=15,16</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following affinity configurations are available for a client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.client.io.input.thread.affinity=1-4
-Dhazelcast.client.io.output.thread.affinity=5-8
-Dhazelcast.client.response.thread.affinity=7-9</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can set the CPU thread affinity properties shown above only on the command line.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a look at how we define the values for the above configuration
properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Individual CPUs</strong>, e.g., <code>1,2,3</code>: This means there are going to be
three threads. The first thread runs on CPU 1, the second thread on CPU 2, and so on.</p>
</li>
<li>
<p><strong>CPU ranges</strong>, e.g., <code>1-3</code>: Shortcut syntax for <code>1,2,3</code>.</p>
</li>
<li>
<p><strong>Group</strong>, e.g., <code>[1-3]</code>: This configures three threads and each of
these threads can run on CPU 1, 2 and 3.</p>
</li>
<li>
<p><strong>Group with thread count</strong>, e.g., <code>[1-3]:2</code>: This configures two
threads and each of these two threads can run on CPU 1, 2 and 3.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also combine those, e.g., <code>1,2,[5-7],[10,12,16]:2</code>.</p>
</div>
<div class="paragraph">
<p>Note that, the syntax for CPU thread affinity shown above not only determines
the mapping of CPUs to threads, it also determines the thread count.
If you use CPU thread affinity, e.g., <code>hazelcast.io.input.thread.affinity</code>,
then <code>hazelcast.io.input.thread.count</code> is ignored. See <a href="#io-threading">[io-threading]</a> for more
information on specifying explicit thread counts.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t configure affinity for a category of threads, it means they can run on any CPU.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example. Assuming you have the <code>numactl</code> utility, run
the following command on your machine to see the mapping between the NUMA
nodes and threads:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>numactl --hardware</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example output is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>available: 2 nodes (0-1)
node 0 cpus: 0 1 2 3 4 5 6 7 8 9 20 21 22 23 24 25 26 27 28 29
node 0 size: 393090 MB
node 0 free: 372729 MB
node 1 cpus: 10 11 12 13 14 15 16 17 18 19 30 31 32 33 34 35 36 37 38 39
node 1 size: 393216 MB
node 1 free: 343296 MB
node distances:
node   0   1
  0:  10  21
  1:  21  10</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to configure 20 threads on NUMA node 0 and 20 threads on NUMA node 1,
and confine the threads to these NUMA nodes, you can use the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.operation.thread.affinity=[0-9,20-29],[10-19,30-39]</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access" target="_blank" rel="noopener">here</a>
for information on NUMA nodes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_running_on_ec2"><a class="anchor" href="#_running_on_ec2"></a>22.4. Running on EC2</h3>
<div class="paragraph">
<p>For the best performance of your Hazelcast on AWS EC2:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Select the newest Linux AMIs.</p>
</li>
<li>
<p>Select the HVM based instances.</p>
</li>
<li>
<p>Select at least a system with 8 vCPUs, e.g., c4.2xlarge. For an overview of all types of
EC2 instances, please check <a href="https://www.ec2instances.info" target="_blank" rel="noopener">this web page</a>.</p>
</li>
<li>
<p>Consider setting a placement group.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_back_pressure"><a class="anchor" href="#_back_pressure"></a>22.5. Back Pressure</h3>
<div class="paragraph">
<p>Hazelcast uses operations to make remote calls. For example, a <code>map.get</code> is an operation and
a <code>map.put</code> is one operation for the primary
and one operation for each of the backups, i.e., <code>map.put</code> is executed for the primary and also for each backup.
In most cases, there is a natural balance between the number of threads performing operations
and the number of operations being executed. However, the following may pile up this balance and operations
and eventually lead to <code>OutofMemoryException</code> (<code>OOME</code>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Asynchronous calls: With async calls, the system may be flooded with the requests.</p>
</li>
<li>
<p>Asynchronous backups: The asynchronous backups may be piling up.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To prevent the system from crashing, Hazelcast provides back pressure. Back pressure works by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>limiting the number of concurrent operation invocations</p>
</li>
<li>
<p>and periodically making an async backup sync.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_member_side"><a class="anchor" href="#_member_side"></a>22.5.1. Member Side</h4>
<div class="paragraph">
<p>Back pressure is disabled by default and you can enable it using the following system property:</p>
</div>
<div class="paragraph">
<p><code>hazelcast.backpressure.enabled</code></p>
</div>
<div class="paragraph">
<p>To control the number of concurrent invocations, you can configure the number of invocations allowed per partition using the
following system property:</p>
</div>
<div class="paragraph">
<p><code>hazelcast.backpressure.max.concurrent.invocations.per.partition</code></p>
</div>
<div class="paragraph">
<p>The default value of this system property is 100. Using a default configuration a system is allowed to
have (271 + 1) * 100 = 27200 concurrent invocations (271 partitions + 1 for generic operations).</p>
</div>
<div class="paragraph">
<p>Back pressure is only applied to normal operations. System operations like heart beats and partition migration operations
are not influenced by back pressure. 27200 invocations might seem like a lot, but keep in mind that executing a task on <code>IExecutor</code>
or acquiring a lock also requires an operation.</p>
</div>
<div class="paragraph">
<p>If the maximum number of invocations has been reached, Hazelcast automatically applies an exponential backoff policy. This
gives the system some time to deal with the load.
Using the following system property, you can configure the maximum time to wait before a <code>HazelcastOverloadException</code> is thrown:</p>
</div>
<div class="paragraph">
<p><code>hazelcast.backpressure.backoff.timeout.millis</code></p>
</div>
<div class="paragraph">
<p>This system property&#8217;s default value is 60000 milliseconds.</p>
</div>
<div class="paragraph">
<p>The Health Monitor keeps an eye on the usage of the invocations.
If it sees a member has consumed 70% or more of the invocations, it starts to log health messages.</p>
</div>
<div class="paragraph">
<p>Apart from controlling the number of invocations, you also need to control the number of pending async backups.
This is done by periodically making these backups sync instead of async.
This forces all pending backups to get drained. For this, Hazelcast tracks the number of
asynchronous backups for each partition. At every <strong>Nth</strong> call, one synchronization is forced. This <strong>N</strong> is
controlled through the following property:</p>
</div>
<div class="paragraph">
<p><code>hazelcast.backpressure.syncwindow</code></p>
</div>
<div class="paragraph">
<p>This system property&#8217;s default value is 100. It means, out of 100 <strong>asynchronous</strong> backups,
Hazelcast makes 1 of them a <strong>synchronous</strong> one. A randomization is added,
so the sync window with default configuration is between 75 and 125
invocations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_client_side"><a class="anchor" href="#_client_side"></a>22.5.2. Client Side</h4>
<div class="paragraph">
<p>To prevent the system on the client side from overloading, you can apply
a constraint on the number of concurrent invocations.
You can use the following system property on the client side for this purpose:</p>
</div>
<div class="paragraph">
<p><code>hazelcast.client.max.concurrent.invocations</code></p>
</div>
<div class="paragraph">
<p>This property defines the maximum allowed number of concurrent invocations.
When it is not explicitly set, it has the value <code>Integer.MAX_VALUE</code> by default, which means infinite.
When you set it and if the maximum number of concurrent invocations is exceeded this value,
Hazelcast throws <code>HazelcastOverloadException</code> when a new invocation comes in.</p>
</div>
<div class="paragraph">
<p>Please note that back off timeout and controlling the number of
pending async backups (sync window) is not supported on the client side.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#system-properties">System Properties appendix</a> to learn how to configure the system properties.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_threading_model"><a class="anchor" href="#_threading_model"></a>22.6. Threading Model</h3>
<div class="paragraph">
<p>Your application server has its own threads. Hazelcast does not use these; it manages its own threads.</p>
</div>
<div class="sect3">
<h4 id="_io_threading"><a class="anchor" href="#_io_threading"></a>22.6.1. I/O Threading</h4>
<div class="paragraph">
<p>Hazelcast uses a pool of threads for I/O. A single thread does not perform all the I/O.
Instead, multiple threads perform the I/O. On each cluster member, the I/O threading is split up in 3 types of I/O threads:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I/O thread for the accept requests</p>
</li>
<li>
<p>I/O threads to read data from other members/clients</p>
</li>
<li>
<p>I/O threads to write data to other members/clients</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can configure the number of I/O threads using the <code>hazelcast.io.thread.count</code> system property.
Its default value is 3 per member. If 3 is used, in total there are 7 I/O threads:
1 accept I/O thread, 3 read I/O threads and 3 write I/O threads. Each I/O thread has
its own Selector instance and waits on the <code>Selector.select</code> if there is nothing to do.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also specify counts for input and output threads separately.
There are <code>hazelcast.io.input.thread.count</code> and <code>hazelcast.io.output.thread.count</code> properties for this purpose.
See the <a href="#system-properties">System Properties appendix</a> for information on these properties and how to set them.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast periodically scans utilization of each I/O thread and
can decide to migrate a connection to a new thread if
the existing thread is servicing a disproportionate number of I/O events.
You can customize the scanning interval by configuring the <code>hazelcast.io.balancer.interval.seconds</code> system property;
its default interval is 20 seconds. You can disable the balancing process by setting this property to a negative value.</p>
</div>
<div class="paragraph">
<p>In case of the read I/O thread, when sufficient bytes for a packet have been received, the <code>Packet</code> object is created. This <code>Packet</code> object is
then sent to the system where it is de-multiplexed. If the <code>Packet</code> header signals that it is an operation/response, the <code>Packet</code> is handed
over to the operation service (see the <a href="#operation-threading">Operation Threading section</a>). If the <code>Packet</code> is an event, it is handed
over to the event service (see the <a href="#event-threading">Event Threading section</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_event_threading"><a class="anchor" href="#_event_threading"></a>22.6.2. Event Threading</h4>
<div class="paragraph">
<p>Hazelcast uses a shared event system to deal with components that rely on events, such as topic, collections, listeners and Near Cache.</p>
</div>
<div class="paragraph">
<p>Each cluster member has an array of event threads and each thread has its own work queue. When an event is produced,
either locally or remotely, an event thread is selected (depending on if there is a message ordering) and the event is placed
in the work queue for that event thread.</p>
</div>
<div class="paragraph">
<p>You can set the following properties
to alter the system&#8217;s behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.event.thread.count</code>: Number of event-threads in this array. Its default value is 5.</p>
</li>
<li>
<p><code>hazelcast.event.queue.capacity</code>: Capacity of the work queue. Its default value is 1000000.</p>
</li>
<li>
<p><code>hazelcast.event.queue.timeout.millis</code>: Timeout for placing an item on the work queue in milliseconds. Its default value is 250 milliseconds.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you process a lot of events and have many cores, changing the value of <code>hazelcast.event.thread.count</code> property to
a higher value is a good practice. This way, more events can be processed in parallel.</p>
</div>
<div class="paragraph">
<p>Multiple components share the same event queues. If there are 2 topics, say A and B, for certain messages
they may share the same queue(s) and hence the same event thread. If there are a lot of pending messages produced by A, then B needs to wait.
Also, when processing a message from A takes a lot of time and the event thread is used for that, B suffers from this.
That is why it is better to offload processing to a dedicated thread (pool) so that systems are better isolated.</p>
</div>
<div class="paragraph">
<p>If the events are produced at a higher rate than they are consumed, the queue grows in size. To prevent overloading the system
and running into an <code>OutOfMemoryException</code>, the queue is given a capacity of 1 million items. When the maximum capacity is reached, the items are
dropped. This means that the event system is a 'best effort' system. There is no guarantee that you are going to get an
event. Topic A might have a lot of pending messages and therefore B cannot receive messages because the queue
has no capacity and messages for B are dropped.</p>
</div>
</div>
<div class="sect3">
<h4 id="_iexecutor_threading"><a class="anchor" href="#_iexecutor_threading"></a>22.6.3. IExecutor Threading</h4>
<div class="paragraph">
<p>Executor threading is straight forward. When a task is received to be executed on Executor E, then E will have its
own <code>ThreadPoolExecutor</code> instance and the work is placed in the work queue of this executor.
Thus, Executors are fully isolated, but still share the same underlying hardware - most importantly the CPUs.</p>
</div>
<div class="paragraph">
<p>You can configure the IExecutor using the <code>ExecutorConfig</code> (programmatic configuration) or
using <code>&lt;executor&gt;</code> (declarative configuration). See also the <a href="#configuring-executor-service">Configuring Executor Service section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_operation_threading"><a class="anchor" href="#_operation_threading"></a>22.6.4. Operation Threading</h4>
<div class="paragraph">
<p>The following are the operation types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>operations that are aware of a certain partition, e.g., <code>IMap.get(key)</code></p>
</li>
<li>
<p>operations that are not partition aware, e.g., <code>IExecutorService.executeOnMember(command, member)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each of these operation types has a different threading model explained in the following sections.</p>
</div>
<div class="sect4">
<h5 id="_partition_aware_operations"><a class="anchor" href="#_partition_aware_operations"></a>Partition-aware Operations</h5>
<div class="paragraph">
<p>To execute partition-aware operations, an array of operation threads is created.
The default value of this array&#8217;s size is the number of cores and it has a minimum value of 2.
This value can be changed using the <code>hazelcast.operation.thread.count</code> property.</p>
</div>
<div class="paragraph">
<p>Each operation thread has its own work queue and it consumes messages from this work queue. If a partition-aware
operation needs to be scheduled, the right thread is found using the formula below.</p>
</div>
<div class="paragraph">
<p><code>threadIndex = partitionId % partition thread-count</code></p>
</div>
<div class="paragraph">
<p>After the <code>threadIndex</code> is determined, the operation is put in the work queue of that operation thread. This means the followings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A single operation thread executes operations for multiple partitions;
if there are 271 partitions and 10 partition threads, then roughly every operation thread executes operations for 27 partitions.</p>
</li>
<li>
<p>Each partition belongs to only 1 operation thread.
All operations for a partition are always handled by exactly the same operation thread.</p>
</li>
<li>
<p>Concurrency control is not needed to deal with partition-aware operations because
once a partition-aware operation is put in the work queue of a partition-aware operation thread, only 1 thread is able to touch that partition.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Because of this threading strategy, there are two forms of false sharing you need to be aware of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>False sharing of the partition - two completely independent data structures share the same partition.
For example, if there is a map <code>employees</code> and a map <code>orders</code>,
the method <code>employees.get("peter")</code> running on partition 25 may be blocked by
the method <code>orders.get(1234)</code> also running on partition 25.
If independent data structures share the same partition, a slow operation on one data structure can slow down the other data structures.</p>
</li>
<li>
<p>False sharing of the partition-aware operation thread - each operation thread is responsible for executing
operations on a number of partitions. For example, <strong>thread 1</strong> could be responsible for partitions 0, 10, 20, etc. and <strong>thread-2</strong> could be responsible for partitions
1, 11, 21, etc. If an operation for partition 1 takes a lot of time, it blocks the execution of an operation for partition
11 because both of them are mapped to the same operation thread.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to be careful with long running operations because you could starve operations of a thread.
As a general rule, the partition thread should be released as soon as possible because operations are not designed
as long running operations. That is why, for example, it is very dangerous to execute a long running operation
using <code>AtomicReference.alter()</code> or an <code>IMap.executeOnKey()</code>, because these operations block other operations to be executed.</p>
</div>
<div class="paragraph">
<p>Currently, there is no support for work stealing. Different partitions that map to the same thread may need to wait
till one of the partitions is finished, even though there are other free partition-aware operation threads available.</p>
</div>
<div class="paragraph">
<p><strong>Example:</strong></p>
</div>
<div class="paragraph">
<p>Take a cluster with three members. Two members have 90 primary partitions and one member has 91 primary partitions. Let&#8217;s
say you have one CPU and four cores per CPU. By default, four operation threads will be allocated to serve 90 or 91 partitions.</p>
</div>
</div>
<div class="sect4">
<h5 id="_non_partition_aware_operations"><a class="anchor" href="#_non_partition_aware_operations"></a>Non-Partition-aware Operations</h5>
<div class="paragraph">
<p>To execute operations that are not partition-aware, e.g., <code>IExecutorService.executeOnMember(command, member)</code>, generic operation
threads are used. When the Hazelcast instance is started, an array of operation threads is created. The size of this array
has a default value of the number of cores divided by two with a minimum value of 2. It can be changed using the
<code>hazelcast.operation.generic.thread.count</code> property.</p>
</div>
<div class="paragraph">
<p>A non-partition-aware operation thread does not execute an operation for a specific partition. Only partition-aware
  operation threads execute partition-aware operations.</p>
</div>
<div class="paragraph">
<p>Unlike the partition-aware operation threads, all the generic operation threads share the same work queue: <code>genericWorkQueue</code>.</p>
</div>
<div class="paragraph">
<p>If a non-partition-aware operation needs to be executed, it is placed in that work queue and any generic operation
thread can execute it. The big advantage is that you automatically have work balancing since any generic operation
thread is allowed to pick up work from this queue.</p>
</div>
<div class="paragraph">
<p>The disadvantage is that this shared queue can be a point of contention. You may not see this contention in
production since performance is dominated by I/O and the system does not run many non-partition-aware operations.</p>
</div>
</div>
<div class="sect4">
<h5 id="_priority_operations"><a class="anchor" href="#_priority_operations"></a>Priority Operations</h5>
<div class="paragraph">
<p>In some cases, the system needs to run operations with a higher priority, e.g., an important system operation.
To support priority operations, Hazelcast has the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For partition-aware operations: Each partition thread has its own work queue and it also has a priority
work queue. The partition thread always checks the priority queue before it processes work from its normal work queue.</p>
</li>
<li>
<p>For non-partition-aware operations: Next to the <code>genericWorkQueue</code>, there is also a <code>genericPriorityWorkQueue</code>. When a priority operation
needs to be run, it is put in the <code>genericPriorityWorkQueue</code>. Like the partition-aware operation threads, a generic
operation thread first checks the <code>genericPriorityWorkQueue</code> for work.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since a worker thread blocks on the normal work queue (either partition specific or generic), a priority operation
may not be picked up because it is not put in the queue where it is blocking. Hazelcast always sends a 'kick the worker' operation that
only triggers the worker to wake up and check the priority queue.</p>
</div>
</div>
<div class="sect4">
<h5 id="_operation_response_and_invocation_future"><a class="anchor" href="#_operation_response_and_invocation_future"></a>Operation-response and Invocation-future</h5>
<div class="paragraph">
<p>When an Operation is invoked, a <code>Future</code> is returned. See the example code below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">GetOperation operation = new GetOperation( mapName, key );
Future future = operationService.invoke( operation );
future.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The calling side blocks for a reply. In this case, <code>GetOperation</code> is set in the work queue for the partition of <code>key</code>, where
it eventually is executed. Upon execution, a response is returned and placed on the <code>genericWorkQueue</code> where it is executed by a
"generic operation thread". This thread signals the <code>future</code> and notifies the blocked thread that a response is available.
Hazelcast has a plan of exposing this <code>future</code> to the outside world, and we will provide the ability to register a completion listener so you can perform asynchronous calls.</p>
</div>
</div>
<div class="sect4">
<h5 id="_local_calls"><a class="anchor" href="#_local_calls"></a>Local Calls</h5>
<div class="paragraph">
<p>When a local partition-aware call is done, an operation is made and handed over to the work queue of the correct partition operation thread,
and a <code>future</code> is returned. When the calling thread calls <code>get</code> on that <code>future</code>, it acquires a lock and waits for the result
to become available. When a response is calculated, the <code>future</code> is looked up and the waiting thread is notified.</p>
</div>
<div class="paragraph">
<p>In the future, this will be optimized to reduce the amount of expensive systems calls, such as <code>lock.acquire()</code>/<code>notify()</code> and the expensive
interaction with the operation-queue. Probably, we will add support for a caller-runs mode, so that an operation is directly run on
the calling thread.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_slowoperationdetector"><a class="anchor" href="#_slowoperationdetector"></a>22.7. SlowOperationDetector</h3>
<div class="paragraph">
<p>The <code>SlowOperationDetector</code> monitors the operation threads and collects information about all slow operations.
An <code>Operation</code> is a task executed by a generic or partition thread (see <a href="#operation-threading">Operation Threading</a>).
An operation is considered as slow when it takes more computation time than the configured threshold.</p>
</div>
<div class="paragraph">
<p>The <code>SlowOperationDetector</code> stores the fully qualified classname of the operation and its stacktrace as well as
operation details, start time and duration of each slow invocation. All collected data is available in
the <a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-members" target="_blank" rel="noopener">Management Center</a>.</p>
</div>
<div class="paragraph">
<p>The <code>SlowOperationDetector</code> is configured via the following system properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.slow.operation.detector.enabled</code></p>
</li>
<li>
<p><code>hazelcast.slow.operation.detector.log.purge.interval.seconds</code></p>
</li>
<li>
<p><code>hazelcast.slow.operation.detector.log.retention.seconds</code></p>
</li>
<li>
<p><code>hazelcast.slow.operation.detector.stacktrace.logging.enabled</code></p>
</li>
<li>
<p><code>hazelcast.slow.operation.detector.threshold.millis</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#system-properties">System Properties appendix</a> for explanations of these properties.</p>
</div>
<div class="sect3">
<h4 id="_logging_of_slow_operations"><a class="anchor" href="#_logging_of_slow_operations"></a>22.7.1. Logging of Slow Operations</h4>
<div class="paragraph">
<p>The detected slow operations are logged as warnings in the Hazelcast log files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>WARN 2015-05-07 11:05:30,890 SlowOperationDetector: [127.0.0.1]:5701
  Slow operation detected: com.hazelcast.map.impl.operation.PutOperation
  Hint: You can enable the logging of stacktraces with the following config
  property: hazelcast.slow.operation.detector.stacktrace.logging.enabled
WARN 2015-05-07 11:05:30,891 SlowOperationDetector: [127.0.0.1]:5701
  Slow operation detected: com.hazelcast.map.impl.operation.PutOperation
  (2 invocations)
WARN 2015-05-07 11:05:30,892 SlowOperationDetector: [127.0.0.1]:5701
  Slow operation detected: com.hazelcast.map.impl.operation.PutOperation
  (3 invocations)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stacktraces are always reported to the Management Center, but by default they are not printed to keep the log size small.
If logging of stacktraces is enabled, the full stacktrace is printed every 100 invocations.
All other invocations print a shortened version.</p>
</div>
</div>
<div class="sect3">
<h4 id="_purging_of_slow_operation_logs"><a class="anchor" href="#_purging_of_slow_operation_logs"></a>22.7.2. Purging of Slow Operation Logs</h4>
<div class="paragraph">
<p>Since a Hazelcast cluster can run for a very long time, Hazelcast purges the slow operation logs periodically to prevent an OOME.
You can configure the purge interval and the retention time for each invocation.</p>
</div>
<div class="paragraph">
<p>The purging removes each invocation whose retention time is exceeded.
When all invocations are purged from a slow operation log, the log is deleted.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_near_cache"><a class="anchor" href="#_near_cache"></a>22.8. Near Cache</h3>
<div class="paragraph">
<p>Map or Cache entries in Hazelcast are partitioned across the cluster members.
Hazelcast clients do not have local data at all. Suppose you read the key <code>k</code> a number of times from
a Hazelcast client or <code>k</code> is owned by another member in your cluster.
Then each <code>map.get(k)</code> or <code>cache.get(k)</code> will be a remote operation, which creates a lot of network trips.
If you have a data structure that is mostly read, then you should consider creating a local Near Cache,
so that reads are sped up and less network traffic is created.</p>
</div>
<div class="paragraph">
<p>These benefits do not come for free. See the following trade-offs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Members with a Near Cache has to hold the extra cached data, which increases memory consumption.</p>
</li>
<li>
<p>If invalidation is enabled and entries are updated frequently, then invalidations will be costly.</p>
</li>
<li>
<p>Near Cache breaks the strong consistency guarantees; you might be reading stale data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Near Cache is highly recommended for data structures that are mostly read.</p>
</div>
<div class="paragraph">
<p>In a client/server system you must enable the Near Cache separately on the client, without the need
to configure it on the server. Please note that Near Cache configuration is specific to the server or client itself:
a data structure on a server may not have Near Cache configured while the same data structure on a client may have Near Cache configured.
They also can have different Near Cache configurations.</p>
</div>
<div class="paragraph">
<p>If you are using Near Cache, you should take into account that
your hits to the keys in the Near Cache are not reflected as hits to the original keys on the primary members.
This has for example an impact on IMap&#8217;s maximum idle seconds or time-to-live seconds expiration.
Therefore, even though there is a hit on a key in Near Cache, your original key on the primary member may expire.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Near Cache works only when you access data via <code>map.get(k)</code> or <code>cache.get(k)</code> methods.
Data returned using a predicate is not stored in the Near Cache.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_hazelcast_data_structures_with_near_cache_support"><a class="anchor" href="#_hazelcast_data_structures_with_near_cache_support"></a>22.8.1. Hazelcast Data Structures with Near Cache Support</h4>
<div class="paragraph">
<p>The following matrix shows the Hazelcast data structures with Near Cache support.
Please have a look at the next section for a detailed explanation of <code>cache-local-entries</code>, <code>local-update-policy</code>, <code>preloader</code> and <code>serialize-keys</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Data structure</th>
<th class="tableblock halign-left valign-top">Near Cache Support</th>
<th class="tableblock halign-left valign-top"><code>cache-local-entries</code></th>
<th class="tableblock halign-left valign-top"><code>local-update-policy</code></th>
<th class="tableblock halign-left valign-top"><code>preloader</code></th>
<th class="tableblock halign-left valign-top"><code>serialize-keys</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IMap member</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IMap client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JCache member</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JCache client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReplicatedMap member</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReplicatedMap client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TransactionalMap member</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">limited</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TransactionalMap client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Even though lite members do not store any data for Hazelcast data structures,
you can enable Near Cache on lite members for faster reads.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_near_cache"><a class="anchor" href="#_configuring_near_cache"></a>22.8.2. Configuring Near Cache</h4>
<div class="paragraph">
<p>The following shows the configuration for the Hazelcast Near Cache.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please keep in mind that, if you want to use near cache on a Hazelcast member,
configure it on the member; if you want to use it on a Hazelcast client, configure it on the client.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;near-cache name="myDataStructure"&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;invalidate-on-change&gt;true&lt;/invalidate-on-change&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;max-idle-seconds&gt;60&lt;/max-idle-seconds&gt;
        &lt;eviction eviction-policy="LFU"
            max-size-policy= "ENTRY_COUNT"
            size="1000"/&gt;
        &lt;cache-local-entries&gt;false&lt;/cache-local-entries&gt;
        &lt;local-update-policy&gt;INVALIDATE&lt;/local-update-policy&gt;
        &lt;preloader enabled="true"
             directory="nearcache-example"
             store-initial-delay-seconds="0"
             store-interval-seconds="0"/&gt;
    &lt;/near-cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
    near-cache:
      myDataStructure:
        in-memory-format: BINARY
        invalidate-on-change: true
        time-to-live-seconds: 0
        max-idle-seconds: 60
        eviction:
          size: 1000
          max-size-policy: ENTRY_COUNT
          eviction-policy: LFU
        cache-local-entries: false
        local-update-policy: INVALIDATE
        preloader:
          enabled: true
          directory: nearcache-example
          store-initial-delay-seconds: 0
          store-interval-seconds: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The element <code>&lt;near-cache&gt;</code> has an optional attribute <code>name</code> whose default value is <code>default</code>.</p>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        EvictionConfig evictionConfig = new EvictionConfig()
                .setMaxSizePolicy(MaxSizePolicy.ENTRY_COUNT)
                .setEvictionPolicy(EvictionPolicy.LRU)
                .setSize( 1 );

        NearCachePreloaderConfig preloaderConfig = new NearCachePreloaderConfig()
                .setEnabled(true)
                .setDirectory("nearcache-example")
                .setStoreInitialDelaySeconds( 1 )
                .setStoreIntervalSeconds( 2 );

        NearCacheConfig nearCacheConfig = new NearCacheConfig()
                .setName("myDataStructure")
                .setInMemoryFormat(InMemoryFormat.BINARY)
                .setSerializeKeys(true)
                .setInvalidateOnChange(false)
                .setTimeToLiveSeconds( 1 )
                .setMaxIdleSeconds( 5 )
                .setEvictionConfig(evictionConfig)
                .setCacheLocalEntries(true)
                .setLocalUpdatePolicy(NearCacheConfig.LocalUpdatePolicy.CACHE_ON_UPDATE)
                .setPreloaderConfig(preloaderConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/NearCacheConfig.html" target="_blank" rel="noopener">NearCacheConfig</a>
is used for all supported Hazelcast data structures on members and clients.</p>
</div>
<div class="paragraph">
<p>The following are the descriptions of all configuration elements and attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>in-memory-format</code>: Specifies in which format data is stored in your Near Cache.
Note that a map&#8217;s in-memory format can be different from that of its Near Cache. Available values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>BINARY</code>: Data is stored in serialized binary format (default value).</p>
</li>
<li>
<p><code>OBJECT</code>: Data is stored in deserialized form.</p>
</li>
<li>
<p><code>NATIVE</code>: Data is stored in the Near Cache that uses Hazelcast&#8217;s High-Density Memory Store feature.
This option is available only in Hazelcast IMDG Enterprise HD. Note that a map and
its Near Cache can independently use High-Density Memory Store.
For example, while your map does not use High-Density Memory Store, its Near Cache can use it.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>invalidate-on-change</code>: Specifies whether the cached entries are evicted when the entries are updated or removed.
Its default value is true.</p>
</li>
<li>
<p><code>time-to-live-seconds</code>: Maximum number of seconds for each entry to stay in the Near Cache.
Entries that are older than this period are automatically evicted from the Near Cache.
Regardless of the eviction policy used, <code>time-to-live-seconds</code> still applies.
Any integer between 0 and <code>Integer.MAX_VALUE</code>. 0 means infinite. Its default value is 0.</p>
</li>
<li>
<p><code>max-idle-seconds</code>: Maximum number of seconds each entry can stay in the Near Cache as untouched (not read).
Entries that are not read more than this period are removed from the Near Cache.
Any integer between 0 and <code>Integer.MAX_VALUE</code>. 0 means <code>Integer.MAX_VALUE</code>. Its default value is 0.</p>
</li>
<li>
<p><code>eviction</code>: Specifies the eviction behavior when you use High-Density Memory Store for your Near Cache.
It has the following attributes:</p>
<div class="ulist">
<ul>
<li>
<p><code>eviction-policy</code>: Eviction policy configuration. Available values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>LRU</code>: Least Recently Used (default value).</p>
</li>
<li>
<p><code>LFU</code>: Least Frequently Used.</p>
</li>
<li>
<p><code>NONE</code>: No items are evicted and the property <code>max-size</code> is ignored.
You still can combine it with <code>time-to-live-seconds</code> and <code>max-idle-seconds</code> to evict items from the Near Cache.</p>
</li>
<li>
<p><code>RANDOM</code>: A random item is evicted.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>max-size-policy</code>: Maximum size policy for eviction of the Near Cache. Available values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>ENTRY_COUNT</code>: Maximum size based on the entry count in the Near Cache (default value).</p>
</li>
<li>
<p><code>USED_NATIVE_MEMORY_SIZE</code>: Maximum used native memory size of the specified Near Cache in MB to trigger the eviction.
If the used native memory size exceeds this threshold, the eviction is triggered.
Available only for <code>NATIVE</code> in-memory format. This is supported only by Hazelcast IMDG Enterprise.</p>
</li>
<li>
<p><code>USED_NATIVE_MEMORY_PERCENTAGE</code>: Maximum used native memory percentage of the specified Near Cache to trigger the eviction.
If the native memory usage percentage (relative to maximum native memory size) exceeds this threshold, the eviction is triggered.
Available only for <code>NATIVE</code> in-memory format. This is supported only by Hazelcast IMDG Enterprise.</p>
</li>
<li>
<p><code>FREE_NATIVE_MEMORY_SIZE</code>: Minimum free native memory size of the specified Near Cache in MB to trigger the eviction.
If free native memory size goes below this threshold, eviction is triggered. Available only for <code>NATIVE</code> in-memory format.
This is supported only by Hazelcast IMDG Enterprise.</p>
</li>
<li>
<p><code>FREE_NATIVE_MEMORY_PERCENTAGE</code>: Minimum free native memory percentage of the specified Near Cache to trigger eviction.
If free native memory percentage (relative to maximum native memory size) goes below this threshold, eviction is triggered.
Available only for <code>NATIVE</code> in-memory format. This is supported only by Hazelcast IMDG Enterprise.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>size</code>: Maximum size of the Near Cache used for <code>max-size-policy</code>. When this is reached the Near Cache is evicted based on
the policy defined. Any integer between <code>1</code> and <code>Integer.MAX_VALUE</code>. This value has different defaults, depending on the data structure.</p>
<div class="ulist">
<ul>
<li>
<p><code>IMap</code>: Its default value is <code>Integer.MAX_VALUE</code> for on-heap maps and <code>10000</code> for the <code>NATIVE</code> in-memory format.</p>
</li>
<li>
<p><code>JCache</code>: Its default value is <code>10000</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>cache-local-entries</code>: Specifies whether the local entries are cached. It can be useful when in-memory format for
Near Cache is different from that of the map. By default, it is disabled.
Is just available on Hazelcast members, not on Hazelcast clients (which have no local entries).</p>
</li>
<li>
<p><code>local-update-policy</code>: Specifies the update policy of the local Near Cache.
It is available on JCache clients. Available values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>INVALIDATE</code>: Removes the Near Cache entry on mutation. After the mutative call to the member completes but before the operation returns to the caller,
the Near Cache entry is removed. Until the mutative operation completes, the readers still continue to read the old value.
But as soon as the update completes the Near Cache entry is removed.
Any threads reading the key after this point will have a Near Cache miss and call through to the member, obtaining the new entry.
This setting provides read-your-writes consistency. This is the default setting.</p>
</li>
<li>
<p><code>CACHE_ON_UPDATE</code>: Updates the Near Cache entry on mutation. After the mutative call to the member completes but before the put returns to the caller,
the Near Cache entry is updated.
So a remove will remove it and one of the put methods will update it to the new value.
Until the update/remove operation completes, the entry&#8217;s old value can still be read from the Near Cache.
But before the call completes the Near Cache entry is updated. Any threads reading the key after this point read the new entry.
If the mutative operation was a remove, the key will no longer exist in the cache, both the Near Cache and the original copy in the member.
The member initiates an invalidate event to any other Near Caches, however the caller Near Cache is
not invalidated as it already has the new value. This setting also provides read-your-writes consistency.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>preloader</code>: Specifies if the Near Cache should store and pre-load its keys for a faster re-population after
a Hazelcast client restart. Is just available on IMap and JCache clients. It has the following attributes:</p>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether the preloader for this Near Cache is enabled or not, <code>true</code> or <code>false</code>.</p>
</li>
<li>
<p><code>directory</code>: Specifies the parent directory for the preloader of this Near Cache. The filenames for
the preloader storage are generated from the Near Cache name. You can additionally specify the parent directory
to have multiple clients on the same machine with the same Near Cache names.</p>
</li>
<li>
<p><code>store-initial-delay-seconds</code>: Specifies the delay in seconds until the keys of this Near Cache
are stored for the first time. Its default value is <code>600</code> seconds.</p>
</li>
<li>
<p><code>store-interval-seconds</code>: Specifies the interval in seconds in which the keys of this Near Cache are stored.
Its default value is <code>600</code> seconds.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_near_cache_configuration_examples"><a class="anchor" href="#_near_cache_configuration_examples"></a>22.8.3. Near Cache Configuration Examples</h4>
<div class="paragraph">
<p>This section shows some configuration examples for different Hazelcast data structures.</p>
</div>
<div class="sect4">
<h5 id="_near_cache_example_for_imap"><a class="anchor" href="#_near_cache_example_for_imap"></a>Near Cache Example for IMap</h5>
<div class="paragraph">
<p>The following are configuration examples for IMap Near Caches for Hazelcast members and clients.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="mostlyReadMap"&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;near-cache&gt;
            &lt;in-memory-format&gt;OBJECT&lt;/in-memory-format&gt;
            &lt;invalidate-on-change&gt;false&lt;/invalidate-on-change&gt;
            &lt;time-to-live-seconds&gt;600&lt;/time-to-live-seconds&gt;
            &lt;eviction eviction-policy="NONE" max-size-policy="ENTRY_COUNT" size="5000"/&gt;
            &lt;cache-local-entries&gt;true&lt;/cache-local-entries&gt;
        &lt;/near-cache&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    mostlyReadMap:
      in-memory-format: BINARY
      near-cache:
        in-memory-format: OBJECT
        invalidate-on-change: false
        time-to-live-seconds: 600
        eviction:
          eviction-policy: NONE
          max-size-policy: ENTRY_COUNT
          size: 5000
          cache-local-entries: true</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EvictionConfig evictionConfig = new EvictionConfig()
  .setEvictionPolicy(EvictionPolicy.NONE)
  .setMaximumSizePolicy(MaxSizePolicy.ENTRY_COUNT)
  .setSize(5000);

NearCacheConfig nearCacheConfig = new NearCacheConfig()
  .setInMemoryFormat(InMemoryFormat.OBJECT)
  .setInvalidateOnChange(false)
  .setTimeToLiveSeconds(600)
  .setEvictionConfig(evictionConfig);

Config config = new Config();
config.getMapConfig("mostlyReadMap")
  .setInMemoryFormat(InMemoryFormat.BINARY)
  .setNearCacheConfig(nearCacheConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Near Cache configuration for maps on members is a child of the map configuration,
so you do not have to define the map name in the Near Cache configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;near-cache name="mostlyReadMap"&gt;
        &lt;in-memory-format&gt;OBJECT&lt;/in-memory-format&gt;
        &lt;invalidate-on-change&gt;true&lt;/invalidate-on-change&gt;
        &lt;eviction eviction-policy="LRU" max-size-policy="ENTRY_COUNT" size="50000"/&gt;
    &lt;/near-cache&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  near-cache:
    mostlyReadMap:
      in-memory-format: OBJECT
      invalidate-on-change: true
      eviction:
        eviction-policy: LRU
        max-size-policy: ENTRY_COUNT
        size: 50000</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EvictionConfig evictionConfig = new EvictionConfig()
  .setEvictionPolicy(EvictionPolicy.LRU)
  .setMaximumSizePolicy(MaxSizePolicy.ENTRY_COUNT)
  .setSize(50000);

NearCacheConfig nearCacheConfig = new NearCacheConfig()
  .setName("mostlyReadMap")
  .setInMemoryFormat(InMemoryFormat.OBJECT)
  .setInvalidateOnChange(true)
  .setEvictionConfig(evictionConfig);

ClientConfig clientConfig = new ClientConfig()
  .addNearCacheConfig(nearCacheConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Near Cache on the client side must have the same name as the data structure on the member for which
this Near Cache is being created. You can use wildcards, so in this example <code>mostlyRead*</code> would also match the map <code>mostlyReadMap</code>.</p>
</div>
<div class="paragraph">
<p>A Near Cache can have its own <code>in-memory-format</code> which is independent of the <code>in-memory-format</code> of the data structure.</p>
</div>
</div>
<div class="sect4">
<h5 id="_near_cache_example_for_jcache_clients"><a class="anchor" href="#_near_cache_example_for_jcache_clients"></a>Near Cache Example for JCache Clients</h5>
<div class="paragraph">
<p>The following is a configuration example for a JCache Near Cache for a Hazelcast client.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;near-cache name="mostlyReadCache"&gt;
        &lt;in-memory-format&gt;OBJECT&lt;/in-memory-format&gt;
        &lt;invalidate-on-change&gt;true&lt;/invalidate-on-change&gt;
        &lt;eviction eviction-policy="LRU" max-size-policy="ENTRY_COUNT" size="30000"/&gt;
        &lt;local-update-policy&gt;CACHE_ON_UPDATE&lt;/local-update-policy&gt;
    &lt;/near-cache&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  near-cache:
    mostlyReadCache:
      in-memory-format: OBJECT
      invalidate-on-change: true
      eviction:
        eviction-policy: LRU
        max-size-policy: ENTRY_COUNT
        size: 30000
      local-update-policy: CACHE_ON_UPDATE</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EvictionConfig evictionConfig = new EvictionConfig()
  .setEvictionPolicy(EvictionPolicy.LRU)
  .setMaximumSizePolicy(MaxSizePolicy.ENTRY_COUNT)
  .setSize(30000);

NearCacheConfig nearCacheConfig = new NearCacheConfig()
  .setName("mostlyReadCache")
  .setInMemoryFormat(InMemoryFormat.OBJECT)
  .setInvalidateOnChange(true)
  .setEvictionConfig(evictionConfig)
  .setLocalUpdatePolicy(LocalUpdatePolicy.CACHE_ON_UPDATE);

ClientConfig clientConfig = new ClientConfig()
  .addNearCacheConfig(nearCacheConfig);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_example_for_near_cache_with_high_density_memory_store"><a class="anchor" href="#_example_for_near_cache_with_high_density_memory_store"></a>Example for Near Cache with High-Density Memory Store</h5>
<div class="paragraph">
<p><strong class="navy">Hazelcast IMDG Enterprise HD Feature</strong></p>
</div>
<div class="paragraph">
<p>The following is a configuration example for an IMap High-Density Near Cache for a Hazelcast member.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="mostlyReadMapWithHighDensityNearCache"&gt;
        &lt;in-memory-format&gt;OBJECT&lt;/in-memory-format&gt;
        &lt;near-cache&gt;
            &lt;in-memory-format&gt;NATIVE&lt;/in-memory-format&gt;
            &lt;eviction eviction-policy="LFU" max-size-policy="USED_NATIVE_MEMORY_PERCENTAGE" size="90"/&gt;
        &lt;/near-cache&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    mostlyReadMapWithHighDensityNearCache
      in-memory-format: OBJECT
      near-cache:
        in-memory-format: NATIVE
        eviction:
          eviction-policy: LFU
          max-size-policy: USED_NATIVE_MEMORY_PERCENTAGE
          size: 90</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EvictionConfig evictionConfig = new EvictionConfig()
  .setEvictionPolicy(EvictionPolicy.LFU)
  .setMaximumSizePolicy(MaxSizePolicy.USED_NATIVE_MEMORY_PERCENTAGE)
  .setSize(90);

NearCacheConfig nearCacheConfig = new NearCacheConfig()
  .setInMemoryFormat(InMemoryFormat.NATIVE)
  .setEvictionConfig(evictionConfig);

Config config = new Config();
config.getMapConfig("mostlyReadMapWithHighDensityNearCache")
  .setInMemoryFormat(InMemoryFormat.OBJECT)
  .setNearCacheConfig(nearCacheConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that you should have already enabled the High-Density Memory Store usage for your cluster.
See the <a href="#configuring-high-density-memory-store">Configuring High-Density Memory Store section</a>.</p>
</div>
<div class="paragraph">
<p>Note that a map and its Near Cache can independently use High-Density Memory Store.
For example, if your map does not use High-Density Memory Store, its Near Cache can still use it.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_near_cache_eviction"><a class="anchor" href="#_near_cache_eviction"></a>22.8.4. Near Cache Eviction</h4>
<div class="paragraph">
<p>In the scope of Near Cache, eviction means evicting (clearing) the entries selected according to
the given <code>eviction-policy</code> when the specified <code>max-size-policy</code> has been reached.</p>
</div>
<div class="paragraph">
<p>The <code>max-size-policy</code> defines the state when the Near Cache is full and determines whether
the eviction should be triggered. The <code>size</code> is either interpreted as entry count, memory size or percentage, depending on the chosen policy.</p>
</div>
<div class="paragraph">
<p>Once the eviction is triggered the configured <code>eviction-policy</code> determines which, if any, entries must be evicted.</p>
</div>
<div class="paragraph">
<p>Note that the policies mentioned are configured under the <code>near-cache</code> configuration block, as seen in the above
<a href="#near-cache-configuration-examples">configuration examples</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_near_cache_expiration"><a class="anchor" href="#_near_cache_expiration"></a>22.8.5. Near Cache Expiration</h4>
<div class="paragraph">
<p>Expiration means the eviction of expired records. A record is expired:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if it is not touched (accessed/read) for <code>max-idle-seconds</code></p>
</li>
<li>
<p><code>time-to-live-seconds</code> passed since it is put to Near Cache.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The actual expiration is performed in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a record is accessed: it is checked if the record is expired or not.
If it is expired, it is evicted and <code>null</code> is returned as the value to the caller.</p>
</li>
<li>
<p>In the background: there is an expiration task that periodically (currently 5 seconds) scans records and evicts the expired records.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that <code>max-idle-seconds</code> and <code>time-to-live-seconds</code> are configured under the <code>near-cache</code> configuration block, as seen in the above
<a href="#near-cache-configuration-examples">configuration examples</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_near_cache_invalidation"><a class="anchor" href="#_near_cache_invalidation"></a>22.8.6. Near Cache Invalidation</h4>
<div class="paragraph">
<p>Invalidation is the process of removing an entry from the Near Cache when its value is updated or
it is removed from the original data structure (to prevent stale reads).
Near Cache invalidation happens asynchronously at the cluster level, but synchronously at the current member.
This means that the Near Cache is invalidated within the whole cluster after the modifying operation is finished,
but updated from the current member before the modifying operation is done.
A modifying operation can be an EntryProcessor, an explicit update or remove as well as an expiration or eviction.
Generally, whenever the state of an entry changes in the record store by updating its value or removing it, the invalidation event is sent for that entry.</p>
</div>
<div class="paragraph">
<p>Invalidations can be sent from members to client Near Caches or to member Near Caches, either individually or in batches.
Default behavior is sending in batches. If there are lots of mutating operations such as put/remove on data structures,
it is advised that you configure batch invalidations.
This reduces the network traffic and keeps the eventing system less busy, but may increase the delay of individual invalidations.</p>
</div>
<div class="paragraph">
<p>You can use the following system properties to configure the Near Cache invalidation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.map.invalidation.batch.enabled</code>: Enable or disable batching.
Its default value is <code>true</code>. When it is set to <code>false</code>, all invalidations are sent immediately.</p>
</li>
<li>
<p><code>hazelcast.map.invalidation.batch.size</code>: Maximum number of invalidations in a batch. Its default value is <code>100</code>.</p>
</li>
<li>
<p><code>hazelcast.map.invalidation.batchfrequency.seconds</code>: If the collected invalidations do not reach the configured batch size,
a background process sends them periodically. Its default value is <code>10</code> seconds.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there are a lot of clients or many mutating operations, batching should remain enabled and
the batch size should be configured with the <code>hazelcast.map.invalidation.batch.size</code> system property to a suitable value.</p>
</div>
</div>
<div class="sect3">
<h4 id="_near_cache_consistency"><a class="anchor" href="#_near_cache_consistency"></a>22.8.7. Near Cache Consistency</h4>
<div class="sect4">
<h5 id="_eventual_consistency"><a class="anchor" href="#_eventual_consistency"></a>Eventual Consistency</h5>
<div class="paragraph">
<p>Near Caches are invalidated by invalidation events. Invalidation events can be lost due to the fire-and-forget fashion of eventing system.
If an event is lost, reads from Near Cache can indefinitely be stale.</p>
</div>
<div class="paragraph">
<p>To solve this problem, Hazelcast provides
eventually consistent behavior for IMap/JCache Near Caches by detecting invalidation losses.
After detection of an invalidation loss, stale data is made unreachable and Near Cache&#8217;s <code>get</code> calls to
that data are directed to the underlying IMap/JCache to fetch the fresh data.</p>
</div>
<div class="paragraph">
<p>You can configure eventual consistency with the system properties below (same properties are valid for both member and client side Near Caches):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.invalidation.max.tolerated.miss.count</code>: Default value is 10.
If missed invalidation count is bigger than this value, relevant cached data is made unreachable.</p>
</li>
<li>
<p><code>hazelcast.invalidation.reconciliation.interval.seconds</code>: Default value is 60 seconds.
This is a periodic task that scans cluster members periodically to compare generated invalidation events with the received ones from Near Cache.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_locally_initiated_changes"><a class="anchor" href="#_locally_initiated_changes"></a>Locally Initiated Changes</h5>
<div class="paragraph">
<p>For local invalidations, when a record is updated/removed, future reads will see this
update/remove to provide read-your-writes consistency. To achieve this consistency, Near Cache configuration provides the following update policies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>INVALIDATE</code></p>
</li>
<li>
<p><code>CACHE_ON_UPDATE</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you choose <code>INVALIDATE</code>, the entry is removed from the Near Cache after the update/remove occurs in
the underlying data structure and before the operation (get) returns to the caller.
Until the update/remove operation completes, the entry&#8217;s old value can still be read from the Near Cache.</p>
</div>
<div class="paragraph">
<p>If you choose <code>CACHE_ON_UPDATE</code>, the entry is updated after the
update/remove occurs in the underlying data structure and before the operation (put/get) returns to the caller.
If it is an update operation, it removes the entry and the new value is placed.
Until the update/remove operation completes, the entry&#8217;s old value can still be read from the Near Cache.
Any threads reading the key after this point read the new entry. If the mutative operation was a remove,
the key will no longer exist in the Near Cache and the original copy in the member.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_near_cache_preloader"><a class="anchor" href="#_near_cache_preloader"></a>22.8.8. Near Cache Preloader</h4>
<div class="paragraph">
<p>The Near Cache preloader is a functionality to store the keys from a Near Cache to provide
a fast re-population of the previous hot data set after a Hazelcast Client has been restarted.
It is available on IMap and JCache clients.</p>
</div>
<div class="paragraph">
<p>The Near Cache preloader stores the keys (not the values) of Near Cache entries in regular intervals.
You can define the initial delay via <code>store-initial-delay-seconds</code>, e.g., if you know that your hot data set needs
some time to build up. You can configure the interval via <code>store-interval-seconds</code> which determines how often
the key-set is stored. The persistence does not run continuously. Whenever the storage is scheduled, it is performed on the actual keys in the Near Cache.</p>
</div>
<div class="paragraph">
<p>The Near Cache preloader is triggered on the first initialization of the data structure on the client, e.g., <code>client.getMap("myNearCacheMap")</code>.
This schedules the preloader, which works in the background, so your application is not blocked.
The storage is enabled after the loading is completed.</p>
</div>
<div class="paragraph">
<p>The configuration parameter <code>directory</code> is optional.
If you omit it, the base folder becomes the user working directory (normally where the JVM was started or
configured with the system property <code>user.dir</code>).
The storage filenames are always created from the Near Cache name.
So even if you use a wildcard name in the Near Cache Configuration, the preloader filenames are unique.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you run multiple Hazelcast clients with enabled Near Cache preloader on the same machine,
you have to configure a unique storage filename for each client or run them from different user directories.
If two clients would write into the same file, only the first client succeeds.
The following clients throw an exception as soon as the Near Cache preloader is triggered.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_caching_deserialized_values"><a class="anchor" href="#_caching_deserialized_values"></a>22.9. Caching Deserialized Values</h3>
<div class="paragraph">
<p>There may be cases where you do not want to deserialize some values in your Hazelcast map again which were already deserialized previously.
This way your query operations get faster.
This is possible by using the <code>cache-deserialized-values</code> element in your declarative Hazelcast configuration, as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;cache-deserialized-values&gt;INDEX-ONLY&lt;/cache-deserialized-values&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      in-memory-format: BINARY
      cache-deserialized-values: INDEX-ONLY
      backup-count: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>cache-deserialized-values</code> element controls the caching of deserialized values.
Note that caching makes the query evaluation faster, but it consumes more memory. This element has the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NEVER: Deserialized values are never cached.</p>
</li>
<li>
<p>INDEX-ONLY: Deserialized values are cached only when they are inserted into an index.</p>
</li>
<li>
<p>ALWAYS: Deserialized values are always cached.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you are using portable serialization or your map&#8217;s in-memory format is <code>OBJECT</code> or <code>NATIVE</code>,
then <code>cache-deserialized-values</code> element does not have any effect.</p>
</div>
<div class="sect3">
<h4 id="_performance_anti_patterns"><a class="anchor" href="#_performance_anti_patterns"></a>22.9.1. Performance Anti Patterns</h4>
<div class="paragraph">
<p>This section covers various recommendations to improve the performance of your Hazelcast IMDG clusters.</p>
</div>
<div class="sect4">
<h5 id="_using_single_member_per_machine"><a class="anchor" href="#_using_single_member_per_machine"></a>Using Single Member per Machine</h5>
<div class="paragraph">
<p>A Hazelcast member assumes it is alone on a machine, so we recommend not running multiple
Hazelcast members on a machine. Having multiple
members on a single machine most likely gives a worse performance compared to
running a single member, since there will be more
context switching, less batching, etc. So unless it is proven that running multiple members per machine does give a better
performance/behavior in your particular setup, it is best to run a single member per machine.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_operation_threads_efficiently"><a class="anchor" href="#_using_operation_threads_efficiently"></a>Using Operation Threads Efficiently</h5>
<div class="paragraph">
<p>By default, Hazelcast uses the machine&#8217;s core count to determine the number of operation threads. Creating more
operation threads than this core count is highly unlikely leads to an improved performance since there will be more context
switching, more thread notification, etc.</p>
</div>
<div class="paragraph">
<p>Especially if you have a system that does simple operations like put and get,
it is better to use a lower thread count than the number of cores.
The reason behind the increased performance
by reducing the core count is that the operations executed on the operation threads normally execute very fast and there can
be a very significant amount of overhead caused by thread parking and unparking. If there are less threads, a thread needs
to do more work, will block less and therefore needs to be notified less.</p>
</div>
</div>
<div class="sect4">
<h5 id="_avoiding_random_changes"><a class="anchor" href="#_avoiding_random_changes"></a>Avoiding Random Changes</h5>
<div class="paragraph">
<p>Tweaking can be very rewarding because significant performance improvements are possible. By default, Hazelcast tries
to behave at its best for all situations, but this doesn&#8217;t always lead to the best performance. So if you know what
you are doing and what to look for, it can be very rewarding to tweak. However it is also important that tweaking should
be done with proper testing to see if there is actually an improvement. Tweaking without proper benchmarking
is likely going to lead to confusion and could cause all kinds of problems. In case of doubt, we recommend not to tweak.</p>
</div>
</div>
<div class="sect4">
<h5 id="_creating_the_right_benchmark_environment"><a class="anchor" href="#_creating_the_right_benchmark_environment"></a>Creating the Right Benchmark Environment</h5>
<div class="paragraph">
<p>When benchmarking, it is important that the benchmark reflects your production environment. Sometimes with calculated
guess, a representative smaller environment can be set up; but if you want to use the benchmark statistics to inference
how your production system is going to behave, you need to make sure that you get as close as your production setup as
possible. Otherwise, you are at risk of spotting the issues too late or focusing on the things which are not relevant.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hazelcast_simulator"><a class="anchor" href="#_hazelcast_simulator"></a>23. Hazelcast Simulator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast Simulator is a production simulator used to test Hazelcast and Hazelcast-based applications in clustered environments. It also allows you to create your own tests and perform them on your Hazelcast clusters and applications that are deployed to cloud computing environments. In your tests, you can provide any property that can be specified on these environments (Amazon EC2, Google Compute Engine(GCE), or your own environment): properties such as hardware specifications, operating system and Java version.</p>
</div>
<div class="paragraph">
<p>See the documentation on its own GitHub repository at <a href="https://github.com/hazelcast/hazelcast-simulator/blob/master/README.md" target="_blank" rel="noopener">Hazelcast Simulator</a>.</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/index.adoc - include::wan:index.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_osgi"><a class="anchor" href="#_osgi"></a>24. OSGI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter explains how Hazelcast is supported on OSGI (Open Service Gateway Initiatives) environments.</p>
</div>
<div class="sect2">
<h3 id="_osgi_support"><a class="anchor" href="#_osgi_support"></a>24.1. OSGI Support</h3>
<div class="paragraph">
<p>Hazelcast bundles provide OSGI services so that Hazelcast users can
manage (create, access, shutdown) Hazelcast instances through these services on OSGI environments.
When you enable the property <code>hazelcast.osgi.start</code> (default is disabled), when
an Hazelcast OSGI service is activated, a default Hazelcast instance is created automatically.</p>
</div>
<div class="paragraph">
<p>Created Hazelcast instances can be served as an OSGI service that the other Hazelcast bundles can access.
Registering created Hazelcast instances behavior is enabled by default;
you can disable it using the property <code>hazelcast.osgi.register.disabled</code>.</p>
</div>
<div class="paragraph">
<p>Each Hazelcast bundle provides a different OSGI service.
Their instances can be grouped (clustered) together to prevent possible compatibility issues between
different Hazelcast versions/bundles. This grouping behavior is enabled by default and
you disable it using the property <code>hazelcast.osgi.grouping.disabled</code>.</p>
</div>
<div class="paragraph">
<p>Hazelcast OSGI service&#8217;s lifecycle (and the owned/created instances&#8217;s lifecycles) is the same with
the owner Hazelcast bundles. When the bundle is stopped (deactivated), the owned service and
Hazelcast instances are also deactivated/shutdown and deregistered automatically.
When the bundle is re-activated, its service is registered again.</p>
</div>
<div class="paragraph">
<p>The Hazelcast IMDG Enterprise JAR package is also an OSGI bundle like the Hazelcast Open Source JAR package.</p>
</div>
</div>
<div class="sect2">
<h3 id="_api"><a class="anchor" href="#_api"></a>24.2. API</h3>
<div class="paragraph">
<p><strong><code>HazelcastOSGiService</code>:</strong> Contract point for Hazelcast services on top of OSGI.
Registered to <code>org.osgi.framework.BundleContext</code> as the OSGI service so the other bundles can
access and use Hazelcast on the OSGI environment through this service.</p>
</div>
<div class="paragraph">
<p><strong><code>HazelcastOSGiInstance</code>:</strong> Contract point for <code>HazelcastInstance</code> implementations based on OSGI service.
<code>HazelcastOSGiService</code> provides proxy Hazelcast instances typed <code>HazelcastOSGiInstance</code> which is
a subtype of <code>HazelcastInstance</code> and these instances delegate all calls to the underlying <code>HazelcastInstance</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_hazelcast_osgi_support"><a class="anchor" href="#_configuring_hazelcast_osgi_support"></a>24.3. Configuring Hazelcast OSGI Support</h3>
<div class="paragraph">
<p><code>HazelcastOSGiService</code> uses the following configurations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><code>hazelcast.osgi.start</code>:</strong> If this property is enabled (it is disabled by default), when an
<code>HazelcastOSGiService</code> is activated, a default Hazelcast instance is created automatically.</p>
</li>
<li>
<p><strong><code>hazelcast.osgi.register.disabled</code>:</strong> If this property is disabled
(it is disabled by default), when a Hazelcast instance is created by
<code>HazelcastOSGiService</code>, the created <code>HazelcastOSGiInstance</code> is registered automatically as
OSGI service with type of <code>HazelcastOSGiInstance</code> and it is deregistered automatically when
the created <code>HazelcastOSGiInstance</code> is shutdown.</p>
</li>
<li>
<p><strong><code>hazelcast.osgi.grouping.disabled</code>:</strong> If this property is disabled
(it is disabled by default), every created <code>HazelcastOSGiInstance</code> is grouped as
their owner <code>HazelcastOSGiService</code> and do not join each other unless no cluster name is specified in the <code>Config</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_design"><a class="anchor" href="#_design"></a>24.4. Design</h3>
<div class="paragraph">
<p><code>HazelcastOSGiService</code> is specific to each Hazelcast bundle. This means that
every Hazelcast bundle has its own <code>HazelcastOSGiService</code> instance.</p>
</div>
<div class="paragraph">
<p>Every Hazelcast bundle registers its <code>HazelcastOSGiService</code> instances via
Hazelcast Bundle Activator (<code>com.hazelcast.osgi.impl.Activator</code>) while they are being started,
and it deregisters its <code>HazelcastOSGiService</code> instances while they are being stopped.</p>
</div>
<div class="paragraph">
<p>Each <code>HazelcastOSGiService</code> instance has a different service ID as the combination of
Hazelcast version and artifact type (<code>OSS</code> or <code>EE</code>). Examples are <code>3.6#OSS</code>, <code>3.6#EE</code>, <code>3.7#OSS</code>, <code>3.7#EE</code>, etc.</p>
</div>
<div class="paragraph">
<p><code>HazelcastOSGiService</code> instance lifecycle is the same with the owner Hazelcast bundle.
This means that when the owner bundle is deactivated, the owned <code>HazelcastOSGiService</code> instance is
deactivated, and all active Hazelcast instances that are created and served by
that <code>HazelcastOSGiService</code> instance are also shutdown and deregistered.
When the Hazelcast bundle is re-activated, its <code>HazelcastOSGiService</code> instance is registered again as the OSGI service.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/Design.png" alt="OSGI Design">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_hazelcast_osgi_service"><a class="anchor" href="#_using_hazelcast_osgi_service"></a>24.5. Using Hazelcast OSGI Service</h3>
<div class="sect3">
<h4 id="_getting_hazelcast_osgi_service_instances"><a class="anchor" href="#_getting_hazelcast_osgi_service_instances"></a>24.5.1. Getting Hazelcast OSGI Service Instances</h4>
<div class="paragraph">
<p>You can access all <code>HazelcastOSGiService</code> instances through <code>org.osgi.framework.BundleContext</code> for each Hazelcast bundle as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">for (ServiceReference serviceRef : context.getServiceReferences(HazelcastOSGiService.class.getName(), null)) {
    HazelcastOSGiService service = (HazelcastOSGiService) context.getService(serviceRef);
    String serviceId = service.getId();
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_managing_and_using_hazelcast_instances"><a class="anchor" href="#_managing_and_using_hazelcast_instances"></a>24.5.2. Managing and Using Hazelcast instances</h4>
<div class="paragraph">
<p>You can use <code>HazelcastOSGiService</code> instance to create and shutdown Hazelcast instances on OSGI environments.
The created Hazelcast instances are <code>HazelcastOSGiInstance</code> typed (which is sub-type of <code>HazelcastInstance</code>) and
are just proxies to the underlying Hazelcast instance. There are several methods in <code>HazelcastOSGiService</code> to use
Hazelcast instances on OSGI environments as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Get the default Hazelcast instance owned by `hazelcastOsgiService`
// Returns null if `HAZELCAST_OSGI_START` is not enabled
HazelcastOSGiInstance defaultInstance = hazelcastOsgiService.getDefaultHazelcastInstance();


// Creates a new Hazelcast instance with default configurations as owned by `hazelcastOsgiService`
HazelcastOSGiInstance newInstance1 = hazelcastOsgiService.newHazelcastInstance();


// Creates a new Hazelcast instance with specified configuration as owned by `hazelcastOsgiService`
Config config = new Config();
config.setInstanceName("OSGI-Instance");
...
HazelcastOSGiInstance newInstance2 = hazelcastOsgiService.newHazelcastInstance(config);

// Gets the Hazelcast instance with the name `OSGI-Instance`, which is `newInstance2` created above
HazelcastOSGiInstance instance = hazelcastOsgiService.getHazelcastInstanceByName("OSGI-Instance");

// Shuts down the Hazelcast instance with name `OSGI-Instance`, which is `newInstance2`
hazelcastOsgiService.shutdownHazelcastInstance(instance);

// Print all active Hazelcast instances owned by `hazelcastOsgiService`
for (HazelcastOSGiInstance instance : hazelcastOsgiService.getAllHazelcastInstances()) {
    System.out.println(instance);
}

// Shuts down all Hazelcast instances owned by `hazelcastOsgiService`
hazelcastOsgiService.shutdownAll();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extending_hazelcast"><a class="anchor" href="#_extending_hazelcast"></a>25. Extending Hazelcast</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes the different possibilities to extend Hazelcast with
additional services or features.</p>
</div>
<div class="sect2">
<h3 id="_operationparker"><a class="anchor" href="#_operationparker"></a>25.1. OperationParker</h3>
<div class="paragraph">
<p><code>OperationParker</code> is an interface offered by SPI for the objects, such as
Lock and Semaphore, to be used when a thread needs to wait for a lock to be released.</p>
</div>
<div class="paragraph">
<p><code>OperationParker</code> keeps a list of waiters. For each notify operation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it looks for a waiter</p>
</li>
<li>
<p>it asks the waiter whether it wants to keep waiting</p>
</li>
<li>
<p>if the waiter responds <strong>no</strong>, the service executes its registered operation (operation itself knows where to send a response)</p>
</li>
<li>
<p>it rinses and repeats until a waiter wants to keep waiting.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each waiter can sit on a wait-notify queue for, at most, its operation&#8217;s call timeout.
For example, by default, each waiter can wait here for at most 1 minute.
A continuous task scans expired/timed-out waiters and invalidates them with <code>CallTimeoutException</code>.
Each waiter on the remote side should retry and keep waiting if it still wants to wait.
This is a liveness check for remote waiters.</p>
</div>
<div class="paragraph">
<p>This way, it is possible to distinguish an unresponsive member and a long (~infinite) wait.
On the caller side, if the waiting thread does not get a response for either
a call timeout or for more than <strong>2 times the call-timeout</strong>, it will exit with
<code>OperationTimeoutException</code>.</p>
</div>
<div class="paragraph">
<p>Note that this behavior breaks the fairness. Hazelcast does not support
fairness for any of the data structures with blocking operations, such as Lock and Semaphore.</p>
</div>
</div>
<div class="sect2">
<h3 id="_discovery_spi"><a class="anchor" href="#_discovery_spi"></a>25.2. Discovery SPI</h3>
<div class="paragraph">
<p>By default, Hazelcast is bundled with multiple ways to define and find other members in the same network.
Commonly used, especially with development, is the Multicast discovery.
This sends out a multicast request to a network segment and awaits other members to
answer with their IP addresses. In addition, Hazelcast supports a number of built-in discovery strategies described in
the <a href="#discovery-mechanisms">Discovery Mechanisms</a> section.</p>
</div>
<div class="paragraph">
<p>Since there is an ever growing number of public and private cloud environments,
as well as numerous Service Discovery systems in the wild,
Hazelcast provides cloud or service discovery vendors with the option to
implement their own discovery strategy.</p>
</div>
<div class="paragraph">
<p>Over the course of this section, we will build a simple
discovery strategy based on the <code>/etc/hosts</code> file.</p>
</div>
<div class="sect3">
<h4 id="_discovery_spi_interfaces_and_classes"><a class="anchor" href="#_discovery_spi_interfaces_and_classes"></a>25.2.1. Discovery SPI Interfaces and Classes</h4>
<div class="paragraph">
<p>The Hazelcast Discovery SPI (Member Discovery Extensions) consists of
multiple interfaces and abstract classes. In the following subsections,
we will have a quick look at all of them and shortly introduce the idea and usage behind them.
The example will follow in the next section, <a href="#discovery-strategy">Discovery Strategy</a>.</p>
</div>
<div class="sect4">
<h5 id="_discoverystrategy_implement"><a class="anchor" href="#_discoverystrategy_implement"></a>DiscoveryStrategy: Implement</h5>
<div class="paragraph">
<p>The <code>com.hazelcast.spi.discovery.DiscoveryStrategy</code> interface is
the main entry point for vendors to implement their corresponding member discovery strategies.
Its main purpose is to return discovered members on request.
The <code>com.hazelcast.spi.discovery.DiscoveryStrategy</code> interface also offers
light lifecycle capabilities for setup and teardown logic (for example, opening or closing sockets or REST API clients).</p>
</div>
<div class="paragraph">
<p><code>DiscoveryStrategy</code>s can also do automatic registration / de-registration on
service discovery systems if necessary.
You can use the provided <code>DiscoveryNode</code> that is passed to
the factory method to retrieve local addresses and ports, as well as metadata.</p>
</div>
</div>
<div class="sect4">
<h5 id="_abstractdiscoverystrategy_abstract_class"><a class="anchor" href="#_abstractdiscoverystrategy_abstract_class"></a>AbstractDiscoveryStrategy: Abstract Class</h5>
<div class="paragraph">
<p>The <code>com.hazelcast.spi.discovery.AbstractDiscoveryStrategy</code> is a convenience abstract class meant to
ease the implementation of strategies. It basically provides additional support for
reading / resolving configuration properties and empty implementations of lifecycle methods if unnecessary.</p>
</div>
</div>
<div class="sect4">
<h5 id="_discoverystrategyfactory_factory_contract"><a class="anchor" href="#_discoverystrategyfactory_factory_contract"></a>DiscoveryStrategyFactory: Factory Contract</h5>
<div class="paragraph">
<p>The <code>com.hazelcast.spi.discovery.DiscoveryStrategyFactory</code> interface describes
the factory contract that creates a certain <code>DiscoveryStrategy</code>.
<code>DiscoveryStrategyFactory</code> s are registered automatically at startup of
a Hazelcast member or client whenever they are found in the classpath.
For automatic discovery, factories need to announce themselves as
SPI services using a resource file according to the
<a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html" target="_blank" rel="noopener">Java Service Provider Interface</a>.
The service registration file must be part of the JAR file, located under
<code>META-INF/services/com.hazelcast.spi.discovery.DiscoveryStrategyFactory</code>, and consist of
a line with the full canonical class name of the <code>DiscoveryStrategy</code> per provided strategy implementation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_discoverynode_describe_a_member"><a class="anchor" href="#_discoverynode_describe_a_member"></a>DiscoveryNode: Describe a Member</h5>
<div class="paragraph">
<p>The <code>com.hazelcast.spi.discovery.DiscoveryNode</code> abstract class describes a member in the Discovery SPI.
It is used for multiple purposes, since it will be returned from strategies for discovered members.
It is also passed to <code>DiscoveryStrategyFactory</code>s factory method to define
the local member itself if created on a Hazelcast member; on Hazelcast clients, null is passed.</p>
</div>
</div>
<div class="sect4">
<h5 id="_simplediscoverynode_default_discoverynode"><a class="anchor" href="#_simplediscoverynode_default_discoverynode"></a>SimpleDiscoveryNode: Default DiscoveryNode</h5>
<div class="paragraph">
<p><code>com.hazelcast.spi.discovery.SimpleDiscoveryNode</code> is a default implementation of the <code>DiscoveryNode</code>.
It is meant for convenience use of the Discovery SPI and can be returned from
vendor implementations if no special needs are required.</p>
</div>
</div>
<div class="sect4">
<h5 id="_nodefilter_filter_members"><a class="anchor" href="#_nodefilter_filter_members"></a>NodeFilter: Filter Members</h5>
<div class="paragraph">
<p>You can configure <code>com.hazelcast.spi.discovery.NodeFilter</code> before startup and
you can implement logic to do additional filtering of members.
This might be necessary if query languages for discovery strategies are not
expressive enough to describe members or to overcome inefficiencies of strategy implementations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>DiscoveryStrategy</code> vendor does not need to take possibly configured filters into account
as their use is transparent to the strategies.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_discoveryservice_support_in_integrator_systems"><a class="anchor" href="#_discoveryservice_support_in_integrator_systems"></a>DiscoveryService: Support In Integrator Systems</h5>
<div class="paragraph">
<p>A <code>com.hazelcast.spi.discovery.integration.DiscoveryService</code> is part of the integration domain.
<code>DiscoveryStrategy</code> vendors do not need to implement <code>DiscoveryService</code> because
it is meant to support the Discovery SPI in situations where vendors integrate Hazelcast into
their own systems or frameworks. Certain needs might be necessary as part of the classloading or
<a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html" target="_blank" rel="noopener">Java Service Provider Interface</a> lookup.</p>
</div>
</div>
<div class="sect4">
<h5 id="_discoveryserviceprovider_provide_a_discoveryservice"><a class="anchor" href="#_discoveryserviceprovider_provide_a_discoveryservice"></a>DiscoveryServiceProvider: Provide a DiscoveryService</h5>
<div class="paragraph">
<p>Use the <code>com.hazelcast.spi.discovery.integration.DiscoveryServiceProvider</code> to provide
a <code>DiscoveryService</code> to the Hazelcast discovery subsystem. Configure the provider with the Hazelcast configuration API.</p>
</div>
</div>
<div class="sect4">
<h5 id="_discoveryservicesettings_configure_discoveryservice"><a class="anchor" href="#_discoveryservicesettings_configure_discoveryservice"></a>DiscoveryServiceSettings: Configure DiscoveryService</h5>
<div class="paragraph">
<p>A <code>com.hazelcast.spi.discovery.integration.DiscoveryServiceSettings</code> instance is passed to
the <code>DiscoveryServiceProvider</code> at creation time to configure the <code>DiscoveryService</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_discoverymode_member_or_client"><a class="anchor" href="#_discoverymode_member_or_client"></a>DiscoveryMode: Member or Client</h5>
<div class="paragraph">
<p>The <code>com.hazelcast.spi.discovery.integration.DiscoveryMode</code> enum tells if
a created <code>DiscoveryService</code> is running on a Hazelcast member or client to change the behavior accordingly.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_discovery_strategy"><a class="anchor" href="#_discovery_strategy"></a>25.2.2. Discovery Strategy</h4>
<div class="paragraph">
<p>This subsection walks through the implementation of a simple <code>DiscoveryStrategy</code> and its necessary setup.</p>
</div>
<div class="sect4">
<h5 id="_discovery_strategy_example"><a class="anchor" href="#_discovery_strategy_example"></a>Discovery Strategy Example</h5>
<div class="paragraph">
<p>The example strategy uses the local <code>/etc/hosts</code> (and on Windows it uses
the equivalent to the <code>*nix</code> hosts file named <code>%SystemRoot%\system32\drivers\etc\hosts</code>) to
lookup IP addresses of different hosts. The strategy implementation expects hosts to be configured with
hostname sub-groups under the same domain. So far to theory, let&#8217;s get into it.</p>
</div>
<div class="paragraph">
<p>The full example&#8217;s source code can be found <a href="https://github.com/hazelcast/hazelcast-code-samples" target="_blank" rel="noopener">here</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_site_domain"><a class="anchor" href="#_configuring_site_domain"></a>Configuring Site Domain</h5>
<div class="paragraph">
<p>As a first step we do some basic configuration setup. We want the user to be able to
configure the site domain for the discovery inside the hosts file, therefore we define
a configuration property called <code>site-domain</code>. The configuration is not optional:
you need to configure it before the creation of the <code>HazelcastInstance</code>, either
via Hazelcast&#8217;s declarative or programmatic configuration.</p>
</div>
<div class="paragraph">
<p>It is recommended that you keep all defined properties in a separate configuration class as
public constants (<code>public static final</code>) with sufficient documentation.
This allows users to easily look up possible configuration values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class HostsDiscoveryConfiguration {

    public static final PropertyDefinition DOMAIN = new SimplePropertyDefinition("site-domain", PropertyTypeConverter.STRING);

    private HostsDiscoveryConfiguration() {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An additional <code>ValueValidator</code> could be passed to the definition to make sure
the configured value looks like a domain or has a special format.</p>
</div>
</div>
<div class="sect4">
<h5 id="_creating_discovery"><a class="anchor" href="#_creating_discovery"></a>Creating Discovery</h5>
<div class="paragraph">
<p>As the second step we create the very simple <code>DiscoveryStrategyFactory</code> implementation class.
To keep things clear we are going to name the discovery strategy after its purpose:
looking into the hosts file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HostsDiscoveryStrategyFactory implements DiscoveryStrategyFactory {

    private static final Collection&lt;PropertyDefinition&gt; PROPERTIES = singletonList(HostsDiscoveryConfiguration.DOMAIN);

    @Override
    public Class&lt;? extends DiscoveryStrategy&gt; getDiscoveryStrategyType() {
        return HostsDiscoveryStrategy.class;
    }

    @Override
    public DiscoveryStrategy newDiscoveryStrategy(DiscoveryNode discoveryNode, ILogger logger, Map&lt;String, Comparable&gt; properties) {
        return new HostsDiscoveryStrategy(logger, properties);
    }

    @Override
    public Collection&lt;PropertyDefinition&gt; getConfigurationProperties() {
        return PROPERTIES;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This factory now defines properties known to the discovery strategy implementation and
provides a clean way to instantiate it. While creating the <code>HostsDiscoveryStrategy</code> we ignore
the passed <code>DiscoveryNode</code> since this strategy does not support automatic registration of new members.
In cases where the strategy does not support registration, the environment has to handle this in some provided way.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that, when created on a Hazelcast client, the provided <code>DiscoveryNode</code> is null, as there is no
local member in existence.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, we register the <code>DiscoveryStrategyFactory</code> to make Hazelcast pick it up automatically at startup.
As described earlier, this is done according to the
<a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html" target="_blank" rel="noopener">Java Service Provider Interface</a> specification.
The filename is the name of the interface itself. Therefore we create a new resource file called
<code>com.hazelcast.spi.discovery.DiscoveryStrategyFactory</code> and place it under <code>META-INF/services</code>.
The content is the full canonical class name of our factory implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>com.hazelcast.examples.spi.discovery.HostsDiscoveryStrategyFactory</code></pre>
</div>
</div>
<div class="paragraph">
<p>If our JAR file contains multiple factories, each consecutive line can define another
full canonical <code>DiscoveryStrategyFactory</code> implementation class name.</p>
</div>
</div>
<div class="sect4">
<h5 id="_implementing_discovery_strategy"><a class="anchor" href="#_implementing_discovery_strategy"></a>Implementing Discovery Strategy</h5>
<div class="paragraph">
<p>Now comes the interesting part. We are going to implement the discovery itself.
The previous parts we did are normally pretty similar for all strategies aside from the configuration properties itself.
However, implementing the discovery heavily depends on the way the strategy has to come up with
IP addresses of other Hazelcast members.</p>
</div>
</div>
<div class="sect4">
<h5 id="_extending_the_abstractdiscoverystrategy"><a class="anchor" href="#_extending_the_abstractdiscoverystrategy"></a>Extending The <code>AbstractDiscoveryStrategy</code></h5>
<div class="paragraph">
<p>For ease of implementation, we back our implementation by extending the <code>AbstractDiscoveryStrategy</code> and
only implementing the absolute minimum ourselves.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HostsDiscoveryStrategy extends AbstractDiscoveryStrategy {

    private static final String HOSTS_NIX = "/etc/hosts";
    private static final String HOSTS_WINDOWS = "%SystemRoot%\\system32\\drivers\\etc\\hosts";

    private final String siteDomain;

    HostsDiscoveryStrategy(ILogger logger, Map&lt;String, Comparable&gt; properties) {
        super(logger, properties);

        this.siteDomain = getOrNull("discovery.hosts", HostsDiscoveryConfiguration.DOMAIN);
    }

    @Override
    public Iterable&lt;DiscoveryNode&gt; discoverNodes() {
        List&lt;String&gt; assignments = filterHosts();
        return mapToDiscoveryNodes(assignments);
    }

    private List&lt;String&gt; filterHosts() {
        String os = System.getProperty("os.name");

        String hostsPath;
        if (os.contains("Windows")) {
            hostsPath = HOSTS_WINDOWS;
        } else {
            hostsPath = HOSTS_NIX;
        }

        File hosts = new File(hostsPath);


        List&lt;String&gt; lines = readLines(hosts);

        List&lt;String&gt; assignments = new ArrayList&lt;String&gt;();
        for (String line : lines) {

            if (matchesDomain(line)) {
                assignments.add(line);
            }
        }
        return assignments;
    }

    private Iterable&lt;DiscoveryNode&gt; mapToDiscoveryNodes(List&lt;String&gt; assignments) {
        Collection&lt;DiscoveryNode&gt; discoveredNodes = new ArrayList&lt;DiscoveryNode&gt;();

        for (String assignment : assignments) {
            String address = sliceAddress(assignment);
            String hostname = sliceHostname(assignment);

            Map&lt;String, String&gt; attributes = Collections.singletonMap("hostname", hostname);

            InetAddress inetAddress = mapToInetAddress(address);
            Address addr = new Address(inetAddress, NetworkConfig.DEFAULT_PORT);

            discoveredNodes.add(new SimpleDiscoveryNode(addr, attributes));
        }
        return discoveredNodes;
    }

    private List&lt;String&gt; readLines(File hosts) {
        try {
            List&lt;String&gt; lines = new ArrayList&lt;String&gt;();
            BufferedReader reader = new BufferedReader(new FileReader(hosts));

            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.startsWith("#")) {
                    lines.add(line.trim());
                }
            }

            return lines;
        } catch (IOException e) {
            throw new RuntimeException("Could not read hosts file", e);
        }
    }

    private boolean matchesDomain(String line) {
        if (line.isEmpty()) {
            return false;
        }
        String hostname = sliceHostname(line);
        return hostname.endsWith("." + siteDomain);
    }

    private String sliceAddress(String assignment) {
        String[] tokens = assignment.split("\\p{javaSpaceChar}+");
        if (tokens.length &lt; 1) {
            throw new RuntimeException("Could not find ip address in " + assignment);
        }
        return tokens[0];
    }

    private static String sliceHostname(String assignment) {
        String[] tokens = assignment.split("(\\p{javaSpaceChar}+|\t+)+");
        if (tokens.length &lt; 2) {
            throw new RuntimeException("Could not find hostname in " + assignment);
        }
        return tokens[1];
    }

    private InetAddress mapToInetAddress(String address) {
        try {
            return InetAddress.getByName(address);
        } catch (UnknownHostException e) {
            throw new RuntimeException("Could not resolve ip address", e);
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_overriding_discovery_configuration"><a class="anchor" href="#_overriding_discovery_configuration"></a>Overriding Discovery Configuration</h5>
<div class="paragraph">
<p>So far our implementation retrieves the configuration property for the <code>site-domain</code>.
Our implementation offers the option to override the value from the configuration
(declarative or programmatic) right from the system environment or JVM properties.
That can be useful when the <code>hazelcast.xml</code> defines a setup for an developer system (like <code>cluster.local</code>) and
operations wants to override it for the real deployment.
By providing a prefix (in this case <code>discovery.hosts</code>) we created an
external property named <code>discovery.hosts.site-domain</code> which can be set as an
environment variable or passed as a JVM property from the startup script.</p>
</div>
<div class="paragraph">
<p>The lookup priority is explained in the following list, priority is from top to bottom:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JVM properties (or under the <code>properties</code> element in <code>hazelcast.xml</code>)</p>
</li>
<li>
<p>System environment</p>
</li>
<li>
<p>Configuration properties</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_implementing_lookup"><a class="anchor" href="#_implementing_lookup"></a>Implementing Lookup</h5>
<div class="paragraph">
<p>Since we have the value for our property now, we can implement the actual lookup and
mapping as already prepared in the <code>discoverNodes</code> method.
The following part is very specific to this special discovery strategy;
for completeness we are showing it anyways.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private static final String HOSTS_NIX = "/etc/hosts";
private static final String HOSTS_WINDOWS =
                   "%SystemRoot%\\system32\\drivers\\etc\\hosts";

private List&lt;String&gt; filterHosts() {
    String os = System.getProperty( "os.name" );

    String hostsPath;
    if ( os.contains( "Windows" ) ) {
        hostsPath = HOSTS_WINDOWS;
    } else {
    hostsPath = HOSTS_NIX;
    }

    File hosts = new File( hostsPath );

    // Read all lines
    List&lt;String&gt; lines = readLines( hosts );

    List&lt;String&gt; assignments = new ArrayList&lt;String&gt;();
    for ( String line : lines ) {
        // Example:
        // 192.168.0.1   host1.cluster.local
        if ( matchesDomain( line ) ) {
            assignments.add( line );
        }
    }
    return assignments;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_mapping_to_discoverynode"><a class="anchor" href="#_mapping_to_discoverynode"></a>Mapping to DiscoveryNode</h5>
<div class="paragraph">
<p>After we have collected the address assignments configured in the hosts file,
we can go to the final step and map those to the <code>DiscoveryNode</code>s to return
them from our strategy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Iterable&lt;DiscoveryNode&gt; mapToDiscoveryNodes( List&lt;String&gt; assignments ) {
  Collection&lt;DiscoveryNode&gt; discoveredNodes = new ArrayList&lt;DiscoveryNode&gt;();

    for ( String assignment : assignments ) {
        String address = sliceAddress( assignment );
        String hostname = sliceHostname( assignment );

        Map&lt;String, Object&gt; attributes =
          Collections.singletonMap( "hostname", hostname );

        InetAddress inetAddress = mapToInetAddress( address );
        Address addr = new Address( inetAddress, NetworkConfig.DEFAULT_PORT );

        discoveredNodes.add( new SimpleDiscoveryNode( addr, attributes ) );
    }
    return discoveredNodes;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With that mapping, we now have a full discovery, executed whenever Hazelcast asks for IPs.
So why don&#8217;t we read them in once and cache them?
The answer is simple: it might happen that members go down or come up over time.
Since we expect the hosts file to be injected into the running container,
it also might change over time. We want to get the latest available
members, therefore we read the file on request.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_discoverystrategy"><a class="anchor" href="#_configuring_discoverystrategy"></a>Configuring DiscoveryStrategy</h5>
<div class="paragraph">
<p>To actually use the new <code>DiscoveryStrategy</code> implementation we need to
configure it like in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;!-- activate Discovery SPI --&gt;
    &lt;properties&gt;
        &lt;property name="hazelcast.discovery.enabled"&gt;true&lt;/property&gt;
    &lt;/properties&gt;
    &lt;network&gt;
        &lt;join&gt;
            &lt;!-- activate our discovery strategy --&gt;
            &lt;discovery-strategies&gt;

                &lt;!-- class equals to the DiscoveryStrategy not the factory! --&gt;
                &lt;discovery-strategy enabled="true"
                    class="com.hazelcast.examples.spi.discovery.HostsDiscoveryStrategy"&gt;
                    &lt;properties&gt;
                        &lt;property name="site-domain"&gt;cluster.local&lt;/property&gt;
                    &lt;/properties&gt;
                &lt;/discovery-strategy&gt;
            &lt;/discovery-strategies&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.discovery.enabled: true
  network:
    join:
      discovery-strategies:
        discovery-strategy:
          - class: com.hazelcast.examples.spi.discovery.HostsDiscoveryStrategy
            enabled: true
            properties:
              site-domain: cluster.local</code></pre>
</div>
</div>
<div class="paragraph">
<p>To find out further details, please have a look at the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/spi/discovery/package-summary.html">Discovery SPI Javadoc</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_discoveryservice_framework_integration"><a class="anchor" href="#_discoveryservice_framework_integration"></a>25.2.3. DiscoveryService (Framework integration)</h4>
<div class="paragraph">
<p>Since the <code>DiscoveryStrategy</code> is meant for cloud vendors or implementors
of service discovery systems, the <code>DiscoveryService</code> is meant for integrators.
In this case, integrators mean people integrating Hazelcast into their own systems or frameworks.
In those situations, there may be special requirements on
how to lookup framework services like the discovery strategies or similar services.
Integrators can extend or implement their own <code>DiscoveryService</code> and
<code>DiscoveryServiceProvider</code> and inject them using the
<code>com.hazelcast.config.DiscoveryConfig</code> configuration API prior to instantiating the <code>HazelcastInstance</code>.
In any case, integrators might have to remember that a <code>DiscoveryService</code> might have to change
behavior based on the runtime environment (Hazelcast member or client) and
then the <code>DiscoveryServiceSettings</code> should provide information about the started <code>HazelcastInstance</code>.</p>
</div>
<div class="paragraph">
<p>Since the implementation heavily depends on one&#8217;s needs,
there is no reason to provide an example of how to implement your own <code>DiscoveryService</code>.
However, Hazelcast provides a default implementation which can be a good example to get started.
This default implementation is <code>com.hazelcast.spi.discovery.impl.DefaultDiscoveryService</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_config_properties_spi"><a class="anchor" href="#_config_properties_spi"></a>25.3. Config Properties SPI</h3>
<div class="paragraph">
<p>The Config Properties SPI is an easy way that you can configure
SPI plugins using a prebuilt system of automatic conversion and validation.</p>
</div>
<div class="sect3">
<h4 id="_config_properties_spi_classes"><a class="anchor" href="#_config_properties_spi_classes"></a>25.3.1. Config Properties SPI Classes</h4>
<div class="paragraph">
<p>The Config Properties SPI consists of a small set of classes and provided implementations.</p>
</div>
<div class="sect4">
<h5 id="_propertydefinition_define_a_single_property"><a class="anchor" href="#_propertydefinition_define_a_single_property"></a>PropertyDefinition: Define a Single Property</h5>
<div class="paragraph">
<p>The <code>com.hazelcast.config.properties.PropertyDefinition</code> interface defines
a single property inside a given configuration.
It consists of a key string and type (in form of a <code>com.hazelcast.core.TypeConverter</code>).</p>
</div>
<div class="paragraph">
<p>You can mark properties as optional and you can have an additional validation step to make sure
the provided value matches certain rules (like port numbers must be between 0-65535 or similar).</p>
</div>
</div>
<div class="sect4">
<h5 id="_simplepropertydefinition_basic_propertydefinition"><a class="anchor" href="#_simplepropertydefinition_basic_propertydefinition"></a>SimplePropertyDefinition: Basic PropertyDefinition</h5>
<div class="paragraph">
<p>For convenience, the <code>com.hazelcast.config.properties.SimplePropertyDefinition</code> class is provided.
This class is a basic implementation of the <code>PropertyDefinition</code> interface and should be enough for most situations.
In case of additional needs, you are free to provide your own implementation of the <code>PropertyDefinition</code> interface.</p>
</div>
</div>
<div class="sect4">
<h5 id="_propertytypeconverter_set_of_typeconverters"><a class="anchor" href="#_propertytypeconverter_set_of_typeconverters"></a>PropertyTypeConverter: Set of TypeConverters</h5>
<div class="paragraph">
<p>The <code>com.hazelcast.config.properties.PropertyTypeConverter</code> enum provides a preset of <code>TypeConverter</code>s as listed below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>String</p>
</li>
<li>
<p>Short</p>
</li>
<li>
<p>Integer</p>
</li>
<li>
<p>Long</p>
</li>
<li>
<p>Float</p>
</li>
<li>
<p>Double</p>
</li>
<li>
<p>Boolean</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_valuevalidator_and_validationexception"><a class="anchor" href="#_valuevalidator_and_validationexception"></a>ValueValidator and ValidationException</h5>
<div class="paragraph">
<p>The <code>com.hazelcast.config.properties.ValueValidator</code> interface implements additional value validation.
The configured value will be validated before it is returned to the requester.
If validation fails, a <code>com.hazelcast.config.properties.ValidationException</code> is thrown and
the requester has to handle it or throw the exception further.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_config_properties_spi_example"><a class="anchor" href="#_config_properties_spi_example"></a>25.3.2. Config Properties SPI Example</h4>
<div class="paragraph">
<p>This sub-section shows a quick example of how to setup, configure and use the Config Properties SPI.</p>
</div>
<div class="sect4">
<h5 id="_defining_a_config_propertydefinition"><a class="anchor" href="#_defining_a_config_propertydefinition"></a>Defining a Config PropertyDefinition</h5>
<div class="paragraph">
<p>Defining a property is as easy as giving it a name and a type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PropertyDefinition property = new SimplePropertyDefinition(
    "my-key", PropertyTypeConverter.STRING
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>We defined a property named <code>my-key</code> with a type of a string.
If none of the predefined <code>TypeConverter</code>s matches the need, users are free to provide their own implementation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_providing_a_value_in_xml"><a class="anchor" href="#_providing_a_value_in_xml"></a>Providing a value in XML</h5>
<div class="paragraph">
<p>The above property is now configurable in two ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- option 1 --&gt;
&lt;my-key&gt;value&lt;/my-key&gt;

&lt;!-- option 2 --&gt;
&lt;property name="my-key"&gt;value&lt;/property&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In any case, both options are useable interchangeably,
however the later version is recommended by Hazelcast for schema applicability.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_retrieving_a_propertydefinition_value"><a class="anchor" href="#_retrieving_a_propertydefinition_value"></a>Retrieving a PropertyDefinition Value</h5>
<div class="paragraph">
<p>To eventually retrieve a value, use the <code>PropertyDefinition</code> to get and convert the value automatically.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public &lt;T&gt; T getConfig( PropertyDefinition property,
                        Map&lt;String, Comparable&gt; properties ) {

  Map&lt;String, Comparable&gt; properties = ...;
  TypeConverter typeConverter = property.typeConverter();

  Comparable value = properties.get( property.key() );
  return typeConverter.convert( value );
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hazelcast-plugins"><a class="anchor" href="#hazelcast-plugins"></a>26. Hazelcast Plugins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes the plugins using which you can extend Hazelcast IMDG&#8217;s functionalities.</p>
</div>
<div class="sect2">
<h3 id="hazelcast-cloud-discovery-plugins"><a class="anchor" href="#hazelcast-cloud-discovery-plugins"></a>26.1. Cloud Discovery Plugins</h3>
<div class="paragraph">
<p>Hazelcast provides the following plugins that allow Hazelcast cluster members to discover each other on the cloud platforms.
They are mainly used for the following reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>provide dynamic member discovery when you do not want to or you cannot provide a list of static IP
addresses (for member-member discovery, client-member discovery, or WAN replication)</p>
</li>
<li>
<p>enable resilience to availability zone failures (ZONE_AWARE feature)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="hazelcast-cloud-discovery-plugins-aws"><a class="anchor" href="#hazelcast-cloud-discovery-plugins-aws"></a>26.1.1. Hazelcast AWS</h4>
<div class="paragraph">
<p>Hazelcast provides support for <a href="https://aws.amazon.com/">Amazon Web Services</a>, covering the following environments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Amazon EC2 discovery with <a href="https://github.com/hazelcast/hazelcast-aws" target="_blank" rel="noopener">Hazelcast AWS Discovery plugin</a></p>
</li>
<li>
<p>Amazon ECS/EC2 discovery with <a href="https://github.com/hazelcast/hazelcast-aws" target="_blank" rel="noopener">Hazelcast AWS Discovery plugin</a></p>
</li>
<li>
<p>Amazon ECS/Fargate with <a href="https://github.com/hazelcast/hazelcast-aws" target="_blank" rel="noopener">Hazelcast AWS Discovery plugin</a></p>
</li>
<li>
<p>Amazon EKS/Fargate with <a href="https://github.com/hazelcast/hazelcast-kubernetes" target="_blank" rel="noopener">Hazelcast Kubernetes Discovery plugin</a></p>
</li>
<li>
<p>Amazon EKS/EC2 with <a href="https://github.com/hazelcast/hazelcast-kubernetes" target="_blank" rel="noopener">Hazelcast Kubernetes Discovery plugin</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In all scenarios you can use the <code>ZONE_AWARE</code> feature to create partition backups in other Availability Zones (AZ)
and therefore prevent any data loss in case of AZ failures.</p>
</div>
<div class="paragraph">
<p>You can easily configure your Hazelcast member/client to use EC2/ECS discovery by having the <code>hazelcast-all</code>
(or <code>hazelcast-aws</code>) JAR on your classpath and enabling AWS in your Hazelcast configuration.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/hazelcast-aws" target="_blank" rel="noopener">Hazelcast AWS Plugin documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="hazelcast-cloud-discovery-plugins-azure"><a class="anchor" href="#hazelcast-cloud-discovery-plugins-azure"></a>26.1.2. Hazelcast Azure</h4>
<div class="paragraph">
<p>Hazelcast provides support for <a href="https://azure.microsoft.com/en-us/" target="_blank" rel="noopener">Microsoft Azure</a>,
covering the following environments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Azure Virtual Machines with <a href="https://github.com/hazelcast/hazelcast-azure" target="_blank" rel="noopener">Hazelcast Azure Discovery plugin</a></p>
</li>
<li>
<p>Azure Kubernetes Service (AKS) with <a href="https://github.com/hazelcast/hazelcast-kubernetes" target="_blank" rel="noopener">Hazelcast Kubernetes Discovery plugin</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In both scenarios you can use the <code>ZONE_AWARE</code> feature to create partition backups in other Availability Zones (AZ)
and therefore prevent any data loss in case of AZ failures.</p>
</div>
<div class="paragraph">
<p>You can easily configure your Hazelcast member/client to use Azure discovery by having the <code>hazelcast-all</code>
(or <code>hazelcast-azure</code>) JAR on your classpath and enabling Azure in your Hazelcast configuration.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/hazelcast-azure" target="_blank" rel="noopener">Hazelcast Azure Plugin documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="hazelcast-cloud-discovery-plugins-gcp"><a class="anchor" href="#hazelcast-cloud-discovery-plugins-gcp"></a>26.1.3. Hazelcast GCP</h4>
<div class="paragraph">
<p>Hazelcast provides support for <a href="https://cloud.google.com/compute/" target="_blank" rel="noopener">Google Compute Engine</a>,
covering the following environments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compute Engine VM Instances with <a href="https://github.com/hazelcast/hazelcast-gcp" target="_blank" rel="noopener">Hazelcast GCP Discovery plugin</a></p>
</li>
<li>
<p>Google Kubernetes Engine (GKE) with <a href="https://github.com/hazelcast/hazelcast-kubernetes" target="_blank" rel="noopener">Hazelcast Kubernetes Discovery plugin</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In both scenarios you can use the <code>ZONE_AWARE</code> feature to create partition backups in other Availability Zones (AZ)
and therefore prevent any data loss in case of AZ failures.</p>
</div>
<div class="paragraph">
<p>You can easily configure your Hazelcast member/client to use GCP discovery by having the <code>hazelcast-all</code>
(or <code>hazelcast-gcp</code>) JAR on your classpath and enabling GCP in your Hazelcast configuration.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/hazelcast-gcp" target="_blank" rel="noopener">Hazelcast GCP Plugin documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="hazelcast-cloud-discovery-plugins-kubernetes"><a class="anchor" href="#hazelcast-cloud-discovery-plugins-kubernetes"></a>26.1.4. Hazelcast Kubernetes</h4>
<div class="paragraph">
<p>Hazelcast provides support for all <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> environments with the use of
<a href="https://github.com/hazelcast/hazelcast-kubernetes">Hazelcast Kubernetes Discovery plugin</a>.</p>
</div>
<div class="paragraph">
<p>We tested Hazelcast in the following environments: GKE, EKS, AKS, OpenShift, IBM Cloud, Minikube.</p>
</div>
<div class="paragraph">
<p>The plugin supports the <code>ZONE_AWARE</code> feature to create partition backups in other Availability Zones (AZ)
and therefore prevent any data loss in case of AZ failures.</p>
</div>
<div class="paragraph">
<p>You can easily configure your Hazelcast member/client to use Kubernetes discovery by having the <code>hazelcast-all</code>
(or <code>hazelcast-kubernetes</code>) JAR on your classpath and enabling Kubernetes in your Hazelcast configuration.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/hazelcast-kubernetes" target="_blank" rel="noopener">Hazelcast Kubernetes Plugin documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="hazelcast-cloud-discovery-plugins-eureka"><a class="anchor" href="#hazelcast-cloud-discovery-plugins-eureka"></a>26.1.5. Hazelcast Eureka</h4>
<div class="paragraph">
<p>Hazelcast supports using <a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Eureka</a> server as the discovery mechanism
with the use of <a href="https://github.com/hazelcast/hazelcast-eureka">Hazelcast Eureka Discovery plugin</a>.</p>
</div>
<div class="paragraph">
<p>You can easily configure your Hazelcast member/client to use Eureka discovery by having the <code>hazelcast-eureka-one</code>
JAR on your classpath and enabling Eureka in your Hazelcast configuration.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/hazelcast-eureka" target="_blank" rel="noopener">Hazelcast Eureka Plugin documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="hazelcast-cloud-discovery-plugins-zookeeper"><a class="anchor" href="#hazelcast-cloud-discovery-plugins-zookeeper"></a>26.1.6. Hazelcast Zookeeper</h4>
<div class="paragraph">
<p>Hazelcast supports using <a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper</a> as the discovery mechanism
with the use of <a href="https://github.com/hazelcast/hazelcast-zookeeper">Hazelcast Zookeeper Discovery plugin</a>.</p>
</div>
<div class="paragraph">
<p>You can easily configure your Hazelcast member/client to use Zookeeper discovery by having the <code>hazelcast-zookeeper</code>
JAR on your classpath and enabling Zookeeper in your Hazelcast configuration.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/hazelcast-zookeeper" target="_blank" rel="noopener">Hazelcast Zookeeper Plugin documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_other_discovery_plugins"><a class="anchor" href="#_other_discovery_plugins"></a>26.1.7. Other Discovery Plugins</h4>
<div class="paragraph">
<p>Apart from the officially maintained plugins listed above, there are a number of community plugins implementing
Hazelcast Discovery SPI:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/bitsofinfo/hazelcast-docker-swarm-discovery-spi">Hazelcast Docker Swarm Discovery Plugin</a></p>
</li>
<li>
<p><a href="https://github.com/bitsofinfo/hazelcast-consul-discovery-spi">Hazelcast Consul Discovery Plugin</a></p>
</li>
<li>
<p><a href="https://github.com/bitsofinfo/hazelcast-etcd-discovery-spi">Hazelcast Etcd Discovery Plugin</a></p>
</li>
<li>
<p><a href="https://github.com/jkutner/hazelcast-heroku-discovery">Hazelcast Heroku Discovery Plugin</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_web_session_replication_plugins"><a class="anchor" href="#_web_session_replication_plugins"></a>26.2. Web Session Replication Plugins</h3>
<div class="paragraph">
<p>You can use Hazelcast to replicate your web session in a number of environments.</p>
</div>
<div class="sect3">
<h4 id="_filter_based_web_session_replication"><a class="anchor" href="#_filter_based_web_session_replication"></a>26.2.1. Filter Based Web Session Replication</h4>
<div class="paragraph">
<p>This plugin (a.k.a. Generic Web Session Replication) provides
HTTP session replication capabilities across a Hazelcast cluster in order to
handle failover cases. Assuming you have multiple web servers with load balancers;
if one server goes down, your users on that server are directed to one of
the other live servers, but their sessions are not lost. Using this plugin backs up
these HTTP sessions; it clusters them automatically.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://github.com/hazelcast/hazelcast-wm" target="_blank" rel="noopener">Filter Based Web Session Replication documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tomcat_based_web_session_replication"><a class="anchor" href="#_tomcat_based_web_session_replication"></a>26.2.2. Tomcat Based Web Session Replication</h4>
<div class="paragraph">
<p>Tomcat based web session replication is offered through Hazelcast Tomcat Session Manager.
It is a container specific module that enables session replication for
JEE Web Applications without requiring changes to the application.</p>
</div>
<div class="paragraph">
<p>See the following for more details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-tomcat-sessionmanager" target="_blank" rel="noopener">Tomcat Based Web Session Replication documentation</a></p>
</li>
<li>
<p><a href="https://guides.hazelcast.org/springboot-tomcat-session-replication" target="_blank" rel="noopener">Hazelcast Guides: Tomcat Session Replication with Spring Boot and Hazelcast</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_jetty_based_web_session_replication"><a class="anchor" href="#_jetty_based_web_session_replication"></a>26.2.3. Jetty Based Web Session Replication</h4>
<div class="paragraph">
<p>Jetty based web session replication is offered through Hazelcast Jetty Session Manager.
It is a container specific module that enables session replication for
JEE Web Applications without requiring changes to the application.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://www.eclipse.org/jetty/documentation/current/configuring-sessions-hazelcast.html" target="_blank" rel="noopener">Jetty: Persistent Sessions with Hazelcast</a>
for more details.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_framework_integration_plugins"><a class="anchor" href="#_framework_integration_plugins"></a>26.3. Framework Integration Plugins</h3>
<div class="paragraph">
<p>Hazelcast provides the following integration plugins that
allow Hazelcast to integrate with other frameworks and applications.</p>
</div>
<div class="sect3">
<h4 id="_hazelcast_hibernate_2lc"><a class="anchor" href="#_hazelcast_hibernate_2lc"></a>26.3.1. Hazelcast Hibernate 2LC</h4>
<div class="paragraph">
<p><a href="http://hibernate.org/" target="_blank" rel="noopener">Hibernate</a> is an object-relational mapping tool for the Java programming language.
It provides a framework for mapping an object-oriented domain model to a relational database and
enables developers to more easily write applications whose data outlives the application process.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/hazelcast/hazelcast-hibernate" target="_blank" rel="noopener">Hazelcast Hibernate plugin</a> provides Hazelcast&#8217;s own distributed
second level cache implementation for your Hibernate entities, collections and queries.</p>
</div>
<div class="paragraph">
<p>To use this plugin, add the <code>hazelcast-all</code> (or <code>hazelcast-hibernate*</code>) dependency into your classpath.</p>
</div>
<div class="paragraph">
<p>See the following for more details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-hibernate" target="_blank" rel="noopener">Hazelcast Hibernate Plugin documentation</a>.</p>
</li>
<li>
<p><a href="https://guides.hazelcast.org/springboot-hibernate/" target="_blank" rel="noopener">Hazelcast Guides: Hibernate Second-Level Cache</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_spring_boot"><a class="anchor" href="#_spring_boot"></a>26.3.2. Spring Boot</h4>
<div class="paragraph">
<p>Hazelcast is very well integrated with the whole <a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">Spring Boot</a> ecosystem.
See the following resources for the details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">Spring Boot: Hazelcast</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-caching-provider-hazelcast" target="_blank" rel="noopener">Spring Boot: Caching with Hazelcast</a></p>
</li>
<li>
<p><a href="https://guides.hazelcast.org/hazelcast-embedded-springboot/" target="_blank" rel="noopener">Hazelcast Guides: Hazelcast with Spring Boot</a></p>
</li>
<li>
<p><a href="https://guides.hazelcast.org/caching-springboot/" target="_blank" rel="noopener">Hazelcast Guides: Caching in SpringBoot Microservices</a></p>
</li>
<li>
<p><a href="https://guides.hazelcast.org/springboot-webfilter-session-replication/" target="_blank" rel="noopener">Hazelcast Guides: Session Replication with Spring Boot</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_spring_integration"><a class="anchor" href="#_spring_integration"></a>26.3.3. Spring Integration</h4>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-integration" target="_blank" rel="noopener">Spring Integration</a> provides an extension for Hazelcast.
It includes, but is not limited to, the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Event-driven inbound channel adapter: Listens related Hazelcast data structure events and
sends event messages to the defined channel.</p>
</li>
<li>
<p>Continuous query inbound channel adapter: Listens the modifications performed on specific map entries.</p>
</li>
<li>
<p>Cluster monitor inbound channel adapter:  Listens the modifications performed on the cluster.</p>
</li>
<li>
<p>Distributed SQL inbound channel adapter: Runs the defined distributed SQL and returns
the results in the light of iteration type.</p>
</li>
<li>
<p>Outbound channel adapter: Listens the defined channel and writes the incoming messages to
the related distributed data structure.</p>
</li>
<li>
<p>Leader election: Elects a cluster member, for example, for highly available
message consumer where only one member should receive messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/spring-projects/spring-integration-extensions/tree/master/spring-integration-hazelcast" target="_blank" rel="noopener">Spring Integration Extension documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_spring_data_hazelcast"><a class="anchor" href="#_spring_data_hazelcast"></a>26.3.4. Spring Data Hazelcast</h4>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data" target="_blank" rel="noopener">Spring Data</a> provides
a consistent, Spring-based programming model for data access while
preserving the features of the underlying data store.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/hazelcast/spring-data-hazelcast" target="_blank" rel="noopener">Spring Data Hazelcast plugin</a> provides an implementation
of the <a href="https://github.com/spring-projects/spring-data-keyvalue" target="_blank" rel="noopener">Spring Data Key Value</a> abstraction, which
lets you use Hazelcast as the data store or a layer in between your application and the database.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/spring-data-hazelcast" target="_blank" rel="noopener">Spring Data Hazelcast documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_quarkus"><a class="anchor" href="#_quarkus"></a>26.3.5. Quarkus</h4>
<div class="paragraph">
<p>Hazelcast integrates well with the <a href="https://quarkus.io/" target="_blank" rel="noopener">Quarkus framework</a>. What&#8217;s more is that, if you use
the client/server topology, then Hazelcast client works in the GraalVM native executable mode. That means that
you can use Hazelcast in your super-fast native Docker images.</p>
</div>
<div class="paragraph">
<p>See the following resources for more details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/quarkus-hazelcast-client" target="_blank" rel="noopener">Hazelcast Client for Quarkus documentation</a></p>
</li>
<li>
<p><a href="https://guides.hazelcast.org/hazelcast-client-quarkus/" target="_blank" rel="noopener">Hazelcast Guides: Hazelcast Client with Quarkus</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_micronaut"><a class="anchor" href="#_micronaut"></a>26.3.6. Micronaut</h4>
<div class="paragraph">
<p>Hazelcast can be used as a caching provider in the <a href="https://micronaut.io/">Micronaut</a> framework.
See the following resources for more details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://micronaut-projects.github.io/micronaut-cache/snapshot/guide/#hazelcast" target="_blank" rel="noopener">Micronaut: Hazelcast Support</a></p>
</li>
<li>
<p><a href="https://guides.hazelcast.org/caching-micronaut/" target="_blank" rel="noopener">Hazelcast Guides: Caching in Micronaut Microservices</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_hazelcast_jca_resource_adapter"><a class="anchor" href="#_hazelcast_jca_resource_adapter"></a>26.3.7. Hazelcast JCA Resource Adapter</h4>
<div class="paragraph">
<p>Hazelcast JCA Resource Adapter is a system-level software driver which
can be used by a Java application to connect to the Hazelcast cluster.
Using this adapter, you can integrate Hazelcast into Java EE containers.
After a proper configuration, Hazelcast can participate in the standard Java EE transactions.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/hazelcast-ra" target="_blank" rel="noopener">Hazelcast JCA Resource Adapter documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hazelcast_dynacache"><a class="anchor" href="#_hazelcast_dynacache"></a>26.3.8. Hazelcast DynaCache</h4>
<div class="paragraph">
<p><a href="https://www.ibm.com/support/knowledgecenter/en/linuxonibm/liaag/cache/pubwasdynacachoverview.htm" target="_blank" rel="noopener">DynaCache</a> by IBM is
used to store objects, and later, based on some data matching rules, to retrieve those objects and serve them from its cache.
This plugin is for Liberty Profile which is a lightweight profile of IBM WebSphere Application Server.</p>
</div>
<div class="paragraph">
<p>In the Liberty Profile, you can use a dynamic cache engine in order to cache your data.
With this plugin, you can use Hazelcast as a cache provider.</p>
</div>
<div class="paragraph">
<p>See the
<a href="https://github.com/hazelcast/hazelcast-dynacache" target="_blank" rel="noopener">Hazelcast DynaCache documentation</a>
for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mulesoft"><a class="anchor" href="#_mulesoft"></a>26.3.9. MuleSoft</h4>
<div class="paragraph">
<p>Hazelcast is embedded within a MuleSoft container as an out-of-the-box offering.
For a proper integration you should edit the <code>mule-deploy.properties</code> file to have the following entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>loader.override=com.hazelcast</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_other_integrations"><a class="anchor" href="#_other_integrations"></a>26.4. Other Integrations</h3>
<div class="paragraph">
<p>Apart from the officially maintained integrations listed above, there are a number of Hazelcast community plugins:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://lenses.stream/connectors/sink/hazelcast.html" target="_blank" rel="noopener">Hazelcast Connector for Kafka</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-spark" target="_blank" rel="noopener">Hazelcast Connector for Apache Spark</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-mesos" target="_blank" rel="noopener">Hazelcast Mesos</a></p>
</li>
<li>
<p><a href="https://www.igniterealtime.org/projects/openfire/plugins/hazelcast/readme.html" target="_blank" rel="noopener">Hazelcast Openfire integration</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-grails" target="_blank" rel="noopener">Hazelcast Grails plugin</a></p>
</li>
<li>
<p><a href="https://github.com/jerrinot/subzero" target="_blank" rel="noopener">Hazelcast SubZero serialization</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_consistency_and_replication_model"><a class="anchor" href="#_consistency_and_replication_model"></a>27. Consistency and Replication Model</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_brief_overview_of_consistency_and_replication_in_distributed_systems"><a class="anchor" href="#_a_brief_overview_of_consistency_and_replication_in_distributed_systems"></a>27.1. A Brief Overview of Consistency and Replication in Distributed Systems</h3>
<div class="paragraph">
<p>Partitioning and replication are the two common techniques used together in
distributed databases to achieve scalable, available and transparent data distribution.
The data space is divided into partitions, each of which contains
a distinct portion of the overall data set. For these partitions, multiple copies called replicas
are created. Partition replicas are distributed among the cluster members.
Each member is assigned to at most a single replica for a partition.
In this setting, different replication techniques can be used to access the data and
keep the replicas in sync on updates. The technique being used directly affects
the guarantees and properties a distributed data store provides, due to
the CAP (<strong>C</strong>onsistency, <strong>A</strong>vailability and <strong>P</strong>artition Tolerance) principle.</p>
</div>
<div class="paragraph">
<p>One aspect of replication techniques is about where a replicated data set is
accessed and updated. For instance, primary-copy systems first elect
a replica, which can be called as primary, master, etc., and use that
replica to access the data. Changes in the data on the primary replica are
propagated to other replicas. This approach has different namings, such as
<em>primary-copy</em>, <em>single-master</em>, <em>passive replication</em>. The primary-copy technique is
a powerful model as it prevents conflicts, deadlocks among the replicas.
However, primary replicas can become bottlenecks.
On the other hand, we can have a different technique by eliminating
the primary-copy and treating each replica as equal. These systems can
achieve a higher level of availability as a data entry can be accessed and
updated using any replica. However, it can become more difficult to keep
the replicas in sync with each other.</p>
</div>
<div class="paragraph">
<p>Replication techniques also differ in how updates are propagated among replicas.
One option is to update each replica as part of a single atomic transaction, called as
<em>eager replication</em> or <em>synchronous replication</em>. Consensus algorithms apply
this approach to achieve strong consistency on a replicated data set.
The main drawback is the amount of coordination and communication required while
running the replication algorithm. CP systems implement consensus algorithms under the hood.
Another option is the <em>lazy replication</em> technique, which is also called as
<em>asynchronous replication</em>. Lazy replication algorithms execute updates on replicas with
separate transactions. They generally work with best-effort.
By this way, the amount of coordination among the replicas are degraded and
data can be accessed in a more performant manner. Yet, it can happen that
a particular update is executed on some replicas but not on others, which causes
replicas to diverge. Such problems can be resolved with different approaches, such as
<em>read-repair</em>, <em>write-repair</em>, <em>anti-entropy</em>. Lazy replication techniques are
popular among AP systems.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hazelcasts_replication_algorithm"><a class="anchor" href="#_hazelcasts_replication_algorithm"></a>27.2. Hazelcast&#8217;s Replication Algorithm</h3>
<div class="paragraph">
<p>The discussion here generally applies to any system that maintains multiple copies of
a data set. It applies to Hazelcast as well. In the context of CAP principle, <strong>Hazelcast offers
AP and CP functionality with different data structure implementations</strong>.
Data structures exposed under <code>HazelcastInstance</code> API are all <strong>AP</strong> data structures.
Hazelcast also contains a <strong>CP</strong> subsystem, built on the Raft consensus algorithm and
accessed via <code>HazelcastInstance.getCPSubsytem()</code> which provides <strong>CP</strong> data structures and APIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The replication algorithm and consistency model explained below apply
to AP data structures only. For CP subsystem and CP data structures,
see the <a href="#cp-subsystem">CP Subsystem</a> section.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For AP data structures, Hazelcast employs the combination of primary-copy and
configurable lazy replication techniques. As briefly described in
the <a href="#data-partitioning">Data Partitioning section</a>, each data entry is mapped to
a single Hazelcast partition and put into replicas of that partition. One of
the replicas is elected as the primary replica, which is responsible for
performing operations on that partition. When you read or
write a map entry, you transparently talk to the Hazelcast member to which
primary replica of the corresponding partition is assigned.
By this way, each request hits the most up-to-date version of
a particular data entry in a stable cluster. Backup replicas stay
in standby mode until the primary replica fails.
Upon failure of the primary replica, one of the backup replicas is promoted to the primary role.</p>
</div>
<div class="paragraph">
<p>With <em>lazy replication</em>, when the primary replica receives
an update operation for a key, it executes the update locally and
propagates it to backup replicas. It marks each update with
a logical timestamp so that backups apply them in the correct order and
converge to the same state with the primary. Backup replicas can be used to
scale reads (see the <a href="#enabling-backup-reads">Enabling Backup Reads section</a>) with
no strong consistency but monotonic reads guarantee.</p>
</div>
<div class="paragraph">
<p>Hazelcast offers features such as <em>SplitBrainProtection</em>, <em>ILock</em> and <em>AtomicLong</em>.
In the journey of being a highly elastic, dynamic and easy to
use product, Hazelcast tries to provide best-effort consistency guarantees without
being a complete CP solution. Therefore, we recommend these features to be used for
efficiency purposes in general, instead of correctness. For instance, they can be used to
prevent to run a resource-extensive computation multiple times, which would not
create any correctness problem if runs more than once. See the
<a href="#best-effort-consistency">Best-Effort Consistency</a> and <a href="#split-brain-syndrome">Network Partitioning</a> sections
for more information.</p>
</div>
<div class="sect3">
<h4 id="_best_effort_consistency"><a class="anchor" href="#_best_effort_consistency"></a>27.2.1. Best-Effort Consistency</h4>
<div class="paragraph">
<p>Hazelcast&#8217;s replication technique enables Hazelcast clusters to offer high throughput.
However, due to temporary situations in the system, such as
network interruption, backup replicas can miss some updates and
diverge from the primary. Backup replicas can also hit
VM or long GC pauses, and fall behind the primary, which is a situation called as
<em>replication lag</em>. If a Hazelcast partition primary replica member crashes while
there is a replication lag between itself and the backups, strong consistency of the data can be lost.</p>
</div>
<div class="paragraph">
<p>Please note that CP systems can have similar problems as well.
However, in a CP system, once a replica performs
an update locally (i.e., <em>commits</em> the update), the underlying consensus algorithm guarantees
durability of the update for the rest of the execution.</p>
</div>
<div class="paragraph">
<p>On the other hand, in AP systems like Hazelcast, a replica can perform
an update locally, even if the update is not to be performed on other replicas.
This is a fair trade-off to reduce amount of coordination among replicas and
maintain high throughput &amp; high availability of the system.
These systems employ additional measurements to maintain consistency in a
best-effort manner. In this regard, Hazelcast tries to minimize the effect of
such scenarios using an active anti-entropy solution as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each Hazelcast member runs a periodic task in the background.</p>
</li>
<li>
<p>For each primary replica it is assigned, it creates a summary information and
sends it to the backups.</p>
</li>
<li>
<p>Then, each backup member compares the summary information with its own data to
see if it is up-to-date with the primary.</p>
</li>
<li>
<p>If a backup member detects a missing update, it triggers
the synchronization process with the primary.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_invocation_lifecycle"><a class="anchor" href="#_invocation_lifecycle"></a>27.3. Invocation Lifecycle</h3>
<div class="paragraph">
<p>When a write is requested with the methods, such as
<code>map.put()</code> or <code>queue.offer()</code>, a write operation is submitted to
the Hazelcast member that owns the primary replica of the specific partition.
Partition of an operation is determined based on a parameter (key of an entry or
name of the data structure, etc.) related to that operation depending on
the data structure. Target Hazelcast member is figured out by looking up
a local partition assignment/ownership table, which is updated on
each partition migration and broadcasted to all cluster eventually.</p>
</div>
<div class="paragraph">
<p>When a Hazelcast member receives a partition specific operation,
it executes the operation and propagates it to backup replica(s) with
a logical timestamp. Number of backups for each operation depends on
the data structure and its configuration. See
<a href="#operation-threading">Threading Model - Operation Threading</a> for threading details.</p>
</div>
<div class="paragraph">
<p>Two types of backup replication are available: <em>sync</em> and <em>async</em>.
Despite what their names imply, both types are still implementations of
the lazy (async) replication model. The only difference between
<em>sync</em> and <em>async</em> is that, the former makes the caller block until
backup updates are applied by backup replicas and acknowledgments are sent back to
the caller, but the latter is just fire &amp; forget. Number of sync and
async backups are defined in the data structure configurations, and you can use
a combination of sync and async backups.</p>
</div>
<div class="paragraph">
<p>When backup updates are propagated, response of the execution including
number of sync backup updates is sent to the caller and after receiving
the response, caller waits to receive the specified number of
sync backup acknowledgements for a predefined timeout.
This timeout is 5 seconds by default and defined by
the system property <code>hazelcast.operation.backup.timeout.millis</code>
(see <a href="#system-properties">System Properties appendix</a>).</p>
</div>
<div class="paragraph">
<p>A backup update can be missed because of a few reasons, such as
a stale partition table information on a backup replica member,
network interruption, or a member crash. That&#8217;s why sync backup acks require
a timeout to give up. Regardless of being a sync or async backup, if a backup update is missed,
the periodically running anti-entropy mechanism detects the inconsistency and
synchronizes backup replicas with the primary. Also the graceful shutdown procedure ensures
that all backup replicas for partitions whose primary replicas are assigned to
the shutting down member will be consistent.</p>
</div>
<div class="paragraph">
<p>In some cases, although the target member of an invocation is assumed to be
alive by the failure detector, the target may not execute the operation or
send the response back in time. Network splits, long pauses caused by
high load, GC or I/O (disk, network) can be listed as a few possible reasons.
When an invocation doesn&#8217;t receive any response from the member that owns
primary replica, then invocation fails with an <code>OperationTimeoutException</code>.
This timeout is 2 minutes by default and defined by
the system property <code>hazelcast.operation.call.timeout.millis</code>
(see <a href="#system-properties">System Properties appendix</a>).
When timeout is passed, result of the invocation will be indeterminate.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exactly_once_at_least_once_or_at_most_once_execution"><a class="anchor" href="#_exactly_once_at_least_once_or_at_most_once_execution"></a>27.4. Exactly-once, At-least-once or At-most-once Execution</h3>
<div class="paragraph">
<p>Hazelcast, as an AP product, does not provide the exactly-once guarantee.
In general, Hazelcast tends to be an at-least-once solution.</p>
</div>
<div class="paragraph">
<p>In the following failure case, exactly-once guarantee can be broken:
When the target member of a pending invocation leaves the cluster while
the invocation is waiting for a response, that invocation is re-submitted to
its new target due to the new partition table. It can be that, it has
already been executed on the leaving member and backup updates are propagated to
the backup replicas, but the response is not received by the caller.
If that happens, the operation will be executed twice.</p>
</div>
<div class="paragraph">
<p>In the following failure case, invocation state becomes indeterminate:
As explained above, when an invocation does not receive a response in time,
invocation fails with an <code>OperationTimeoutException</code>. This exception does not
say anything about outcome of the operation, that means operation may not be
executed at all, it may be executed once or twice (due to member left case explained above).</p>
</div>
</div>
<div class="sect2">
<h3 id="_indeterminateoperationstateexception"><a class="anchor" href="#_indeterminateoperationstateexception"></a>27.5. IndeterminateOperationStateException</h3>
<div class="paragraph">
<p>As described in <a href="#invocation-lifecycle">Invocation Lifecycle</a> section,
for partition-based <strong>mutating</strong> invocations, such as <code>map.put()</code>,
a caller waits with a timeout for the operation that is executed on
corresponding partition&#8217;s primary replica and backup replicas, based on
the sync backup configuration of the distributed data structure.
Hazelcast 3.9 introduces a new mechanism to detect indeterminate situations while
making such invocations. If <code>hazelcast.operation.fail.on.indeterminate.state</code> system property is
enabled, a <strong>mutating</strong> invocation throws <code>IndeterminateOperationStateException</code> when
it encounters the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The operation fails on partition primary replica member with <code>MemberLeftException</code>.
In this case, the caller may not determine the status of the operation.
It could happen that the primary replica executes the operation, but fails before
replicating it to all the required backup replicas. Even if the caller receives
backup acks from some backup replicas, it cannot decide if it has received
all required ack responses, since it does not know how many acks it should wait for.</p>
</li>
<li>
<p>There is at least one missing ack from the backup replicas for the given timeout duration.
In this case, the caller knows that the operation is executed on the primary replica,
but some backup may have missed it. It could be also a false-positive,
if the backup timeout duration is configured with a very small value.
However, Hazelcast&#8217;s active anti-entropy mechanism eventually kicks in and
resolves durability of the write on all available backup replicas as long as
the primary replica member is alive.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an invocation fails with <code>IndeterminateOperationStateException</code>,
the system does not try to rollback the changes which are executed on healthy replicas.
Effect of a failed invocation may be even observed by another caller,
if the invocation has succeeded on the primary replica.
Hence, this new behavior does not guarantee linearizability.
However, if an invocation completes without <code>IndeterminateOperationStateException</code> when
the configuration is enabled, it is guaranteed that the operation has been
executed exactly-once on the primary replica and specified number of backup replicas of the partition.</p>
</div>
<div class="paragraph">
<p>Please note that <code>IndeterminateOperationStateException</code> does not apply to
read-only operations, such as <code>map.get()</code>. If a partition primary replica member crashes before
replying to a read-only operation, the operation is retried on the new owner of the primary replica.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_network_partitioning"><a class="anchor" href="#_network_partitioning"></a>28. Network Partitioning</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_split_brain_syndrome"><a class="anchor" href="#_split_brain_syndrome"></a>28.1. Split-Brain Syndrome</h3>
<div class="paragraph">
<p>In general, network partitioning is a network failure that causes
the members to split into multiple groups such that
a member in a group cannot communicate with members in other groups.
In a partition scenario, all sides of the original cluster operate independently
assuming members in other sides are failed. Network partitioning is also called as <em>Split-Brain Syndrome</em>.</p>
</div>
<div class="paragraph">
<p>Even though this communication failure is called as <em>network partitioning</em>,
in practice a process or an entire OS that&#8217;s suspending/pausing very long can cause
communication interruptions. If these interruptions take long enough time to
assume that the other side is crashed, the cluster splits into
multiple partitions and they start operating independently.
That&#8217;s why any communication failure/interruption long enough can be
classified as network partitioning.</p>
</div>
<div class="paragraph">
<p>Moreover, communication failures don&#8217;t have to be symmetrical.
A network failure can interrupt only one side of the channel or
a suspended process/member may not even observe the rest as crashed.
That kind of network partitioning can be called as <em>partial network partitioning</em>.
See <a href="#partial-network-partitions">Partial Network Partitions section</a> for more info.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dealing_with_network_partitions"><a class="anchor" href="#_dealing_with_network_partitions"></a>28.2. Dealing with Network Partitions</h3>
<div class="paragraph">
<p>Hazelcast handles network partitions using the following solutions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Split-brain protection: Split-brain protection could be used when
consistency is the major concern on a network partitioning.
It requires a minimum cluster size to keep a particular data structure available.
When cluster size is below the defined split-brain protection size,
then subsequent operations are rejected with a <code>SplitBrainProtectionException</code>.
See the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</li>
<li>
<p>Split-brain recovery (merge policies): Split-brain recovery is to
make data structures available and operational on both sides of a network partition,
and merge their data once the network partitioning problem is resolved.
See the <a href="#split-brain-recovery">Split-Brain Recovery section</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Split-brain recovery is also supported for
the data structures whose in-memory format is <code>NATIVE</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_split_brain_protection"><a class="anchor" href="#_split_brain_protection"></a>28.3. Split-Brain Protection</h3>
<div class="paragraph">
<p>Split-brain protection mechanism provided in Hazelcast protects
your cluster in case the number of cluster members drops below the specified one.
How to respond to a split-brain scenario depends on whether consistency of
data or availability of your application is of primary concern.
In either case, because a split-brain scenario is caused by
a network failure, you must initiate an effort to identify and
correct the network failure. Your cluster cannot be brought back to
steady state operation until the underlying network failure is fixed.
If consistency is your primary concern, you can use Hazelcast&#8217;s split-brain
protection feature.</p>
</div>
<div class="paragraph">
<p>This feature enables you to specify
the minimum cluster size required for operations to occur.
This is achieved by defining and configuring a <code>minimum-cluster-size</code> for the cluster.
If the cluster size is below this minimum value, the operations are rejected and
the rejected operations return a <code>SplitBrainProtectionException</code> to their callers.
Additionally, it is possible to configure this size with a user-defined
<code>SplitBrainProtectionFunction</code> which is consulted to determine there is no split-brain on
each cluster membership change.</p>
</div>
<div class="paragraph">
<p>Your application continues its operations on the remaining operating cluster.
Any application instances connected to the cluster with sizes below the minimum threshold
defined by the split-brain protection configuration receive exceptions which, depending on the programming and
monitoring setup, should generate alerts. The key point is that rather than
applications continuing in error with stale data, they are prevented from doing so.</p>
</div>
<div class="paragraph">
<p>Split-brain protection is supported for the following Hazelcast data structures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IMap (for Hazelcast 3.5 and higher versions)</p>
</li>
<li>
<p>Transactional Map (for Hazelcast 3.5 and higher versions)</p>
</li>
<li>
<p>ICache (for Hazelcast 3.5 and higher versions)</p>
</li>
<li>
<p>ILock (for Hazelcast 3.8 and higher versions)</p>
</li>
<li>
<p>IQueue (for Hazelcast 3.8 and higher versions)</p>
</li>
<li>
<p>IExecutorService, DurableExecutorService, IScheduledExecutorService,
MultiMap, ISet, IList, Ringbuffer, Replicated Map, Cardinality Estimator,
IAtomicLong, IAtomicReference, ISemaphore, ICountdownLatch
(for Hazelcast 3.10 and higher versions)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each data structure to be protected should have the configuration added to
it as explained in the <a href="#configuring-split-brain-protection">Configuring Split-Brain Protection section</a>.</p>
</div>
<div class="sect3">
<h4 id="_time_window_for_split_brain_protection"><a class="anchor" href="#_time_window_for_split_brain_protection"></a>28.3.1. Time Window for Split-Brain Protection</h4>
<div class="paragraph">
<p>Cluster membership is established and maintained by heartbeats.
A network partitioning presents some members as being unreachable.
While configurable, it is normally seconds or tens of seconds before
the cluster is adjusted to exclude unreachable members.
The cluster size is based on the currently understood number of members.</p>
</div>
<div class="paragraph">
<p>For this reason, there will be a time window between
the network partitioning and the application of split-brain protection.
Length of this window depends on the failure detector.
Given guarantee is, every member eventually detects
the failed members and rejects the operation on the data structure which
requires the split-brain protection.</p>
</div>
<div class="paragraph">
<p>Split-brain protection can be
configured with out-of-the-box <code>SplitBrainProtectionFunction</code>s which
determine whether there is a split-brain situation independent of the
cluster membership manager. These functions take advantage of the heartbeat
and other failure-detector information configured on
the Hazelcast members.</p>
</div>
<div class="paragraph">
<p>For more information, see the <a href="#consistency-and-replication-model">Consistency and Replication Model chapter</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_split_brain_protection"><a class="anchor" href="#_configuring_split_brain_protection"></a>28.3.2. Configuring Split-Brain Protection</h4>
<div class="paragraph">
<p>You can set up the split-brain protection configuration using either
declarative or programmatic mechanism.</p>
</div>
<div class="paragraph">
<p>Assume that you have a 7-member Hazelcast Cluster and you want to
set the minimum number of four members for the cluster to continue operating.
In this case, if a split-brain happens, the sub-clusters of sizes 1, 2 and 3 are
prevented from being used. Only the sub-cluster of four members is allowed to be used.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is preferable to have an odd-sized initial cluster size to prevent
a single network partitioning (split-brain) from creating two equal sized clusters.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_member_count_split_brain_protection"><a class="anchor" href="#_member_count_split_brain_protection"></a>Member Count Split-Brain Protection</h5>
<div class="paragraph">
<p>This type of split-brain protection function determines the presence of split-brain protection based on
the count of members in the cluster, as observed by the local member&#8217;s cluster
membership manager and is available since Hazelcast 3.5.
The following are map configurations for the example 7-member cluster scenario described above:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection name="splitBrainProtectionRuleWithFourMembers" enabled="true"&gt;
        &lt;minimum-cluster-size&gt;4&lt;/minimum-cluster-size&gt;
    &lt;/split-brain-protection&gt;
    &lt;map name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitBrainProtectionRuleWithFourMembers&lt;/split-brain-protection-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    splitBrainProtectionRuleWithFourMembers:
      enabled: true
      minimum-cluster-size: 4
  map:
    default:
      split-brain-protection-ref: splitBrainProtectionRuleWithFourMembers</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SplitBrainProtectionConfig splitBrainProtectionConfig = new SplitBrainProtectionConfig();
splitBrainProtectionConfig.setName("splitBrainProtectionRuleWithFourMembers")
 .setEnabled(true)
 .setMinimumClusterSize(4);

MapConfig mapConfig = new MapConfig();
mapConfig.setSplitBrainProtectionName("splitBrainProtectionRuleWithFourMembers");

Config config = new Config();
config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
config.addMapConfig(mapConfig);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_probabilistic_split_brain_protection_function"><a class="anchor" href="#_probabilistic_split_brain_protection_function"></a>Probabilistic Split-Brain Protection Function</h5>
<div class="paragraph">
<p>The probabilistic split-brain protection function uses a private instance of
<a href="#phi-accrual-failure-detector">Phi Accrual Cluster Failure Detector</a> which is
updated with member heartbeats and its parameters can be fine-tuned to
determine the count of live members in the cluster, independently of
the cluster&#8217;s membership manager.</p>
</div>
<div class="paragraph">
<p>This function has the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>acceptable-heartbeat-pause-millis</code>: Duration in milliseconds corresponding to
the number of potentially lost/delayed heartbeats that are accepted before
considering it to be an anomaly. This margin is important to be able to
survive sudden, occasional, pauses in heartbeat arrivals, due to
for example garbage collection or network drops.
The value must be in the [heartbeat interval , maximum no heartbeat interval] range,
otherwise Hazelcast does not start. Its default value is <code>60000</code> milliseconds.</p>
</li>
<li>
<p><code>suspicion-threshold</code>: Threshold for suspicion () level.
A low threshold is prone to generate many wrong suspicions but
ensures a quick detection in the event of a real crash.
Conversely, a high threshold generates fewer mistakes but
needs more time to detect actual crashes. Its default value is <code>10</code>.</p>
</li>
<li>
<p><code>max-sample-size</code>: Number of samples to use for
calculation of mean and standard deviation of inter-arrival times.
Its default value is <code>200</code>.</p>
</li>
<li>
<p><code>heartbeat-interval-millis</code>: Bootstrap the stats with heartbeats that
corresponds to this duration in milliseconds, with a rather
high standard deviation (since environment is unknown in the beginning).
Its default value is <code>5000</code> milliseconds.</p>
</li>
<li>
<p><code>min-std-deviation-millis</code>: Minimum standard deviation (in milliseconds) to use for
the normal distribution used when calculating phi. Too low standard deviation might
result in too much sensitivity for sudden, but normal, deviations in heartbeat
inter arrival times. Its default value is <code>100</code> milliseconds.</p>
</li>
</ul>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection enabled="true" name="probabilistic-split-brain-protection"&gt;
        &lt;minimum-cluster-size&gt;3&lt;/minimum-cluster-size&gt;
        &lt;protect-on&gt;READ_WRITE&lt;/protect-on&gt;
        &lt;probabilistic-split-brain-protection acceptable-heartbeat-pause-millis="5000"
                max-sample-size="500" suspicion-threshold="10" /&gt;
    &lt;/split-brain-protection&gt;
    &lt;set name="split-brain-protected-set"&gt;
        &lt;split-brain-protection-ref&gt;probabilistic-split-brain-protection&lt;/split-brain-protection-ref&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    probabilistic-split-brain-protection:
      enabled: true
      minimum-cluster-size: 3
      protect-on: READ_WRITE
      probabilistic-split-brain-protection:
        acceptable-heartbeat-pause-millis: 5000
        max-sample-size: 500
        suspicion-threshold: 10
  set:
    split-brain-protected-set:
      split-brain-protection-ref: probabilistic-split-brain-protection</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SplitBrainProtectionConfig splitBrainProtectionConfig =
        SplitBrainProtectionConfig.newProbabilisticSplitBrainProtectionConfigBuilder("probabilist-splitBrainProtection", 3)
                .withAcceptableHeartbeatPauseMillis(5000)
                .withMaxSampleSize(500)
                .withSuspicionThreshold(10)
                .build();
splitBrainProtectionConfig.setProtectOn(SplitBrainProtectionOn.READ_WRITE);
SetConfig setConfig = new SetConfig("split-brain-protected-set");
setConfig.setSplitBrainProtectionName("probabilist-splitBrainProtection");
Config config = new Config();
config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
config.addSetConfig(setConfig);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_recently_active_split_brain_protection_function"><a class="anchor" href="#_recently_active_split_brain_protection_function"></a>Recently-Active Split-Brain Protection Function</h5>
<div class="paragraph">
<p>This function can be used to implement
a more conservative split-brain protection by requiring that
a heartbeat has been received from each member within a configurable
time window since now.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection enabled="true" name="recently-active-split-brain-protection"&gt;
        &lt;minimum-cluster-size&gt;4&lt;/minimum-cluster-size&gt;
        &lt;protect-on&gt;READ_WRITE&lt;/protect-on&gt;
        &lt;recently-active-split-brain-protection heartbeat-tolerance-millis="60000" /&gt;
    &lt;/split-brain-protection&gt;
    &lt;set name="split-brain-protected-set"&gt;
        &lt;split-brain-protection-ref&gt;recently-active-split-brain-protection&lt;/split-brain-protection-ref&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    recently-active-split-brain-protection:
      enabled: true
      minimum-cluster-size: 4
      protect-on: READ_WRITE
      recently-active-split-brain-protection:
        heartbeat-tolerance-millis: 60000
  set:
    split-brain-protected-set:
      split-brain-protection-ref: recently-active-split-brain-protection</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SplitBrainProtectionConfig splitBrainProtectionConfig =
        SplitBrainProtectionConfig.newRecentlyActiveSplitBrainProtectionConfigBuilder("recently-active-splitBrainProtection", 4, 60000)
                .build();
splitBrainProtectionConfig.setProtectOn(SplitBrainProtectionOn.READ_WRITE);
SetConfig setConfig = new SetConfig("split-brain-protected-set");
setConfig.setSplitBrainProtectionName("recently-active-splitBrainProtection");
Config config = new Config();
config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
config.addSetConfig(setConfig);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_split_brain_protection_configuration_reference"><a class="anchor" href="#_split_brain_protection_configuration_reference"></a>Split-Brain Protection Configuration Reference</h5>
<div class="paragraph">
<p>The split-brain protection configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>minimum-cluster-size</code>: Minimum number of members required in a cluster for
the cluster to remain in an operational state. If the number of
members is below the defined minimum at any time, the operations are
rejected and the rejected operations return a <code>SplitBrainProtectionException</code> to their callers.</p>
</li>
<li>
<p><code>protect-on</code>: Type of the cluster split-brain protection. Available values are READ, WRITE and READ_WRITE.</p>
</li>
<li>
<p><code>split-brain-protection-function-class-name</code>: Class name of a <code>SplitBrainProtectionFunction</code> implementation,
allows to configure split-brain protection with a custom split-brain protection function.
It cannot be used in conjunction with <code>probabilistic-split-brain-protection</code> or <code>recently-active-split-brain-protection</code>.</p>
</li>
<li>
<p><code>split-brain-protection-listeners</code>: Declaration of split-brain protection listeners which are
notified on split-brain protection status changes.</p>
</li>
<li>
<p><code>probabilistic-split-brain-protection</code>: Configures the split-brain protection with a probabilistic
protection function. It cannot be used in conjunction with <code>split-brain-protection-function-class-name</code> or
<code>recently-active-split-brain-protection</code>.</p>
</li>
<li>
<p><code>recently-active-split-brain-protection</code>: Configures the split-brain protection with a recently-active
protection function. It cannot be used in conjunction with <code>split-brain-protection-function-class-name</code>
or <code>probabilistic-split-brain-protection</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example configuration with custom SplitBrainProtectionFunction implementation</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package my.domain;

public class CustomSplitBrainProtectionFunction implements SplitBrainProtectionFunction {
        @Override
        public boolean apply(Collection&lt;Member&gt; members) {
            // implement split-brain detection logic here
        }
    }</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection enabled="true" name="member-count-split-brain-protection"&gt;
        &lt;protect-on&gt;READ_WRITE&lt;/protect-on&gt;
        &lt;minimum-cluster-size&gt;3&lt;/minimum-cluster-size&gt;
        &lt;split-brain-protection-function-class-name&gt;my.domain.CustomSplitBrainProtectionFunction&lt;/split-brain-protection-function-class-name&gt;
    &lt;/split-brain-protection&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    member-count-split-brain-protection:
      enabled: true
      protect-on: READ_WRITE
      minimum-cluster-size: 3
      split-brain-protection-function-class-name: my.domain.CustomSplitBrainProtectionFunction</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_split_brain_protection_listeners"><a class="anchor" href="#_configuring_split_brain_protection_listeners"></a>28.3.3. Configuring Split-Brain Protection Listeners</h4>
<div class="paragraph">
<p>You can register listeners to be notified about the split-brain protection results.
Split-brain protection listeners are local to the member where they are registered,
so they receive only events that occurred on that local member.</p>
</div>
<div class="paragraph">
<p>These listeners can be configured via declarative or programmatic configuration.
The following examples are such configurations.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection name="splitBrainProtectionRuleWithFourMembers" enabled="true"&gt;
        &lt;minimum-cluster-size&gt;4&lt;/minimum-cluster-size&gt;
        &lt;split-brain-protection-listeners&gt;
            &lt;split-brain-protection-listener&gt;
               com.company.splitbrainprotection.FourMemberSplitBrainProtectionListener
            &lt;/split-brain-protection-listener&gt;
        &lt;/split-brain-protection-listeners&gt;
    &lt;/split-brain-protection&gt;
    &lt;map name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitBrainProtectionRuleWithFourMembers&lt;/split-brain-protection-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    splitBrainProtectionRuleWithFourMembers:
      enabled: true
      minimum-cluster-size: 4
      split-brain-protection-listener: com.company.splitbrainprotection.FourMemberSplitBrainProtectionListener
  map:
    default:
      split-brain-protection-ref: splitBrainProtectionRuleWithFourMembers</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SplitBrainProtectionListenerConfig listenerConfig = new SplitBrainProtectionListenerConfig();
// You can either directly set SplitBrainProtection listener implementation of your own
listenerConfig.setImplementation(new SplitBrainProtectionListener() {
    @Override
    public void onChange(SplitBrainProtectionEvent splitBrainProtectionEvent) {
        if (splitBrainProtectionEvent.isPresent()) {
            // handle SplitBrainProtection presence
        } else {
            // handle SplitBrainProtection absence
        }
    }
});
// Or you can give the name of the class that implements SplitBrainProtectionListener interface.
listenerConfig.setClassName("com.company.splitBrainProtection.ThreeMemberSplitBrainProtectionListener");

SplitBrainProtectionConfig splitBrainProtectionConfig = new SplitBrainProtectionConfig();
splitBrainProtectionConfig.setName("splitBrainProtectionRuleWithFourMembers")
					    .setEnabled(true)
					    .setMinimumClusterSize(4)
					    .addListenerConfig(listenerConfig);


MapConfig mapConfig = new MapConfig();
mapConfig.setSplitBrainProtectionName("splitBrainProtectionRuleWithFourMembers");

Config config = new Config();
config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
config.addMapConfig(mapConfig);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_querying_split_brain_protection_results"><a class="anchor" href="#_querying_split_brain_protection_results"></a>28.3.4. Querying Split-Brain Protection Results</h4>
<div class="paragraph">
<p>Split-brain protection service gives you the ability to
query split-brain protection results over the <code>SplitBrainProtection</code> instances.
These instances let you query the result of a particular split-brain protection.</p>
</div>
<div class="paragraph">
<p>The following is a <code>SplitBrainProtection</code> interface that you can interact with.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * {@link SplitBrainProtection} provides access to the current status of a split-brain protection.
 */
public interface SplitBrainProtection {
    /**
     * Returns true if the minimum cluster size is satisfied, otherwise false.
     *
     * @return boolean whether the minimum cluster size property is satisfied
     */
    boolean hasMinimumSize();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can retrieve the <code>SplitBrainProtection</code> instance as in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        String splitBrainProtectionName = "at-least-one-storage-member";
        SplitBrainProtectionConfig splitBrainProtectionConfig = new SplitBrainProtectionConfig();
        splitBrainProtectionConfig.setName(splitBrainProtectionName);
        splitBrainProtectionConfig.setEnabled(true);

        MapConfig mapConfig = new MapConfig();
        mapConfig.setSplitBrainProtectionName(splitBrainProtectionName);

        Config config = new Config();
        config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
        config.addMapConfig(mapConfig);

        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config);
        SplitBrainProtectionService splitBrainProtectionService = hazelcastInstance.getSplitBrainProtectionService();
        SplitBrainProtection splitBrainProtection = splitBrainProtectionService.getSplitBrainProtection(splitBrainProtectionName);

        boolean splitBrainProtectionPresence = splitBrainProtection.hasMinimumSize();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_split_brain_recovery"><a class="anchor" href="#_split_brain_recovery"></a>28.4. Split-Brain Recovery</h3>
<div class="paragraph">
<p>Hazelcast deploys a background task that periodically searches for split clusters.
When a split is detected, the side that will initiate the merge process is decided.
This decision is based on the cluster size; the smaller cluster, by
member count, merges into the bigger one. If they have an equal number of members,
then a hashing algorithm determines the merging cluster. When deciding the merging side,
both sides ensure that there&#8217;s no intersection in their member lists.</p>
</div>
<div class="paragraph">
<p>After the merging side is decided, the oldest cluster member of
the merging side initiates the cluster merge process by sending
merge instructions to the members in its cluster.</p>
</div>
<div class="paragraph">
<p>While recovering from partitioning, Hazelcast uses merge policies for
supported data structures to resolve data conflicts between split clusters.
A merge policy is a callback function to resolve conflicts between
the existing and merging data. Hazelcast provides an interface to be
implemented and also a selection of out-of-the-box policies.
Data structures without split-brain recovery support discarding the data from merging side.</p>
</div>
<div class="paragraph">
<p>Each member of the merging cluster:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>closes all of its network connections (detach from its cluster)</p>
</li>
<li>
<p>takes a snapshot of local data structures which support split-brain recovery</p>
</li>
<li>
<p>discards all data structure data</p>
</li>
<li>
<p>joins to the new cluster as lite member</p>
</li>
<li>
<p>sends merge operations to the new cluster from local snapshots.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see the <a href="#consistency-and-replication-model">Consistency and Replication Model chapter</a>.</p>
</div>
<div class="sect3">
<h4 id="_merge_policies"><a class="anchor" href="#_merge_policies"></a>28.4.1. Merge Policies</h4>
<div class="paragraph">
<p>Since Hazelcast 3.10 all merge policies implement
the unified interface <code>com.hazelcast.spi.SplitBrainMergePolicy</code>.
We provide the following out-of-the-box implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DiscardMergePolicy</code>: The entry from the smaller cluster is discarded.</p>
</li>
<li>
<p><code>ExpirationTimeMergePolicy</code>: The entry with the higher expiration time wins.</p>
</li>
<li>
<p><code>HigherHitsMergePolicy</code>: The entry with the higher number of hits wins.</p>
</li>
<li>
<p><code>HyperLogLogMergePolicy</code>: Specialized merge policy for the <code>CardinalityEstimator</code>,
which uses the default merge algorithm from HyperLogLog research, keeping
the maximum register value of the two given instances.</p>
</li>
<li>
<p><code>LatestAccessMergePolicy</code>: The entry with the latest access wins.</p>
</li>
<li>
<p><code>LatestUpdateMergePolicy</code>: The entry with the latest update wins.</p>
</li>
<li>
<p><code>PassThroughMergePolicy</code>: the entry from the smaller cluster wins.</p>
</li>
<li>
<p><code>PutIfAbsentMergePolicy</code>: The entry from the smaller cluster wins if
it doesn&#8217;t exist in the cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally you can develop a custom merge policy by implementing
the <code>SplitBrainMergePolicy</code> interface, as explained in the
<a href="#custom-merge-policies">Custom Merge Policies section</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_supported_data_structures"><a class="anchor" href="#_supported_data_structures"></a>28.4.2. Supported Data Structures</h4>
<div class="paragraph">
<p>The following data structures support split-brain recovery:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IMap</code> (including High-Density Memory Store backed IMap)</p>
</li>
<li>
<p><code>ICache</code> (including High-Density Memory Store backed IMap)</p>
</li>
<li>
<p><code>ReplicatedMap</code></p>
</li>
<li>
<p><code>MultiMap</code></p>
</li>
<li>
<p><code>IAtomicLong</code></p>
</li>
<li>
<p><code>IAtomicReference</code></p>
</li>
<li>
<p><code>IQueue</code></p>
</li>
<li>
<p><code>IList</code></p>
</li>
<li>
<p><code>ISet</code></p>
</li>
<li>
<p><code>RingBuffer</code></p>
</li>
<li>
<p><code>CardinalityEstimator</code></p>
</li>
<li>
<p><code>ScheduledExecutorService</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The statistic based out-of-the-box merge policies are only supported by
<code>IMap</code>, <code>ICache</code>, <code>ReplicatedMap</code> and <code>MultiMap</code>.
The <code>HyperLogLogMergePolicy</code> is supported by the <code>CardinalityEstimator</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Except the <code>CardinalityEstimator</code> data structure,
the default merge policy for all the Hazelcast data structures that
support split-brain recovery (listed above) is <code>PutIfAbsentMergePolicy</code>.
For the <code>CardinalityEstimator</code> data structure,
the default merge policy is <code>HyperLogLogMergePolicy</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See also the <a href="#merge-types">Merge Types section</a> for a complete overview of
supported merge types of each data structure. There is a config validation which
checks these constraints to provide fail-fast behavior for invalid configurations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the other data structures, e.g., <code>ISemaphore</code>, <code>ICountdownLatch</code> and <code>ILock</code>,
the instance from the smaller cluster is discarded during the split-brain recovery.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_merge_policies"><a class="anchor" href="#_configuring_merge_policies"></a>28.4.3. Configuring Merge Policies</h4>
<div class="paragraph">
<p>The merge policies are configured via a <code>MergePolicyConfig</code>, which can be set for
all supported data structures. The only exception is <code>ICache</code>, which just accepts
the merge policy classname (due to compatibility reasons with older Hazelcast clients).
For <code>ICache</code>, all other configurable merge parameters are the default values from <code>MergePolicyConfig</code>.</p>
</div>
<div class="paragraph">
<p>For custom merge policies you should set the full class name of your implementation as
the <code>merge-policy</code> configuration. For the out-of-the-box merge policies the simple classname is enough.</p>
</div>
<div class="sect4">
<h5 id="_declarative_configuration"><a class="anchor" href="#_declarative_configuration"></a>Declarative Configuration</h5>
<div class="paragraph">
<p>Here are examples how merge policies can be specified for various data structures:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;merge-policy batch-size="100"&gt;LatestUpdateMergePolicy&lt;/merge-policy&gt;
    &lt;/map&gt;

    &lt;replicatedmap name="default"&gt;
        &lt;merge-policy batch-size="100"&gt;org.example.merge.MyMergePolicy&lt;/merge-policy&gt;
    &lt;/replicatedmap&gt;

    &lt;multimap name="default"&gt;
        &lt;merge-policy batch-size="50"&gt;HigherHitsMergePolicy&lt;/merge-policy&gt;
    &lt;/multimap&gt;

    &lt;list name="default"&gt;
        &lt;merge-policy batch-size="500"&gt;org.example.merge.MyMergePolicy&lt;/merge-policy&gt;
    &lt;/list&gt;

    &lt;atomic-long name="default"&gt;
        &lt;merge-policy&gt;PutIfAbsentMergePolicy&lt;/merge-policy&gt;
    &lt;/atomic-long&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      merge-policy:
        batch-size: 100
        class-name: LatestUpdateMergePolicy
  replicatedmap:
    default:
      merge-policy:
        batch-size: 100
        class-name: org.example.merge.MyMergePolicy
  multimap:
    default:
      merge-policy:
        batch-size: 50
        class-name: HigherHitsMergePolicy
  list:
    default:
      merge-policy:
        batch-size: 500
        class-name: org.example.merge.MyMergePolicy
  atomic-long:
    default:
      merge-policy:
        class-name: PutIfAbsentMergePolicy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how merge policies are specified for <code>ICache</code> (it is the same configuration tag,
but lacks the support for additional attributes like <code>batch-size</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cache name="default"&gt;
        &lt;merge-policy&gt;org.example.merge.MyMergePolicy&lt;/merge-policy&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cache:
    default:
      merge-policy:
        class-name: org.example.merge.MyMergePolicy</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_programmatic_configuration"><a class="anchor" href="#_programmatic_configuration"></a>Programmatic Configuration</h5>
<div class="paragraph">
<p>Here are examples how merge policies can be specified for various data structures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        MergePolicyConfig mergePolicyConfig = new MergePolicyConfig()
                .setPolicy("org.example.merge.MyMergePolicy")
                .setBatchSize(100);

        MapConfig mapConfig = new MapConfig("default")
                .setMergePolicyConfig(mergePolicyConfig);

        ListConfig listConfig = new ListConfig("default")
                .setMergePolicyConfig(mergePolicyConfig);

        Config config = new Config()
                .addMapConfig(mapConfig)
                .addListConfig(listConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how merge policies are specified for <code>ICache</code> (you can only set the merge policy classname):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CacheConfig mapConfig = new CacheConfig()
  .setName("default")
  .setMergePolicy("org.example.merge.MyMergePolicy");

Config config = new Config()
  .addMapConfig(mapConfig);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_merge_policies"><a class="anchor" href="#_custom_merge_policies"></a>28.4.4. Custom Merge Policies</h4>
<div class="paragraph">
<p>To implement a custom merge policy you have to implement <code>com.hazelcast.spi.SplitBrainMergePolicy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SplitBrainMergePolicy&lt;V, T extends MergingValue&lt;V&gt;, R&gt;
    extends DataSerializable {

  R merge(T mergingValue, T existingValue);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MergingValue</code> is an interface which describes a merge type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please have in mind that <code>existingValue</code> can be <code>null</code>.
This happens when a data structure or key-based entry was just created in the smaller cluster.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_merge_types"><a class="anchor" href="#_merge_types"></a>Merge Types</h5>
<div class="paragraph">
<p>A merge type defines an attribute which is required by a merge policy and provided by a data structure.</p>
</div>
<div class="paragraph">
<p><code>MergingValue</code> is the main merge type, which is required by all merge policies and provided by
all data structures. It contains the value of the merged data in raw (in-memory storage) and
deserialized format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MergingValue&lt;V&gt; extends MergingView {

  V getValue();

  Object getRawValue();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MergingValue</code> extends <code>MergingView</code>, which is a marker interface extended by all provided merge types.</p>
</div>
<div class="paragraph">
<p>The most common extension of <code>MergingValue</code> is <code>MergingEntry</code>, which additionally provides the key in
raw (in-memory storage) and deserialized format (used by all key-based data structures like
<code>IMap</code> or <code>ICache</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MergingEntry&lt;K, V&gt; extends MergingValue&lt;V&gt; {

  K getKey();

  Object getRawKey();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition we have a bunch of specialized merge types, e.g., for provided statistics.
An example is <code>MergingHits</code>, which provides the hit counter of the merge data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MergingHits extends MergingView {

  long getHits();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>com.hazelcast.spi.merge.SplitBrainMergeTypes</code> contains composed interfaces,
which show the provided merge types and required merge policy return type for each data structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ReplicatedMapMergeTypes&lt;K, V&gt; extends MergingEntry&lt;K, V&gt;,
    MergingCreationTime, MergingHits, MergingLastAccessTime, MergingLastUpdateTime,
    MergingTTL {
}

public interface QueueMergeTypes&lt;V&gt; extends MergingValue&lt;Collection&lt;V&gt;&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ReplicatedMap</code> provides key/value merge data, with the creation time, access hits,
last access time, last update time and TTL. The return type of the merge policy is <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>The <code>IQueue</code> just provides a collection of values. The return type is also a <code>Collection&lt;Object&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The following is the full list of merge types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MergingValue</code>: Represents the value of the merged data.</p>
</li>
<li>
<p><code>MergingEntry</code>: Represents the key and value of the merged data.</p>
</li>
<li>
<p><code>MergingCreationTime</code>: Represents the creation time of the merging process.</p>
</li>
<li>
<p><code>MergingHits</code>: Represents the access hits of the merged data.</p>
</li>
<li>
<p><code>MergingLastAccessTime</code>: Represents the last time when the merged data is accessed.</p>
</li>
<li>
<p><code>MergingLastUpdateTime</code>: Represents the last time when the merged data is updated.</p>
</li>
<li>
<p><code>MergingTTL</code>: Represents the time-to-live value of the merged data.</p>
</li>
<li>
<p><code>MergingMaxIdle</code>: Represents the maximum idle timeout value of the merged data.</p>
</li>
<li>
<p><code>MergingCost</code>: Represents the memory costs for the merging process after a split-brain.</p>
</li>
<li>
<p><code>MergingVersion</code>: Represents the version of the merged data.</p>
</li>
<li>
<p><code>MergingExpirationTime</code>: Represents the expiration time of the merged data.</p>
</li>
<li>
<p><code>MergingLastStoredTime</code>: Represents the last stored time of the merged data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the following table shows the merge types provided by each data structure:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 19. Merge Types</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Data Structure</th>
<th class="tableblock halign-left valign-top">Merge Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IMap</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
<li>
<p><code>MergingCreationTime</code></p>
</li>
<li>
<p><code>MergingHits</code></p>
</li>
<li>
<p><code>MergingLastAccessTime</code></p>
</li>
<li>
<p><code>MergingLastUpdateTime</code></p>
</li>
<li>
<p><code>MergingTTL</code></p>
</li>
<li>
<p><code>MergingMaxIdle</code></p>
</li>
<li>
<p><code>MergingCosts</code></p>
</li>
<li>
<p><code>MergingVersion</code></p>
</li>
<li>
<p><code>MergingExpirationTime</code></p>
</li>
<li>
<p><code>MergingLastStoredTime</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ICache</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
<li>
<p><code>MergingCreationTime</code></p>
</li>
<li>
<p><code>MergingHits</code></p>
</li>
<li>
<p><code>MergingLastAccessTime</code></p>
</li>
<li>
<p><code>MergingLastUpdateTime</code></p>
</li>
<li>
<p><code>MergingTTL</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReplicatedMap</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
<li>
<p><code>MergingCreationTime</code></p>
</li>
<li>
<p><code>MergingHits</code></p>
</li>
<li>
<p><code>MergingLastAccessTime</code></p>
</li>
<li>
<p><code>MergingLastUpdateTime</code></p>
</li>
<li>
<p><code>MergingTTL</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MultiMap</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
<li>
<p><code>MergingCreationTime</code></p>
</li>
<li>
<p><code>MergingHits</code></p>
</li>
<li>
<p><code>MergingLastAccessTime</code></p>
</li>
<li>
<p><code>MergingLastUpdateTime</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IQueue</code>, <code>ISet</code>, <code>IList</code>, <code>Ringbuffer</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingValue</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IAtomicLong</code>, <code>IAtomicReference</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingValue</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CardinalityEstimator</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ScheduledExecutorService</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following sections show various examples on how to implement
merge type interfaces for all data structures, specific merge types or a specific data structure.</p>
</div>
</div>
<div class="sect4">
<h5 id="_accessing_deserialized_values"><a class="anchor" href="#_accessing_deserialized_values"></a>Accessing Deserialized Values</h5>
<div class="paragraph">
<p><code>MergingValue.getRawValue()</code> and <code>MergingEntry.getRawKey()</code> always return
the data in the in-memory format of the data structure.
For some data structure like <code>IMap</code> this depends on your configuration.
Other data structure like <code>ISet</code> or <code>IList</code> always use the <code>BINARY</code> in-memory format.</p>
</div>
<div class="paragraph">
<p>If you need the deserialized key or value, you have to call <code>MergingValue.getValue()</code> or
<code>MergingEntry.getKey()</code>.
The deserialization is done lazily on that method call, since it&#8217;s quite expensive and
should be avoided if the result is not needed.
This also requires the deserialized classes to be on the classpath of the server.
Otherwise a <code>ClassNotFoundException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>This is an example which checks if the (deserialized) value of
the <code>mergingValue</code> or <code>existingValue</code> is an <code>Integer</code>.
If so it is merged, otherwise <code>null</code> is returned (which  removes the entry):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MergeIntegerValuesMergePolicy&lt;V&gt; implements SplitBrainMergePolicy&lt;V, MergingValue&lt;V&gt;, Object&gt; {

    @Override
    public Object merge(MergingValue&lt;V&gt; mergingValue, MergingValue&lt;V&gt; existingValue) {
        Object mergingUserValue = mergingValue.getValue();
        Object existingUserValue = existingValue == null ? null : existingValue.getValue();
        System.out.println("========================== Merging..."
                + "\n    mergingValue: " + mergingUserValue
                + "\n    existingValue: " + existingUserValue
                + "\n    mergingValue class: " + mergingUserValue.getClass().getName()
                + "\n    existingValue class: " + (existingUserValue == null ? "null" : existingUserValue.getClass().getName())
        );
        if (mergingUserValue instanceof Integer) {
            return mergingValue.getRawValue();
        }
        return null;
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For data structures like <code>ISet</code> or <code>ICollection</code> you need a merge policy, which supports collections:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MergeCollectionOfIntegerValuesMergePolicy
        implements SplitBrainMergePolicy&lt;Collection&lt;Object&gt;, MergingValue&lt;Collection&lt;Object&gt;&gt;, Collection&lt;Object&gt;&gt; {

    @Override
    public Collection&lt;Object&gt; merge(MergingValue&lt;Collection&lt;Object&gt;&gt; mergingValue,
                                    MergingValue&lt;Collection&lt;Object&gt;&gt; existingValue) {
        Collection&lt;Object&gt; result = new ArrayList&lt;&gt;();
        for (Object value : mergingValue.getValue()) {
            if (value instanceof Integer) {
                result.add(value);
            }
        }
        if (existingValue != null) {
            for (Object value : existingValue.getValue()) {
                if (value instanceof Integer) {
                    result.add(value);
                }
            }
        }
        return result;
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also combine both merge policies to support single values and collections.
This merge policy is a bit more complex and less type safe, but can be configured on all data structures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MergeIntegerValuesMergePolicy2&lt;V, T extends MergingValue&lt;V&gt;&gt; implements SplitBrainMergePolicy&lt;V, T, Object&gt; {

    @Override
    public Object merge(T mergingValue, T existingValue) {
        if (mergingValue.getValue() instanceof Integer) {
            return mergingValue.getRawValue();
        }
        if (existingValue != null &amp;&amp; existingValue.getValue() instanceof Integer) {
            return existingValue.getRawValue();
        }
        if (mergingValue.getRawValue() instanceof Collection) {
            Collection&lt;Object&gt; result = new ArrayList&lt;&gt;();
            addIntegersToCollection(mergingValue, result);
            if (result.isEmpty() &amp;&amp; existingValue != null) {
                addIntegersToCollection(existingValue, result);
            }
            return result;
        }
        return null;
    }

    private void addIntegersToCollection(T mergingValue, Collection&lt;Object&gt; result) {
        for (Object value : (Collection&lt;Object&gt;) mergingValue.getValue()) {
            if (value instanceof Integer) {
                result.add(value);
            }
        }
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please have in mind that <code>existingValue</code> can be <code>null</code>, so a <code>null</code> check is
mandatory before calling <code>existingValue.getValue()</code> or <code>existingValue.getRawValue()</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you return <code>null</code> on a collection based data structure, the whole data structure will be removed.
An empty collection works in the same way, so you don&#8217;t have to check <code>Collection.isEmpty()</code> in your merge policy.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_accessing_hazelcast_usercontext"><a class="anchor" href="#_accessing_hazelcast_usercontext"></a>Accessing Hazelcast UserContext</h5>
<div class="paragraph">
<p>If you need access to external references in your merge policy,
you can use the Hazelcast <code>UserContext</code> to get them injected.
An example would be a database connection to check which value is stored in your database.
To achieve this your merge policy needs to implement <code>HazelcastInstanceAware</code> and
call <code>HazelcastInstance.getUserContext()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserContextMergePolicy&lt;V&gt; implements SplitBrainMergePolicy&lt;V, MergingValue&lt;V&gt;, Object&gt;, HazelcastInstanceAware {

    public static final String TRUTH_PROVIDER_ID = "truthProvider";

    private transient TruthProvider truthProvider;

    @Override
    public Object merge(MergingValue&lt;V&gt; mergingValue, MergingValue&lt;V&gt; existingValue) {
        Object mergingUserValue = mergingValue.getValue();
        Object existingUserValue = existingValue == null ? null : existingValue.getValue();
        boolean isMergeable = truthProvider.isMergeable(mergingUserValue, existingUserValue);
        System.out.println("========================== Merging..."
                        + "\n    mergingValue: " + mergingUserValue
                        + "\n    existingValue: " + existingUserValue
                        + "\n    isMergeable(): " + isMergeable
        );
        if (isMergeable) {
            return mergingValue.getRawValue();
        }
        return null;
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }

    @Override
    public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {
        ConcurrentMap&lt;String, Object&gt; userContext = hazelcastInstance.getUserContext();
        truthProvider = (TruthProvider) userContext.get(TRUTH_PROVIDER_ID);
    }

    public interface TruthProvider {

        boolean isMergeable(Object mergingValue, Object existingValue);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>UserContext</code> can be setup like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MergePolicyConfig mergePolicyConfig = new MergePolicyConfig()
  .setPolicy(UserContextMergePolicy.class.getName());

MapConfig mapConfig = new MapConfig("default")
  .setMergePolicyConfig(mergePolicyConfig);

ConcurrentMap&lt;String, Object&gt; userContext = new ConcurrentHashMap&lt;String, Object&gt;();
userContext.put(TruthProvider.TRUTH_PROVIDER_ID, new ExampleTruthProvider());

Config config = new Config()
  .addMapConfig(mapConfig)
  .setUserContext(userContext);

Hazelcast.newHazelcastInstance(config);</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The merge operations are executed on the partition threads.
Database accesses are slow compared to in-memory operations.
The <code>SplitBrainMergePolicy.merge()</code> method is called for every key-value pair or
every collection from your smaller cluster, which has a merge policy defined.
So there can be millions of database accesses due to a merge policy, which implements this.
Be aware that this can block your cluster for a long time or overload your database due to the high amount of queries.</p>
</div>
<div class="paragraph">
<p>Also the <code>com.hazelcast.core.LifeCycleEvent.MERGED</code> is thrown
after a timeout (we don&#8217;t wait forever for merge operations to continue).
At the moment this timeout is 500 milliseconds per merged item or entry, but at least 5 seconds.
If your database is slow, you might get the <code>LifeCycleEvent</code> while there are still merge operations in progress.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_merge_policies_with_multiple_merge_types"><a class="anchor" href="#_merge_policies_with_multiple_merge_types"></a>Merge Policies With Multiple Merge Types</h5>
<div class="paragraph">
<p>You can also write a merge policy, which requires multiple merge types.
This merge policy is supported by all data structures, which provide <code>MergingHits</code> and <code>MergingCreationTime</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ComposedHitsAndCreationTimeMergePolicy&lt;V, T extends MergingValue&lt;V&gt; &amp; MergingHits &amp; MergingCreationTime&gt;
        implements SplitBrainMergePolicy&lt;V, T, Object&gt; {

    @Override
    public Object merge(T mergingValue, T existingValue) {
        if (existingValue == null) {
            return mergingValue.getValue();
        }
        System.out.println("========================== Merging value " + mergingValue.getValue() + "..."
                + "\n    mergingValue creation time: " + mergingValue.getCreationTime()
                + "\n    existingValue creation time: " + existingValue.getCreationTime()
                + "\n    mergingValue hits: " + mergingValue.getHits()
                + "\n    existingValue hits: " + existingValue.getHits()
        );

        if (mergingValue.getCreationTime() &lt; existingValue.getCreationTime()
                &amp;&amp; mergingValue.getHits() &gt; existingValue.getHits()) {
            return mergingValue.getRawValue();
        }
        return existingValue.getRawValue();
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you configure this merge policy on a data structures, which does not provide these merge types,
you get an <code>InvalidConfigurationException</code> with a message like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>The merge policy org.example.merge.ComposedHitsAndCreationTimeMergePolicy
can just be configured on data structures which provide the merging type
com.hazelcast.spi.merge.MergingHits.
See SplitBrainMergingTypes for supported merging types.</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_merge_policies_for_specific_data_structures"><a class="anchor" href="#_merge_policies_for_specific_data_structures"></a>Merge Policies For Specific Data Structures</h5>
<div class="paragraph">
<p>It&#8217;s also possible to restrict a merge policy to a specific data structure.
This merge policy, for example, only works on <code>IMap</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MapEntryCostsMergePolicy implements SplitBrainMergePolicy&lt;Object, MapMergeTypes&lt;Object, Object&gt;, Object&gt; {

    @Override
    public Object merge(MapMergeTypes mergingValue, MapMergeTypes existingValue) {
        if (existingValue == null) {
            return mergingValue.getValue();
        }
        System.out.println("========================== Merging key " + mergingValue.getKey() + "..."
                + "\n    mergingValue costs: " + mergingValue.getCost()
                + "\n    existingValue costs: " + existingValue.getCost()
        );

        if (mergingValue.getCost() &gt; existingValue.getCost()) {
            return mergingValue.getRawValue();
        }
        return existingValue.getRawValue();
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you configure it on other data structures, you get an <code>InvalidConfigurationException</code> with a message like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>The merge policy org.example.merge.MapEntryCostsMergePolicy
can just be configured on data structures which provide the merging type
com.hazelcast.spi.merge.SplitBrainMergeTypes$MapMergeTypes.
See SplitBrainMergingTypes for supported merging types.</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is another example for a merge policy, which only works on
the <code>IAtomicReference</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AtomicReferenceMergeIntegerValuesMergePolicy
        implements SplitBrainMergePolicy&lt;Object, AtomicReferenceMergeTypes, Object&gt; {

    @Override
    public Object merge(AtomicReferenceMergeTypes mergingValue, AtomicReferenceMergeTypes existingValue) {
        Object mergingUserValue = mergingValue.getValue();
        Object existingUserValue = existingValue == null ? null : existingValue.getValue();
        System.out.println("========================== Merging..."
                + "\n    mergingValue: " + mergingUserValue
                + "\n    existingValue: " + existingUserValue
                + "\n    mergingValue class: " + mergingUserValue.getClass().getName()
                + "\n    existingValue class: " + (existingUserValue == null ? "null" : existingUserValue.getClass().getName())
        );
        if (mergingUserValue instanceof Integer) {
            return mergingValue.getRawValue();
        }
        return null;
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although every data structure supports <code>MergingValue</code>, which is
the only merge type of <code>AtomicReferenceMergeTypes</code>, this merge policy is restricted to <code>IAtomicReference</code> data structures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>The merge policy org.example.merge.AtomicReferenceMergeIntegerValuesMergePolicy
can just be configured on data structures which provide the merging type
com.hazelcast.spi.merge.SplitBrainMergeTypes$AtomicReferenceMergeTypes.
See SplitBrainMergingTypes for supported merging types.</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_best_practices_2"><a class="anchor" href="#_best_practices_2"></a>Best Practices</h5>
<div class="paragraph">
<p>Here are some best practices when implementing your own merge policy</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Only call <code>MergingValue.getValue()</code> and <code>MergingEntry.getKey()</code> when you really need
the deserialized value to save costs (CPU and memory) and avoid <code>ClassNotFoundException</code>.</p>
</li>
<li>
<p>If you want to return one of the given values (merging or existing),
it&#8217;s best to return <code>mergingValue.getRawValue()</code> or <code>existingValue.getRawValue()</code>,
since they are already in the correct in-memory format of the data structure.
If you return a deserialized value, it might need to be serialized again, which are avoidable costs.</p>
</li>
<li>
<p>Be careful with slow operations in the merge policy (like database accesses),
since they block your partition threads. Also the <code>LifeCycleEvent.MERGED</code> or
<code>LifeCycleEvent.MERGE_FAILED</code> may be thrown too early, if the merge operations take too long to finish.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_partial_network_partitions"><a class="anchor" href="#_partial_network_partitions"></a>28.5. Partial Network Partitions</h3>
<div class="paragraph">
<p>In some cases, detecting and handling network partitions are not very straightforward.
Because these kind of network partitions don&#8217;t cause a clearly separated, distinct groups.
But they create overlapping partitioned groups or worse, asymmetric communication failures
between members. This can be called as partial network partitioning.</p>
</div>
<div class="paragraph">
<p>Assume <code>[N1, N2, N3, N4]</code> is a cluster with four members. This is how a healthy cluster looks,
each member has a connection to other members:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/HealthyCluster.png" alt="Healthy Cluster">
</div>
</div>
<div class="paragraph">
<p>Assuming that <code>N2</code> becomes partitioned away from rest of the cluster when it disconnects from
the other members, two separate groups are formed: <code>[N1, N3, N4]</code> and <code>[N2]</code>.
This is called a full network partition:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/FullNetworkPartition.png" alt="Full Network Partition">
</div>
</div>
<div class="paragraph">
<p>But when <code>N2</code> cannot communicate only one or two of the rest, then there won&#8217;t be a clear
separation of partitioned groups. For instance when <code>N2</code> becomes disconnected from both
<code>N3</code> and <code>N4</code>, two overlapping healthy groups are formed: <code>[N1, N2]</code> and <code>[N1, N3, N4]</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/PartialNetworkPartition1.png" alt="Partial Network Partition">
</div>
</div>
<div class="paragraph">
<p>Or, when <code>N2</code> is disconnected only from <code>N1</code>, again two overlapping healthy groups are
formed, but this time with equal size: <code>[N1, N3, N4]</code> and <code>[N2, N3, N4]</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/PartialNetworkPartition1.png" alt="Partial Network Partition">
</div>
</div>
<div class="paragraph">
<p>Last two figures above are samples of the partial network partitioning. Our solution to
this problem is to figure out the largest set of fully-connected members and artificially separate
these members from the rest. This way we will have a completely separated set of members without
any intersection. This is the same problem with the <a href="https://en.wikipedia.org/wiki/Clique_problem" target="_blank" rel="noopener">maximum clique problem</a>
in graph theory. Hence we are using an implementation of the
<a href="https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm" target="_blank" rel="noopener">BronKerbosch algorithm</a>
to find the maximum clique.</p>
</div>
<div class="paragraph">
<p>Normally each Hazelcast member tracks the liveliness of other members using local failure detectors.
But they don&#8217;t share their failure detection knowledge with other cluster members. In order to
execute the BronKerbosch algorithm and figure out the largest set of fully-connected members,
we need to gather those local failure detection data from all members. When partial network
partitioning resolution mechanism is enabled, all members send their local failure detections
(suspicions about other members) inside the usual heartbeat message.
(See the <a href="#failure-detector-configuration">Failure Detector Configuration section</a>
for more info about failure detectors.) The master (oldest) member in the cluster gathers all this
information and executes the maximum clique algorithm and then decides the smallest set of Hazelcast members,
if any, to kick from the cluster so that the remaining members are fully-connected to each other again.
In a healthy cluster this set is empty.</p>
</div>
<div class="paragraph">
<p>This process has two properties to configure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.partial.member.disconnection.resolution.heartbeat.count</code>:  When the master receives
a heartbeat problem report from another member, it first waits for a number of heartbeat rounds
to allow other members to report their problems if there is any. After that, it takes all reports
received so far and checks if it can update the cluster member in a way that the minimum number of
members will be kicked from the cluster and there won&#8217;t be any heartbeat problem between the remaining members.</p>
<div class="paragraph">
<p>If this configuration option is set to <code>0</code>, this functionality is disabled. It is recommended to be
set to at least <code>3</code> or <code>5</code> so that the master will wait long enough to collect heartbeat problem reports.
Otherwise, the master member can make sub-optimal decisions. Default value is <code>0</code>.</p>
</div>
</li>
<li>
<p><code>hazelcast.partial.member.disconnection.resolution.algorithm.timeout.seconds</code>: The partial member
disconnection resolution mechanism uses a graph algorithm that finds a maximum clique in non-polynomial time.
Since it could take a lot of time to find a maximum clique in a large graph, i.e, in a large cluster with
lots of random network disconnections, we use a timeout mechanism to stop execution of the algorithm.
Default value is <code>5</code> seconds.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Partial network partition resolution mechanism is not enabled by default.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_system_properties"><a class="anchor" href="#_system_properties"></a>Appendix A: System Properties</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The table below lists the system properties with their descriptions in alphabetical order.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you want to reconfigure a system property,
you need to restart the members for which the property is modified.
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 20. System Properties</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 60%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Description</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.aggregation.accumulation.parallel.evaluation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether to run the aggregation accumulation for multiple entries in parallel.
Each Hazelcast IMDG member executes the accumulation stage of an
aggregation using a single thread by default. In most cases it is useful to do it in parallel.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.backpressure.backoff.timeout.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls the maximum timeout in milliseconds to wait for an invocation space to be available.
The value needs to be equal to or larger than 0.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.backpressure.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enable back pressure.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.backpressure.max.concurrent.invocations.per.partition</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum number of concurrent invocations per partition.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.backpressure.syncwindow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Used when back pressure is enabled.
The larger the sync window value, the less frequent an asynchronous backup is converted to a sync backup.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.cache.invalidation.batch.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether the cache invalidation event batch sending is enabled or not.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.cache.invalidation.batch.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Defines the maximum number of cache invalidation events to be drained and sent to the event listeners in a batch.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.cache.invalidation.batchfrequency.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Defines cache invalidation event batch sending frequency in seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.cleanup.period.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Period, in milliseconds, to check if a client is still part of the cluster.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.cleanup.timeout.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">120000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Timeout duration to decide if a client is still part of the cluster.
If a member cannot find any connection to a client in the cluster,
it cleans up the local resources that are owned by that client.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="client-max-no"></a> <code>hazelcast.client.max.no.heartbeat.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">300</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Time after which the member assumes the client is dead and closes its connections to the client.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.client.protocol.max.message.bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1024</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Client protocol message size limit (in bytes) for unverified connections. I.e. maximal length of the client authentication message.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.clientengine.blocking.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of threads that the client engine has available for
processing requests that are blocking, e.g., transactions. When
not set, it is set as the value of core size * 20.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.clientengine.query.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of threads to process query requests coming from the clients.
Default count is the number of cores multiplied by 1.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.clientengine.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum number of threads to process non-partition-aware client requests, like <code>map.size()</code>, executor tasks, etc.
Default count is the number of cores multiplied by 20.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.connect.all.wait.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">120</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Timeout to connect all other cluster members when a member is joining to a cluster.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.connection.monitor.interval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Minimum interval in milliseconds to consider a connection error as critical.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.connection.monitor.max.faults</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum I/O error count before disconnecting from a member.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.cluster.version.auto.upgrade.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether the automatic cluster version upgrading is enabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.cluster.version.auto.upgrade.min.cluster.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When set to a value greater than 1, automatic upgrading waits to reach that cluster size to proceed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.directory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>user.dir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Output directory of the diagnostic log files.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For detailed information on the diagnostic tool,
along with this and the following diagnostic related system properties, see the <a href="#diagnostics">Diagnostics section</a>.
</td>
</tr>
</table>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.concurrent.window.ms</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Property needed for concurrency detection so that write through can be done correctly.
This property sets the time window, in milliseconds, between the concurrency detection
and its notification. Normally in a concurrent system, the window
keeps sliding forward so it always remains concurrent.
Setting it too high effectively disables the optimization because once
a concurrency is detected it will keep that way. Setting it too low
could lead to suboptimal performance because the system
will try write through and other optimizations even though the system is concurrent.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether diagnostics tool is enabled or not for the cluster.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.filename.prefix</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Optional prefix for the diagnostics log file.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.invocation.sample.period.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Frequency of scanning all the pending invocations in seconds.
0 means the <code>Invocations</code> plugin for diagnostics tool is disabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.invocation.slow.threshold.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Threshold period, in seconds, that makes an invocation to be considered as slow.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.max.rolled.file.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Allowed count of diagnostic files within each roll.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.max.rolled.file.size.mb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Size of each diagnostic file to be rolled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.member-heartbeat.max-deviation-percentage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum allowed deviation for a member-to-member heartbeats.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.member-heartbeat.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Period for which the MemberHeartbeats plugin of the diagnostics tool runs.
0 means this plugin is disabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.memberinfo.period.second</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Frequency, in seconds, at which the cluster information is dumped to the diagnostics log file.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.metrics.period.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Frequency, in seconds, at which the Metrics plugin dumps information to the diagnostics log file.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.operation-heartbeat.max-deviation-percentage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">33</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum allowed deviation for a member-to-member operation heartbeats.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.operation-heartbeat.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Period, in seconds, for which the OperationHeartbeats plugin of the diagnostics tool runs.
0 means this plugin is disabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.pending.invocations.period.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Period, in seconds, for which the PendingInvocations plugin of the diagnostics tool runs.
0 means this plugin is disabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.slowoperations.period.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Period, in seconds, for which the SlowOperations plugin of the diagnostics tool runs.
0 means this plugin is disabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.storeLatency.period.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Period, in seconds, for which the StoreLatency plugin of the diagnostics tool runs.
0 means this plugin is disabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.storeLatency.reset.period.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Period, in seconds, for resetting the statistics for the StoreLatency plugin of the diagnostics tool.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.systemlog.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether the SystemLog plugin of the diagnostics tool is enabled or not.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.diagnostics.systemlog.partitions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether the SystemLog plugin collects information about partition migrations.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.discovery.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enables/disables the Discovery SPI lookup over the old native implementations.
See <a href="#discovery-spi">[discovery-spi]</a> for more information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.discovery.public.ip.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enable use of public IP address in member discovery with Discovery SPI.
If you set this property to true in your source cluster, please make sure you have set the public addresses for your
target members since they will be discovered using their public addresses. Otherwise, they cannot be discovered.
See the <a href="#public-address">Public Address section</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.dynamicconfig.ignore.conflicts</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether you want IMDG to ignore the configuration conflicts while registering a
new dynamic configuration. Set to <code>true</code> and restart your cluster with this property to
ignore these conflicts.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.enterprise.license.key</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://hazelcast.com/products/" target="_blank" rel="noopener">Hazelcast IMDG Enterprise</a> license key.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.event.queue.capacity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Capacity of internal event queue.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.event.queue.timeout.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">250</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Timeout to enqueue events to event queue.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.event.sync.timeout.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>To prevent overloading of the outbound connections,
once in a while an event is made synchronous by wrapping it in a
dummy operation and waiting for a dummy response. This causes
the outbound write queue of the connection to get drained.
This timeout configures the maximum amount of waiting time for this response.
Setting it to a too low value can lead to an uncontrolled growth
of the outbound write queue of the connection.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.event.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of event handler threads.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.graceful.shutdown.max.wait</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">600</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum wait in seconds during graceful shutdown.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.health.monitoring.delay.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Health monitoring logging interval in seconds. NOTE: For detailed information on
the health monitoring tool, along with this and the following health monitoring related system properties,
see the <a href="#health-check-and-monitoring">Health Check and Monitoring section</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.health.monitoring.level</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SILENT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Health monitoring log level. When <strong>SILENT</strong>, logs are printed only when values exceed some predefined threshold.
When <strong>NOISY</strong>, logs are always printed periodically. Set <strong>OFF</strong> to turn off completely.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.health.monitoring.threshold.cpu.percentage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">70</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When the health monitoring level is <strong>SILENT</strong>, logs are printed only when the CPU usage exceeds this threshold.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.health.monitoring.threshold.memory.percentage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">70</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When the health monitoring level is <strong>SILENT</strong>, logs are printed only when the memory usage exceeds this threshold.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.heartbeat.failuredetector.type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>deadline</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Type of the heartbeat failure detector. See the
<a href="#failure-detector-configuration">Failure Detector Configuration section</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.heartbeat.interval.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Heartbeat send interval in seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.hidensity.check.freememory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If enabled and is able to fetch memory statistics via Java&#8217;s <code>OperatingSystemMXBean</code>,
it checks whether there is enough free physical memory for the requested number of bytes.
If the free memory checker is disabled (false), acts as if the check is succeeded.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.hotrestart.free.native.memory.percentage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Percentage of the free memory space that is required by a hot restart.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.index.copy.behavior</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">COPY_ON_READ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Defines the behavior for index copying on index read/write.
See the <a href="#copying-indexes">Copying Indexes section</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.init.cluster.version</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Used to override the cluster version to use while an IMDG instance is not
member of a cluster yet. The cluster version assumed before joining
a cluster may affect the serialization format of the cluster discovery.
The default is to use the member&#8217;s codebase version. You may
need to override it for your member to join a cluster running on a
previous cluster version.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.initial.min.cluster.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Initial expected cluster size to wait before member to start completely.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.initial.wait.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Initial time in seconds to wait before member to start completely.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.internal.map.expiration.cleanup.operation.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Count of scannable partitions in each run of the background expiration task. No default value exists. It is
dynamically calculated against the partition count or partition thread count.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.internal.map.expiration.cleanup.percentage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Scannable percentage of the entries in the maps' partitions in each run of the background expiration task.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.internal.map.expiration.task.period.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Interval, in seconds, at which the background expiration task is going to run.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.invalidation.max.tolerated.miss.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If missed invalidation count is bigger than this value, relevant cached data is made unreachable.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.invalidation.reconciliation.interval.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Period for which the cluster members are scanned to compare generated invalidation events with the received ones from Near Cache.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.invocation.max.retry.count</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum number of retries for an invocation. After threshold is reached,
the invocation is assumed as failed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.invocation.retry.pause.millis</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Pause time between each retry cycle of an invocation in milliseconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.io.balancer.interval.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Interval in seconds between IOBalancer executions.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.io.input.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of socket input threads.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.io.output.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of socket output threads.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.io.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of threads performing socket input and socket output.
If, for example, the default value (3) is used, it means there are 3 threads performing input and 3 threads performing output (6 threads in total).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.io.write.through</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Optimization that allows sending of packets over the network to be done on the calling thread if the
conditions are right. This can reduce the latency and increase the performance for low threaded environments.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.jcache.provider.type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Type of the JCache provider. Values can be <code>client</code> or <code>server</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.jmx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enable <a href="#monitoring-with-jmx">JMX</a> agent.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.local.localAddress</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It is an overrider property for the default server socket listener&#8217;s IP address.
If this property is set, then this is the address where the server socket is bound to.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.local.publicAddress</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It is an overrider property for the default public address to be advertised to other cluster members and clients.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.lock.max.lease.time.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long.MAX_VALUE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>All locks which are acquired without an explicit lease time use this value (in seconds) as the lease time.
When you want to set an explicit lease time for your locks, you cannot set it to a longer time than this value.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.logging.details.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether the cluster name, IP and version should be included in
all log messages.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.logging.type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">jdk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">enum</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Name of <a href="#logging-configuration">logging</a> framework type to send logging events.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.entry.filtering.natural.event.types</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Notify <a href="#listening-to-map-entries-with-predicates">entry listeners with predicates</a> on map entry updates with
events that match entry, update or exit from predicate value space.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.expiry.delay.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Delays expiration of backup map entries by the defined amount.
This may be useful to prevent some cases where an entry might be observed
on the primary replica (partition owner) but not on the backup replica.
For instance, when running an entry processor on both primary and backup replicas.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.eviction.batch.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum number of IMap entries Hazelcast will evict during a
single eviction cycle. Eviction cycle is triggered by a map
mutation. Typically it is fine to evict at most a single entry.
However, when you insert values in a
loop, each iteration doubles the entry size. In this
situation more than just a single entry should be evicted.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.invalidation.batchfrequency.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the collected invalidations do not reach the configured batch size, a background process sends them at this interval.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.invalidation.batch.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enable or disable batching. When it is set to <code>false</code>, all invalidations are sent immediately.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.invalidation.batch.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum number of invalidations in a batch.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.load.chunk.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum size of the key batch sent to the partition owners for value loading and
the maximum size of a key batch for which values are loaded in a single partition.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.replica.scheduled.task.delay.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Scheduler delay for map tasks those are executed on backup members.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.write.behind.queue.capacity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum write-behind queue capacity per member. It is the total of all write-behind queue sizes in a member including backups.
Its maximum value is <code>Integer.MAX_VALUE</code>.
The value of this property is taken into account only if the <code>write-coalescing</code> element of the
Map Store configuration is <code>false</code>. See <a href="#setting-write-behind-persistence">here</a> for the description of the <code>write-coalescing</code> element.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.max.join.merge.target.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Split-brain merge timeout for a specific target.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.max.join.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">300</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Join timeout, maximum time to try to join before giving.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.max.no.heartbeat.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum timeout of heartbeat in seconds for a member to assume it is dead.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Setting this value too low may cause members to be evicted from the cluster when
they are under heavy load: they will be unable to send heartbeat operations in time, so other members will assume that it is dead.
</td>
</tr>
</table>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.max.wait.seconds.before.join</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum wait time before join operation.
This is an upper limit on the cluster&#8217;s pre-join phase duration. The pre-join
phase starts when the master receives the first join request, and ends after
no new members have tried to join for <code>hazelcast.wait.seconds.before.join</code>
seconds, or after this upper limit elapsed (whichever comes first). Once the
pre-join phase ends, the master moves into the join phase, during which it
will only admit members that have already tried joining during the pre-join
phase and are still trying to. Once the join phase is complete, the master
will again start admitting new members.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.mc.executor.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of threads that the Management Center service has available
for processing the operations sent from the connected Management Center instance.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.mc.max.visible.slow.operations.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Management Center maximum visible slow operations count.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.member.list.publish.interval.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Interval at which master member publishes a member list.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.member.naming.moby.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Defines whether the Moby naming should be used for generating instance
names when they are not provided by user. Moby name is a short human-readable
name consisting of a randomly chosen adjective and the surname of a famous person.
If set to <code>true</code>, a Moby name is generated. Otherwise, a name that is concatenation
of a static prefix, number and cluster name is provided.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.merge.first.run.delay.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">300</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Initial run delay of <a href="#split-brain-syndrome">split-brain/merge process</a> in seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.merge.next.run.delay.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">120</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Run interval of <a href="#split-brain-syndrome">split-brain/merge process</a> in seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.metrics.collection.frequency</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Frequency, in seconds, of the <a href="#metrics">metrics</a> collection cycle. Note that
the preferred way for controlling this setting is <a href="#metrics-configuration">Metrics Configuration</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.metrics.datastructures.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether collecting metrics from the distributed data structures is enabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.metrics.debug.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enables collecting debug metrics if set to <code>true</code>, disables it otherwise.
Note that this is meant to be enabled only if diagnostics feature is enabled,
since currently only this feature consumes the debug metrics.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.metrics.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enables the <a href="#metrics">metrics collection</a> if set to <code>true</code>, disables it otherwise. Note that the preferred way for
controlling this setting is <a href="#metrics-configuration">Metrics Configuration</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.metrics.mc.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enables buffering the collected <a href="#metrics">metrics</a> for Management Center if set to <code>true</code>, disables it otherwise. Note that
the preferred way for controlling this setting is <a href="#metrics-configuration">Metrics Configuration</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.metrics.mc.retention</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Duration, in seconds, that the <a href="#metrics">metrics</a> are retained for Management Center. Note that
the preferred way for controlling this setting is <a href="#metrics-configuration">Metrics Configuration</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.metrics.jmx.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enables exposing the collected <a href="#metrics">metrics</a> over JMX if set to <code>true</code>, disables it otherwise. Note that
the preferred way for controlling this setting is <a href="#metrics-configuration">Metrics Configuration</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.network.stats.refresh.interval.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Interval, in seconds, at which the network statistics (bytes sent and received)
are re-calculated and published. It is valid only when
<a href="#advanced-network-configuration">advanced networking</a> is used.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.nio.tcp.spoofing.checks</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls whether more strict checks upon BIND requests towards a cluster member are applied.
The checks mainly validate the remote BIND request against the remote address as found in the socket.
By default they are disabled, to avoid connectivity issues when deployed under NAT&#8217;ed infrastructure.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.operation.backup.timeout.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum time a caller to wait for backup responses of an operation.
After this timeout, operation response is returned to the caller even no backup response is received.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.operation.call.timeout.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Timeout to wait for a response when a remote call is sent, in milliseconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.operation.fail.on.indeterminate.state</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When enabled, an operation fails with <code>IndeterminateOperationStateException</code>,
if it does not receive backup acks in time with respect to backup configuration of
its data structure, or the member which owns primary replica of the target partition leaves the cluster.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.operation.generic.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of generic operation handler threads. <code>-1</code> means CPU core count / 2.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.operation.priority.generic.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of priority generic operation handler threads per member.
Having at least 1 priority generic operation thread helps to improve
cluster stability since a lot of cluster operations are generic priority
operations and they should get executed as soon as possible. If there is
a dedicated generic operation thread then these operations don&#8217;t get delayed
because the generic threads are busy executing regular user operations.
So unless memory consumption is an issue, make sure there is at least 1 thread.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.operation.response.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of threads the process responses.
The default value gives stable and good performance.
If set to 0, the response threads are bypassed and the
response handling is done on the IO threads. Under certain
conditions this can give a higher throughput.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.operation.responsequeue.idlestrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">block</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether the response thread for internal operations on the member side are blocked or not.
If you use <code>block</code> (the default value) the thread is blocked and need to be notified which can cause
a reduction in the performance. If you use <code>backoff</code> there is no blocking.
By enabling the backoff mode and depending on your use case, you can get a 5-10% performance improvement.
However, keep in mind that this increases the CPU utilization.
We recommend you to use backoff with care and if you have a tool for measuring your cluster&#8217;s performance.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.operation.thread.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Number of partition based operation handler threads. <code>-1</code> means CPU core count.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partial.member.disconnection.resolution.algorithm.timeout.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Timeout, in seconds, to stop the execution of resolution algorithm when needed,
in the case of lots of possible random network disconnections especially
in the large clusters.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partial.member.disconnection.resolution.heartbeat.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When the master (oldest member in the cluster) receives a heartbeat
problem report from another member, it first waits for a number
of heartbeat rounds to allow other members
to report their problems, if there is any. This property sets the number
of these rounds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partition.backup.sync.interval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Interval for syncing backup replicas in seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partition.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Total partition count.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partition.max.parallel.replications</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum number of parallel partition backup replication operations per member.
When a partition backup ownership changes or a backup inconsistency is detected, the members start to sync their backup partitions.
This parameter limits the maximum running replication operations in parallel.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partition.migration.fragments.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When enabled, which is the default behavior, partitions are migrated/replicated in small fragments instead of one big chunk.
Migrating partitions in fragments reduces pressure on the memory and network
since smaller packets are created in the memory and sent through the network.
Note that it can increase the migration time to complete.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partition.migration.interval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Interval to run partition migration tasks in seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partition.migration.stale.read.disabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Hazelcast allows read operations to be performed while a partition is being migrated.
This can lead to stale reads for some scenarios.
You can disable stale read operations by setting this system property&#8217;s value to "true".
Its default value is "false", meaning that stale reads are allowed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partition.migration.timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">300</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Timeout for partition migration tasks in seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partition.table.send.interval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Interval for publishing partition table periodically to all cluster members in seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.partitioning.strategy.class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Class name implementing <code>com.hazelcast.core.PartitioningStrategy</code>, which defines key to partition mapping.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.phone.home.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enable or disable the sending of phone home data to Hazelcast&#8217;s phone home server.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.prefer.ipv4.stack</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Prefer IPv4 network interface when picking a local address.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.query.max.local.partition.limit.for.precheck</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maximum value of local partitions to trigger local pre-check for <code>Predicates#alwaysTrue()</code>
query operations on maps.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.query.optimizer.type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RULES</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Type of the query optimizer. For optimizations based on static rules, set the value to <code>RULES</code>.
To disable the optimization, set the value to <code>NONE</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="parallel-predicates"></a> <code>hazelcast.query.predicate.parallel.evaluation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Each Hazelcast member evaluates query predicates using a single thread by default.
In most cases, the overhead of inter-thread communications overweight can benefit from parallel execution.
When you have a large dataset and/or slow predicate, you may benefit from parallel predicate evaluations.
Set to <code>true</code> if you are using slow predicates or have &gt; 100,000s entries per member.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.query.result.size.limit</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Result size limit for query operations on maps.
This value defines the maximum number of returned elements for a single query result.
If a query exceeds this number of elements, a QueryResultSizeExceededException is thrown.
Its default value is -1, meaning it is disabled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.serialization.version</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Version of the Hazelcast serialization. Accepted values are between 1 and
the highest supported serialization version.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.shutdownhook.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enable Hazelcast shutdownhook thread.
When this is enabled, this thread terminates the Hazelcast instance without waiting to shutdown gracefully.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.shutdownhook.policy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TERMINATE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the behavior when JVM is exiting while the Hazelcast instance is still running.
It has two values: TERMINATE and GRACEFUL. The former one terminates the Hazelcast instance immediately.
The latter, GRACEFUL, initiates the graceful shutdown which can significantly slow down the JVM exit process, but it tries to retain data safety.
Note that you should always shutdown Hazelcast explicitly via using the method <code>HazelcastInstance.shutdown()</code>.
It&#8217;s not recommended to rely on the shutdown hook, this is a last-effort measure.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.slow.operation.detector.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enables/disables the <a href="#slowoperationdetector">SlowOperationDetector</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.slow.operation.detector.log.purge.interval.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">300</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Purge interval for slow operation logs.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.slow.operation.detector.log.retention.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3600</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Defines the retention time of invocations in slow operation logs.
If an invocation is older than this value, it is purged from the log to prevent unlimited memory usage.
When all invocations are purged from a log, the log itself is deleted.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.slow.operation.detector.stacktrace.logging.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Defines if the stacktraces of slow operations are logged in the log file.
Stack traces are always reported to the Management Center, but by default, they are not printed to keep the log size small.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.slow.operation.detector.threshold.millis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Defines a threshold above which a running operation in <code>OperationService</code> is considered to be slow.
These operations log a warning and are shown in the Management Center with detailed information, e.g., stacktrace.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.bind.any</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Bind both server-socket and client-sockets to any local interface.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.buffer.direct</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether the byte buffers used in the socket should be a direct byte buffer (<code>true</code>) or a regular one (<code>false</code>).
When it is set to <code>true</code>, Hazelcast internally uses the method <code>ByteBuffer.allocateDirect</code> (instead of <code>ByteBuffer.allocate</code>) which makes use of
the off-heap and may skip the memory copying when performing socket I/O operations.
See <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html" target="_blank" rel="noopener">here</a> for more information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.client.bind</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Bind client socket to an interface when connecting to a remote server socket.
When set to <code>false</code>, client socket is not bound to any interface.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.client.bind.any</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Bind client-sockets to any local interface. If not set, <code>hazelcast.socket.bind.any</code> is used as the default.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.client.receive.buffer.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Hazelcast creates all connections with receive buffer size set according to the <code>hazelcast.socket.receive.buffer.size</code>.
When it detects a connection opened by a client, then it adjusts the receive buffer size according to this property.
It is in kilobytes and its default value is -1.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.client.send.buffer.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Hazelcast creates all connections with send buffer size set according to the <code>hazelcast.socket.send.buffer.size</code>.
When it detects a connection opened by a client, then it adjusts the send buffer size according to this property.
It is in kilobytes and its  default value is -1.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.connect.timeout.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Socket connection timeout in seconds. <code>Socket.connect()</code> is blocked until
either connection is established or connection is refused or this timeout passes.
Default is 0, means infinite.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.keep.alive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Socket set keep alive (<code>SO_KEEPALIVE</code>).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.linger.seconds</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Set socket <code>SO_LINGER</code> option.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.no.delay</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Socket set TCP no delay.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.receive.buffer.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Socket receive buffer (<code>SO_RCVBUF</code>) size in KB.
If you have a very fast network, e.g., 10gbit) and/or you have large entries, then you may benefit from increasing sender/receiver buffer sizes.
Use this property and the next one below tune the size.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.send.buffer.size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Socket send buffer (<code>SO_SNDBUF</code>) size in KB.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.socket.server.bind.any</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Bind server-socket to any local interface. If not set, <code>hazelcast.socket.bind.any</code> is used as the default.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.tcp.join.port.try.count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of incremental ports, starting with the port number defined in the network configuration,
that is used to connect to a host (which is defined without a port in TCP/IP member list while a member is searching for a cluster).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.wait.seconds.before.join</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Wait time before join operation.
This time establishes a pre-join phase time window for newcomer members to
make their first join requests. Once <code>hazelcast.wait.seconds.before.join</code>
elapses since the last first-timer join request (i.e., where the member hasn&#8217;t
made any previous join request), or the pre-join phase has lasted for
<code>hazelcast.max.wait.seconds.before.join</code> seconds, the phase ends and the
master starts forming the cluster.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_migration_guides"><a class="anchor" href="#_migration_guides"></a>Appendix B: Migration Guides</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This appendix provides guidelines when upgrading to a new Hazelcast IMDG version.
See also the <a href="https://docs.hazelcast.org/docs/rn/index.html" target="_blank" rel="noopener">release notes</a> document
for the changes for each Hazelcast IMDG release.</p>
</div>
<div class="sect2">
<h3 id="_upgrading_to_hazelcast_imdg_4_0"><a class="anchor" href="#_upgrading_to_hazelcast_imdg_4_0"></a>B.1. Upgrading to Hazelcast IMDG 4.0</h3>
<div class="paragraph">
<p>This section provides the guidelines for you
when migrating to Hazelcast IMDG 4.0</p>
</div>
<div class="sect3">
<h4 id="_upgrading_to_4_0_from_prior_versions_3_x"><a class="anchor" href="#_upgrading_to_4_0_from_prior_versions_3_x"></a>B.1.1. Upgrading to 4.0 from Prior Versions (3.x)</h4>
<div class="paragraph">
<p>IMDG 4.0 is a major version release. The last major version release was over five years ago.
Major releases allow us to break compatibility in the wire protocols and API, as well as removing
the previously deprecated API.</p>
</div>
<div class="paragraph">
<p>As breaking changes have been made to the client and cluster member protocols, it is not possible
to perform any in-place or rolling upgrade from a running IMDG 3.x cluster to IMDG 4.x.
The only way to upgrade to IMDG 4.x is to completely shutdown the cluster.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_hazelcast_client_module"><a class="anchor" href="#_removal_of_hazelcast_client_module"></a>B.1.2. Removal of Hazelcast Client Module</h4>
<div class="ulist">
<ul>
<li>
<p>The <code>hazelcast-client</code> module has been merged into the core module: All the classes
in the <code>hazelcast-client</code> module have been moved to <code>hazelcast</code>.
<code>hazelcast-client.jar</code> will not be created anymore.</p>
</li>
<li>
<p>Also the <code>com.hazelcast.client</code> Java module is not used anymore. All classes
are now available within the <code>com.hazelcast.core</code> module.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_jcache_default_caching_provider"><a class="anchor" href="#_jcache_default_caching_provider"></a>B.1.3. JCache default Caching Provider</h4>
<div class="paragraph">
<p>The default <code>CachingProvider</code> is the client-side <code>CachingProvider</code>. In order to select the
member-side <code>CachingProvider</code>, you can specify the member-side <code>CachingProvider</code> by defining
the Hazelcast property <code>hazelcast.jcache.provider.type</code>. See the <a href="#configuring-jcache-provider">Configuring JCache Provider</a> section for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_user_defined_services"><a class="anchor" href="#_removal_of_user_defined_services"></a>B.1.4. Removal of User Defined Services</h4>
<div class="paragraph">
<p>Hazelcast IMDG&#8217;s public SPI (Service Provider Interface) which was known as
User Defined Service has been removed. It was not simple enough and
backwards compatibility was broken. A new and clearly
defined SPI may be developed in the future if there is enough interest.
The removed SPI&#8217;s classes will be kept to be used internally.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_client_connection_retry_mechanism"><a class="anchor" href="#_changes_in_client_connection_retry_mechanism"></a>B.1.5. Changes in Client Connection Retry Mechanism</h4>
<div class="ulist">
<ul>
<li>
<p>The <code>connection-attempt-period</code> and <code>connection-attempt-limit</code>
configuration have been removed. Instead, the elements of
<code>connection-retry</code> are now used. See the <a href="#configuring-client-connection-retry">[configuring-client-connection-retry]</a>
for the usage of those new elements.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_increasing_the_memberclient_thread_counts"><a class="anchor" href="#_increasing_the_memberclient_thread_counts"></a>B.1.6. Increasing the Member/Client Thread Counts</h4>
<div class="paragraph">
<p>If there are 20 or more processors detected, the Hazelcast member
by default starts 4+4 (4 input and 4 output) I/O threads.
This is to increase out of the box performance on faster machines
because often (especially the cache with
caching situations) the performance is I/O bound and
having some extra cores available for I/O can make a significant
difference. If less than 20 cores are detected, 3+3 IO threads are used
and the behavior remains the same as Hazelcast IMDG 3.x series.</p>
</div>
<div class="paragraph">
<p>A smart client, by default, gets 3+3 (3 input and 3 output) I/O threads to
speed up the performance. Before Hazelcast IMDG 4.0, this was
1+1. However, the client I/O can become a bottleneck with too few threads.
If TLS/SSL is enabled, then by default a smart client
makes use of 3+3 I/O threads which was already the case with previous versions.</p>
</div>
<div class="paragraph">
<p>There is a new performance feature in Hazelcast IMDG 4.0 called
thread overcommit. By default, Hazelcast creates more
threads than it has cores, e.g., on a 20 cores machine it creates 28 threads;
20 threads for the partition operations
and 4+4 threads for I/O. In case of a typical caching usage (get/put/set, etc.)
having too many threads can cause a performance
degradation due to increased context switching. So there is
a new option called <code>hazelcast.operation.thread.overcommit</code>.
If this property is set to true, i.e., <code>-Dhazelcast.operation.thread.overcommit=true</code>,
which is the default, Hazelcast uses the old style thread
configuration where there are more threads than cores. If set to false,
the number of partition threads plus the I/O threads will be equal to the  core count.
It depends on the environment if this gives a performance boost or not.
In some environments it can give a significant boost
and in some it will give a significant loss; it is best to benchmark
for your specific situation. If you are doing lots of queries or other tasks
which are CPU-bound, e.g aggregations, you probably want to have as many cores available to partition
operations as possible.</p>
</div>
<div class="paragraph">
<p>See the <a href="#threading-model">Threading Model section</a> for more information on Hazelcast IMDG&#8217;s threading model.</p>
</div>
</div>
<div class="sect3">
<h4 id="_optimizing_for_single_threaded_usages"><a class="anchor" href="#_optimizing_for_single_threaded_usages"></a>B.1.7. Optimizing for Single Threaded Usages</h4>
<div class="paragraph">
<p>A write-through optimization has been performed. This helps to reduce the
latency in case of single threaded usages.</p>
</div>
<div class="paragraph">
<p>Normally, when a request is made, the request is handed over the
I/O system where an I/O thread takes care of sending it over the wire.
This is great for throughput, but in case of single threaded setups,
it adds to the latency and therefore it reduces the throughput because threads
need to be notified.</p>
</div>
<div class="paragraph">
<p>With this release, Hazelcast IMDG detects the single threaded usage
and tries to write through to the socket directly instead of handing
it over to the I/O thread; this optimization is called "write-through".</p>
</div>
<div class="paragraph">
<p>This technique is being applied on the client, but also on the member.
We have something similar when responses are received: normally a
response is processed by the response thread, but in case of
a single threaded usage, the response is processed on the I/O thread
so we can remove a thread notification and therefore get higher throughput.</p>
</div>
<div class="paragraph">
<p>Both the write-through and response-through are enabled by default.
If Hazelcast IMDG detects that there are many active threads,
response- and write-through are disabled so it won&#8217;t cause a performance
degradation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removing_deprecated_client_configurations"><a class="anchor" href="#_removing_deprecated_client_configurations"></a>B.1.8. Removing Deprecated Client Configurations</h4>
<div class="paragraph">
<p>The following methods of <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/client/config/ClientConfig.html" target="_blank" rel="noopener">ClientConfig</a> have been refactored:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>addNearCacheConfig(String, NearCacheConfig)</code> &#8594; <code>addNearCacheConfig(NearCacheConfig)</code></p>
</li>
<li>
<p><code>setSmartRouting(boolean)</code> &#8594; <code>getNetworkConfig().setSmartRouting(boolean);</code></p>
</li>
<li>
<p><code>getSocketInterceptorConfig()</code> &#8594; <code>getNetworkConfig().getSocketInterceptorConfig();</code></p>
</li>
<li>
<p><code>setSocketInterceptorConfig(SocketInterceptorConfig)</code> &#8594; <code>getNetworkConfig().setSocketInterceptorConfig(SocketInterceptorConfig);</code></p>
</li>
<li>
<p><code>getConnectionTimeout()</code> &#8594; <code>getNetworkConfig().getConnectionTimeout();</code></p>
</li>
<li>
<p><code>setConnectionTimeout(int)</code> &#8594; <code>getNetworkConfig().setConnectionTimeout(int);</code></p>
</li>
<li>
<p><code>addAddress(String)</code> &#8594; <code>getNetworkConfig().addAddress(String);</code></p>
</li>
<li>
<p><code>getAddresses()</code> &#8594; <code>getNetworkConfig().getAddresses();</code></p>
</li>
<li>
<p><code>setAddresses(List)</code> &#8594; <code>getNetworkConfig().setAddresses(List);</code></p>
</li>
<li>
<p><code>isRedoOperation()</code> &#8594; <code>getNetworkConfig().isRedoOperation();</code></p>
</li>
<li>
<p><code>setRedoOperation(boolean)</code> &#8594; <code>getNetworkConfig().setRedoOperation(boolean);</code></p>
</li>
<li>
<p><code>getSocketOptions()</code> &#8594; <code>getNetworkConfig().getSocketOptions();</code></p>
</li>
<li>
<p><code>setSocketOptions()</code> &#8594; <code>getNetworkConfig().setSocketOptions(SocketOptions);</code></p>
</li>
<li>
<p><code>setSocketOptions()</code> &#8594; <code>getNetworkConfig().setSocketOptions(SocketOptions);</code></p>
</li>
<li>
<p><code>getNetworkConfig().setAwsConfig(new ClientAwsConfig());</code> &#8594; <code>getNetworkConfig().setAwsConfig(new AwsConfig());</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also the <code>ClientAwsConfig</code> class has been renamed as <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/AwsConfig.html" target="_blank" rel="noopener">AwsConfig</a>.</p>
</div>
<div class="paragraph">
<p>The naming for the declarative configuration elements have not been changed.
See the <a href="https://docs.hazelcast.org/docs/rn/#4-0-beta-1" target="_blank" rel="noopener">Release Notes</a> for
new/removed configuration features.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after configuration samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Adding Near Cache</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
clientConfig.addNearCacheConfig("myCache", new NearCacheConfig());</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
NearCacheConfig nearCacheConfig = new NearCacheConfig("myCache");
clientConfig.addNearCacheConfig(nearCacheConfig);</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Programmatic Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
            clientConfig.setSmartRouting(true);
            clientConfig.isSmartRouting();
            clientConfig.getSocketInterceptorConfig();
            clientConfig.setSocketInterceptorConfig(new SocketInterceptorConfig());
            clientConfig.getConnectionTimeout();
            clientConfig.setConnectionTimeout(1000);
            clientConfig.addAddress("127.0.0.1:5701");
            clientConfig.getAddresses();
            clientConfig.setAddresses(Collections.singletonList("127.0.0.1:5701"));
            clientConfig.isRedoOperation();
            clientConfig.setRedoOperation(true);
            clientConfig.getSocketOptions();
            clientConfig.setSocketOptions(new SocketOptions());
            clientConfig.getNetworkConfig().setAwsConfig(new ClientAwsConfig());
            ClientAwsConfig awsConfig = clientConfig.getNetworkConfig().getAwsConfig();
        }</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
            clientConfig.getNetworkConfig().setSmartRouting(true);
            clientConfig.getNetworkConfig().isSmartRouting();
            clientConfig.getNetworkConfig().getSocketInterceptorConfig();
            clientConfig.getNetworkConfig().setSocketInterceptorConfig(new SocketInterceptorConfig());
            clientConfig.getNetworkConfig().getConnectionTimeout();
            clientConfig.getNetworkConfig().setConnectionTimeout(1000);
            clientConfig.getNetworkConfig().addAddress("127.0.0.1:5701");
            clientConfig.getNetworkConfig().getAddresses();
            clientConfig.getNetworkConfig().setAddresses(Collections.singletonList("127.0.0.1:5701"));
            clientConfig.getNetworkConfig().isRedoOperation();
            clientConfig.getNetworkConfig().setRedoOperation(true);
            clientConfig.getNetworkConfig().getSocketOptions();
            clientConfig.getNetworkConfig().setSocketOptions(new SocketOptions());
            clientConfig.getNetworkConfig().setAwsConfig(new AwsConfig());
            AwsConfig awsConfig = clientConfig.getNetworkConfig().getAwsConfig();
        }</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_changes_in_index_configuration"><a class="anchor" href="#_changes_in_index_configuration"></a>B.1.9. Changes in Index Configuration</h4>
<div class="paragraph">
<p>In order to support further extensibility of Hazelcast,
index configuration has been refactored.</p>
</div>
<div class="paragraph">
<p>Index type is now defined through the <code>IndexType</code> enumeration
instead of the boolean flag: ordered index is now referred to as
<code>IndexType.SORTED</code>, unordered as <code>IndexType.HASH</code>.</p>
</div>
<div class="paragraph">
<p>In composite indexes, index parts are now defined as
a list of strings instead of a single string with comma-separated values.</p>
</div>
<div class="paragraph">
<p>With these changes, the following configuration parameters
have been renamed:</p>
</div>
<div class="paragraph">
<p><strong>Programmatic configuration objects and methods:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MapIndexConfig</code> &#8594; <code>IndexConfig</code></p>
</li>
<li>
<p><code>MapConfig.getMapIndexConfig</code> &#8594; <code>MapConfig.getIndexConfig</code></p>
</li>
<li>
<p><code>MapConfig.setMapIndexConfig</code> &#8594; <code>MapConfig.setIndexConfig</code></p>
</li>
<li>
<p><code>MapConfig.addMapIndexConfig</code> &#8594; <code>MapConfig.addIndexConfig</code></p>
</li>
<li>
<p><code>IMap.addIndex(String, boolean)</code> &#8594; <code>IMap.addIndex(IndexConfig)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the following table for the before/after samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Programmatic Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">MapIndexConfig indexConfig = new MapIndexConfig();
indexConfig.setOrdered(false);
indexConfig.setAttribute("name, age");

MapConfig mapConfig = new MapConfig();
mapConfig.addMapIndexConfig(indexConfig);</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">IndexConfig indexConfig = new IndexConfig();
indexConfig.setType(IndexType.HASH);
indexConfig.addAttribute("name");
indexConfig.addAttribute("age");

MapConfig mapConfig = new MapConfig();
mapConfig.addIndexConfig(indexConfig);</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Declarative Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="person"&gt;
        &lt;indexes&gt;
            &lt;index ordered="false"&gt;name, age&lt;/index&gt;
        &lt;/indexes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="person"&gt;
        &lt;indexes&gt;
            &lt;index type="HASH"&gt;
                &lt;attributes&gt;
                    &lt;attribute&gt;name&lt;/attribute&gt;
                    &lt;attribute&gt;age&lt;/attribute&gt;
                &lt;/attributes&gt;
            &lt;/index&gt;
        &lt;/indexes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Dynamic Index Create</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">IMap map;

map.addIndex("name, age", false);</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">IMap map;

map.addIndex(new IndexConfig(IndexType.HASH, "name", "age"));</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_changes_in_custom_attributes"><a class="anchor" href="#_changes_in_custom_attributes"></a>B.1.10. Changes in Custom Attributes</h4>
<div class="paragraph">
<p><a href="#custom-attributes">Custom attributes</a> are referenced in
predicates, queries and indexes. Some improvements have been
performed in Hazelcast&#8217;s query engine and one of the results
is the change in custom attribute configurations.</p>
</div>
<div class="paragraph">
<p>With this change, the following configuration parameters
have been renamed:</p>
</div>
<div class="paragraph">
<p><strong>Declarative configuration elements:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>extractor</code> &#8594; <code>extractor-class-name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Programmatic configuration objects and methods:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MapAttributeConfig</code> &#8594; <code>AttributeConfig</code></p>
</li>
<li>
<p><code>setExtractor()</code> &#8594; <code>setExtractorClassName()</code></p>
</li>
<li>
<p><code>addMapAttributeConfig()</code> &#8594; <code>addAttributeConfig()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the following table for the before/after samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Programmatic Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">MapAttributeConfig attributeConfig = new MapAttributeConfig();
attributeConfig.setName("currency");
attributeConfig.setExtractor("com.bank.CurrencyExtractor");

MapConfig mapConfig = new MapConfig();
mapConfig.addMapAttributeConfig(attributeConfig);</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">AttributeConfig attributeConfig = new AttributeConfig();
attributeConfig.setName("currency");
attributeConfig.setExtractorClassName("com.bank.CurrencyExtractor");

MapConfig mapConfig = new MapConfig();
mapConfig.addAttributeConfig(attributeConfig);</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Declarative Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="trades"&gt;
        &lt;attributes&gt;
            &lt;attribute extractor="com.bank.CurrencyExtractor"&gt;currency&lt;/attribute&gt;
        &lt;/attributes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="trades"&gt;
        &lt;attributes&gt;
            &lt;attribute extractor-class-name="com.bank.CurrencyExtractor"&gt;currency&lt;/attribute&gt;
        &lt;/attributes&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Also, some custom query attribute classes were previously abstract classes
with one abstract method. They have been converted into functional interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/query/extractor/ValueCallback.html" target="_blank" rel="noopener">ValueCallback</a></p>
</li>
<li>
<p><a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/query/extractor/ValueExtractor.html" target="_blank" rel="noopener">ValueExtractor</a></p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Implementing <code>ValueExtractor</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public static class PortableNameExtractor extends ValueExtractor&lt;ValueReader, Object&gt; {
    @Override
    public void extract(ValueReader target, Object argument, ValueCollector collector) {
        target.read("name", new ValueCallback&lt;Object&gt;() {
            @Override
            public void onResult(Object value) {
                collector.addObject(value);
            }
        });
    }
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public static class PortableNameExtractor implements ValueExtractor&lt;ValueReader, Object&gt; {
    @Override
    public void extract(ValueReader target, Object argument, ValueCollector collector) {
        target.read("name", (ValueCallback) value -&gt; collector.addObject(value));
    }
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_removal_of_mapreduce"><a class="anchor" href="#_removal_of_mapreduce"></a>B.1.11. Removal of MapReduce</h4>
<div class="paragraph">
<p>MapReduce API has been removed, which was deprecated
since Hazelcast IMDG 3.8. Instead, you can use the
<a href="#aggregations">Aggregations</a> on top of Query infrastructure and the
<a href="https://docs.hazelcast.org/docs/jet/latest/manual/" target="_blank" rel="noopener">Hazelcast Jet</a>
distributed computing platform as its successors and replacements.</p>
</div>
<div class="paragraph">
<p>See the following table for the before(MapReduce)/after(Hazelcast Jet)
word count sample.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0 (MapReduce)</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0 (Hazelcast Jet)</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Word Count Sample</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">JobTracker tracker = hazelcastInstance.getJobTracker("default");

IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
KeyValueSource&lt;String, String&gt; source = KeyValueSource.fromMap(map);

Job&lt;String, String&gt; job = tracker.newJob(source);
ICompletableFuture&lt;Map&lt;String, Integer&gt;&gt; future = job
           .mapper(new TokenizerMapper())
           .combiner(new WordcountCombinerFactory())
           .reducer(new WordcountReducerFactory())
           .submit();

     System.out.println(ToStringPrettyfier.toString(future.get()));</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">JobTracker t = hz.getJobTracker("word-count");
IMap&lt;Long, String&gt; documents = hz.getMap("documents");
LongSumAggregation&lt;String, String&gt; aggr = new LongSumAggregation&lt;&gt;();
Map&lt;String, Long&gt; counts =
        t.newJob(KeyValueSource.fromMap(documents))
         .mapper((Long x, String document, Context&lt;String, Long&gt; ctx) -&gt;
                 Stream.of(document.toLowerCase().split("\\W+"))
                       .filter(w -&gt; !w.isEmpty())
                       .forEach(w -&gt; ctx.emit(w, 1L)))
         .combiner(aggr.getCombinerFactory())
         .reducer(aggr.getReducerFactory())
         .submit()
         .get();</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>See the <a href="https://github.com/hazelcast/hazelcast-jet/tree/master/examples/wordcount" target="_blank" rel="noopener">Jet Code Samples</a> for a full insight.</p>
</div>
</div>
<div class="sect3">
<h4 id="_refactoring_of_migration_listener"><a class="anchor" href="#_refactoring_of_migration_listener"></a>B.1.12. Refactoring of Migration Listener</h4>
<div class="paragraph">
<p>The <code>MigrationListener</code> API has been refactored.
With this change, an event is published when a new
migration process starts and another event when migration
is completed. These events include statistics
about the migration process including the start time,
planned migration count, completed migration count, etc.</p>
</div>
<div class="paragraph">
<p>Additionally, a migration event is published on each replica
migration, both for primary and backup replica migrations.
This event includes the partition ID, replica index and
migration progress statistics.</p>
</div>
<div class="paragraph">
<p>Before IMDG 4.0, the following were the events listened by <code>MigrationListener</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>migrationStarted</code></p>
</li>
<li>
<p><code>migrationCompleted</code></p>
</li>
<li>
<p><code>migrationFailed</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After IMDG 4.0, we have the following events instead:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>migrationStarted</code></p>
</li>
<li>
<p><code>migrationFinished</code></p>
</li>
<li>
<p><code>replicaMigrationCompleted</code></p>
</li>
<li>
<p><code>replicaMigrationFailed</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the following table for the before/after samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Implementing a Migration Listener</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">import com.hazelcast.core.MigrationEvent;
import com.hazelcast.core.MigrationListener;

public class ClusterMigrationListener implements MigrationListener {
    @Override
    public void migrationStarted(MigrationEvent migrationEvent) {
        System.err.println("Started: " + migrationEvent);
    }
    @Override
    public void migrationCompleted(MigrationEvent migrationEvent) {
        System.err.println("Completed: " + migrationEvent);
    }
    @Override
    public void migrationFailed(MigrationEvent migrationEvent) {
        System.err.println("Failed: " + migrationEvent);
    }
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">import com.hazelcast.partition.MigrationListener;
import com.hazelcast.partition.MigrationState;
import com.hazelcast.partition.ReplicaMigrationEvent;

public class ClusterMigrationListener implements MigrationListener {

    @Override
    public void migrationStarted(MigrationState state) {
        System.out.println("Migration Started: " + state);
    }

    @Override
    public void migrationFinished(MigrationState state) {
        System.out.println("Migration Finished: " + state);
    }

    @Override
    public void replicaMigrationCompleted(ReplicaMigrationEvent event) {
        System.out.println("Replica Migration Completed: " + event);
    }

    @Override
    public void replicaMigrationFailed(ReplicaMigrationEvent event) {
        System.out.println("Replica Migration Failed: " + event);
    }
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/partition/MigrationListener.html" target="_blank" rel="noopener">MigrationListener</a> Javadoc
for a full insight.</p>
</div>
</div>
<div class="sect3">
<h4 id="_defaulting_to_openssl"><a class="anchor" href="#_defaulting_to_openssl"></a>B.1.13. Defaulting to OpenSSL</h4>
<div class="paragraph">
<p>Hazelcast IMDG defaults to use OpenSSL when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when you use <a href="#tlsssl">TLS/SSL</a> and Hazelcast IMDG detects some <a href="#integrating-openssl-boringssl">OpenSSL</a> capabilities</p>
</li>
<li>
<p>the Java version is less than 11</p>
</li>
<li>
<p>no explicit <a href="#configuring-hazelcast-for-openssl">SSLEngineFactory</a> is configured.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_security_configurations"><a class="anchor" href="#_changes_in_security_configurations"></a>B.1.14. Changes in Security Configurations</h4>
<div class="sect4">
<h5 id="_replacing_group_by_simple_cluster_name_configuration"><a class="anchor" href="#_replacing_group_by_simple_cluster_name_configuration"></a>Replacing <code>group</code> by Simple Cluster Name Configuration</h5>
<div class="paragraph">
<p>The <code>GroupConfig</code> class has been removed. Both the client and member configurations have
the <code>GroupConfig</code> (or <code>&lt;group&gt;</code> in XML) replaced by a simple  cluster name configuration.
The password part from the <code>GroupConfig</code> which was already deprecated is removed now.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after sample configurations.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Declarative Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;group&gt;
        &lt;name&gt;dev&lt;/name&gt;
        &lt;password&gt;dev-pass&lt;/password&gt;
    &lt;/group&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name&gt;dev&lt;/cluster-name&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Programmatic Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Config configProd = new Config();
configProd.getGroupConfig().setName( "production" );

Config configDev = new Config();
configDev.getGroupConfig().setName( "development" );</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Config configProd = new Config();
configProd.setClusterName( "production" );

Config configDev = new Config();
configDev.setClusterName( "development" );</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_member_authentication_and_identity_configuration"><a class="anchor" href="#_member_authentication_and_identity_configuration"></a>Member Authentication and Identity Configuration</h5>
<div class="paragraph">
<p>Hazelcast IMDG 4.0 replaces the <code>&lt;member-credentials-factory&gt;</code>, <code>&lt;member-login-modules&gt;</code> and
<code>&lt;client-login-modules&gt;</code> configuration by references to security realms.
The security realms is a new abstraction in the security configuration of Hazelcast members.
It defines the security configuration independently on the configuration
part where the security is used. The component requesting security just references
the security realm name.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after sample configurations.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;security enabled="true"&gt;
    &lt;member-credentials-factory class-name="com.hazelcast.examples.MyCredentialsFactory"&gt;
        &lt;properties&gt;
            &lt;property name="property"&gt;value&lt;/property&gt;
        &lt;/properties&gt;
    &lt;/member-credentials-factory&gt;
    &lt;member-login-modules&gt;
        &lt;login-module class-name="com.hazelcast.examples.MyRequiredLoginModule" usage="REQUIRED"&gt;
            &lt;properties&gt;
                &lt;property name="property"&gt;value&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/login-module&gt;
    &lt;/member-login-modules&gt;
    &lt;client-login-modules&gt;
        &lt;login-module class-name="com.hazelcast.examples.MyRequiredLoginModule" usage="REQUIRED"&gt;
            &lt;properties&gt;
                &lt;property name="property"&gt;value&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/login-module&gt;
    &lt;/client-login-modules&gt;
&lt;/security&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;security enabled="true"&gt;
    &lt;realms&gt;
        &lt;realm name="realm1"&gt;
            &lt;authentication&gt;
                &lt;jaas&gt;
                    &lt;login-module class-name="com.hazelcast.examples.MyRequiredLoginModule" usage="REQUIRED"&gt;
                        &lt;properties&gt;
                            &lt;property name="property"&gt;value&lt;/property&gt;
                        &lt;/properties&gt;
                    &lt;/login-module&gt;
                &lt;/jaas&gt;
            &lt;/authentication&gt;
            &lt;identity&gt;
                &lt;credentials-factory class-name="com.hazelcast.examples.MyCredentialsFactory"&gt;
                    &lt;properties&gt;
                        &lt;property name="property"&gt;value&lt;/property&gt;
                    &lt;/properties&gt;
                &lt;/credentials-factory&gt;
            &lt;/identity&gt;
        &lt;/realm&gt;
    &lt;/realms&gt;
    &lt;member-authentication realm="realm1"/&gt;
    &lt;client-authentication realm="realm1"/&gt;
&lt;/security&gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_client_identity_configuration"><a class="anchor" href="#_client_identity_configuration"></a>Client Identity Configuration</h5>
<div class="paragraph">
<p>The <code>&lt;credentials&gt;</code> configuration is not supported
anymore in the client security configuration.
Existing <code>&lt;credentials-factory&gt;</code> configuration allows
to fully replace the credentials as it is more flexible.
There are also new <code>&lt;username-password&gt;</code> and <code>&lt;token&gt;</code>
configuration elements which simplify the migration.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after sample configurations.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;security&gt;
    &lt;credentials&gt;com.acme.security.JohnDoeCredentials&lt;/credentials&gt;
&lt;/security&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;security&gt;
    &lt;username-password username="johndoe" password="s3crEt"/&gt;
&lt;/security&gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_jaas_authentication_cleanups"><a class="anchor" href="#_jaas_authentication_cleanups"></a>B.1.15. JAAS Authentication Cleanups</h4>
<div class="sect4">
<h5 id="_introducing_new_principal_types"><a class="anchor" href="#_introducing_new_principal_types"></a>Introducing New Principal Types</h5>
<div class="paragraph">
<p>The <code>ClusterPrincipal</code> class representing an authenticated user within the JAAS Subject
has been replaced by three different principal types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ClusterIdentityPrincipal</code></p>
</li>
<li>
<p><code>ClusterRolePrincipal</code></p>
</li>
<li>
<p><code>ClusterEndpointPrincipal</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these new principal types share the <code>HazelcastPrincipal</code> interface so
it is simple to get or remove them all from the subject.</p>
</div>
<div class="paragraph">
<p>With this change, the <code>Credentials</code> object is not referenced from
the principals anymore.</p>
</div>
<div class="paragraph">
<p>Also, <code>DefaultPermissionPolicy</code> which was consuming <code>ClusterPrincipal</code>
and also reading the endpoint address from it works with the new
<code>ClusterRolePrincipals</code> and <code>ClusterEndpointPrincipals</code> principal types.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after sample <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/security/IPermissionPolicy.html" target="_blank" rel="noopener">IPermissionPolicy</a> implementations.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public PermissionCollection getPermissions(Subject subject, Class&lt;? extends Permission&gt; type) {
    PermissionCollection collection = ...;
    for (ClusterPrincipal principal : subject.getPrincipals(ClusterPrincipal.class)) {
      String endpoint = principal.getEndpoint();
      String principalName = principal.getPrincipal();
      addPermissionsToPrincipal(collection, principalName, endpoint);
    }
    return collection;
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public PermissionCollection getPermissions(Subject subject, Class&lt;? extends Permission&gt; type) {
    PermissionCollection collection = ...;
    Set&lt;ClusterEndpointPrincipal&gt; endpointPrincipals = subject.getPrincipals(ClusterEndpointPrincipal.class);
    String endpoint = endpointIterator.hasNext() ? endpointIterator.next().getName() : null;
    for (ClusterRolePrincipal rolePrincipal : subject.getPrincipals(ClusterRolePrincipal.class)) {
        String role = rolePrincipal.getName();
        addPermissionsToPrincipal(collection, role, endpoint);
    }
    return collection;
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_changes_in_clusterloginmodule"><a class="anchor" href="#_changes_in_clusterloginmodule"></a>Changes in ClusterLoginModule</h5>
<div class="paragraph">
<p><code>ClusterLoginModule</code> in Hazelcast IMDG 3.x contained four
abstract methods to alter the behavior of <code>LoginModule</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>onLogin</code></p>
</li>
<li>
<p><code>onCommit</code></p>
</li>
<li>
<p><code>onAbort</code></p>
</li>
<li>
<p><code>onLogout</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The login module was retrieving <code>Credentials</code> and
using it to create the <code>ClusterPrincipal</code> back then.</p>
</div>
<div class="paragraph">
<p>In Hazelcast IMDG 4.0, only <code>onLogin</code> is abstract.
Others now have empty implementations. The login module creates
<code>ClusterEndpointPrincipal</code> automatically and adds it to the <code>Subject</code>.</p>
</div>
<div class="paragraph">
<p>The <code>getName()</code> abstract method has been added. It is used for
constructing <code>ClusterIdentityPrincipal</code>. The <code>addRole(String)</code> method
can be called by the child implementations to add <code>ClusterRolePrincipals</code>
with the given name.</p>
</div>
<div class="paragraph">
<p>Also, <code>ClusterLoginModule</code> introduces three login module options (boolean),
which allows skipping principals of a given type to the JAAS <code>Subject</code>.
It allows, for instance, to have just one <code>ClusterIdentityPrincipal</code>
in the <code>Subject</code> even if there are more login modules in the chain. These
options are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>skipIdentity</code></p>
</li>
<li>
<p><code>skipRole</code></p>
</li>
<li>
<p><code>skipEndpoint</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the following table for the before/after sample implementations.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class TestLoginModule extends ClusterLoginModule {

    @Override
    public boolean onLogin() throws LoginException {
        UsernamePasswordCredentials usernamePasswordCredentials = (UsernamePasswordCredentials) credentials;
        if ("foo".equals(usernamePasswordCredentials.getUsername())
                &amp;&amp; "bar".equals(usernamePasswordCredentials.getPassword())) {
            // the "foo" principal is added
            return true;
        }
        throw new FailedLoginException("Username or password doesn't match expected value.");
    }

    @Override
    public boolean onCommit() {
        return loginSucceeded;
    }

    @Override
    protected boolean onAbort() {
        return true;
    }

    @Override
    protected boolean onLogout() {
        return true;
    }
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class TestLoginModule extends ClusterLoginModule {

    private String name;

    @Override
    public boolean onLogin() throws LoginException {
        NameCallback ncb = new NameCallback("");
        PasswordCallback pcb = new PasswordCallback("", false);
        try {
            callbackHandler.handle(new Callback[] { ncb, pcb });
        } catch (IOException | UnsupportedCallbackException e) {
            throw new LoginException("Unable to handle credentials");
        }
        name = credentials.getName();
        if ("foo".equals(name)
                &amp;&amp; Arrays.equals("bar".toCharArray(), pcb.getPassword())) {
            addRole("admin");
            return true;
        }
        throw new FailedLoginException("Username or password doesn't match expected value.");
    }

    @Override
    protected String getName() {
        return name;
    }
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_changes_in_credentials_for_client_protocol"><a class="anchor" href="#_changes_in_credentials_for_client_protocol"></a>Changes in Credentials for Client Protocol</h5>
<div class="paragraph">
<p>In Hazelcast IMDG 3.x, the custom credentials coming through
the client protocol was always automatically deserialized. To
avoid this, the <code>Credentials</code> interface has been redesigned in
Hazelcast IMDG 4.0 to contain only the <code>getName()</code>
(renamed from <code>getPrincipal()</code>) method.
The endpoint handling has been moved out of the interface.</p>
</div>
<div class="paragraph">
<p>Now, <code>Credentials</code> has two new subinterfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PasswordCredentials</code>: The existing <code>UsernamePasswordCredentials</code> class
is the default implementation.</p>
</li>
<li>
<p><code>TokenCredentials</code>: The new <code>SimpleTokenCredentials</code> class has been introduced
to implement it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>TokenCredentials</code> is just a holder for byte array, and
the authentication implementations themselves, i.e., custom <code>LoginModules</code>,
are responsible for the data deserialization when needed.</p>
</div>
<div class="paragraph">
<p>The data from client authentication message is not deserialized by Hazelcast members
anymore. For standard authentication, <code>UsernamePasswordCredentials</code> is constructed.
For custom authentication, <code>SimpleTokenCredentials</code> is constructed.
If the original <code>Credentials</code> object is not a <code>PasswordCredentials</code>
or <code>TokenCredentials</code> instance, then it can be deserialized manually.
However, the deserialization during authentication remains a dangerous
operation and should be avoided.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after sample implementations.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public boolean onLogin() throws LoginException {
    if (credentials == null || !(credentials instanceof CustomCredentials)) {
        throw new FailedLoginException("No valid CustomCredentials found");
    }
    CustomCredentials custom = (CustomCredentials) credentials;
    if (!verify(custom.getJsonToken())) {
      throw new FailedLoginException("JSON token is not valid.");
    }
    return true;
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public boolean onLogin() throws LoginException {
    CredentialsCallback cc = new CredentialsCallback();
    try {
        callbackHandler.handle(new Callback[] { cc });
    } catch (IOException</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Credentials</code> serialization and deserialization in the member protocol
has not been changed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_changes_in_jaas_callbacks"><a class="anchor" href="#_changes_in_jaas_callbacks"></a>Changes in JAAS Callbacks</h5>
<div class="paragraph">
<p>In Hazelcast IMDG 3.x, the <code>CallbackHandler</code> implementation <code>ClusterCallbackHandler</code>
was only able to work with Hazelcast&#8217;s <code>CredentialsCallback</code>.
In Hazelcast IMDG 4.0, it also works with the standard Java Callback implementations
<code>NameCallback</code> and <code>PasswordCallback</code>.</p>
</div>
<div class="paragraph">
<p><code>DefaultLoginModule</code> was using the login module options to retrieve the
member&#8217;s <code>Config</code> object. Now, custom <code>Callback</code> types have been
implemented which can be used to retrieve additional data required for
the authentication.</p>
</div>
<div class="paragraph">
<p>List of the supported <code>Callback</code>s in Hazelcast IMDG 4.0:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>javax.security.auth.callback.NameCallback</code></p>
</li>
<li>
<p><code>javax.security.auth.callback.PasswordCallback</code></p>
</li>
<li>
<p><code>com.hazelcast.security.CredentialsCallback</code> (provides access to the incoming <code>Credentials</code> instance)</p>
</li>
<li>
<p><code>com.hazelcast.security.EndpointCallback</code> (allows retrieving the remote host address, it&#8217;s a replacement for <code>Credentials.getEndpoint()</code> in Hazelcast IMDG 3.x)</p>
</li>
<li>
<p><code>com.hazelcast.security.ConfigCallback</code> (allows retrieving member&#8217;s <code>Config</code> object)</p>
</li>
<li>
<p><code>com.hazelcast.security.SerializationServiceCallback</code> (provides access to Hazelcast <code>SerializationService</code>)</p>
</li>
<li>
<p><code>com.hazelcast.security.ClusterNameCallback</code> (provides access to Hazelcast cluster name sent by the connecting party)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_renaming_quorum_as_split_brain_protection"><a class="anchor" href="#_renaming_quorum_as_split_brain_protection"></a>B.1.16. Renaming Quorum as Split Brain Protection</h4>
<div class="paragraph">
<p>Both in the API/code samples and documentation, the term "quorum" has been
replaced by "split-brain protection".</p>
</div>
<div class="paragraph">
<p>With this change, the following configuration parameters
have been renamed:</p>
</div>
<div class="paragraph">
<p><strong>Declarative configuration elements:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quorum</code> &#8594; <code>split-brain-protection</code></p>
</li>
<li>
<p><code>quorum-size</code> &#8594; <code>minimum-cluster-size</code></p>
</li>
<li>
<p><code>quorum-ref</code> &#8594;  <code>split-brain-protection-ref</code></p>
</li>
<li>
<p><code>quorum-type</code> &#8594; <code>protect-on</code></p>
</li>
<li>
<p><code>probabilistic-quorum</code> &#8594; <code>probabilistic-split-brain-protection</code></p>
</li>
<li>
<p><code>recently-active-quorum</code> &#8594; <code>recently-active-split-brain-protection</code></p>
</li>
<li>
<p><code>quorum-function-class-name</code> &#8594; <code>split-brain-protection-function-class-name</code></p>
</li>
<li>
<p><code>quorum-listeners</code> &#8594; <code>split-brain-protection-listeners</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Programmatic configuration objects and methods:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QuorumConfig</code> &#8594; <code>SplitBrainProtectionConfig</code></p>
</li>
<li>
<p><code>QuorumConfig.setSize()</code> &#8594; <code>SplitBrainProtectionConfig.setMinimumClusterSize()</code></p>
</li>
<li>
<p><code>QuorumConfig.setType()</code> &#8594; <code>SplitBrainProtectionConfig.setProtectOn()</code></p>
</li>
<li>
<p><code>QuorumListenerConfig</code> &#8594; <code>SplitBrainProtectionListenerConfig</code></p>
</li>
<li>
<p><code>QuorumEvent</code> &#8594; <code>SplitBrainProtectionEvent</code></p>
</li>
<li>
<p><code>QuorumService</code> &#8594; <code>SplitBrainProtectionService</code></p>
</li>
<li>
<p><code>QuorumService.getQuorum()</code> &#8594; <code>SplitBrainProtectionService.getSplitBrainProtection()</code></p>
</li>
<li>
<p><code>isPresent()</code> &#8594; <code>hasMinimumSize()</code></p>
</li>
<li>
<p><code>setQuorumName()</code> &#8594; <code>setSplitBrainProtectionName()</code></p>
</li>
<li>
<p><code>addQuorumConfig()</code> &#8594; <code>addSplitBrainProtectionConfig()</code></p>
</li>
<li>
<p><code>newProbabilisticQuorumConfigBuilder()</code> &#8594; <code>newProbabilisticSplitBrainProtectionConfigBuilder()</code></p>
</li>
<li>
<p><code>newRecentlyActiveQuorumConfigBuilder()</code> &#8594; <code>newRecentlyActiveSplitBrainProtectionConfigBuilder()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the following table for a before/after sample.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;quorum name="quorumRuleWithFourMembers" enabled="true"&gt;
        &lt;quorum-size&gt;4&lt;/quorum-size&gt;
    &lt;/quorum&gt;
    &lt;map name="default"&gt;
        &lt;quorum-ref&gt;quorumRuleWithFourMembers&lt;/quorum-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection name="splitBrainProtectionRuleWithFourMembers" enabled="true"&gt;
        &lt;minimum-cluster-size&gt;4&lt;/minimum-cluster-size&gt;
    &lt;/split-brain-protection&gt;
    &lt;map name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitBrainProtectionRuleWithFourMembers&lt;/split-brain-protection-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>See the <a href="#split-brain-protection">Split-Brain Protection section</a> for more information on network partitioning.</p>
</div>
</div>
<div class="sect3">
<h4 id="_renaming_getid_to_getclassid_in_identifieddataserializable"><a class="anchor" href="#_renaming_getid_to_getclassid_in_identifieddataserializable"></a>B.1.17. Renaming getID to getClassId in IdentifiedDataSerializable</h4>
<div class="paragraph">
<p>The <code>getId()</code> method of the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/nio/serialization/IdentifiedDataSerializable.html" target="_blank" rel="noopener">IdentifiedDataSerializable</a> interface
is a method with a common name, meaning a naming conflict would happen frequently.
For example, database entities also have a <code>getId()</code> method.
Therefore, it has been renamed as <code>getClassId()</code>.</p>
</div>
<div class="paragraph">
<p>See the following table showing the interface code before and after IMDG 4.0.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">package com.hazelcast.nio.serialization;

public interface IdentifiedDataSerializable extends DataSerializable {

    int getFactoryId();

    int getId();
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">package com.hazelcast.nio.serialization;

public interface IdentifiedDataSerializable extends DataSerializable {

    int getFactoryId();

    int getClassId();
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>See <a href="#identifieddataserializable">here</a> for more information on <code>IdentifiedDataSerializable</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_introducing_lambda_friendly_interfaces"><a class="anchor" href="#_introducing_lambda_friendly_interfaces"></a>B.1.18. Introducing Lambda Friendly Interfaces</h4>
<div class="sect4">
<h5 id="_entry_processor_2"><a class="anchor" href="#_entry_processor_2"></a>Entry Processor</h5>
<div class="paragraph">
<p>The <code>EntryBackupProcessor</code> interface has been removed in favor
of <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/EntryProcessor.html" target="_blank" rel="noopener">EntryProcessor</a> which now defines how the entries will be processed
both on the primary and the backup replicas.</p>
</div>
<div class="paragraph">
<p>Because of this, the <code>AbstractEntryProcessor</code> interface has been removed.
This should make writing entry processors more lambda friendly.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        map.executeOnKey(key, new AbstractEntryProcessor&lt;Integer, Employee&gt;() {

            @Override
            public Object process(Map.Entry&lt;Integer, Employee&gt; entry) {
                Employee employee = entry.getValue();
                if (employee == null) {
                    employee = new Employee();
                }
                employee.setSalary(value);
                entry.setValue(employee);
                return null;
            }
        });</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">map.executeOnKey(key,
        entry -&gt; {
            Employee employee = entry.getValue();
            if (employee == null) {
                employee = new Employee();
            }
            employee.setSalary(value);
            entry.setValue(employee);
            return null;
        });</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This should cover most cases. If you need to define a custom
backup entry processor, you can override the <code>EntryProcessor#getBackupProcessor</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">map.executeOnKey(key, new EntryProcessor&lt;Object, Object, Object&gt;() {
    @Override
    public Object process(Entry&lt;Object, Object&gt; entry) {
        // process primary entry
    }

    private Object processBackupEntry(Entry&lt;Object, Object&gt; backupEntry) {
        // process backup entry
    }

    @Nullable
    @Override
    public EntryProcessor&lt;Object, Object, Object&gt; getBackupProcessor() {
        return this::processBackupEntry;
    }
});</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_functional_and_serializable_interfaces"><a class="anchor" href="#_functional_and_serializable_interfaces"></a>Functional and Serializable Interfaces</h5>
<div class="paragraph">
<p>Introduces interfaces with single abstract method which declares a
checked exception. The interfaces are also <code>Serializable</code> and can be
readily used when providing a lambda which is then serialized.</p>
</div>
<div class="paragraph">
<p>The <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/projection/Projection.html" target="_blank" rel="noopener">Projection</a> class was an abstract interface for historical reasons.
It has been turned into a functional interface so it&#8217;s more lambda-friendly.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after sample implementations.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Collection&lt;String&gt; keys = map.project(new Projection&lt;Entry&lt;String, Double&gt;, String&gt;() {
    @Override
    public String transform(Entry&lt;String, Double&gt; input) {
        return input.getKey();
    }
});</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Collection&lt;String&gt; keys = map.project(Entry::getKey);</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_expanding_nullablenonnull_annotations"><a class="anchor" href="#_expanding_nullablenonnull_annotations"></a>B.1.19. Expanding Nullable/Nonnull Annotations</h4>
<div class="paragraph">
<p>The APIs of the distributed data structures have been made cleaner
by adding <code>Nullable</code> and <code>Nonnull</code> annotations, and
their API documentation have been improved:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Now, it is obvious when looking at the API where <code>null</code> is allowed and
where it is not.</p>
</li>
<li>
<p>Some methods were throwing <code>NullPointerException</code> while others were throwing
<code>IllegalArgumentException</code>. Now the behavior is aligned and an unexpected <code>null</code>
argument results in a <code>NullPointerException</code> being thrown.</p>
</li>
<li>
<p>Some methods actually allowed <code>null</code> but there was no indication that they did.</p>
</li>
<li>
<p>A method when used on the member would accept <code>null</code> and have some behavior
accordingly while, on the client, the method would throw a <code>NullPointerException</code>.
Now, the behavior of the member and client have been aligned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The data structures and interfaces enhanced in this sense are listed below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IQueue</code>, <code>ISet</code>, <code>IList</code></p>
</li>
<li>
<p><code>IMap</code>, <code>MultiMap</code>, <code>ReplicatedMap</code></p>
</li>
<li>
<p><code>Cluster</code></p>
</li>
<li>
<p><code>ITopic</code></p>
</li>
<li>
<p><code>Ringbuffer</code></p>
</li>
<li>
<p><code>ScheduledExecutor</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_icompletablefuture"><a class="anchor" href="#_removal_of_icompletablefuture"></a>B.1.20. Removal of ICompletableFuture</h4>
<div class="paragraph">
<p>In Hazelcast IMDG 3.x series, <code>com.hazelcast.core.ICompletableFuture</code> was
introduced to enable reactive programming style. <code>ICompletableFuture</code> was
intended as a temporary, JDK 6 compatible replacement for <code>java.util.concurrent.CompletableFuture</code>
that was introduced in Java 8. Since Hazelcast 4.0 requires Java 8, the user-facing
asynchronous Hazelcast API methods now have their return type changed from
<code>ICompletableFuture</code> to Java 8&#8217;s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" target="_blank" rel="noopener">java.util.concurrent.CompletionStage</a>.</p>
</div>
<div class="paragraph">
<p>Dependent computation stages registered using default async methods which do not
accept an explicit <code>Executor</code> argument (such as <code>thenAcceptAsync</code>, <code>whenCompleteAsync</code> etc)
are executed by the <code>java.util.concurrent.ForkJoinPool#commonPool()</code> (unless it does not
support a parallelism level of at least two, in which case, a new <code>Thread</code> is created to
run each task).</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;

public class Main {

    public static void main(String[] args) {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IMap&lt;Integer, String&gt; map = hazelcastInstance.getMap("map");

        map.putAsync(1, "one").andThen(new ExecutionCallback&lt;String&gt;() {
            @Override
            public void onResponse(String response) {
                map.getAsync(1).andThen(new ExecutionCallback&lt;String&gt;() {
                    @Override
                    public void onResponse(String response) {
                        System.out.println("Value of 1 is " + response);
                    }

                    @Override
                    public void onFailure(Throwable t) {
                        t.printStackTrace();
                    }
                });
            }

            @Override
            public void onFailure(Throwable t) {
                t.printStackTrace();
            }
        });
    }
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;

public class Main {

    public static void main(String[] args) {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IMap&lt;Integer, String&gt; map = hazelcastInstance.getMap("map");

        map.putAsync(1, "one").whenCompleteAsync((response, throwable) -&gt; {
            if (throwable == null) {
                map.getAsync(1).thenAcceptAsync(v -&gt; {
                    System.out.println("Value of 1 is " + v);
                });
            } else {
                throwable.printStackTrace();
            }
        });
    }
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_wan_replication_configuration_changes"><a class="anchor" href="#_wan_replication_configuration_changes"></a>B.1.21. WAN Replication Configuration Changes</h4>
<div class="paragraph">
<p>Previously, Configuring WAN replication was problematic:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You needed to specify the fully qualified class name of the WAN implementation that should be used.
In most cases, this was the built-in Hazelcast IMDG Enterprise Edition (EE) implementation.</p>
</li>
<li>
<p>There were various configuration options, some of which were present as Java class instance fields
or XML child nodes and attributes while others were present in a properties list. The issue with
the property list is that there was no checking for typos, no documentation and no IDE help.</p>
</li>
<li>
<p>If you wanted to use a custom WAN publisher SPI implementation, some configuration options did not
make sense as they were tied to our implementation, e.g., WAN queue size.</p>
</li>
<li>
<p>It was verbose.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The tag which was supposed to cover both cases, using the built-in Hazelcast EE implementation and a
custom WAN replication implementation (<code>wan-publisher</code> or <code>WanPublisherConfig</code>), has been separated into
two configuration elements/classes to be used for built-in and custom WAN publishers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>batch-publisher</code> (declarative configuration) or <code>WanBatchPublisherConfig</code> (programmatic configuration)</p>
</li>
<li>
<p><code>custom-publisher</code> (declarative configuration) or <code>WanCustomPublisherConfig</code> (programmatic configuration)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This means, if you&#8217;re using the Hazelcast built-in WAN replication, the new configuration element
is <code>batch-publisher</code> or <code>WanBatchPublisherConfig</code>.
If you&#8217;re using a custom WAN replication implementation, the new configuration element is
<code>custom-publisher</code> or <code>WanCustomPublisherConfig</code>.</p>
</div>
<div class="paragraph">
<p>Additionally, the group password has been removed from the configuration and now only the cluster name is checked
when connecting to the target cluster. This has been done to align the behavior with members forming a single
cluster, where members with different passwords but with the same cluster name (previously group name)
could form a cluster.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after built-in WAN publisher examples:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Declarative Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;wan-publisher group-name="builtInPublisher" publisher-id="builtInPublisherId"&gt;
    &lt;class-name&gt;com.hazelcast.enterprise.wan.impl.replication.WanBatchReplication&lt;/class-name&gt;
    &lt;queue-capacity&gt;15000&lt;/queue-capacity&gt;
    &lt;queue-full-behavior&gt;DISCARD_AFTER_MUTATION&lt;/queue-full-behavior&gt;
    &lt;initial-publisher-state&gt;REPLICATING&lt;/initial-publisher-state&gt;
    &lt;wan-sync&gt;
        &lt;consistency-check-strategy&gt;NONE&lt;/consistency-check-strategy&gt;
    &lt;/wan-sync&gt;
    &lt;properties&gt;
        &lt;property name="endpoints"&gt;10.3.5.1:5701,10.3.5.2:5701&lt;/property&gt;
        &lt;property name="batch.size"&gt;1000&lt;/property&gt;
        &lt;property name="batch.max.delay.millis"&gt;2000&lt;/property&gt;
        &lt;property name="response.timeout.millis"&gt;60000&lt;/property&gt;
        &lt;property name="ack.type"&gt;ACK_ON_OPERATION_COMPLETE&lt;/property&gt;
        &lt;property name="snapshot.enabled"&gt;false&lt;/property&gt;
        &lt;property name="group.password"&gt;nyc-pass&lt;/property&gt;
    &lt;/properties&gt;
&lt;/wan-publisher&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;batch-publisher&gt;
    &lt;cluster-name&gt;builtInPublisher&lt;/cluster-name&gt;
    &lt;publisher-id&gt;builtInPublisherId&lt;/publisher-id&gt;
    &lt;batch-size&gt;1000&lt;/batch-size&gt;
    &lt;batch-max-delay-millis&gt;2000&lt;/batch-max-delay-millis&gt;
    &lt;response-timeout-millis&gt;60000&lt;/response-timeout-millis&gt;
    &lt;acknowledge-type&gt;ACK_ON_OPERATION_COMPLETE&lt;/acknowledge-type&gt;
    &lt;initial-publisher-state&gt;REPLICATING&lt;/initial-publisher-state&gt;
    &lt;snapshot-enabled&gt;false&lt;/snapshot-enabled&gt;
    &lt;queue-full-behavior&gt;DISCARD_AFTER_MUTATION&lt;/queue-full-behavior&gt;
    &lt;queue-capacity&gt;10000&lt;/queue-capacity&gt;
    &lt;target-endpoints&gt;10.3.5.1:5701,10.3.5.2:5701&lt;/target-endpoints&gt;
    &lt;sync&gt;
        &lt;consistency-check-strategy&gt;NONE&lt;/consistency-check-strategy&gt;
    &lt;/sync&gt;
&lt;/batch-publisher&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Programmatic Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">WanPublisherConfig publisherConfig = new WanPublisherConfig()
        .setGroupName("builtInPublisher")
        .setPublisherId("builtInPublisherId")
        .setClassName("com.hazelcast.enterprise.wan.impl.replication.WanBatchReplication")
        .setQueueCapacity(15000)
        .setQueueFullBehavior(WANQueueFullBehavior.DISCARD_AFTER_MUTATION)
        .setInitialPublisherState(WanPublisherState.REPLICATING);
publisherConfig.getWanSyncConfig().setConsistencyCheckStrategy(ConsistencyCheckStrategy.NONE);
Map&lt;String, Comparable&gt; properties = publisherConfig.getProperties();
properties.put("endpoints", "10.3.5.1:5701,10.3.5.2:5701");
properties.put("batch.size", 1000);
properties.put("batch.max.delay.millis", 2000);
properties.put("response.timeout.millis", 60000);
properties.put("ack.type", WanAcknowledgeType.ACK_ON_OPERATION_COMPLETE.toString());
properties.put("snapshot.enabled", false);
properties.put("group.password", "nyc-pass");</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        .setClusterName("builtInPublisher")
        .setPublisherId("builtInPublisherId")
        .setClassName("com.hazelcast.enterprise.wan.impl.replication.WanBatchReplication")
        .setQueueCapacity(15000)
        .setQueueFullBehavior(WanQueueFullBehavior.DISCARD_AFTER_MUTATION)
        .setInitialPublisherState(WanPublisherState.REPLICATING)
        .setTargetEndpoints("10.3.5.1:5701,10.3.5.2:5701")
        .setBatchSize(1000)
        .setBatchMaxDelayMillis(2000)
        .setResponseTimeoutMillis(60000)
        .setAcknowledgeType(WanAcknowledgeType.ACK_ON_OPERATION_COMPLETE)
        .setSnapshotEnabled(false);
publisherConfig.getWanSyncConfig().setConsistencyCheckStrategy(ConsistencyCheckStrategy.NONE);</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>See the following table for the before/after custom WAN publisher examples:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Declarative Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;wan-publisher group-name="customWanPublisherId"&gt;
    &lt;class-name&gt;com.myCompany.MyImplementation&lt;/class-name&gt;
    &lt;properties&gt;
        &lt;property name="some.property"&gt;some-value&lt;/property&gt;
        &lt;property name="some.other.property"&gt;some-other-value&lt;/property&gt;
    &lt;/properties&gt;
&lt;/wan-publisher&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;custom-publisher&gt;
    &lt;publisher-id&gt;customPublisherId&lt;/publisher-id&gt;
    &lt;class-name&gt;com.myCompany.MyImplementation&lt;/class-name&gt;
    &lt;properties&gt;
        &lt;property name="some.property"&gt;some-value&lt;/property&gt;
        &lt;property name="some.other.property"&gt;some-other-value&lt;/property&gt;
    &lt;/properties&gt;
&lt;/custom-publisher&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Programmatic Configuration</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">WanPublisherConfig publisherConfig = new WanPublisherConfig()
        .setGroupName("customWanPublisherId")
        .setClassName("com.myCompany.MyImplementation");
Map&lt;String, Comparable&gt; properties = publisherConfig.getProperties();
properties.put("some.property", "some-value");
properties.put("some.other.property", "some-other-value");</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">WanCustomPublisherConfig publisherConfig = new WanCustomPublisherConfig()
        .setPublisherId("customWanPublisherId")
        .setClassName("com.myCompany.MyImplementation");
Map&lt;String, Comparable&gt; properties = publisherConfig.getProperties();
properties.put("some.property", "some-value");
properties.put("some.other.property", "some-other-value");</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>See the <a href="#wan-replication">here</a> for more information on WAN Replication.</p>
</div>
</div>
<div class="sect3">
<h4 id="_wan_replication_spi_changes"><a class="anchor" href="#_wan_replication_spi_changes"></a>B.1.22. WAN Replication SPI Changes</h4>
<div class="paragraph">
<p>In IMDG 3.x series, the WAN publisher SPI allowed you to plug into the lifecycle of a map/cache entry
and replicate the updates to another system. For example, you might implement replication to
Kafka or some JMS queue or even write out map and cache event changes to a log on disk.
The SPI was not very intuitive though:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It was not clear which interface needed to be implemented (<code>WanPublisher</code> vs. <code>WanReplicationEndpoint</code>).</p>
</li>
<li>
<p>You had to implement different interfaces, depending on whether you were using Hazelcast IMDG
Open Source or Enterprise edition.</p>
</li>
<li>
<p>There were cases of leaking internals which don&#8217;t make sense for some custom implementations.</p>
</li>
<li>
<p>There were unused methods in the public SPI.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Hazelcast IMDG 4.0, we have provided a new and cleaner WAN publisher SPI. You only need to
implement a single interface: <code>com.hazelcast.wan.WanPublisher</code>. This implementation can
then be set in the WAN replication configuration and be used with both Hazelcast Open Source and
Enterprise editions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_predicate_api_cleanups"><a class="anchor" href="#_predicate_api_cleanups"></a>B.1.23. Predicate API Cleanups</h4>
<div class="paragraph">
<p>The following refactors and cleanups have been performed
on the public Predicate related API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Moved the following classes from the <code>com.hazelcast.query</code> package
to <code>com.hazelcast.query.impl.predicates</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>IndexAwarePredicate</code></p>
</li>
<li>
<p><code>VisitablePredicate</code></p>
</li>
<li>
<p><code>SqlPredicate/Parser</code></p>
</li>
<li>
<p><code>TruePredicate</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Moved the <code>FalsePredicate</code> and <code>SkipIndexPredicate</code> classes to
the <code>com.hazelcast.query.impl.predicates</code> package.</p>
</li>
<li>
<p>Converted <code>PagingPredicate</code> and <code>PartitionPredicate</code> to interfaces
and added <code>PagingPredicateImpl</code> and <code>PartitionPredicateImpl</code> to
the <code>com.hazelcast.query.impl.predicate</code> package.</p>
</li>
<li>
<p>Converted <code>PredicateBuilder</code> and <code>EntryObject</code> to interfaces (and made
<code>EntryObject</code> a nested interface in <code>PredicateBuilder</code>) and added
<code>PredicateBuilderImpl</code> to the <code>com.hazelcast.query.impl.predicates</code> package.</p>
</li>
<li>
<p>The public API classes/interfaces no longer extend <code>IndexAwarePredicate</code>/
<code>VisitablePredicate</code>; this dependency has been moved to the <code>impl</code> classes.</p>
</li>
<li>
<p>Introduced the new factory methods in <code>Predicates</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>newPredicateBuilder()</code></p>
</li>
<li>
<p><code>sql()</code></p>
</li>
<li>
<p><code>pagingPredicate()</code></p>
</li>
<li>
<p><code>partitionPredicate()</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consequently, the public Predicate API now provides only interfaces (<code>Predicate</code>,
<code>PagingPredicate</code> and <code>PartitionPredicate</code>) with no dependencies on any internal APIs.</p>
</div>
<div class="paragraph">
<p>See the <a href="#distributed-query">Distributed Query chapter</a> for more information on predicates.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changing_the_uuid_string_type_to_uuid"><a class="anchor" href="#_changing_the_uuid_string_type_to_uuid"></a>B.1.24. Changing the UUID String Type to UUID</h4>
<div class="paragraph">
<p>Some public APIs that return UUID strings have been changed to return UUID.
These changes include <code>getUuid()</code> method of the <code>Endpoint</code> interface,
<code>getTxnId()</code> method of the <code>TransactionContext</code> interface,
return values of the listener registrations and <code>registrationId</code> parameters for the methods
that de-register the listeners.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after sample implementations.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        String registrationId = hazelcastInstance.getClientService().addClientListener(new ClientListener() {
            @Override
            public void clientConnected(Client client) {
                String clientUuid = client.getUuid();
                System.out.println("Client connected &gt;&gt;&gt; " + clientUuid);
            }

            @Override
            public void clientDisconnected(Client client) {
                String clientUuid = client.getUuid();
                System.out.println("Client disconnected &gt;&gt;&gt; " + clientUuid);
            }
        });
        hazelcastInstance.getClientService().removeClientListener(registrationId);</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        UUID registrationId = hazelcastInstance.getClientService().addClientListener(new ClientListener() {
            @Override
            public void clientConnected(Client client) {
                UUID clientUuid = client.getUuid();
                System.out.println("Client connected &gt;&gt;&gt; " + clientUuid);
            }

            @Override
            public void clientDisconnected(Client client) {
                UUID clientUuid = client.getUuid();
                System.out.println("Client disconnected &gt;&gt;&gt; " + clientUuid);
            }
        });
        hazelcastInstance.getClientService().removeClientListener(registrationId);</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecated_concurrency_api_implementations"><a class="anchor" href="#_removal_of_deprecated_concurrency_api_implementations"></a>B.1.25. Removal of Deprecated Concurrency API Implementations</h4>
<div class="paragraph">
<p>After introduction of <em>CP Subsystem</em> in Hazelcast IMDG 3.12,
legacy implementations of the distributed concurrency APIs, e.g., <code>ILock</code> and <code>IAtomicLong</code>,
had been deprecated.
In IMDG 4.0, these deprecated implementations and additionally
<code>ILock</code> and <code>ICondition</code> interfaces are completely removed.</p>
</div>
<div class="paragraph">
<p>Differently from Hazelcast IMDG 3.12, <em>CP Subsystem</em> received
an <em>unsafe</em> operation mode in IMDG 4.0 which provides weaker
consistency guarantees similar to former implementations in Hazelcast IMDG 3.x series.</p>
</div>
<div class="paragraph">
<p>For more information, see the <a href="#cp-subsystem">CP Subsystem section</a>.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IAtomicLong;
import com.hazelcast.core.IAtomicReference;
import com.hazelcast.core.ICountDownLatch;
import com.hazelcast.core.ILock;
import com.hazelcast.core.ISemaphore;

public class Main {

    public static void main(String[] args) {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

        IAtomicLong atomiclong = hazelcastInstance.getAtomicLong("atomiclong");
        atomiclong.incrementAndGet();

        IAtomicReference&lt;String&gt; atomicref = hazelcastInstance.getAtomicReference("atomicref");
        atomicref.set("value");

        ILock lock = hazelcastInstance.getLock("lock");
        lock.tryLock();

        ISemaphore semaphore = hazelcastInstance.getSemaphore("semaphore");
        semaphore.tryAcquire();

        ICountDownLatch latch = hazelcastInstance.getCountDownLatch("latch");
        latch.countDown();
    }
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.cp.CPSubsystem;
import com.hazelcast.cp.IAtomicLong;
import com.hazelcast.cp.IAtomicReference;
import com.hazelcast.cp.ICountDownLatch;
import com.hazelcast.cp.ISemaphore;
import com.hazelcast.cp.lock.FencedLock;

public class Main {

    public static void main(String[] args) {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        CPSubsystem cpSubsystem = hazelcastInstance.getCPSubsystem();

        IAtomicLong atomiclong = cpSubsystem.getAtomicLong("atomiclong");
        atomiclong.incrementAndGet();

        IAtomicReference&lt;String&gt; atomicref = cpSubsystem.getAtomicReference("atomicref");
        atomicref.set("value");

        FencedLock lock = cpSubsystem.getLock("lock");
        lock.tryLock();

        ISemaphore semaphore = cpSubsystem.getSemaphore("semaphore");
        semaphore.tryAcquire();

        ICountDownLatch latch = cpSubsystem.getCountDownLatch("latch");
        latch.countDown();
    }
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_removal_of_legacy_merge_policies"><a class="anchor" href="#_removal_of_legacy_merge_policies"></a>B.1.26. Removal of Legacy Merge Policies</h4>
<div class="paragraph">
<p>All legacy merge policies have been removed. Replacements of
legacies are under the <code>com.hazelcast.spi.merge</code> package.</p>
</div>
<div class="paragraph">
<p>These are the replacements for IMap and ICache:</p>
</div>
<div class="paragraph">
<p><em>Removed IMap Merge Policies and Their Replacements</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.map.merge.HigherHitsMapMergePolicy</code> &#8594; <code>com.hazelcast.spi.merge.HigherHitsMergePolicy</code></p>
</li>
<li>
<p><code>com.hazelcast.map.merge.LatestUpdateMapMergePolicy</code> &#8594; <code>com.hazelcast.spi.merge.LatestUpdateMergePolicy</code></p>
</li>
<li>
<p><code>com.hazelcast.map.merge.PassThroughMergePolicy</code> &#8594; <code>com.hazelcast.spi.merge.PassThroughMergePolicy</code></p>
</li>
<li>
<p><code>com.hazelcast.map.merge.PutIfAbsentMapMergePolicy</code> &#8594; <code>com.hazelcast.spi.merge.PutIfAbsentMergePolicy</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Removed ICache Merge Policies and Their Replacements</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.cache.merge.HigherHitsCacheMergePolicy</code> &#8594; <code>com.hazelcast.spi.merge.HigherHitsMergePolicy</code></p>
</li>
<li>
<p><code>com.hazelcast.cache.merge.LatestAccessCacheMergePolicy</code> &#8594; <code>com.hazelcast.spi.merge.LatestAccessMergePolicy</code></p>
</li>
<li>
<p><code>com.hazelcast.cache.merge.PassThroughCacheMergePolicy</code> &#8594; <code>com.hazelcast.spi.merge.PassThroughMergePolicy</code></p>
</li>
<li>
<p><code>com.hazelcast.cache.merge.PutIfAbsentCacheMergePolicy</code> &#8594; <code>com.hazelcast.spi.merge.PutIfAbsentMergePolicy</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Moreover, the <code>setMergePolicy/getMergePolicy</code> methods have been
removed from <code>MapConfig</code>, <code>ReplicatedMapConfig</code> and <code>CacheConfig</code>.
They have been replaced by the <code>setMergePolicyConfig/getMergePolicyConfig</code> methods.</p>
</div>
<div class="paragraph">
<p>The <code>merge-policy</code> declarative configuration element that
has been used in the older IMDG versions still can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;merge-policy batch-size="100"&gt;LatestAccessMergePolicy&lt;/merge-policy&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#configuring-merge-policies">here</a> for more information on configuring merge policies.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_aws_configuration"><a class="anchor" href="#_changes_in_aws_configuration"></a>B.1.27. Changes in AWS Configuration</h4>
<div class="paragraph">
<p>AWS programmatic configuration has been merged with a more universal configuration
infrastructure common to all cloud providers. The declarative configuration
remains unchanged. See <a href="https://github.com/hazelcast/hazelcast-aws/blob/master/README.md#configuration" target="_blank" rel="noopener">here</a>
for more information on configuring Hazelcast IMDG on AWS.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">AwsConfig config = new AwsConfig();
config.setSecretKey("my-secret-key") ;
config.setRegion("my-region");
config.setSecurityGroupName("my-security-group");
config.setTagKey("my-tag-key");
config.setTagValue("my-tag-value");
...
config.setEnabled(true);</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">AwsConfig config = new AwsConfig();
config.setProperty("secret-key", "my-secret-key") ;
config.setProperty("region", "my-region");
config.setProperty("security-group-name", "my-security-group-name");
config.setProperty("tag-key", "my-tag-key");
config.setProperty("tag-value", "my-tag-value");
...
config.setEnabled(true);</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecated_system_properties"><a class="anchor" href="#_removal_of_deprecated_system_properties"></a>B.1.28. Removal of Deprecated System Properties</h4>
<div class="paragraph">
<p>The following deprecated cluster properties were removed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.rest.enabled</code></p>
</li>
<li>
<p><code>hazelcast.memcache.enabled</code></p>
</li>
<li>
<p><code>hazelcast.http.healthcheck.enabled</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please see the <a href="#using-the-rest-endpoint-groups">Using the REST Endpoint Groups section</a> on how
to configure Hazelcast instance to expose REST endpoints.
Please see the the <a href="#health-check-and-monitoring">Health Check and Monitoring section</a> on how
to enable the health check.
Please see the <a href="#memcache-client">Memcache Client section</a> on how to enable memcache client
request listener service.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecations_in_loginmoduleconfig"><a class="anchor" href="#_removal_of_deprecations_in_loginmoduleconfig"></a>B.1.29. Removal of Deprecations in <code>LoginModuleConfig</code></h4>
<div class="paragraph">
<p>The following deprecated methods have been removed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getImplementation()</code>, replaced by <code>getClassName()</code>.</p>
</li>
<li>
<p><code>setImplementation(Object)</code>, replaced by <code>setClassName(String)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In declarative configuration <code>class-name</code> property should be used instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecations_in_multimapconfig"><a class="anchor" href="#_removal_of_deprecations_in_multimapconfig"></a>B.1.30. Removal of Deprecations in <code>MultiMapConfig</code></h4>
<div class="paragraph">
<p>The following deprecated methods have been removed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getSyncBackupCount()</code>, replaced by <code>getBackupCount()</code>.</p>
</li>
<li>
<p><code>setSyncBackupCount(int)</code>, replaced by <code>setBackupCount(int)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In declarative configuration <code>backup-count</code> property should be used instead.</p>
</div>
<div class="paragraph">
<p>See <a href="#configuring-multimap">here</a> for more information on configuring MultiMap.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecations_in_partitioningstrategyconfig"><a class="anchor" href="#_removal_of_deprecations_in_partitioningstrategyconfig"></a>B.1.31. Removal of Deprecations in <code>PartitioningStrategyConfig</code></h4>
<div class="paragraph">
<p>Misspelled <code>setPartitionStrategy(PartitioningStrategy)</code> has been removed,
<code>setPartitioningStrategy(PartitioningStrategy)</code> should be used instead.</p>
</div>
<div class="paragraph">
<p>See <a href="#partitioningstrategy">here</a> for more information on configuring MultiMap.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecations_in_serviceconfig"><a class="anchor" href="#_removal_of_deprecations_in_serviceconfig"></a>B.1.32. Removal of Deprecations in <code>ServiceConfig</code></h4>
<div class="paragraph">
<p>The following deprecated methods have been removed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getServiceImpl()</code>, replaced by <code>getImplementation()</code>.</p>
</li>
<li>
<p><code>setServiceImpl(Object)</code>, replaced by <code>setImplementation(Object)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/ServiceConfig.html" target="_blank" rel="noopener">here</a>
for <code>ServiceConfig</code>s Javadoc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecations_in_transactioncontext"><a class="anchor" href="#_removal_of_deprecations_in_transactioncontext"></a>B.1.33. Removal of Deprecations in <code>TransactionContext</code></h4>
<div class="paragraph">
<p>Deprecated <code>getXaResource()</code> method has been removed. <code>HazelcastInstance.getXAResource()</code>
should be used instead.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/core/HazelcastInstance.html" target="_blank" rel="noopener">here</a>
for <code>HazelcastInstance</code>s Javadoc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecations_in_distributedobjectevent"><a class="anchor" href="#_removal_of_deprecations_in_distributedobjectevent"></a>B.1.34. Removal of Deprecations in <code>DistributedObjectEvent</code></h4>
<div class="paragraph">
<p>Deprecated <code>getObjectId()</code> method has been removed, <code>getObjectName()</code> should be used
instead.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/core/DistributedObjectEvent.html" target="_blank" rel="noopener">here</a>
for <code>DistributedObjectEvents</code>s Javadoc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removal_of_deprecated_entrylistener_based_listener_api_in_imap"><a class="anchor" href="#_removal_of_deprecated_entrylistener_based_listener_api_in_imap"></a>B.1.35. Removal of Deprecated <code>EntryListener</code>-based Listener API in <code>IMap</code></h4>
<div class="paragraph">
<p>The following set of deprecated <code>EntryListener</code>-based listener API methods has been
removed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>addLocalEntryListener(EntryListener&lt;K, V&gt;)</code></p>
</li>
<li>
<p><code>addLocalEntryListener(EntryListener&lt;K, V&gt;, Predicate&lt;K, V&gt;, boolean)</code></p>
</li>
<li>
<p><code>addLocalEntryListener(EntryListener&lt;K, V&gt;, Predicate&lt;K, V&gt;, K, boolean)</code></p>
</li>
<li>
<p><code>addEntryListener(EntryListener&lt;K, V&gt;, boolean)</code></p>
</li>
<li>
<p><code>addEntryListener(EntryListener&lt;K, V&gt;, K, boolean)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following <code>MapListener</code>-based methods should be used as replacements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>addLocalEntryListener(MapListener)</code></p>
</li>
<li>
<p><code>addLocalEntryListener(MapListener, Predicate&lt;K,V&gt;, boolean)</code></p>
</li>
<li>
<p><code>addLocalEntryListener(MapListener, Predicate&lt;K,V&gt;, K, boolean)</code></p>
</li>
<li>
<p><code>addEntryListener(MapListener, boolean)</code></p>
</li>
<li>
<p><code>addEntryListener(MapListener, K, boolean)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>EntryListener</code>-based listeners are still supported by the newer
<code>MapListener</code>-based API and declarative configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_imap_eviction_configuration"><a class="anchor" href="#_changes_in_imap_eviction_configuration"></a>B.1.36. Changes in <code>IMap</code> Eviction Configuration</h4>
<div class="paragraph">
<p>There has been a simplification and improvement in the
way of configuring the eviction for a map.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;eviction-policy&gt;LRU&lt;/eviction-policy&gt;
        &lt;max-size policy="PER_NODE"&gt;20&lt;/max-size&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;eviction eviction-policy="LRU" max-size-policy="PER_NODE" size="20"/&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_changes_in_imap_custom_eviction_policy_configuration"><a class="anchor" href="#_changes_in_imap_custom_eviction_policy_configuration"></a>B.1.37. Changes in <code>IMap</code> Custom Eviction Policy Configuration</h4>
<div class="paragraph">
<p>There has been a simplification and improvement in the
way of configuring the custom eviction policy for a map.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after samples.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;map-eviction-policy-class-name&gt;
            com.mycompany.MyMapEvictionPolicyComparator
        &lt;/map-eviction-policy-class-name&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;eviction comparator-class-name="com.mycompany.MyMapEvictionPolicyComparator"/&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_changes_in_entrylistenerconfig"><a class="anchor" href="#_changes_in_entrylistenerconfig"></a>B.1.38. Changes in <code>EntryListenerConfig</code></h4>
<div class="paragraph">
<p>Return type of the <code>EntryListenerConfig.getImplementation()</code>
method has been changed from <code>EntryListener</code> to <code>MapListener</code>.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after snippets.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EntryListenerConfig config = new EntryListenerConfig();
EntryListener listenerImpl = config.getImplementation();</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EntryListenerConfig config = new EntryListenerConfig();
MapListener listenerImpl = config.getImplementation();</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_changes_in_rest_endpoints"><a class="anchor" href="#_changes_in_rest_endpoints"></a>B.1.39. Changes in REST Endpoints</h4>
<div class="paragraph">
<p>The following REST endpoints have been changed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/hazelcast/rest/mancenter/changeurl</code> is removed</p>
</li>
<li>
<p>All <code>/hazelcast/rest/mancenter/wan/*</code> endpoints are renamed to <code>/hazelcast/rest/wan/</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following REST endpoints now require cluster name and password
as the first two URL-encoded parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/hazelcast/rest/wan/sync/map</code></p>
</li>
<li>
<p><code>/hazelcast/rest/wan/sync/allmaps</code></p>
</li>
<li>
<p><code>/hazelcast/rest/wan/clearWanQueues</code></p>
</li>
<li>
<p><code>/hazelcast/rest/wan/addWanConfig</code></p>
</li>
<li>
<p><code>/hazelcast/rest/wan/pausePublisher</code></p>
</li>
<li>
<p><code>/hazelcast/rest/wan/stopPublisher</code></p>
</li>
<li>
<p><code>/hazelcast/rest/wan/resumePublisher</code></p>
</li>
<li>
<p><code>/hazelcast/rest/wan/consistencyCheck/map</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The output of the following endpoints has been changed to JSON:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/hazelcast/health/node-state</code></p>
</li>
<li>
<p><code>/hazelcast/health/cluster-state</code></p>
</li>
<li>
<p><code>/hazelcast/health/cluster-safe</code></p>
</li>
<li>
<p><code>/hazelcast/health/migration-queue-size</code></p>
</li>
<li>
<p><code>/hazelcast/health/cluster-size</code></p>
</li>
<li>
<p><code>/hazelcast/health/ready</code></p>
</li>
<li>
<p><code>/hazelcast/rest/cluster</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_the_diagnostics_configuration"><a class="anchor" href="#_changes_in_the_diagnostics_configuration"></a>B.1.40. Changes in the Diagnostics Configuration</h4>
<div class="paragraph">
<p>By introducing the <a href="#metrics">metrics system</a> in Hazelcast IMDG 4.0,
the metrics collected by <a href="#diagnostics">Diagnostics</a>
and the metrics system is shared.
This has come with the following changes of the system
properties that configure diagnostics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.diagnostics.metric.level</code> is not available anymore.
Collecting debug metrics can be enabled by setting
the <code>hazelcast.metrics.debug.enabled</code> or <code>hazelcast.client.metrics.debug.enabled</code>
system properties to <code>true</code> for the members and clients respectively.</p>
</li>
<li>
<p><code>hazelcast.diagnostics.metric.distributed.datastructures</code> is not anymore available
since the data structure metrics are required for the other <a href="#metric-consumers">Metric Consumers</a>.
Therefore, they are collected by default and no need for enabling it for the diagnostics.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_the_management_center_configuration"><a class="anchor" href="#_changes_in_the_management_center_configuration"></a>B.1.41. Changes in the Management Center Configuration</h4>
<div class="paragraph">
<p>As Management Center now uses Hazelcast Java client for communication with the cluster,
all attributes and nested elements have been removed from programmatic, XML and YAML configurations
for Management Center, i.e., from <code>ManagementCenterConfig</code> class and <code>management-center</code>
configuration element, except for the <code>scripting-enabled</code> attribute.</p>
</div>
<div class="paragraph">
<p>The default value of <code>scripting-enabled</code> attribute is <code>false</code>, whereas in
Hazelcast 3.x it was enabled by default for Hazelcast Open Source.</p>
</div>
<div class="paragraph">
<p>A full example of settings available in the Management Center configuration now looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;management-center scripting-enabled="true" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This has come with the following changes of the system properties that configure Management Center:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.mc.url.change.enabled</code> is not available anymore.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_changes_in_the_event_journal_configuration"><a class="anchor" href="#_changes_in_the_event_journal_configuration"></a>B.1.42. Changes in the Event Journal Configuration</h4>
<div class="paragraph">
<p>Event journal configuration had been put as a top-level configuration
element. With IMDG 4.0, this restriction has been removed; this means
event journal configuration now can be part of both map and cache
configurations. This eliminates additionally specifying the map
/cache names on the event journal configuration to connect it
to the map/cache configurations.</p>
</div>
<div class="paragraph">
<p>See the following table for the before/after snippets.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>Before IMDG 4.0</em></strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong><em>After IMDG 4.0</em></strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;event-journal enabled="false"&gt;
        &lt;mapName&gt;default&lt;/mapName&gt;
        &lt;capacity&gt;10000&lt;/capacity&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
    &lt;/event-journal&gt;
    ...
    &lt;event-journal enabled="false"&gt;
        &lt;cacheName&gt;default&lt;/cacheName&gt;
        &lt;capacity&gt;10000&lt;/capacity&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
    &lt;/event-journal&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;event-journal enabled="false"&gt;
            &lt;capacity&gt;10000&lt;/capacity&gt;
            &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;/event-journal&gt;
    &lt;/map&gt;
    ...
    &lt;cache name="default"&gt;
        &lt;event-journal enabled="false"&gt;
            &lt;capacity&gt;10000&lt;/capacity&gt;
            &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;/event-journal&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_to_hazelcast_imdg_3_12_x"><a class="anchor" href="#_upgrading_to_hazelcast_imdg_3_12_x"></a>B.2. Upgrading to Hazelcast IMDG 3.12.x</h3>
<div class="ulist">
<ul>
<li>
<p><strong>REST endpoint authentication</strong>: The authentication to REST endpoints has been changed
in Hazelcast IMDG 3.12. Hazelcast IMDG 3.11.x checks group name and password, while 3.12 checks
just the group name when security is disabled, and it uses the client login modules when the security is enabled.</p>
</li>
<li>
<p><strong>Upgrading Cluster Version From IMDG 3.11 to 3.12</strong>:
For the IMDG versions before 3.12, REST API could be enabled by using the
<code>hazelcast.rest.enabled</code> system property, which is deprecated now.
IMDG 3.12 and newer versions introduce the <code>rest-api</code> configuration element
along with REST endpoint groups.
Therefore, a configuration change is needed specifically when performing
a rolling member upgrade from IMDG 3.11 to 3.12.</p>
<div class="paragraph">
<p>So, the steps listed in the above <a href="#rolling-upgrade-procedure">Rolling Upgrade Procedure</a> section
should be as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Shutdown the 3.11 member</p>
</li>
<li>
<p>Wait until all partition migrations are completed</p>
</li>
<li>
<p>Update the member with 3.12 binaries</p>
</li>
<li>
<p>Update the configuration (see below)</p>
</li>
<li>
<p>Start the member</p>
<div class="paragraph">
<p>For the 4th step ("Update the configuration"), the configuration
should be updated as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;rest-api enabled="true"&gt;
        &lt;endpoint-group name="CLUSTER_WRITE" enabled="true"/&gt;
    &lt;/rest-api&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#using-the-rest-endpoint-groups">[using-the-rest-endpoint-groups]</a> section for more
information.</p>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_from_hazelcast_imdg_3_10_x"><a class="anchor" href="#_upgrading_from_hazelcast_imdg_3_10_x"></a>B.3. Upgrading from Hazelcast IMDG 3.10.x</h3>
<div class="paragraph">
<p>This section provides information to be considered when upgrading from Hazelcast IMDG 3.9.x to 3.10.x and newer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Starting with Hazelcast 3.10, split-brain recovery is supported for
the data structures whose in-memory format is <code>NATIVE</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_from_hazelcast_imdg_3_9_x"><a class="anchor" href="#_upgrading_from_hazelcast_imdg_3_9_x"></a>B.4. Upgrading from Hazelcast IMDG 3.9.x</h3>
<div class="paragraph">
<p>This section provides information to be considered when upgrading from Hazelcast IMDG 3.9.x to 3.10.x and newer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://docs.hazelcast.org/docs/3.10/manual/html-single/#requirements-and-linuxunix-configuration">system property based configuration</a>
for Ping Failure Detector is deprecated. Instead, use the elements to configure it, an example of which is shown below:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;network&gt;
    ...
        &lt;failure-detector&gt;
            &lt;icmp enabled="true"&gt;
                &lt;timeout-milliseconds&gt;1000&lt;/timeout-milliseconds&gt;
                &lt;fail-fast-on-startup&gt;true&lt;/fail-fast-on-startup&gt;
                &lt;interval-milliseconds&gt;1000&lt;/interval-milliseconds&gt;
                &lt;max-attempts&gt;2&lt;/max-attempts&gt;
                &lt;parallel-mode&gt;true&lt;/parallel-mode&gt;
                &lt;ttl&gt;255&lt;/ttl&gt;
            &lt;/icmp&gt;
        &lt;/failure-detector&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Until Hazelcast IMDG 3.10, the configuration has been like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.icmp.enabled"&gt;true&lt;/property&gt;
        &lt;property name="hazelcast.icmp.parallel.mode"&gt;true&lt;/property&gt;
        &lt;property name="hazelcast.icmp.timeout"&gt;1000&lt;/property&gt;
        &lt;property name="hazelcast.icmp.max.attempts"&gt;3&lt;/property&gt;
        &lt;property name="hazelcast.icmp.interval"&gt;1000&lt;/property&gt;
        &lt;property name="hazelcast.icmp.ttl"&gt;0&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_to_hazelcast_imdg_3_8_x"><a class="anchor" href="#_upgrading_to_hazelcast_imdg_3_8_x"></a>B.5. Upgrading to Hazelcast IMDG 3.8.x</h3>
<div class="paragraph">
<p>This section provides information to be considered when upgrading from Hazelcast IMDG 3.7.x to 3.8.x and newer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Introducing &lt;wan-publisher&gt; element</strong>: The configuration element <code>&lt;target-cluster&gt;</code> has been replaced with
the element <code>&lt;wan-publisher&gt;</code> in WAN replication configuration.</p>
</li>
<li>
<p><strong>WaitNotifyService</strong> interface has been renamed as <strong>OperationParker</strong>.</p>
</li>
<li>
<p><strong>Synchronizing WAN Target Cluster</strong>: The URL for the related REST call has been changed from
<code>http://member_ip:port/hazelcast/rest/wan/sync/map</code> to <code>http://member_ip:port/hazelcast/rest/mancenter/wan/sync/map</code>.</p>
</li>
<li>
<p><strong><code>JCache usage</code>:</strong> Due to a compatibility problem, <code>CacheConfig</code> serialization may not
work if your member is 3.8.x where x &lt; 5. You need to use the 3.8.5 or higher versions where the problem is fixed.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_to_hazelcast_imdg_3_7_x"><a class="anchor" href="#_upgrading_to_hazelcast_imdg_3_7_x"></a>B.6. Upgrading to Hazelcast IMDG 3.7.x</h3>
<div class="paragraph">
<p>This section provides information to be considered when upgrading from Hazelcast IMDG 3.6.x to 3.7.x and newer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Important note about Hazelcast System Properties:</strong> Even Hazelcast has not been
recommending the usage of <code>GroupProperties.java</code> class while benefiting from system properties,
there has been a change to inform to the users who have been using this class:
the class <code>GroupProperties.java</code> has been replaced by <code>GroupProperty.java</code>.
In this new class, system properties are instances of the newly introduced <code>HazelcastProperty</code> object.
You can access the names of these properties by calling the <code>getName()</code> method of <code>HazelcastProperty</code>.</p>
</li>
<li>
<p><strong>Removal of WanNoDelayReplication</strong>: <code>WanNoDelayReplication</code> implementation of Hazelcast&#8217;s WAN Replication has been removed.
You can still achieve this behavior by setting the batch size to <code>1</code> while configuring the WanBatchReplication.
See the <a href="#defining-wan-replication">Defining WAN Replication section</a> for more information.</p>
</li>
<li>
<p><strong><code>JCache</code> usage:</strong> Changes in <code>JCache</code> implementation which broke compatibility of 3.6.x clients to 3.7, 3.7.1, 3.7.2 cluster members and
vice versa. 3.7, 3.7.1, 3.7.2 clients are also incompatible with 3.6.x cluster members.
This issue only affects Java clients which use <code>JCache</code> functionality.</p>
<div class="paragraph">
<p>You can use a compatibility option which can be used to ensure backwards compatibility with 3.6.x clients.</p>
</div>
<div class="paragraph">
<p>In order to upgrade a 3.6.x cluster and clients to 3.7.3 (or later), you need to use this
compatibility option on either the member or the client side, depending on which one is upgraded first:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>first upgrade your cluster members to 3.7.3, adding property <code>hazelcast.compatibility.3.6.client=true</code> to your configuration;
when started with this property, cluster members are compatible with 3.6.x and 3.7.3+ clients but not with 3.7, 3.7.1, 3.7.2 clients.
Once your cluster is upgraded, you may upgrade your applications to use client version 3.7.3+.</p>
</li>
<li>
<p>upgrade your clients from 3.6.x to 3.7.3, adding property <code>hazelcast.compatibility.3.6.server=true</code> to your Hazelcast client configuration.
A 3.7.3 client started with this compatibility option is compatible with 3.6.x and 3.7.3+ cluster members but incompatible with 3.7, 3.7.1, 3.7.2 cluster members.
Once your clients are upgraded, you may then proceed to upgrade your cluster members to version 3.7.3 or later.</p>
<div class="paragraph">
<p>You may use any of the supported ways as described in the <a href="#system-properties">System Properties section</a> to configure
the compatibility option. When done upgrading your cluster and clients, you may remove the compatibility property from
your Hazelcast member configuration.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>eviction-percentage</code> and <code>min-eviction-check-millis</code> elements are deprecated.
They are ignored if configured, since the map eviction is based on the sampling of entries.
See the <a href="#eviction-algorithm">Eviction Algorithm section</a> for details.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_to_hazelcast_imdg_3_6_x"><a class="anchor" href="#_upgrading_to_hazelcast_imdg_3_6_x"></a>B.7. Upgrading to Hazelcast IMDG 3.6.x</h3>
<div class="paragraph">
<p>This section provides information to be considered when upgrading from Hazelcast IMDG 3.5.x to 3.6.x and newer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Introducing new configuration options for WAN replication:</strong> WAN replication related system properties, which are
configured on a per member basis, can now be configured per target cluster.
The following system properties are no longer valid.</p>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.enterprise.wanrep.batch.size</code>, see the <a href="#batch-size">Batch Size section</a>.</p>
</li>
<li>
<p><code>hazelcast.enterprise.wanrep.batchfrequency.seconds</code>, see the <a href="#batch-maximum-delay">Batch Maximum Delay section</a>.</p>
</li>
<li>
<p><code>hazelcast.enterprise.wanrep.optimeout.millis</code>, see the <a href="#response-timeout">Response Timeout section</a>.</p>
</li>
<li>
<p><code>hazelcast.enterprise.wanrep.queue.capacity</code>, see the <a href="#queue-capacity">Queue Capacity section</a>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Removal of deprecated <code>getId()</code> method</strong>: The method <code>getId()</code> in the interface <code>DistributedObject</code> has been removed.
Please use the <code>getName()</code> method instead.</p>
</li>
<li>
<p><strong>Change in the Custom Serialization in the C++ Client Distribution</strong>:
Before, the method <code>getTypeId()</code> was used to retrieve the ID of the object to be serialized.
With this release, the method <code>getHazelcastTypeId()</code> is used and you give your object as a parameter to this new method.
Also, <code>getTypeId()</code> was used in your custom serializer class; it has been renamed to <code>getHazelcastTypeId()</code>, too.</p>
</li>
<li>
<p>The <code>LOCAL</code> transaction type has been deprecated. Use <code>ONE_PHASE</code> for the Hazelcast IMDG releases 3.6 and higher.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_to_hazelcast_imdg_3_5_x"><a class="anchor" href="#_upgrading_to_hazelcast_imdg_3_5_x"></a>B.8. Upgrading to Hazelcast IMDG 3.5.x</h3>
<div class="paragraph">
<p>This section provides information to be considered when upgrading from Hazelcast IMDG 3.4.x to 3.5.x and newer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Introducing the <code>spring-aware</code> element:</strong> Hazelcast used <code>SpringManagedContext</code> to scan <code>SpringAware</code> annotations by default.
This was causing some performance overhead for the users who do not use <code>SpringAware</code>.
With this release, <code>SpringAware</code> annotations are disabled by default.
By introducing the <code>spring-aware</code> element, it is possible to enable it by adding the <code>&lt;hz:spring-aware /&gt;</code> tag to the configuration.
See the <a href="#integration-with-spring">Spring Integration section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_to_hazelcast_imdg_3_x"><a class="anchor" href="#_upgrading_to_hazelcast_imdg_3_x"></a>B.9. Upgrading to Hazelcast IMDG 3.x</h3>
<div class="paragraph">
<p>This section provides information to be considered when upgrading from Hazelcast IMDG 2.x to 3.x.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Removal of deprecated static methods:</strong> The static methods of Hazelcast class reaching Hazelcast data components have been removed.
The functionality of these methods can be reached from the <code>HazelcastInstance</code> interface.
You should replace the following:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Map&lt;Integer, String&gt; customers = Hazelcast.getMap( "customers" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
// or if you already started an instance named "instance1"
// HazelcastInstance hazelcastInstance = Hazelcast.getHazelcastInstanceByName( "instance1" );
Map&lt;Integer, String&gt; customers = hazelcastInstance.getMap( "customers" );</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Renaming "instance" to "distributed object":</strong> There were confusions about the term "instance";
it was used for both the cluster members and distributed objects (map, queue, topic, etc. instances).
Starting with this release, the term "instance" is used for Hazelcast instances.
The term "distributed object" is used for map, queue, etc. instances.
You should replace the related methods with the new renamed ones.
3.0.x clients are smart clients in that they know in which cluster member the data is located,
so you can replace your lite members with native clients.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main( String[] args ) throws InterruptedException {
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IMap map = hazelcastInstance.getMap( "test" );
  Collection&lt;Instance&gt; instances = hazelcastInstance.getInstances();
  for ( Instance instance : instances ) {
    if ( instance.getInstanceType() == Instance.InstanceType.MAP ) {
      System.out.println( "There is a map with name: " + instance.getId() );
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main( String[] args ) throws InterruptedException {
  HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
  IMap map = hz.getMap( "test" );
  Collection&lt;DistributedObject&gt; objects = hazelcastInstance.getDistributedObjects();
  for ( DistributedObject distributedObject : objects ) {
    if ( distributedObject instanceof IMap ) {
      System.out.println( "There is a map with name: " + distributedObject.getName() );
    }
  }
}</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Package structure change:</strong> <code>PartitionService</code> has been moved to the <code>com.hazelcast.core</code> package from <code>com.hazelcast.partition</code>.</p>
</li>
<li>
<p><strong>Listener API change:</strong> The <code>removeListener</code> methods were taking the listener object as a parameter.
But this caused confusion since the same listener object may be used as a parameter for different listener registrations.
So we have changed the listener API. The <code>addListener</code> methods returns a unique ID and you can remove a listener by using this ID.
So you should do the following replacement if needed:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap map = hazelcastInstance.getMap( "map" );
map.addEntryListener( listener, true );
map.removeEntryListener( listener );</code></pre>
</div>
</div>
<div class="paragraph">
<p>with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap map = hazelcastInstance.getMap( "map" );
String listenerId = map.addEntryListener( listener, true );
map.removeEntryListener( listenerId );</code></pre>
</div>
</div>
</li>
<li>
<p><strong>IMap changes:</strong></p>
<div class="ulist">
<ul>
<li>
<p><code>tryRemove(K key, long timeout, TimeUnit timeunit)</code> returns boolean indicating whether operation is successful.</p>
</li>
<li>
<p><code>tryLockAndGet(K key, long time, TimeUnit timeunit)</code> is removed.</p>
</li>
<li>
<p><code>putAndUnlock(K key, V value)</code> is removed.</p>
</li>
<li>
<p><code>lockMap(long time, TimeUnit timeunit)</code> and <code>unlockMap()</code> are removed.</p>
</li>
<li>
<p><code>getMapEntry(K key)</code> is renamed as <code>getEntryView(K key)</code>. The returned object&#8217;s type (<code>MapEntry</code> class) is renamed as <code>EntryView</code>.</p>
</li>
<li>
<p>There is no predefined names for merge policies. You just give the full class name of the merge policy implementation:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;merge-policy&gt;com.hazelcast.map.merge.PassThroughMergePolicy&lt;/merge-policy&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also the <code>MergePolicy</code> interface has been renamed as <code>MapMergePolicy</code> and
returning null from the implemented <code>merge()</code> method causes the existing entry to be removed.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>IQueue changes:</strong> There is no change on IQueue API but there are changes on how <code>IQueue</code> is configured:
there is no backing map configuration for queue. Settings like backup count are directly configured on the queue configuration.
See the <a href="#queue">Queue section</a>.</p>
</li>
<li>
<p><strong>Transaction API change:</strong> Transaction API has been changed. See the <a href="#transactions">Transactions chapter</a>.</p>
</li>
<li>
<p><strong>ExecutorService API change:</strong> The <code>MultiTask</code> and <code>DistributedTask</code> classes have been removed.
All the functionality is supported by the newly presented interface IExecutorService.
See the <a href="#executor-service">Executor Service section</a>.</p>
</li>
<li>
<p><strong>LifeCycleService API:</strong> The lifecycle has been simplified. The <code>pause()</code>, <code>resume()</code>, <code>restart()</code> methods have been removed.</p>
</li>
<li>
<p><strong>AtomicNumber:</strong> <code>AtomicNumber</code> class has been renamed as <code>IAtomicLong</code>.</p>
</li>
<li>
<p><strong>ICountDownLatch:</strong> The <code>await()</code> operation has been removed. We expect users to use <code>await()</code> method with timeout parameters.</p>
</li>
<li>
<p><strong>ISemaphore API:</strong> The <code>ISemaphore</code> has been substantially changed. The <code>attach()</code>, <code>detach()</code> methods have been removed.</p>
</li>
<li>
<p>Before, the default value for <code>max-size</code> eviction policy was <strong>cluster_wide_map_size</strong>.
Starting with this release, the default is <strong>PER_NODE</strong>.
After upgrading, the <code>max-size</code> should be set according to this new default, if it is not changed.
Otherwise, it is likely that <code>OutOfMemoryException</code> may be thrown.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_common_exception_types"><a class="anchor" href="#_common_exception_types"></a>Appendix C: Common Exception Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You may see the following exceptions in any Hazelcast operation when the described situations occur:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HazelcastInstanceNotActiveException</code>: Thrown when <code>HazelcastInstance</code> is not active (already shutdown or
being shutdown) during an invocation.</p>
</li>
<li>
<p><code>HazelcastOverloadException</code>: Thrown when the system cannot handle any more load due to an overload.
This exception is thrown when back pressure is enabled.</p>
</li>
<li>
<p><code>DistributedObjectDestroyedException</code>:
Thrown when a distributed data structure is destroyed using the <code>destroy()</code> method while
there is a blocking operation on it, e.g., waiting a response for the <code>Lock.lock()</code> method.</p>
</li>
<li>
<p><code>MemberLeftException</code>: Thrown when a member leaves during an invocation or execution.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hazelcast also throws the following exceptions in the cases of overall system problems such as
networking issues and long pauses:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PartitionMigratingException</code>: Thrown when an operation is executed on a partition,
but that partition is currently being moved.</p>
</li>
<li>
<p><code>TargetNotMemberException</code>: Thrown when an operation is sent to a machine that is not
a member of the cluster.</p>
</li>
<li>
<p><code>CallerNotMemberException</code>: Thrown when an operation was sent by a machine which is not a member in
the cluster when the operation is executed.</p>
</li>
<li>
<p><code>WrongTargetException</code>: Thrown when an operation is executed on the wrong machine, usually because
the partition that operation belongs to has been moved to some other member.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_license_questions"><a class="anchor" href="#_license_questions"></a>Appendix D: License Questions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast is distributed using the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache License 2</a>,
therefore permissions are granted
to use, reproduce and distribute it along with any kind of open source and closed source applications.</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG Pro and Enterprise are commercial products of Hazelcast, Inc. and distributed under
a commercial license that must be acquired
before using it in any type of released software. Feel free to contact
<a href="http://hazelcast.com/contact/" target="_blank" rel="noopener">Hazelcast sales department</a>
for more information on commercial offers.</p>
</div>
<div class="paragraph">
<p>Depending on the used feature-set, Hazelcast has certain runtime dependencies which might have different licenses.
Following are dependencies and their respective licenses.</p>
</div>
<div class="sect2">
<h3 id="_embedded_dependencies"><a class="anchor" href="#_embedded_dependencies"></a>D.1. Embedded Dependencies</h3>
<div class="paragraph">
<p>Embedded dependencies are merged (shaded) with the Hazelcast codebase at compile-time.
These dependencies become an integral part
of the Hazelcast distribution.</p>
</div>
<div class="paragraph">
<p>For license files of embedded dependencies, see the <code>license</code> directory of the Hazelcast distribution, available at our
<a href="https://hazelcast.org/download/" target="_blank" rel="noopener">download page</a>.</p>
</div>
<div class="paragraph">
<p><strong>minimal-json</strong>:</p>
</div>
<div class="paragraph">
<p>minimal-json is a JSON parsing and generation library which is a part of the Hazelcast distribution.
It is used for communication between the Hazelcast cluster and the Management Center.</p>
</div>
<div class="paragraph">
<p>minimal-json is distributed under the <a href="http://opensource.org/licenses/MIT" target="_blank" rel="noopener">MIT license</a> and
offers the same rights to add, use, modify and distribute the source code as the Apache License 2.0 that Hazelcast uses.
However, some other restrictions might apply.</p>
</div>
</div>
<div class="sect2">
<h3 id="_runtime_dependencies"><a class="anchor" href="#_runtime_dependencies"></a>D.2. Runtime Dependencies</h3>
<div class="paragraph">
<p>Depending on the used features, additional dependencies might be added to the dependency set.
Those runtime dependencies might have
other licenses. See the following list of additional runtime dependencies.</p>
</div>
<div class="paragraph">
<p><strong>Spring Framework</strong>:</p>
</div>
<div class="paragraph">
<p>Hazelcast offers a tight integration into the Spring Framework. Hazelcast can be configured and controlled using Spring.</p>
</div>
<div class="paragraph">
<p>The Spring Framework is distributed under the terms of the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache License 2</a> and therefore it is
fully compatible with Hazelcast.</p>
</div>
<div class="paragraph">
<p><strong>Hibernate</strong>:</p>
</div>
<div class="paragraph">
<p>Hazelcast integrates itself into Hibernate as a second-level cache provider.</p>
</div>
<div class="paragraph">
<p>Hibernate is distributed under the terms of the
<a href="https://www.gnu.org/licenses/lgpl-2.1.html" target="_blank" rel="noopener">Lesser General Public License 2.1</a>,
also known as LGPL. Please read carefully the terms of the LGPL since restrictions might apply.</p>
</div>
<div class="paragraph">
<p><strong>Apache Tomcat</strong>:</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG Enterprise offers native integration into Apache Tomcat for web session clustering.</p>
</div>
<div class="paragraph">
<p>Apache Tomcat is distributed under the terms of the
<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache License 2</a> and therefore
fully compatible with Hazelcast.</p>
</div>
<div class="paragraph">
<p><strong>Eclipse Jetty</strong>:</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG Enterprise offers native integration into Jetty for web session clustering.</p>
</div>
<div class="paragraph">
<p>Jetty is distributed with a dual licensing strategy. It is licensed under the terms of the
<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache License 2</a>
and under the <a href="https://www.eclipse.org/legal/epl-v10.html" target="_blank" rel="noopener">Eclipse Public License v1.0</a>, also known as EPL.
Due to the Apache License, it is fully compatible with Hazelcast.</p>
</div>
<div class="paragraph">
<p><strong>JCache API (JSR 107)</strong>:</p>
</div>
<div class="paragraph">
<p>Hazelcast offers a native implementation for JCache (JSR 107), which has a runtime dependency to the JCache API.</p>
</div>
<div class="paragraph">
<p>The JCache API is distributed under the terms of the so called
<a href="https://jcp.org/aboutJava/communityprocess/licenses/jsr107/Spec-License-JSR-107-10_22_12.pdf" target="_blank" rel="noopener">Specification License</a>.
Please read carefully the terms of this license since restrictions might apply.</p>
</div>
<div class="paragraph">
<p><strong>Boost C++ Libraries</strong>:</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG offers a native C&#43;&#43; client, which has a link-time dependency to the Boost C&#43;&#43; Libraries.</p>
</div>
<div class="paragraph">
<p>The Boost Libraries are distributed under the terms of the <a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank" rel="noopener">Boost Software License</a>), which is
very similar to the MIT or BSD license. Please read carefully the terms of this license since restrictions might apply.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_phone_homes"><a class="anchor" href="#_phone_homes"></a>Appendix E: Phone Homes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast uses phone home data to learn about the
usage of Hazelcast IMDG.</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG member instances call our phone
home server initially when they are started and
then every 24 hours. This applies to all the instances
joined to the cluster.</p>
</div>
<div class="paragraph">
<p><strong>What is sent in?</strong></p>
</div>
<div class="paragraph">
<p>The following information is sent in a phone home:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hazelcast IMDG version</p>
</li>
<li>
<p>Local Hazelcast IMDG member UUID</p>
</li>
<li>
<p>Download ID</p>
</li>
<li>
<p>A hash value of the cluster ID</p>
</li>
<li>
<p>Cluster size bands for 5, 10, 20, 40, 60, 100, 150, 300, 600 and &gt; 600</p>
</li>
<li>
<p>Number of connected clients bands of 5, 10, 20, 40, 60, 100, 150, 300, 600 and &gt; 600</p>
</li>
<li>
<p>Number of clients by language (Java, C++, C#)</p>
</li>
<li>
<p>Cluster uptime</p>
</li>
<li>
<p>Member uptime</p>
</li>
<li>
<p>Environment Information:</p>
<div class="ulist">
<ul>
<li>
<p>Name of operating system</p>
</li>
<li>
<p>Kernel architecture (32-bit or 64-bit)</p>
</li>
<li>
<p>Version of operating system</p>
</li>
<li>
<p>Version of installed Java</p>
</li>
<li>
<p>Name of Java Virtual Machine</p>
</li>
</ul>
</div>
</li>
<li>
<p>Hazelcast IMDG Enterprise specific:</p>
<div class="ulist">
<ul>
<li>
<p>Flag for Hazelcast Enterprise</p>
</li>
<li>
<p>Hash value of license key</p>
</li>
<li>
<p>Native memory usage</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Disabling Phone Homes</strong></p>
</div>
<div class="paragraph">
<p>Set the <code>hazelcast.phone.home.enabled</code> system property to
false either in the config
or on the Java command line. See the
<a href="#system-properties">System Properties appendix</a> for information on how to set a property.</p>
</div>
<div class="paragraph">
<p>You can also disable the phone home using the environment variable <code>HZ_PHONE_HOME_ENABLED</code>.</p>
</div>
<div class="paragraph">
<p>Simply add the following line to your <code>.bash_profile</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>export HZ_PHONE_HOME_ENABLED=false</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Phone Home URLs</strong></p>
</div>
<div class="paragraph">
<p>For versions 1.x and 2.x: <a href="http://www.hazelcast.com/version.jsp" class="bare">http://www.hazelcast.com/version.jsp</a>.</p>
</div>
<div class="paragraph">
<p>For versions 3.x up to 3.6: <a href="http://versioncheck.hazelcast.com/version.jsp" class="bare">http://versioncheck.hazelcast.com/version.jsp</a>.</p>
</div>
<div class="paragraph">
<p>For versions after 3.6: <a href="http://phonehome.hazelcast.com/ping" class="bare">http://phonehome.hazelcast.com/ping</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_frequently_asked_questions"><a class="anchor" href="#_frequently_asked_questions"></a>Appendix F: Frequently Asked Questions</h2>
<div class="sectionbody">
<hr>
<div class="paragraph">
<p><strong>What Guarantees does Hazelcast IMDG offer?</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast IMDGis distributed andhighly availableby nature.
It is achieved by keeping the data partition backup always on anotherHazelcastmember.</p>
</div>
<div class="paragraph">
<p>Hazelcast IMDG offers AP and CP functionality with different data structure implementations
(see <a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener">CAP theorem</a>).
Data structures exposed under<code>HazelcastInstance</code>API are allAPdata structures.
Hazelcast IMDG also contains aCPsubsystem, built on the Raft consensus algorithm and
accessed via<code>HazelcastInstance.getCPSubsytem()</code>which providesCPdata structures and APIs.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AP Hazelcast IMDG guarantees:</p>
<div class="ulist">
<ul>
<li>
<p>Withlazy replication, when the primary replica receives an update operation for a key,
it executes the update locally and propagates it to backup replicas. It marks each update
with a logical timestamp so that backups apply them in the correct order and converge to the
same state with the primary. Backup replicas can be used to scale reads (see the<a href="#enabling-backup-reads">Enabling Backup Reads section</a>)
with no strong consistency but monotonic reads guarantee.</p>
</li>
<li>
<p>It employs additional measurements to maintain consistency in a best-effort manner.</p>
</li>
<li>
<p>Hazelcast, as an AP product, does not provide the exactly-once guarantee. In general,
Hazelcast tends to be an at-least-once solution.</p>
</li>
<li>
<p>See the <a href="#consistency-and-replication-model">Consistency and Replication Model chapter</a>
for more information.</p>
</li>
</ul>
</div>
</li>
<li>
<p>CP Hazelcast IMDG Guarantees:</p>
<div class="ulist">
<ul>
<li>
<p>It builds a strongly consistent layer for a set of distributed data structures.
You can enable CP Subsystem and use it with the strong consistency guarantee.</p>
</li>
<li>
<p>Its data structures areCPwith respect to theCAPprinciple, i.e., they always
maintainlinearizabilityand prefer consistency over availability during network partitions.</p>
</li>
<li>
<p>Besides network partitions, CP Subsystem withstands server and client failures.</p>
</li>
<li>
<p>It provides a good degree of fault tolerance at run-time, and <a href="#cp-subsystem-persistence">CP Subsystem Persistence</a> enables more robustness.</p>
</li>
<li>
<p>See the <a href="#cp-subsystem">CP Subsystem chapter</a> for more information.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p><strong>Why 271 as the default partition count?</strong></p>
</div>
<div class="paragraph">
<p>The partition count of 271, being a prime number, is a good choice because
it is distributed to the members almost evenly.
For a small to medium sized cluster, the count of 271 gives an almost even partition distribution and optimal-sized partitions.
As your cluster becomes bigger, you should make this count bigger to have evenly distributed partitions.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Is Hazelcast thread-safe?</strong></p>
</div>
<div class="paragraph">
<p>Yes. All Hazelcast data structures are thread-safe.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How do members discover each other?</strong></p>
</div>
<div class="paragraph">
<p>When a member is started in a cluster, it is dynamically and automatically discovered.
The following are the types of discovery:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Discovery by TCP/IP: The first member created in the cluster (leader) forms a list of
IP addresses of other joining members and sends this list to these members so the members will know each other.</p>
</li>
<li>
<p>Discovery on clouds: Hazelcast supports discovery on cloud platforms such as jclouds based environments, Azure, Consul and PCF.</p>
</li>
<li>
<p>Multicast discovery: The members in a cluster discover each other by multicast, by default.
It is not recommended for production since UDP is often blocked in production environments and other discovery mechanisms are more definite.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once members are discovered, all the communication between them is via TCP/IP.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#discovery-mechanisms">Discovery Mechanisms section</a> for detailed information.
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p><strong>What happens when a member goes down?</strong></p>
</div>
<div class="paragraph">
<p>Once a member is gone (crashes), the following happens:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, the backups in other members are restored.</p>
</li>
<li>
<p>Then, data from these restored backups are recovered.</p>
</li>
<li>
<p>And finally, new backups for these recovered data are formed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So eventually, availability of the data is maintained.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How do I test the connectivity?</strong></p>
</div>
<div class="paragraph">
<p>If you notice that there is a problem with a member joining a cluster,
you may want to perform a connectivity test between the member to be joined and a member from the cluster.
You can use the <code>iperf</code> tool for this purpose.
For example, you can execute the below command on one member (i.e. listening on port 5701).</p>
</div>
<div class="paragraph">
<p><code>iperf -s -p 5701</code></p>
</div>
<div class="paragraph">
<p>And you can execute the below command on the other member.</p>
</div>
<div class="paragraph">
<p><code>iperf -c</code> <strong><code>&lt;IP address&gt;</code></strong> <code>-d -p 5701</code></p>
</div>
<div class="paragraph">
<p>The output should include connection information, such as the IP addresses, transfer speed and bandwidth.
Otherwise, if the output says <code>No route to host</code>, it means a network connection problem exists.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How do I choose keys properly?</strong></p>
</div>
<div class="paragraph">
<p>When you store a key and value in a distributed Map, Hazelcast serializes
the key and value and stores the byte array version of them in local ConcurrentHashMaps.
These ConcurrentHashMaps use <code>equals</code> and <code>hashCode</code> methods of byte array version of your key.
It does not take into account the actual <code>equals</code> and <code>hashCode</code> implementations of your objects.
So it is important that you choose your keys in a proper way.</p>
</div>
<div class="paragraph">
<p>Implementing <code>equals</code> and <code>hashCode</code> is not enough,
it is also important that the object is always serialized into the same byte array.
All primitive types like String, Long, Integer, etc. are good candidates for keys to be used in Hazelcast.
An unsorted Set is an example of a very bad candidate because Java Serialization may serialize
the same unsorted set in two different byte arrays.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How do I reflect value modifications?</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast always return a clone copy of a value. Modifying the returned value does not
change the actual value in the map (or multimap, list, set).
You should put the modified value back to make changes visible to all members.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">V value = map.get( key );
value.updateSomeProperty();
map.put( key, value );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Collections which return values of methods (such as <code>IMap.keySet</code>, <code>IMap.values</code>,
<code>IMap.entrySet</code>, <code>MultiMap.get</code>, <code>MultiMap.remove</code>, <code>IMap.keySet</code>, <code>IMap.values</code>) contain cloned values.
These collections are NOT backed up by related Hazelcast objects.
Therefore, changes to them are <strong>NOT</strong> reflected in the originals and vice-versa.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How do I test my Hazelcast cluster?</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast allows you to create more than one instance on the same JVM.
Each member is called <code>HazelcastInstance</code> and each has its own configuration,
socket and threads, so you can treat them as totally separate instances.</p>
</div>
<div class="paragraph">
<p>This enables you to write and to run cluster unit tests on a single JVM.
Because you can use this feature for creating separate members different applications running on
the same JVM (imagine running multiple web applications on the same JVM),
you can also use this feature for testing your Hazelcast cluster.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you want to test if two members have the same size of a map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testTwoMemberMapSizes() {
  // start the first member
  HazelcastInstance h1 = Hazelcast.newHazelcastInstance();
  // get the map and put 1000 entries
  Map map1 = h1.getMap( "testmap" );
  for ( int i = 0; i &lt; 1000; i++ ) {
    map1.put( i, "value" + i );
  }
  // check the map size
  assertEquals( 1000, map1.size() );
  // start the second member
  HazelcastInstance h2 = Hazelcast.newHazelcastInstance();
  // get the same map from the second member
  Map map2 = h2.getMap( "testmap" );
  // check the size of map2
  assertEquals( 1000, map2.size() );
  // check the size of map1 again
  assertEquals( 1000, map1.size() );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the test above, everything happens in the same thread.
When developing a multi-threaded test, you need to carefully handle coordination of the thread executions.
It is highly recommended that you use <code>CountDownLatch</code> for thread coordination (you can certainly use other ways).
Here is an example where we need to listen for messages and make sure that we got these messages.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testTopic() {
  // start two member cluster
  HazelcastInstance h1 = Hazelcast.newHazelcastInstance();
  HazelcastInstance h2 = Hazelcast.newHazelcastInstance();
  String topicName = "TestMessages";
  // get a topic from the first member and add a messageListener
  ITopic&lt;String&gt; topic1 = h1.getTopic( topicName );
  final CountDownLatch latch1 = new CountDownLatch( 1 );
  topic1.addMessageListener( new MessageListener() {
    public void onMessage( Object msg ) {
      assertEquals( "Test1", msg );
      latch1.countDown();
    }
  });
  // get a topic from the second member and add a messageListener
  ITopic&lt;String&gt; topic2 = h2.getTopic(topicName);
  final CountDownLatch latch2 = new CountDownLatch( 2 );
  topic2.addMessageListener( new MessageListener() {
    public void onMessage( Object msg ) {
      assertEquals( "Test1", msg );
      latch2.countDown();
    }
  } );
  // publish the first message, both should receive this
  topic1.publish( "Test1" );
  // shutdown the first member
  h1.shutdown();
  // publish the second message, second member's topic should receive this
  topic2.publish( "Test1" );
  try {
    // assert that the first member's topic got the message
    assertTrue( latch1.await( 5, TimeUnit.SECONDS ) );
    // assert that the second members' topic got two messages
    assertTrue( latch2.await( 5, TimeUnit.SECONDS ) );
  } catch ( InterruptedException ignored ) {
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can start Hazelcast members with different configurations.
Remember to call <code>Hazelcast.shutdownAll()</code> after each test case to make sure that
there is no other running member left from the previous tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@After
public void cleanup() throws Exception {
  Hazelcast.shutdownAll();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information please
<a href="https://github.com/hazelcast/hazelcast/tree/master/hazelcast/src/test/java/com/hazelcast/cluster" target="_blank" rel="noopener">check our existing tests</a>.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Does Hazelcast support hundreds of members?</strong></p>
</div>
<div class="paragraph">
<p>Yes. Hazelcast performed a successful test on Amazon EC2 with 200 members.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Does Hazelcast support thousands of clients?</strong></p>
</div>
<div class="paragraph">
<p>Yes. However, there are some points you should consider.
The environment should be LAN with a high stability and the network speed should be 10 Gbps or higher.
If the number of members is high, the client type should be selected as Unisocket, not Smart Client.
In the case of Smart Clients, since each client opens a connection to the members,
these members should be powerful enough (for example, more cores) to handle hundreds or thousands of connections and client requests.
Also, you should consider using Near Caches in clients to lower the network traffic.
And you should use the Hazelcast releases with the NIO implementation (which starts with Hazelcast 3.2).</p>
</div>
<div class="paragraph">
<p>Also, you should configure the clients attentively.
See the <a href="#hazelcast-clients">Clients section</a> for configuration notes.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Difference between Lite Member and Smart Client?</strong></p>
</div>
<div class="paragraph">
<p>Lite member supports task execution (distributed executor service), smart client does not.
Also, Lite Member is highly coupled with cluster, smart client is not.
Starting with Hazelcast 3.9, you can also promote lite members to data members.
See the <a href="#enabling-lite-members">Lite Members section</a> for more information.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How do you give support?</strong></p>
</div>
<div class="paragraph">
<p>We have two support services: community and commercial support.
Community support is provided through our <a href="https://groups.google.com/forum/#!forum/hazelcast" target="_blank" rel="noopener">Mail Group</a> and
<a href="http://stackoverflow.com/" target="_blank" rel="noopener">StackOverflow</a> web site.
For information on support subscriptions, see <a href="https://hazelcast.com/pricing/" target="_blank" rel="noopener">Hazelcast.com</a>.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Does Hazelcast persist?</strong></p>
</div>
<div class="paragraph">
<p>No. However, Hazelcast provides <code>MapStore</code> and <code>MapLoader</code> interfaces.
For example, when you implement the <code>MapStore</code> interface, Hazelcast calls your store and load methods whenever needed.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Can I use Hazelcast in a single server?</strong></p>
</div>
<div class="paragraph">
<p>Yes. But please note that Hazelcast&#8217;s main design focus is multi-member clusters to be used as a distribution platform.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How can I monitor Hazelcast?</strong></p>
</div>
<div class="paragraph">
<p><a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html" target="_blank" rel="noopener">Hazelcast Management Center</a> is what you use to
monitor and manage the members running Hazelcast.
In addition to monitoring the overall state of a cluster, you can analyze and browse data structures in detail,
you can update map configurations and you can take thread dumps from members.</p>
</div>
<div class="paragraph">
<p>You can also use Hazelcast&#8217;s HTTP based health check implementation and health monitoring utility.
See the <a href="#health-check-and-monitoring">Health Check and Monitoring section</a>.
There is also a <a href="#diagnostics">diagnostocs tool</a> where you can see detailed logs enhanced with diagnostic plugins.</p>
</div>
<div class="paragraph">
<p>Moreover, JMX monitoring is also provided. See the <a href="#monitoring-with-jmx">Monitoring with JMX section</a> for details.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How can I see debug level logs?</strong></p>
</div>
<div class="paragraph">
<p>By changing the log level to "Debug". Below are example lines for <strong>log4j</strong> logging framework.
See the <a href="#logging-configuration">Logging Configuration section</a> to learn how to set logging types.</p>
</div>
<div class="paragraph">
<p>First, set the logging type as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String location = "log4j.configuration";
String logging = "hazelcast.logging.type";
System.setProperty( logging, "log4j" );
/**if you want to give a new location. **/
System.setProperty( location, "file:/path/mylog4j.properties" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then set the log level to "Debug" in the properties file. Below is example content.</p>
</div>
<div class="paragraph">
<p><code># direct log messages to stdout #</code></p>
</div>
<div class="paragraph">
<p><code>log4j.appender.stdout=org.apache.log4j.ConsoleAppender</code></p>
</div>
<div class="paragraph">
<p><code>log4j.appender.stdout.Target=System.out</code></p>
</div>
<div class="paragraph">
<p><code>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</code></p>
</div>
<div class="paragraph">
<p><code>log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p [%c{1}] - %m%n</code></p>
</div>
<div class="paragraph">
<p><code>log4j.logger.com.hazelcast=debug</code></p>
</div>
<div class="paragraph">
<p><code>#log4j.logger.com.hazelcast.cluster=debug</code></p>
</div>
<div class="paragraph">
<p><code>#log4j.logger.com.hazelcast.partition=debug</code></p>
</div>
<div class="paragraph">
<p><code>#log4j.logger.com.hazelcast.partition.InternalPartitionService=debug</code></p>
</div>
<div class="paragraph">
<p><code>#log4j.logger.com.hazelcast.nio=debug</code></p>
</div>
<div class="paragraph">
<p><code>#log4j.logger.com.hazelcast.hibernate=debug</code></p>
</div>
<div class="paragraph">
<p>The line <code>log4j.logger.com.hazelcast=debug</code> is used to see debug logs for all Hazelcast operations.
Below this line, you can select to see specific logs (cluster, partition, hibernate, etc.).</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Client-server vs. embedded topologies?</strong></p>
</div>
<div class="paragraph">
<p>In the embedded topology, members include both the data and application.
This type of topology is the most useful if your application focuses on high performance computing and many task executions.
Since application is close to data, this topology supports data locality.</p>
</div>
<div class="paragraph">
<p>In the client-server topology, you create a cluster of members and scale the cluster independently.
Your applications are hosted on the clients and the clients communicate with the members in the cluster to reach data.</p>
</div>
<div class="paragraph">
<p>Client-server topology fits better if there are multiple applications sharing
the same data or if application deployment is significantly greater than
the cluster size (for example, 500 application servers vs. 10 member cluster).</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How can I shutdown a Hazelcast member?</strong></p>
</div>
<div class="paragraph">
<p>The following are the ways of shutting down a Hazelcast member:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can call <code>kill -9 &lt;PID&gt;</code> in the terminal (which sends a SIGKILL signal).
This results in the immediate shutdown which is not recommended for production systems.
If you set the property <code>hazelcast.shutdownhook.enabled</code> to <code>false</code> and then kill the process using <code>kill -15 &lt;PID&gt;</code>, its result is the same (immediate shutdown).</p>
</li>
<li>
<p>You can call <code>kill -15 &lt;PID&gt;</code> in the terminal (which sends a SIGTERM signal), or you can call
the method <code>HazelcastInstance.getLifecycleService().terminate()</code> programmatically, or you can use
the script <code>stop.sh</code> located in your Hazelcast&#8217;s <code>/bin</code> directory. All three of them terminate your member ungracefully.
They do not wait for migration operations, they force the shutdown.
But this is much better than <code>kill -9 &lt;PID&gt;</code> since it releases most of the used resources.</p>
</li>
<li>
<p>In order to gracefully shutdown a Hazelcast member (so that it waits the migration operations to be completed), you have four options:</p>
<div class="ulist">
<ul>
<li>
<p>You can call the method <code>HazelcastInstance.shutdown()</code> programatically.</p>
</li>
<li>
<p>You can use JMX API&#8217;s shutdown method. You can do this by implementing
a JMX client application or using a JMX monitoring tool (like JConsole).</p>
</li>
<li>
<p>You can set the property <code>hazelcast.shutdownhook.policy</code> to <code>GRACEFUL</code> and then shutdown by using <code>kill -15 &lt;PID&gt;</code>.
Your member will be gracefully shutdown.</p>
</li>
<li>
<p>You can use the "Shutdown Member" button in the member view of
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-members" target="_blank" rel="noopener">Hazelcast Management Center</a>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you use systemd&#8217;s <code>systemctl</code> utility, i.e., <code>systemctl stop service_name</code>, a SIGTERM signal is sent.
After 90 seconds of waiting it is followed by a SIGKILL signal by default.
Thus, it calls terminate at first and kill the member directly after 90 seconds.
We do not recommend to use it with its defaults. But
<a href="https://www.linux.com/learn/understanding-and-using-systemd" target="_blank" rel="noopener">systemd</a> is very customizable and
well-documented, you can see its details using the command  <code>man systemd.kill</code>.
If you can customize it to shutdown your Hazelcast member gracefully (by using the methods above), then you can use it.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How do I know it is safe to kill the second member?</strong></p>
</div>
<div class="paragraph">
<p>Starting with Hazelcast 3.7, graceful shutdown of a Hazelcast member can be initiated any time as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>hazelcastInstance.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once a Hazelcast member initiates a graceful shutdown, data of the shutting down member is migrated to the other members automatically.</p>
</div>
<div class="paragraph">
<p>However, there is no such guarantee for termination.</p>
</div>
<div class="paragraph">
<p>Below code snippet terminates a member if the cluster is safe, which means that
there are no partitions being migrated and all backups are in sync when this method is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PartitionService partitionService = hazelcastInstance.getPartitionService();
if (partitionService.isClusterSafe()) {
  hazelcastInstance.getLifecycleService().terminate();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below code snippet terminates the local member if the member is safe to terminate, which means that
all backups of partitions currently owned by local member are in sync when this method is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PartitionService partitionService = hazelcastInstance.getPartitionService();
if (partitionService.isLocalMemberSafe()) {
  hazelcastInstance.getLifecycleService().terminate();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please keep in mind that two code snippets shown above are inherently racy.
If member failures occur in the cluster after the safety condition check passes, termination of the local member can lead to data loss.
For safety of the data, graceful shutdown API is highly recommended.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#safety-checking-cluster-members">Safety Checking Cluster Members section</a> for more information.
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p><strong>When do I need Native Memory solutions?</strong></p>
</div>
<div class="paragraph">
<p>Native Memory solutions can be preferred when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the amount of data per member is large enough to create significant garbage collection pauses</p>
</li>
<li>
<p>your application requires predictable latency.</p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p><strong>Is there any disadvantage of using near-cache?</strong></p>
</div>
<div class="paragraph">
<p>The only disadvantage when using Near Cache is that it may cause stale reads.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Is Hazelcast secure?</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast supports symmetric encryption, transport layer security/secure sockets layer (TLS/SSL) and
Java Authentication and Authorization Service (JAAS). See the <a href="#security">Security chapter</a> for more information.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>How can I set socket options?</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast allows you to set some socket options such as <code>SO_KEEPALIVE</code>, <code>SO_SNDBUF</code> and
<code>SO_RCVBUF</code> using Hazelcast configuration properties. See the <code>hazelcast.socket.*</code> properties explained in
the <a href="#system-properties">System Properties appendix</a>.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Client disconnections during idle time?</strong></p>
</div>
<div class="paragraph">
<p>In Hazelcast, socket connections are created with the <code>SO_KEEPALIVE</code> option enabled by default.
In most operating systems, default keep-alive time is 2 hours.
If you have a firewall between clients and servers which is configured to reset idle connections/sessions,
make sure that the firewall&#8217;s idle timeout is greater than the TCP keep-alive defined in the OS.</p>
</div>
<div class="paragraph">
<p>See <a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html" target="_blank" rel="noopener">Using TCP keepalive under Linux</a> and
<a href="http://technet.microsoft.com/en-us/library/cc957549.aspx" target="_blank" rel="noopener">Microsoft TechNet</a> for additional information.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>OOME: Unable to create new native thread?</strong></p>
</div>
<div class="paragraph">
<p>If you encounter an error of <code>java.lang.OutOfMemoryError: unable to create new native thread</code>,
it may be caused by exceeding the available file descriptors on your operating system, especially if it is Linux.
This exception is usually thrown on a running member, after a period of time when the thread count exhausts the file descriptor availability.</p>
</div>
<div class="paragraph">
<p>The JVM on Linux consumes a file descriptor for each thread created.
The default number of file descriptors available in Linux is usually 1024.
If you have many JVMs running on a single machine, it is possible to exceed this default number.</p>
</div>
<div class="paragraph">
<p>You can view the limit using the following command.</p>
</div>
<div class="paragraph">
<p><code># ulimit -a</code></p>
</div>
<div class="paragraph">
<p>At the operating system level, Linux users can control the amount of
resources (and in particular, file descriptors) used via one of the following options.</p>
</div>
<div class="paragraph">
<p>1 - Editing the <code>limits.conf</code> file:</p>
</div>
<div class="paragraph">
<p><code># vi /etc/security/limits.conf</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>testuser soft nofile 4096&lt;br&gt;
testuser hard nofile 10240&lt;br&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>2 - Or using the <code>ulimit</code> command:</p>
</div>
<div class="paragraph">
<p><code># ulimit -Hn</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>10240</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default number of process per users is 1024. Adding the following to your <code>$HOME/.profile</code> could solve the issue:</p>
</div>
<div class="paragraph">
<p><code># ulimit -u 4096</code></p>
</div>
<hr>
<div class="paragraph">
<p><strong>Does repartitioning wait for Entry Processor?</strong></p>
</div>
<div class="paragraph">
<p>Repartitioning is the process of redistributing the partition ownerships.
Hazelcast performs the repartitioning in the cases where a member leaves the cluster or joins the cluster.
If a repartitioning happens while an entry processor is active in a member processing on an entry object,
the repartitioning waits for the entry processor to complete its job.</p>
</div>
<hr>
<div class="paragraph">
<p><strong>Instances on different machines cannot see each other?</strong></p>
</div>
<div class="paragraph">
<p>Assume you have two instances on two different machines and you develop a configuration as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
NetworkConfig network = config.getNetworkConfig();

JoinConfig join = network.getJoin();
join.getTcpIpConfig().addMember("IP1")
    .addMember("IP2").setEnabled(true);
network.getInterfaces().setEnabled(true)
    .addInterface("IP1").addInterface("IP2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you create the Hazelcast instance, you have to pass the configuration to the instance.
If you create the instances without passing the configuration, each instance starts but cannot see each other.
Therefore, a correct way to create the instance is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an incorrect way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>HazelcastInstance instance = Hazelcast.newHazelcastInstance();</code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p><strong>What Does "Replica: 1 has no owner" Mean?</strong></p>
</div>
<div class="paragraph">
<p>When you start more members after the first one is started, you will see <code>replica: 1 has no owner</code> entry in the newly started member&#8217;s log.
There is no need to worry about it since it refers to a transitory state.
It only means the replica partition is not ready/assigned yet and eventually it will be.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_document_revision_history"><a class="anchor" href="#_document_revision_history"></a>Appendix G: Document Revision History</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter lists the changes made to this document from the previous release.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="https://docs.hazelcast.org/docs/rn/" target="_blank" rel="noopener">Release Notes</a> for the new features, enhancements and fixes performed for each Hazelcast release.
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 21. Revision History</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 71.4286%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chapter</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Description</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-overview">Overview</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The whole chapter content has been reviewed and enhanced along
with outline improvements.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#understanding-configuration">Understanding Configuration</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#overriding-configuration">Overriding Configuration</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#setting-up-clusters">Setting Up Clusters</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#accessing-domain-objects-without-domain-classes-beta">Accessing Domain Objects without Domain Classes</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#auto-detection">Auto Detection</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#distributed-data-structures">Distributed Data Structures</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#managing-the-lifecycle-of-a-maploader">Managing the Lifecycle of a MapLoader</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sql">[sql]</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added as a new chapter explaining the SQL service
provided by Hazelcast.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-jet">Hazelcast Jet</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The whole chapter content has been reviewed and enhanced along
with outline improvements.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#cp-subsystem">[cp-subsystem]</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#cp-subsystem-listeners">[cp-subsystem-listeners]</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-clients">[hazelcast-clients]</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added a note related to non-stop clients (with Near Cache) to the
<a href="#java-client-connection-strategy">Java Client Connection Strategy section</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#management">[management]</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#limiting-source-addresses">Limiting Source Addresses</a> as a new section to
explain how to restrict the source IP addresses for Management Center.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#hazelcast-command-line-tool">Hazelcast Command Line Tool</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#instance-tracking">Instance Tracking</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#security">Security</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#kerberos-authentication-type">Kerberos Authentication Type</a> and
<a href="#security-realms-on-the-client-side">Security Realms on the Client Side</a> as new sections.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#default-authentication">Default authentication</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#auditlog">Logging Auditable Events</a> as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#wan-replication">[wan-replication]</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The whole chapter content has been reviewed and enhanced along
with outline improvements.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#network-partitioning">[network-partitioning]</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added <a href="#partial-network-partitions">Partial Network Partitions</a>
as a new section.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#system-properties">System Properties</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Added the descriptions for the following new system properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>``</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_glossary"><a class="anchor" href="#_glossary"></a>Glossary</h2>
<div class="sectionbody">
<div class="dlist glossary">
<dl>
<dt>2-phase Commit</dt>
<dd>
<p>2-phase commit protocol is an atomic commitment protocol for distributed systems. It consists of two phases: commit-request and commit. In commit-request phase, transaction manager coordinates all of the transaction resources to commit or abort. In commit-phase, transaction manager decides to finalize operation by committing or aborting according to the votes of the each transaction resource.</p>
</dd>
<dt>ACID</dt>
<dd>
<p>A set of properties (Atomicity, Consistency, Isolation, Durability) guaranteeing that transactions are processed reliably. Atomicity requires that each transaction be all or nothing, i.e., if one part of the transaction fails, the entire transaction fails). Consistency ensures that only valid data following all rules and constraints is written. Isolation ensures that transactions are securely and independently processed at the same time without interference (and without transaction ordering). Durability means that once a transaction has been committed, it will remain so, no matter if there is a power loss, crash, or error.</p>
</dd>
<dt>Cache</dt>
<dd>
<p>A high-speed access area that can be either a reserved section of main memory or storage device.</p>
</dd>
<dt>Client Server Topology</dt>
<dd>
<p>Hazelcast topology where members run outside the user application and are connected to clients using client libraries. The client library is installed in the user application.</p>
</dd>
<dt>Embedded Topology</dt>
<dd>
<p>|Hazelcast topology where the members are in-process with the user application and act as both client and server.</p>
</dd>
<dt>Garbage Collection</dt>
<dd>
<p>Garbage collection is the recovery of storage that is being used by an application when that application no longer needs the storage. This frees the storage for use by other applications (or processes within an application). It also ensures that an application using increasing amounts of storage does not reach its quota. Programming languages that use garbage collection are often interpreted within virtual machines like the JVM. The environment that runs the code is also responsible for garbage collection.</p>
</dd>
<dt>Hazelcast Cluster</dt>
<dd>
<p>A virtual environment formed by Hazelcast members communicating with each other in the cluster.</p>
</dd>
<dt>Hazelcast Partitions</dt>
<dd>
<p>Memory segments containing the data. Hazelcast is built-on the partition concept, it uses partitions to store and process data. Each partition can have hundreds or thousands of data entries depending on your memory capacity. You can think of a partition as a block of data. In general and optimally, a partition should have a maximum size of 50-100 Megabytes.</p>
</dd>
<dt>IMDG</dt>
<dd>
<p>An in-memory data grid (IMDG) is a data structure that resides entirely in memory and is distributed among many members in a single location or across multiple locations. IMDGs can support thousands of in-memory data updates per second and they can be clustered and scaled in ways that support large quantities of data.</p>
</dd>
<dt>Invalidation</dt>
<dd>
<p>The process of marking an object as being invalid across the distributed cache.</p>
</dd>
<dt>Java heap</dt>
<dd>
<p>Java heap is the space that Java can reserve and use in memory for dynamic memory allocation. All runtime objects created by a Java application are stored in heap. By default, the heap size is 128 MB, but this limit is reached easily for business applications. Once the heap is full, new objects cannot be created and the Java application shows errors.</p>
</dd>
<dt>LRU, LFU</dt>
<dd>
<p>LRU and LFU are two of eviction algorithms. LRU is the abbreviation for Least Recently Used. It refers to entries eligible for eviction due to lack of interest by applications. LFU is the abbreviation for Least Frequently Used. It refers to the entries eligible for eviction due to having the lowest usage frequency.</p>
</dd>
<dt>Member</dt>
<dd>
<p>A Hazelcast instance. Depending on your Hazelcast usage, it can refer to a server or a Java virtual machine (JVM). Members belong to a Hazelcast cluster. Members are also referred as member nodes, cluster members, or Hazelcast members.</p>
</dd>
<dt>Multicast</dt>
<dd>
<p>A type of communication where data is addressed to a group of destination members simultaneously.</p>
</dd>
<dt>Near Cache</dt>
<dd>
<p>A caching model. When Near Cache is enabled, an object retrieved from a remote member is put into the local cache and the future requests made to this object will be handled by this local member. For example, if you have a map with data that is mostly read, then using Near Cache is a good idea.</p>
</dd>
<dt>NoSQL</dt>
<dd>
<p>"Not Only SQL". A database model that provides a mechanism for storage and retrieval of data that is tailored in means other than the tabular relations used in relational databases. It is a type of database which does not adhering to the traditional relational database management system (RDMS) structure. It is not built on tables and does not employ SQL to manipulate data. It also may not provide full ACID guarantees, but still has a distributed and fault tolerant architecture.</p>
</dd>
<dt>OSGI</dt>
<dd>
<p>Formerly known as the Open Services Gateway initiative, it describes a modular system and a service platform for the Java programming language that implements a complete and dynamic component model.</p>
</dd>
<dt>Partition Table</dt>
<dd>
<p>Table containing all members in the cluster, mappings of partitions to members and further metadata.</p>
</dd>
<dt>Race Condition</dt>
<dd>
<p>This condition occurs when two or more threads can access shared data and they try to change it at the same time.</p>
</dd>
<dt>RSA</dt>
<dd>
<p>An algorithm developed by Rivest, Shamir and Adleman to generate, encrypt and decrypt keys for secure data transmissions.</p>
</dd>
<dt>Serialization</dt>
<dd>
<p>Process of converting an object into a stream of bytes in order to store the object or transmit it to memory, a database, or a file. Its main purpose is to save the state of an object in order to be able to recreate it when needed. The reverse process is called deserialization.</p>
</dd>
<dt>Split-brain</dt>
<dd>
<p>Split-brain syndrome, in a clustering context, is a state in which a cluster of members gets divided (or partitioned) into smaller clusters of members, each of which believes it is the only active cluster.</p>
</dd>
<dt>Transaction</dt>
<dd>
<p>Means a sequence of information exchange and related work (such as data store updating) that is treated as a unit for the purposes of satisfying a request and for ensuring data store integrity.</p>
</dd>
</dl>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../_/js/site.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/vendor/search.js" id="search-script" data-base-path="../.." data-page-path="/hazelcast/1.0.0/index.html"></script>
<script async src="../../_/../search-index.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
