<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hazelcast Hazelcast Documentation</title>
    <link rel="canonical" href="https://jakescahill.github.io/docs-poc/hazelcast/4.1/deploy/advanced_features.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-M267KFN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-M267KFN')</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://jakescahill.github.io/docs-poc">Hazelcast Documentation</a>
          <div class="navbar-item">
            <input id="search-input" type="text" placeholder="Search docs">
          </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Hazelcast Cloud</a>
            <a class="navbar-item" href="https://jakescahill.github.io/docs-poc/hazelcast/4.1/index.html">Hazelcast IMDG</a>
            <a class="navbar-item" href="#">Hazelcast Jet</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://jakescahill.github.io/docs-poc/home/index.html">Docs</a>
            <a class="navbar-item" href="https://training.hazelcast.com/">Online Training</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Demos</a>
            <a class="navbar-item" href="#">Community</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Get Hazelcast</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="hazelcast" data-version="4.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../hazelcast_overview.html">Hazelcast IMDG</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hazelcast_overview.html">Overview</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../get-started/getting_started.html">Get Started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started/glossary.html">Glossary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../develop/hazelcast_clients.html">Develop Solutions</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/jcache.html">JCache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/performance.html">Performance</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/serialization.html">Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/striim_cdc.html">Striim Hot Cache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/transactions.html">Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_query.html">Distributed Query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_sql.html">Distributed SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_events.html">Distributed Events</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_computing.html">Distributed Computing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="installing_upgrading.html">Deploy Clusters</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="starting_members_clients.html">Starting Members and Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="setting_up_clusters.html">Setting Up Clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="management.html">Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="simulator.html">Hazelcast Simulator</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="wan.html">WAN Replication</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="network_partitioning.html">Network Partitioning</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../migrate/migration_guides.html">Migrate</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../troubleshoot/common_exception_types.html">Troubleshooting</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../reference/faq.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/dds.html">Distributed data structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/system_properties.html">System properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/understanding_configuration.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/phone_homes.html">Phone homes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/hazelcast_plugins.html">Plugins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute/extending_hazelcast.html">Contribute</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/licenses.html">Licenses</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/revision_history.html">Documentation changes</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Hazelcast IMDG</span>
    <span class="version">4.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Hazelcast IMDG</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../hazelcast_overview.html">4.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Home</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../home/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../home/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
  <div class="edit-this-page"><a class="git" href="https://github.com/JakeSCahill/docs-poc/edit/develop/hazelcast-docs/modules/deploy/pages/advanced_features.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<div class="sect2">
<h3 id="wr-advanced"><a class="anchor" href="#wr-advanced"></a>Advanced Features</h3>
<div class="paragraph">
<p>This section describes how you can synchronize your WAN replicated clusters,
change their configurations dynamically and intercept WAN replication events using
the event filtering API.</p>
</div>
<div class="sect3">
<h4 id="_synchronizing_wan_clusters"><a class="anchor" href="#_synchronizing_wan_clusters"></a>Synchronizing WAN Clusters</h4>
<div class="paragraph">
<p>WAN Replication replicates mutation events that happen on the source
cluster as they happen. The events are queued up, collected in a batch
and sent to the target cluster to be applied, without any user interaction.</p>
</div>
<div class="paragraph">
<p>However, Hazelcast clusters connected over WAN may become out-of-sync because of various reasons
including but not limited to the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Member failures</p>
</li>
<li>
<p>Concurrent updates</p>
</li>
<li>
<p>Target cluster freshly starts with no data</p>
</li>
<li>
<p>Target cluster experiences problems and some operations fail</p>
</li>
<li>
<p>Two sides disconnect and the in-memory buffer of the source
cluster gets full (the behavior in this case is <a href="#queue-full-behavior">configurable</a>)</p>
</li>
<li>
<p>The WAN link can&#8217;t keep up with the burst that the source cluster experiences
and its in-memory buffer gets full (the behavior in this case is <a href="#queue-full-behavior">configurable</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To overcome this out-of-sync issue, you have the
following options to synchronize your WAN replicated clusters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Full synchronization</p>
</li>
<li>
<p>Delta synchronization</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following sections describe each.</p>
</div>
<div class="sect4">
<h5 id="synchronizing-wan-target-cluster"><a class="anchor" href="#synchronizing-wan-target-cluster"></a>Full WAN Synchronization</h5>
<div class="paragraph">
<p>Full WAN synchronization sends all the data of an IMap to a target cluster to align the state of target IMap with source IMap.
It is useful if two remote clusters lost their synchronizations due to overflow in the WAN queue or in restart scenarios.
This is the default synchronization option.</p>
</div>
<div class="paragraph">
<p>Full WAN Synchronization can be initiated through
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#wan-sync" target="_blank" rel="noopener">Management Center</a> and
Hazelcast&#8217;s REST API.</p>
</div>
<div class="paragraph">
<p>Below is the URL for the REST call;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/sync/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to add URL-encoded parameters to the request in the following order separated by "&amp;";</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cluster name</p>
</li>
<li>
<p>Cluster password</p>
</li>
<li>
<p>Name of the WAN replication configuration</p>
</li>
<li>
<p>WAN replication publisher ID/target cluster name</p>
</li>
<li>
<p>Map name to be synchronized</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Assume that you have configured an IMap with a WAN replication configuration as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;istanbul&lt;/cluster-name&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    &lt;map name="my-map"&gt;
        &lt;wan-replication-ref name="london-wan-rep"&gt;
            &lt;merge-policy&gt;com.hazelcast.spi.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication name: london-wan-rep
    batch-publisher:
      cluster-name: istanbul
  map:
    my-map:
      wan-replication-ref:
        london-wan-rep:
          merge-policy: com.hazelcast.spi.merge.PassThroughMergePolicy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, an example curl command to initiate the synchronization for "my-map" would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterName}&amp;{clusterPassword}&amp;london-wan-rep&amp;istanbul&amp;my-map" --URL http://127.0.0.1:5701/hazelcast/rest/wan/sync/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also synchronize all maps in the source and target clusters.
In that case the curl command using the above parameters becomes as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterName}&amp;{clusterPassword}&amp;london-wan-rep&amp;istanbul" --URL http://127.0.0.1:5701/hazelcast/rest/wan/sync/allMaps</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Synchronization for a target cluster operates only with
the data residing in the memory. Therefore, evicted entries are not
synchronized, not even if <code>MapLoader</code> is configured.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_delta_wan_synchronization"><a class="anchor" href="#_delta_wan_synchronization"></a>Delta WAN Synchronization</h5>
<div class="paragraph">
<p>As explained in the previous section, the default <a href="#synchronizing-wan-target-cluster">Full WAN Synchronization</a> feature
synchronizes  the maps in different clusters by transferring all the entries from the source to the target cluster.
This may be not efficient since some of the entries have remained unchanged on both clusters and
do not require to be transferred. Also, for the entries to be transferred, they need to be copied to
on-heap on the source cluster. This may cause spikes in the heap usage, especially if using large off-heap stores.</p>
</div>
<div class="paragraph">
<p>In addition to the default Full WAN Synchronization, Hazelcast provides Delta WAN Synchronization which uses
<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="noopener">Merkle tree</a> for the same purpose.
It is a data structure used for efficient comparison of the difference in the contents of large data structures.
The precision of this comparison is defined by Merkle tree&#8217;s depth.
Merkle tree hash exchanges can detect inconsistencies in the map data and
synchronize only the different entries when using WAN synchronization, instead of sending all the map entries.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, Delta WAN Synchronization is implemented only for Hazelcast IMap.
It will be implemented also for ICache in the future releases.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="requirements-for-delta-wan-sync"><a class="anchor" href="#requirements-for-delta-wan-sync"></a>Requirements</h6>
<div class="paragraph">
<p>To be able to use Delta WAN synchronization, the following must be met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Source and target cluster versions must be at least Hazelcast 3.11.</p>
</li>
<li>
<p>Both clusters must have the same number of partitions.</p>
</li>
<li>
<p>Both clusters must use the same partitioning strategy.</p>
</li>
<li>
<p>Both clusters must have the Merkle tree structure enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_using_delta_wan_synchronization"><a class="anchor" href="#_using_delta_wan_synchronization"></a>Using Delta WAN Synchronization</h6>
<div class="paragraph">
<p>To be able to use Delta WAN synchronization for a Hazelcast data structure:</p>
</div>
<div class="paragraph">
<p>1 - Configure the WAN synchronization mechanism for your WAN publisher so that
it uses the Merkle tree: If configuring declaratively, you can use the <code>consistency-check-strategy</code> sub-element of
the <code>sync</code> element. If configuring programmatically, you can use the setter of the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/WanSyncConfig.html" target="_blank" rel="noopener">WanSyncConfig</a> object.
Here is a declarative example:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
     &lt;wan-replication name="wanReplicationScheme"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;clusterName&lt;/cluster-name&gt;
            &lt;sync&gt;
                &lt;consistency-check-strategy&gt;MERKLE_TREES&lt;/consistency-check-strategy&gt;
            &lt;/sync&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    wanReplicationScheme:
      batch-publisher:
        cluster-name: clusterName
        sync:
          consistency-check-strategy: MERKLE_TREES</code></pre>
</div>
</div>
<div class="paragraph">
<p>2 - Bind that WAN synchronization configuration to the data structure (currently IMap):
Simply set the WAN replication reference of your map to the name of the WAN replication
configuration which uses the Merkle tree.
Here is a declarative example:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;wan-replication-ref name="wanReplicationScheme"&gt;
          ...
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      wan-replication-ref:
        wanReplicationScheme:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>3 - Finally, configure the Merkle tree using the <code>merkle-tree</code> element which is contained
in the <code>map</code> configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;merkle-tree enabled="true"&gt;
            &lt;depth&gt;5&lt;/depth&gt;
        &lt;/merkle-tree&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      merkle-tree:
        enabled: true
        depth: 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can programmatically configure it, too, using the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/MerkleTreeConfig.html" target="_blank" rel="noopener">MerkleTreeConfig</a> object.</p>
</div>
<div class="paragraph">
<p>Here is the full declarative configuration example showing how to
enable Delta WAN Synchronization, bind it to a Hazelcast data structure (an IMap in this case) and specify its depth:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;wan-replication-ref name="wanReplicationScheme"&gt;
            ...
        &lt;/wan-replication-ref&gt;
        &lt;merkle-tree enabled="true"&gt;
            &lt;depth&gt;10&lt;/depth&gt;
        &lt;/merkle-tree&gt;
    &lt;/map&gt;

    &lt;wan-replication name="wanReplicationScheme"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;clusterName&lt;/cluster-name&gt;
            &lt;sync&gt;
                &lt;consistency-check-strategy&gt;MERKLE_TREES&lt;/consistency-check-strategy&gt;
            &lt;/sync&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      wan-replication-ref:
        wanReplicationScheme:
          ...
      merkle-tree:
        enabled: true
        depth: 10
  wan-replication:
    wanReplicationScheme:
      batch-publisher:
        cluster-name: clusterName
        sync:
          consistency-check-strategy: MERKLE_TREES</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the element <code>consistency-check-strategy</code> sets the strategy for
checking the consistency of data between the source and target clusters.
You must initiate the WAN synchronization (via Management Center or REST API as explained in
<a href="#synchronizing-wan-target-cluster">Synchronizing WAN clusters</a>) to let this strategy reconcile the inconsistencies.
The element <code>consistency-check-strategy</code> has currently two values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NONE</code>: Means that there are no consistency checks. This is the default value.</p>
</li>
<li>
<p><code>MERKLE_TREES</code>: Means that WAN synchronization uses Merkle tree structure.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Merkle tree structure is enabled using its <code>enabled</code> attribute (default is <code>true</code>).
Its  <code>depth</code> element specifies the depth of Merkle tree. Valid values are between 2 and 27 (exclusive).
Its default value is <code>10</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A larger depth means that a data synchronization mechanism is able to pinpoint a smaller subset of
the data structure (e.g., IMap) contents in which a change has occurred.
This causes the synchronization mechanism to be more efficient.
However, keep in mind that a large depth means that the Merkle tree will consume more memory.
As the comparison mechanism is iterative, a larger depth also prolongs the comparison duration.
Therefore, it is recommended not to have large tree depths if the latency of the comparison operation is high.</p>
</li>
<li>
<p>A smaller depth means that the Merkle tree is shallower and the data synchronization mechanism transfers
larger chunks of the data structure (e.g., IMap) in which a possible change has happened.
As you can imagine, a shallower Merkle tree will consume less memory.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also see the <a href="#defining-the-depth">Defining the Depth section</a> for more insights.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not specifically configure the <code>merkle-tree</code> in your
Hazelcast configuration, Hazelcast uses the default Merkle tree structure values
(i.e., it is enabled by default and its default depth is 10) when there is a WAN publisher using
the Merkle tree (i.e., <code>consistency-check-strategy</code> for a WAN replication configuration is set as
<code>MERKLE_TREES</code> and there is a data structure using that WAN replication configuration).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Merkle trees are created for each partition holding IMap data.
Therefore, increasing the partition count also
increases the efficiency of the Delta WAN Synchronization.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_the_process"><a class="anchor" href="#_the_process"></a>The Process</h6>
<div class="paragraph">
<p>Synchronizing the maps based on Merkle trees consists of two phases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Consistency check</em>: Process of exchanging and comparing the hashes stored in the Merkle tree structures in the
source and target clusters. The check starts with the root node and continues recursively with the children with different
hash codes. Both sides send the children of the nodes that the other side sent, hence the comparison is done by <code>depth/2</code>
steps. After this check, the tree leaves holding different entries are identified.</p>
</li>
<li>
<p><em>Synchronization</em>: Process of transferring the entries belong to the leaves identified by the <em>consistency
check</em> from the source to target cluster. On the target cluster the configured merge policy is applied for each entry that
is in both the source and target clusters.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you only need the differences between the clusters, you can trigger the consistency check without performing
synchronization.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The two phases of the Merkle tree based synchronization can be triggered by the REST calls, as it can be done with the
full synchronization.</p>
</div>
<div class="paragraph">
<p>The URL for the consistency check REST call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/consistencyCheck/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>The URL for the synchronization REST call - the same as it is for the default synchronization:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/sync/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the REST call details <a href="#synchronizing-the-clusters">here</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_memory_consumption"><a class="anchor" href="#_memory_consumption"></a>Memory Consumption</h6>
<div class="paragraph">
<p>Since Merkle trees are built for each partition and each map, the memory overhead of the trees with high entry count and deep
trees can be significant. The trees are maintained on-heap, therefore - besides the memory consumption - garbage collection could be another
concern.</p>
</div>
<div class="paragraph">
<p>The table below shows a few examples for what the memory overhead could be.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Merkle trees memory overhead for a member, for one map</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Partitions Owned</th>
<th class="tableblock halign-left valign-top">Depth</th>
<th class="tableblock halign-left valign-top">Memory Overhead</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.27 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">68 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">157 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1252 MB</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="_defining_the_depth"><a class="anchor" href="#_defining_the_depth"></a>Defining the Depth</h6>
<div class="paragraph">
<p>The efficiency of the Delta WAN Synchronization (WAN synchronization based on Merkle trees) is determined by the average number of entries per the tree
leaves that is proportionate to the number of entries in the map. The bigger this average the more entries are getting
synchronized for the same difference. Raising the depth decreases this average at the cost of increasing the memory overhead.</p>
</div>
<div class="paragraph">
<p>This average can be calculated for a map as <code>avgEntriesPerLeaf = mapEntryCount / totalLeafCount</code>, where <code>totalLeafCount =
partitionCount * 2<sup>depth-1</sup></code>. The ideal value is 1, however this may come at significant memory overhead as shown in the
table above.</p>
</div>
<div class="paragraph">
<p>In order to specify the tree depth, a trade-off between memory consumption and effectiveness might be needed.</p>
</div>
<div class="paragraph">
<p>Even if the map is huge and the Merkle trees are configured to be relatively shallow, the Merkle tree based synchronization
may be leveraged if only a small subset of the whole map is expected to be synchronized. The table below illustrates the
efficiency of the Merkle tree based synchronization compared to the default synchronization mechanism.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Efficiency examples</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Map entry count</th>
<th class="tableblock halign-left valign-top">Depth</th>
<th class="tableblock halign-left valign-top">Memory consumption</th>
<th class="tableblock halign-left valign-top">Avg entries / leaf</th>
<th class="tableblock halign-left valign-top">Difference count</th>
<th class="tableblock halign-left valign-top">Entries synced</th>
<th class="tableblock halign-left valign-top">Efficiency</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">39 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">78 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">150%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">160K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6150%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">78 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">99900%</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>Difference count</code> column shows the number of the entries different in the source and the target clusters.
This is the minimum number of the entries that need to be synchronized to make the clusters consistent. The <code>Entries synced</code>
column shows how many entries are synchronized in the given case, calculated as <code>Entries synced</code> = <code>Difference count</code>
* <code>Avg entries / leaf</code>.</p>
</div>
<div class="paragraph">
<p>As shown in the last two rows, the Merkle tree based synchronization transfers significantly less entries than what the
default mechanism does even with 8 deep trees. The efficiency with depth 12 is even better but consumes much more memory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The averages in the table are calculated with 5009 partitions.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The average entries per leaf number above assumes perfect distribution of the entries amongst the leaves. Since this is
typically not true in real-life scenarios the efficiency can be slightly worse. The statistics section below describes how to
get the actual average for the leaves involved in the synchronization.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_wan_synchronization_statistics"><a class="anchor" href="#_wan_synchronization_statistics"></a>WAN Synchronization Statistics</h5>
<div class="paragraph">
<p>Both Full and Delta WAN Synchronization processes write statistics into the
<a href="#diagnostics-2">diagnostics</a> subsystem and send them to Hazelcast Management
Center. Using these statistics you can measure the efficiency of your configuration.</p>
</div>
<div class="paragraph">
<p>Full WAN Synchronization reports the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Duration of the synchronization</p>
</li>
<li>
<p>Count of the synchronized entries</p>
</li>
<li>
<p>Total count of the synchronized partitions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">Synchronization statistics:
	 Synchronization UUID: 8af2f9e7-3f9f-4c31-b594-47c421bfb33c
	 Duration: 0 secs
	 Total records synchronized: 448
	 Total partitions synchronized: 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Delta WAN Synchronization reports the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Duration of the synchronization</p>
</li>
<li>
<p>Count of the synchronized entries</p>
</li>
<li>
<p>Total count of the synchronized partitions</p>
</li>
<li>
<p>Merkle tree nodes checked</p>
</li>
<li>
<p>Merkle tree nodes found to be different</p>
</li>
<li>
<p>Count of the entries needed to be synchronized to make the clusters consistent</p>
</li>
<li>
<p>Average count of entries per tree leaves in the synchronized leaves</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">Merkle synchronization statistics:
	 Synchronization UUID: f49a25ba-dc57-4547-817b-bea67ff7f0fe
	 Duration: 0 secs
	 Total records synchronized: 528
	 Total partitions synchronized: 6
	 Total Merkle tree nodes synchronized: 178
	 Average records per Merkle tree node: 2.97
	 StdDev of records per Merkle tree node: 1.55
	 Minimum records per Merkle tree node: 1
	 Maximum records per Merkle tree node: 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#diagnostics-2">Diagnostics section</a> to learn how to enable
diagnostics and locate its log file to see the above statistics.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dynamically_adding_wan_publishers"><a class="anchor" href="#_dynamically_adding_wan_publishers"></a>Dynamically Adding WAN Publishers</h4>
<div class="paragraph">
<p>When running clusters for an extensive period, you might need to
dynamically change the configuration while the cluster is running.
This includes dynamically adding new WAN replication publishers (new target clusters) and
replicating the subsequent map and cache updates to the new publishers without any manual intervention.</p>
</div>
<div class="paragraph">
<p>You can add new WAN publishers to an existing WAN replication using
almost all of the configuration options that are available when
configuring the WAN publishers in the static configuration (including using Discovery SPI).
The new configuration is not persisted but it is replicated to all existing and new members.
Once the cluster is completely restarted, the dynamically added publisher configuration is lost and
the updates are not replicated to the target cluster anymore until added again.</p>
</div>
<div class="paragraph">
<p>If you wish to preserve the new configuration over cluster restarts, you must add
the exact same configuration to the static configuration file after dynamically adding the publisher configuration to a running cluster.</p>
</div>
<div class="paragraph">
<p>You cannot remove the existing configurations but can put the publishers into
a STOPPED state which prevents the WAN events from being enqueued in the WAN queues and
prevents the replication, rendering the publisher idle. The configurations also cannot be changed.</p>
</div>
<div class="paragraph">
<p>You can dynamically add a WAN publisher configuration using the
following REST call URL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/addWanConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to add the following URL-encoded parameters to the request in the following order separated by "&amp;";</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cluster name</p>
</li>
<li>
<p>Cluster password</p>
</li>
<li>
<p>WAN replication configuration, serialized as JSON</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can, at any point, even when maps and caches are concurrently mutated, add a new WAN publisher to
an existing WAN replication configuration.
The limitation is that there must be an existing WAN replication configuration but
it can be empty, without any publishers (target clusters).
For instance, this is an example of an XML configuration to which you can dynamically add new publishers:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="myWanReplication"&gt;&lt;/wan-replication&gt;
    &lt;map name="my-map"&gt;
        &lt;wan-replication-ref name="myWanReplication"&gt;
            &lt;merge-policy&gt;com.hazelcast.spi.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
            &lt;republishing-enabled&gt;false&lt;/republishing-enabled&gt;
       &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    myWanReplication:
  map:
    myMap:
      wan-replication-ref:
        myWanReplication:
          merge-policy: com.hazelcast.spi.merge.PassThroughMergePolicy
          republishing-enabled: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the map has defined WAN replication but there is no target cluster yet.
You can then add the new WAN replication publishers (target clusters) by
performing an HTTP POST as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "clusterName&amp;clusterPassword&amp;{...}" --URL http://127.0.0.1:5701/hazelcast/rest/wan/addWanConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can provide the full configuration as JSON as a parameter.
Any WAN configuration supported in the XML and programmatic configurations is also supported in this JSON format.
Below are some examples of JSON configuration for a WAN publisher using
the Discovery SPI and static IP configuration. Here are the integer values for <code>initialPublisherState</code>,
<code>queueFullBehavior</code> and <code>consistencyCheckStrategy</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>initialPublisherState</code>:</p>
<div class="ulist">
<ul>
<li>
<p>0: REPLICATING</p>
</li>
<li>
<p>1: PAUSED</p>
</li>
<li>
<p>2: STOPPED</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>queueFullBehavior</code>:</p>
<div class="ulist">
<ul>
<li>
<p>0: DISCARD_AFTER_MUTATION</p>
</li>
<li>
<p>1: THROW_EXCEPTION</p>
</li>
<li>
<p>2: THROW_EXCEPTION_ONLY_IF_REPLICATION_ACTIVE</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>consistencyCheckStrategy</code>:</p>
<div class="ulist">
<ul>
<li>
<p>0: NONE</p>
</li>
<li>
<p>1: MERKLE_TREES</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below is an example using Discovery SPI (AWS configuration):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{
   "name":"wanReplication",
   "publishers":[
      {
         "clusterName":"tokyo",
         "queueCapacity":10000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "discovery":{
            "nodeFilterClass":null,
            "discoveryStrategy":[
               {
                  "className":"com.hazelcast.aws.AwsDiscoveryStrategy",
                  "properties":{
                     "security-group-name":"hazelcast",
                     "tag-value":"cluster1",
                     "host-header":"ec2.amazonaws.com",
                     "tag-key":"aws-test-cluster",
                     "secret-key":"my-secret-key",
                     "iam-role":"s3access",
                     "access-key":"my-access-key",
                     "hz-port":"5701-5708",
                     "region":"us-west-1"
                  }
               }
            ]
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is an example with Discovery SPI (the new AWS configuration)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{
   "name":"wanReplication",
   "publishers":[
      {
         "clusterName":"tokyo",
         "queueCapacity":1000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "aws":{
            "enabled":true,
            "usePublicIp":false,
            "properties":{
               "security-group-name":"hazelcast-sg",
               "tag-value":"hz-nodes",
               "host-header":"ec2.amazonaws.com",
               "tag-key":"type",
               "secret-key":"my-secret-key",
               "iam-role":"dummy",
               "access-key":"my-access-key",
               "region":"us-west-1"
            }
         },
         "sync":{
            "consistencyCheckStrategy":0
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is an example with static IP configuration (with some optional attributes):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{
   "name":"wanReplication",
   "publishers":[
      {
         "clusterName":"tokyo",
         "queueCapacity":1000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "responseTimeoutMillis":5000,
         "targetEndpoints":"10.3.5.1:5701, 10.3.5.2:5701",
         "batchMaxDelayMillis":3000,
         "batchSize":50,
         "snapshotEnabled":false,
         "acknowledgeType":1,
         "sync":{
            "consistencyCheckStrategy":0
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is an XML configuration with two publishers and several (disabled) discovery strategy configurations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{
   "name":"wanReplication",
   "publishers":[
      {
         "clusterName":"tokyo",
         "queueCapacity":1000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "aws":{
            "enabled":true,
            "usePublicIp":false,
            "properties":{
               "security-group-name":"hazelcast-sg",
               "tag-value":"hz-nodes",
               "host-header":"ec2.amazonaws.com",
               "tag-key":"type",
               "secret-key":"my-secret-key",
               "iam-role":"dummy",
               "access-key":"my-access-key",
               "region":"us-west-1"
            }
         },
         "gcp":{
            "enabled":false,
            "usePublicIp":true,
            "properties":{
               "gcp-prop":"gcp-val"
            }
         },
         "azure":{
            "enabled":false,
            "usePublicIp":true,
            "properties":{
               "azure-prop":"azure-val"
            }
         },
         "kubernetes":{
            "enabled":false,
            "usePublicIp":true,
            "properties":{
               "k8s-prop":"k8s-val"
            }
         },
         "eureka":{
            "enabled":false,
            "usePublicIp":true,
            "properties":{
               "eureka-prop":"eureka-val"
            }
         },
         "discovery":{
            "nodeFilterClass":null,
            "discoveryStrategy":[

            ]
         },
         "sync":{
            "consistencyCheckStrategy":0
         }
      },
      {
         "clusterName":"london",
         "queueCapacity":1000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "responseTimeoutMillis":5000,
         "targetEndpoints":"10.3.5.1:5701, 10.3.5.2:5701",
         "batchMaxDelayMillis":3000,
         "batchSize":50,
         "snapshotEnabled":false,
         "acknowledgeType":1,
         "aws":{
            "enabled":false,
            "usePublicIp":false
         },
         "gcp":{
            "enabled":false,
            "usePublicIp":false
         },
         "azure":{
            "enabled":false,
            "usePublicIp":false
         },
         "kubernetes":{
            "enabled":false,
            "usePublicIp":false
         },
         "eureka":{
            "enabled":false,
            "usePublicIp":false
         },
         "discovery":{
            "nodeFilterClass":null,
            "discoveryStrategy":[

            ]
         },
         "sync":{
            "consistencyCheckStrategy":1
         }
      }
   ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_event_filtering_api"><a class="anchor" href="#_event_filtering_api"></a>Event Filtering API</h4>
<div class="paragraph">
<p>WAN replication allows you to intercept WAN replication events before they are placed to
WAN event replication queues by providing a filtering API.
Using this API, you can monitor WAN replication events of each data structure
separately.</p>
</div>
<div class="paragraph">
<p>You can attach filters to your data structures using the <code>filter</code> element of
<code>wan-replication-ref</code> configuration inside <code>hazelcast.xml</code> as shown below.
You can also configure it using the programmatic configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="testMap"&gt;
        &lt;wan-replication-ref name="test"&gt;
            &lt;filters&gt;
                &lt;filter-impl&gt;com.example.MyFilter&lt;/filter-impl&gt;
                &lt;filter-impl&gt;com.example.MyFilter2&lt;/filter-impl&gt;
            &lt;/filters&gt;
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    testMap:
      wan-replication-ref:
        test:
          filters:
            - com.example.MyFilter
            - com.example.MyFilter2</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown in the above configuration, you can define more than one filter. Filters are called in the order that they are introduced.
A WAN replication event is only eligible to publish if it passes all the filters.</p>
</div>
<div class="paragraph">
<p>Map and Cache have different filter interfaces: <code>MapWanEventFilter</code> and
<code>CacheWanEventFilter</code>. Both of these interfaces have the method <code>filter</code> which takes the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mapName</code>/<code>cacheName</code>: Name of the related data structure.</p>
</li>
<li>
<p><code>entryView</code>: <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/core/EntryView.html" target="_blank" rel="noopener">EntryView</a>
or <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/cache/CacheEntryView.html" target="_blank" rel="noopener">CacheEntryView</a> depending on the data structure.</p>
</li>
<li>
<p><code>eventType</code>: Enum type - <code>UPDATED(1)</code>, <code>REMOVED(2)</code> or <code>LOADED(3)</code> - depending on the event.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>LOADED</code> events are filtered out and not replicated to target cluster.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="defining-custom-wr"><a class="anchor" href="#defining-custom-wr"></a>Implementing a Custom WAN Publisher</h4>
<div class="paragraph">
<p>In addition to using the Hazelcast&#8217;s built-in WAN Replication implementation, you can implement your own replication mechanism using the WAN publisher SPI.</p>
</div>
<div class="paragraph">
<p>Following is the configuration snippet where <code>replicatedMap</code> and <code>replicatedCache</code> use the custom implementation
<code>com.my.WanPublisher</code> to replicate map and cache updates.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;custom-publisher&gt;
            &lt;publisher-id&gt;myCustomPublisher&lt;/publisher-id&gt;
            &lt;class-name&gt;com.my.WanPublisher&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="prop1"&gt;val1&lt;/property&gt;
                &lt;property name="prop2"&gt;val2&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/custom-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/map&gt;

    &lt;cache name="replicatedCache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      custom-publisher:
        publisher-id: myCustomPublisher
        class-name: com.my.WanPublisher
        properties:
          prop1: val1
          prop2: val2
  map:
    replicatedMap:
      wan-replication-ref:
        london-wan-rep:
          ...
  cache:
    replicatedCache:
      wan-replication-ref:
        london-wan-rep:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>custom-publisher</code> is used to configure a custom implementation of a WAN replication implementing
<code>com.hazelcast.wan.WanPublisher</code>. For example, you might implement replication to Kafka or some JMS queue or even
write out map and cache event changes to a log on disk. It has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>class-name</code>: Mandatory configuration value defining the fully qualified class name of the
WAN publisher implementation. The class must implement <code>com.hazelcast.wan.WanPublisher</code>.</p>
</li>
<li>
<p><code>publisher-id</code>: Mandatory configuration value for the publisher ID used for identifying the
publisher in a <code>WanReplicationConfig</code>. This ID will be used to refer to this specific WAN publisher in
a certain WAN replication scheme.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In some cases, specifying the configuration on the source/active cluster is enough to fully implement your use case.
This is the case when you don&#8217;t have any target/passive Hazelcast cluster which consumes these events. In cases when
you do have a target Hazelcast cluster and you wish to use a custom WAN Replication implementation, you will need to
configure the target cluster as well. For example, you might want to implement WAN Replication by transmitting WAN events
through some JMS queue like ActiveMQ. In this case, you need to implement both your custom WAN publisher and WAN consumer.</p>
</div>
<div class="paragraph">
<p>Below is a configuration example for specifying a custom WAN replication consumer on the target/passive cluster:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;consumer&gt;
            &lt;class-name&gt;com.my.WanConsumer&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="prop1"&gt;val1&lt;/property&gt;
                &lt;property name="prop2"&gt;val2&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/consumer&gt;
    &lt;/wan-replication&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      consumer:
        class-name: com.my.WanConsumer
        properties:
          prop1: val1
          prop2: val2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>consumer</code> is used to configure the implementation of the <code>com.hazelcast.wan.WanConsumer</code> interface
which will be used to retrieve and process WAN events. A custom WAN consumer allows you to
define custom processing logic and is used in combination with a custom WAN publisher.</p>
</div>
<div class="paragraph">
<p>The <code>consumer</code> configuration element has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>class-name</code>: Name of the class implementing a custom WAN consumer (<code>com.hazelcast.wan.WanConsumer</code>).</p>
</li>
<li>
<p><code>properties</code>: Properties for the custom WAN consumer. These properties are accessible when initializing the WAN consumer.
You can define the host, username and password for the host, name of the queue to be polled by the consumer, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_customizing_wan_event_processing_on_passivetarget_cluster"><a class="anchor" href="#_customizing_wan_event_processing_on_passivetarget_cluster"></a>Customizing WAN Event Processing on Passive/Target Cluster</h4>
<div class="paragraph">
<p>In addition to customizing behavior of the source cluster and how WAN events are sent and retained, you can also
configure some aspects of how WAN events are processed on the receiving (target/passive) cluster. In addition, you
can also define a custom implementation of a WAN event consumer. A custom WAN consumer allows you to define custom
processing logic and is usually used in combination with a custom WAN publisher. A custom consumer is optional and
you may simply omit defining it which causes the default processing logic to be used. See the
<a href="#defining-custom-wr">Using the WAN Custom Publisher section</a> for more information.</p>
</div>
<div class="paragraph">
<p>Below you can see an example configuration of the target/passive cluster where we configure how incoming WAN events
are processed.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...

    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;consumer&gt;
            &lt;persist-wan-replicated-data&gt;false&lt;/persist-wan-replicated-data&gt;
        &lt;/consumer&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/map&gt;

    &lt;cache name="replicatedCache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      consumer:
        persist-wan-replicated-data: false
  map:
    replicatedMap:
      wan-replication-ref:
        london-wan-rep:
          ...
  cache:
    replicatedCache:
      wan-replication-ref:
        london-wan-rep:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the configuration above you can see that the WAN Replication configuration is again matched by WAN replication
scheme name to the exact map and cache configuration. This means that different structures can process WAN events
differently.</p>
</div>
<div class="paragraph">
<p>The processing behavior is configured using the <code>consumer</code> element. It has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>persist-wan-replicated-data</code>: When set to <code>true</code>, an incoming event over WAN replication can be
persisted to a database for example, otherwise it is not persisted. Default value is <code>true</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<link rel="shortcut icon" href="http://hazelcast.com/images/favicon.png">
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/vendor/search.js" id="search-script" data-base-path="../../.." data-page-path="/hazelcast/4.1/deploy/advanced_features.html"></script>
<script async src="../../../_/../search-index.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
