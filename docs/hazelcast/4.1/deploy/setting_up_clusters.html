<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hazelcast Hazelcast Documentation</title>
    <link rel="canonical" href="https://jakescahill.github.io/docs-poc/hazelcast/4.1/deploy/setting_up_clusters.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-M267KFN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-M267KFN')</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://jakescahill.github.io/docs-poc">Hazelcast Documentation</a>
        <div class="navbar-item">
          <input id="search-input" type="text" placeholder="Search docs">
        </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Hazelcast IMDG</a>
            <a class="navbar-item" href="#">Hazelcast Jet</a>
            <a class="navbar-item" href="#">Hazelcast Cloud</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Learn</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Docs</a>
            <a class="navbar-item" href="#">Online Training</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Demos</a>
            <a class="navbar-item" href="#">Community</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Get Hazelcast</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="hazelcast" data-version="4.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../hazelcast_overview.html">Hazelcast IMDG</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hazelcast_overview.html">Overview</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../get-started/getting_started.html">Get Started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started/glossary.html">Glossary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../develop/hazelcast_clients.html">Develop Solutions</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/jcache.html">JCache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/performance.html">Performance</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/serialization.html">Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/striim_cdc.html">Striim Hot Cache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/transactions.html">Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_query.html">Distributed Query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_sql.html">Distributed SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_events.html">Distributed Events</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_computing.html">Distributed Computing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="installing_upgrading.html">Deploy Clusters</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="starting_members_clients.html">Starting Members and Clients</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="setting_up_clusters.html">Setting Up Clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="management.html">Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="simulator.html">Hazelcast Simulator</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="wan.html">WAN Replication</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="network_partitioning.html">Network Partitioning</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../migrate/migration_guides.html">Migrate</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../troubleshoot/common_exception_types.html">Troubleshooting</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../reference/faq.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/dds.html">Distributed data structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/system_properties.html">System properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/understanding_configuration.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/phone_homes.html">Phone homes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/hazelcast_plugins.html">Plugins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute/extending_hazelcast.html">Contribute</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/licenses.html">Licenses</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/revision_history.html">Documentation changes</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Hazelcast IMDG</span>
    <span class="version">4.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Hazelcast IMDG</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../hazelcast_overview.html">4.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Home</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../home/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../home/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../hazelcast_overview.html">Hazelcast IMDG</a></li>
    <li><a href="installing_upgrading.html">Deploy Clusters</a></li>
    <li><a href="setting_up_clusters.html">Setting Up Clusters</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a class="git" href="https://github.com/JakeSCahill/docs-poc/edit/develop/hazelcast-docs/modules/deploy/pages/setting_up_clusters.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<div class="sect1">
<h2 id="setting-up-clusters"><a class="anchor" href="#setting-up-clusters"></a>Setting Up Clusters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes Hazelcast clusters and the methods
cluster members and native clients use to form a Hazelcast cluster.</p>
</div>
<div class="sect2">
<h3 id="discovery-mechanisms"><a class="anchor" href="#discovery-mechanisms"></a>Discovery Mechanisms</h3>
<div class="paragraph">
<p>A Hazelcast cluster is a network of cluster members that run Hazelcast.
Cluster members  automatically join together to form a cluster. This automatic
joining takes place with various discovery mechanisms that the cluster members
use to find each other.</p>
</div>
<div class="paragraph">
<p>Please note that, after a cluster is formed, communication between cluster members
is always via TCP/IP, regardless of the discovery mechanism used.</p>
</div>
<div class="paragraph">
<p>Hazelcast uses the following discovery mechanisms.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="https://hazelcast.com/resources/hazelcast-deployment-operations-guide/" target="_blank" rel="noopener">Hazelcast IMDG Deployment and Operations Guide</a>
for advices on the best discovery mechanism to use.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="auto-detection"><a class="anchor" href="#auto-detection"></a>Auto Detection</h4>
<div class="paragraph">
<p>By default, Hazelcast tries to automatically detect the applicable discovery mechanism based on the runtime environment.</p>
</div>
<div class="paragraph">
<p>Note that using Auto Detection is not recommended for production. Note also that if Hazelcast finds no applicable
discovery mechanism, then it falls back to <a href="#multicast">Multicast</a>.</p>
</div>
<div class="paragraph">
<p>See the <a href="#discovering-members-auto-detection">Discovering Members by Auto Detection section</a> for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="tcp"><a class="anchor" href="#tcp"></a>TCP</h4>
<div class="paragraph">
<p>You can configure Hazelcast to be a full TCP/IP cluster. See the
<a href="#discovering-members-by-tcp">Discovering Members by TCP section</a> for configuration details.</p>
</div>
</div>
<div class="sect3">
<h4 id="multicast"><a class="anchor" href="#multicast"></a>Multicast</h4>
<div class="paragraph">
<p>Multicast mechanism is not recommended for production since UDP is often
blocked in production environments and other discovery mechanisms are more definite.</p>
</div>
<div class="paragraph">
<p>With this mechanism, Hazelcast allows cluster members to find each other
using multicast communication. See the
<a href="#discovering-members-by-multicast">Discovering Members by Multicast section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="aws-cloud-discovery"><a class="anchor" href="#aws-cloud-discovery"></a>AWS Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast supports EC2/ECS auto-discovery. It is useful when you
do not want to provide or you cannot provide the list of possible
IP addresses. See the <a href="#hazelcast-cloud-discovery-plugins-aws">Cloud Discovery Plugins: Hazelcast AWS section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="azure-cloud-discovery"><a class="anchor" href="#azure-cloud-discovery"></a>Azure Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast offers a discovery strategy for your Hazelcast applications
running on Azure. See the <a href="#hazelcast-cloud-discovery-plugins-azure">Cloud Discovery Plugins: Hazelcast Azure section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gcp-cloud-discovery"><a class="anchor" href="#gcp-cloud-discovery"></a>GCP Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast supports discovering members in the <a href="https://cloud.google.com/compute/" target="_blank" rel="noopener">GCP Compute Engine</a>
environment. You can easily configure Hazelcast members discovery, WAN replication,
and Hazelcast Client to work seamlessly on the native GCP VM Instances.
This discovery feature is provided as a Hazelcast plugin.
See the <a href="#hazelcast-cloud-discovery-plugins-gcp">Cloud Discovery Plugins: Hazelcast GCP section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="kubernetes-cloud-discovery"><a class="anchor" href="#kubernetes-cloud-discovery"></a>Kubernetes Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast provides Kubernetes discovery mechanism that looks for IP addresses of members.
See the <a href="#hazelcast-cloud-discovery-plugins-kubernetes">Cloud Discovery Plugins: Hazelcast Kubernetes section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="eureka-cloud-discovery"><a class="anchor" href="#eureka-cloud-discovery"></a>Eureka Cloud Discovery</h4>
<div class="paragraph">
<p>Hazelcast supports the Eureka V1 discovery.
See the <a href="#hazelcast-cloud-discovery-plugins-eureka">Cloud Discovery Plugins: Hazelcast Eureka section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="zookeeper-cloud-discovery"><a class="anchor" href="#zookeeper-cloud-discovery"></a>Zookeeper Cloud Discovery</h4>
<div class="paragraph">
<p>This discovery mechanism provides a service based discovery strategy by using
Apache Curator to communicate with your Zookeeper server.
See the <a href="#hazelcast-cloud-discovery-plugins-zookeeper">Cloud Discovery Plugins: Hazelcast Zookeeper section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="hazelcast-for-pcf"><a class="anchor" href="#hazelcast-for-pcf"></a>Hazelcast for Tanzu VMware</h4>
<div class="paragraph">
<p>Using a clickable Hazelcast Tile for VMWare (former Pivotal Cloud Foundry), you can
deploy your Hazelcast cluster on PCF. This feature is provided as a Hazelcast
plugin.
See the <a href="#deploying-on-pivotal-cloud-foundry">Deploying in VMware Tanzu section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="discovering-members-auto-detection"><a class="anchor" href="#discovering-members-auto-detection"></a>Discovering Members by Auto Detection</h3>
<div class="paragraph">
<p>Auto Detection is a good way to start playing with Hazelcast. It tries to automatically detect the appropriate
discovery plugin and apply it to your Hazelcast configuration. Assuming you have <code>hazelcast-all</code>
on your classpath and your runtime is Kubernetes, Hazelcast automatically applies
the <a href="#kubernetes-cloud-discovery">Kubernetes discovery mechanism</a>.</p>
</div>
<div class="paragraph">
<p>Below is a table with minimal requirements for each environment.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Environment Requirements</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 71.4286%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Environment</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Requirements</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-cloud-discovery-plugins-aws">AWS</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>AWS EC2 requires the following points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Security Group with the port 5701 open</p>
</li>
<li>
<p>IAM role with the <code>ec2:DescribeInstances</code> permission attached to the EC2 Instance</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-cloud-discovery-plugins-azure">Azure</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Azure requires having Azure managed identity with the <code>READ</code> role attached to your Azure Virtual Machine.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-cloud-discovery-plugins-gcp">GCP</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>GCP requires having Cloud API (at minimum Read Only to Compute Engine API) access attached to your VM Instance.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#hazelcast-cloud-discovery-plugins-kubernetes">Kubernetes</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Kubernetes requires applying the
<a href="https://raw.githubusercontent.com/hazelcast/hazelcast-kubernetes/master/rbac.yaml" target="_blank" rel="noopener">RBAC permissions</a>.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="discovering-members-by-tcp"><a class="anchor" href="#discovering-members-by-tcp"></a>Discovering Members by TCP</h3>
<div class="paragraph">
<p>If multicast is not the preferred way of discovery for your environment,
then you can configure Hazelcast to be a full TCP/IP cluster. When you configure
Hazelcast to discover members by TCP/IP, you must list all or a subset of the members'
host names and/or IP addresses as cluster members. You do not have to list all of these
cluster members, but at least one of the listed members has to be active in the cluster
when a new member joins.</p>
</div>
<div class="paragraph">
<p>To configure your Hazelcast to be a full TCP/IP cluster, set the following
configuration elements. See the <a href="#tcp-ip-element">tcp-ip element section</a> for the
full descriptions of the TCP/IP discovery configuration elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set the <code>enabled</code> attribute of the <code>tcp-ip</code> element to <code>true</code>.</p>
</li>
<li>
<p>Provide your <code>member</code> elements within the <code>tcp-ip</code> element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;tcp-ip enabled="true"&gt;
                &lt;member&gt;machine1&lt;/member&gt;
                &lt;member&gt;machine2&lt;/member&gt;
                &lt;member&gt;machine3:5799&lt;/member&gt;
                &lt;member&gt;192.168.1.0-7&lt;/member&gt;
                &lt;member&gt;192.168.1.21&lt;/member&gt;
            &lt;/tcp-ip&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    join:
      tcp-ip:
        enabled: true
        member-list:
          - machine1
          - machine2
          - machine3:5799
          - 192.168.1.0-7
          - 192.168.1.21</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown above, you can provide IP addresses or host names for <code>member</code> elements.
You can also give a range of IP addresses, such as <code>192.168.1.0-7</code>.</p>
</div>
<div class="paragraph">
<p>Instead of providing members line-by-line as shown above, you also have the option
to use the <code>members</code> element and write comma-separated IP addresses, as shown below.</p>
</div>
<div class="paragraph">
<p><code>&lt;members&gt;192.168.1.0-7,192.168.1.21&lt;/members&gt;</code></p>
</div>
<div class="paragraph">
<p>If you do not provide ports for the members, Hazelcast automatically tries the
ports 5701, 5702 and so on.</p>
</div>
<div class="paragraph">
<p>By default, Hazelcast binds to all local network interfaces to accept incoming
traffic. You can change this behavior using the system property <code>hazelcast.socket.bind.any</code>.
If you set this property to <code>false</code>, Hazelcast uses the interfaces specified in the <code>interfaces</code>
element (see the <a href="#interfaces">Interfaces Configuration section</a>). If no interfaces are
provided, then it tries to resolve one interface to bind from the <code>member</code> elements.</p>
</div>
</div>
<div class="sect2">
<h3 id="discovering-members-by-multicast"><a class="anchor" href="#discovering-members-by-multicast"></a>Discovering Members by Multicast</h3>
<div class="paragraph">
<p>With the multicast auto-discovery mechanism, Hazelcast allows cluster members to find
each other using multicast communication. The cluster members do not need to know the
concrete addresses of the other members, as they just multicast to all the other members
for listening. Whether multicast is possible or allowed depends on your environment.</p>
</div>
<div class="paragraph">
<p>To set your Hazelcast to multicast auto-discovery, set the following configuration
elements. See the <a href="#multicast-element">multicast element section</a> for the full
description of the multicast discovery configuration elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set the <code>enabled</code> attribute of the <code>multicast</code> element to <code>true</code>.</p>
</li>
<li>
<p>Set <code>multicast-group</code>, <code>multicast-port</code>, <code>multicast-time-to-live</code>, etc. to your
multicast values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;multicast enabled="true"&gt;
                &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;
                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
                &lt;multicast-time-to-live&gt;32&lt;/multicast-time-to-live&gt;
                &lt;multicast-timeout-seconds&gt;2&lt;/multicast-timeout-seconds&gt;
                &lt;trusted-interfaces&gt;
                    &lt;interface&gt;192.168.1.102&lt;/interface&gt;
                &lt;/trusted-interfaces&gt;
            &lt;/multicast&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    join:
      multicast:
        enabled: true
        multicast-group: 224.2.2.3
        multicast-port: 54327
        multicast-time-to-live: 32
        multicast-timeout-seconds: 2
        trusted-interfaces:
          - 192.168.1.102</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pay attention to the <code>multicast-timeout-seconds</code> element. <code>multicast-timeout-seconds</code>
specifies the time in seconds that a member should wait for a valid multicast
response from another member running in the network before declaring itself the
leader member (the first member joined to the cluster) and creating its own cluster.
This only applies to the startup of members where no leader has been assigned yet. If
you specify a high value to <code>multicast-timeout-seconds</code>, such as 60 seconds, it means
that until a leader is selected, each member waits 60 seconds before moving on. Be careful
when providing a high value. Also, be careful not to set the value too low, or the members
might give up too early and create their own cluster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Multicast auto-discovery is not supported for Hazelcast native clients yet.
However, we offer Multicast Discovery Plugin for this purpose. See the
<a href="#discovering-native-clients">Discovering Native Clients section</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="discovering-native-clients"><a class="anchor" href="#discovering-native-clients"></a>Discovering Native Clients</h3>
<div class="paragraph">
<p>Hazelcast members and native Java clients can find each other with multicast
discovery plugin. This plugin is implemented using <a href="#discovery-spi">Hazelcast Discovery SPI</a>.
You should configure the plugin both at Hazelcast members and Java clients in order to
use multicast discovery.</p>
</div>
<div class="paragraph">
<p>To configure your cluster to have the multicast discovery plugin, follow
these steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set the <code>enabled</code> attribute of the <code>hazelcast.discovery.enabled</code>
property to <code>true</code>.</p>
</li>
<li>
<p>Add multicast discovery strategy configuration to your XML file,
i.e., <code>&lt;discovery-strategies&gt;</code> element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.discovery.enabled"&gt;true&lt;/property&gt;
    &lt;/properties&gt;
    &lt;network&gt;
        &lt;join&gt;
            &lt;discovery-strategies&gt;
                &lt;discovery-strategy class="com.hazelcast.spi.discovery.multicast.MulticastDiscoveryStrategy" enabled="true"&gt;
                    &lt;properties&gt;
                        &lt;property name="group"&gt;224.2.2.3&lt;/property&gt;
                        &lt;property name="port"&gt;54327&lt;/property&gt;
                    &lt;/properties&gt;
                &lt;/discovery-strategy&gt;
            &lt;/discovery-strategies&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.discovery.enabled: true
  network:
    join:
      discovery-strategies:
        discovery-strategy:
          enabled: true
          class: com.hazelcast.spi.discovery.multicast.MulticastDiscoveryStrategy
          properties:
            group: 224.2.2.3
            port: 54327</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the multicast discovery plugin configuration
properties with their descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>group</code>: String value that is used to set the multicast group,
so that you can isolate your clusters.</p>
</li>
<li>
<p><code>port</code>: Integer value that is used to set the multicast port.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="creating-cluster"><a class="anchor" href="#creating-cluster"></a>Creating Clusters</h3>
<div class="paragraph">
<p>You can create clusters using the <code>cluster-name</code> configuration
element.</p>
</div>
<div class="paragraph">
<p>You can separate and group your clusters in a simple way by specifying cluster names.
Example groupings can be by <strong>development</strong>, <strong>production</strong>, <strong>test</strong>, <strong>app</strong>, etc.
The following is an example declarative configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name&gt;production&lt;/cluster-name&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cluster-name: production</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also define the cluster configuration programmatically.
A JVM can host multiple Hazelcast instances. Each Hazelcast instance can only
participate in one group. Each Hazelcast instance only joins to its own group
and does not interact with other groups. The following code example creates
three separate Hazelcast instances--<code>h1</code> belongs to the <code>production</code> cluster,
while <code>h2</code> and <code>h3</code> belong to the <code>development</code> cluster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config configProd = new Config();
        configProd.setClusterName( "production" );

        Config configDev = new Config();
        configDev.setClusterName( "development" );

        HazelcastInstance h1 = Hazelcast.newHazelcastInstance( configProd );
        HazelcastInstance h2 = Hazelcast.newHazelcastInstance( configDev );
        HazelcastInstance h3 = Hazelcast.newHazelcastInstance( configDev );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="member-user-code-deployment"><a class="anchor" href="#member-user-code-deployment"></a>Deploying User Code on the Member</h3>
<div class="paragraph">
<p>Hazelcast can dynamically load your custom classes or domain classes from other
members. A <a href="#enabling-lite-members">lite member</a> can be designated as a <em>class
repository</em>, but any member can <em>provide</em> classes to other members. For this
purpose Hazelcast offers a distributed dynamic class loader.</p>
</div>
<div class="paragraph">
<p>The following is a brief working mechanism of the User Code Deployment feature:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A new dynamic class loader is created to handle each operation.</p>
</li>
<li>
<p>It first checks locally available classes, i.e. the member&#8217;s classpath. If
the class is found, it is used.</p>
</li>
<li>
<p>Then it checks the <em>cache</em> of classes loaded from remote members or clients
(if caching is enabled on your local member, see the
<a href="#configuring-user-code-deployment">Configuring User Code Deployment</a> section). If your class is found there, it
is used.</p>
</li>
<li>
<p>Finally, the dynamic class loader checks configured remote members, one by
one. If some member returns the class, it will be used. It can also put this
class into the local class cache as mentioned in the previous step.</p>
</li>
<li>
<p>If the class is not found, <code>ClassNotFoundException</code> is thrown.</p>
</li>
<li>
<p>The dynamic class loader is released after the operation is handled. A next
operation will load the class from the cache or re-fetch it.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using the user code deployment feature is a fit for your functional objects
like <code>Runnable</code>, <code>Callable</code> and <code>EntryProcessor</code>.
For the domain objects, we recommend you to use the
<a href="#accessing-domain-objects-without-domain-classes">generic object interface</a> (<code>GenericRecord</code>).
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-user-code-deployment"><a class="anchor" href="#configuring-user-code-deployment"></a>Configuring User Code Deployment</h4>
<div class="paragraph">
<p>User Code Deployment feature is not enabled by default. You can control local
caching of the classes loaded from other members, control classes to be
provided to other members and create blacklists and whitelists of classes and
packages.</p>
</div>
<div class="paragraph">
<p>Following are example configuration snippets:</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;user-code-deployment enabled="true"&gt;
        &lt;class-cache-mode&gt;ETERNAL&lt;/class-cache-mode&gt;
        &lt;provider-mode&gt;LOCAL_AND_CACHED_CLASSES&lt;/provider-mode&gt;
        &lt;blacklist-prefixes&gt;com.foo,com.bar&lt;/blacklist-prefixes&gt;
        &lt;whitelist-prefixes&gt;com.bar.MyClass&lt;/whitelist-prefixes&gt;
        &lt;provider-filter&gt;HAS_ATTRIBUTE:lite&lt;/provider-filter&gt;
    &lt;/user-code-deployment&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  user-code-deployment:
    enabled: true
    class-cache-mode: ETERNAL
    provider-mode: LOCAL_AND_CACHED_CLASSES
    blacklist-prefixes: com.foo,com.bar
    whitelist-prefixes: com.bar.MyClass
    provider-filter: HAS_ATTRIBUTE:lite</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        UserCodeDeploymentConfig distCLConfig = config.getUserCodeDeploymentConfig();
        distCLConfig.setEnabled( true )
                .setClassCacheMode( UserCodeDeploymentConfig.ClassCacheMode.ETERNAL )
                .setProviderMode( UserCodeDeploymentConfig.ProviderMode.LOCAL_AND_CACHED_CLASSES )
                .setBlacklistedPrefixes( "com.foo,com.bar" )
                .setWhitelistedPrefixes( "com.bar.MyClass" )
                .setProviderFilter( "HAS_ATTRIBUTE:lite" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>User Code Deployment on the member has the following configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether dynamic class loading is enabled or not. Its
default value is "false" and it&#8217;s a mandatory attribute. If feature is
disabled, the member will never load classes from other members or clients.</p>
</li>
<li>
<p><code>&lt;class-cache-mode&gt;</code>: Controls the local caching behavior for the classes
loaded from remote members (classes loaded from clients are always cached).
Available values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>ETERNAL</code>: Cache the loaded classes locally. This is the default value and
suitable when you load long-living objects, such as domain objects stored in a map.</p>
</li>
<li>
<p><code>OFF</code>: Do not cache the loaded classes locally. It is suitable for loading
runnables, callables, entry processors, etc.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>&lt;provider-mode&gt;</code>: Controls which classes are served to other cluster
members. Available values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>LOCAL_AND_CACHED_CLASSES</code>: Serve classes loaded from both local classpath
and from other members. This is the default value.</p>
</li>
<li>
<p><code>LOCAL_CLASSES_ONLY</code>: Serve classes from the local classpath only. Classes
loaded from other members are used locally, but they are not served to other members.</p>
</li>
<li>
<p><code>OFF</code>: Never serve classes to other members.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>&lt;blacklist-prefixes&gt;</code>: Comma separated class/package name prefixes that
the member will never attempt to load from other members and that the client
won&#8217;t be allowed to upload. For example, if you set it to "com.foo", remote
loading of all classes from the "com.foo" package is prevented, including the
classes from all its sub-packages. If you set it to "com.foo.Class", then
"Class" and all classes starting with "Class" in the "com.foo" package are
blacklisted. There are built-in prefixes which are always blacklisted.
These are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>javax.</code></p>
</li>
<li>
<p><code>java.</code></p>
</li>
<li>
<p><code>sun.</code></p>
</li>
<li>
<p><code>com.hazelcast.</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>&lt;whitelist-prefixes&gt;</code>: Comma separated name prefixes of classes/packages
only from which the classes are allowed to be loaded. It allows to quickly
configure remote loading only for classes from selected packages. It can be
used together with blacklisting. For example, you can whitelist the prefix
"com.foo" and blacklist the prefix "com.foo.secret". If the list is empty, all
classes are allowed.</p>
</li>
<li>
<p><code>&lt;provider-filter&gt;</code>: Filter to constrain members that can be used for a class
loading request when a class is not available locally. The value is in the
format "HAS_ATTRIBUTE:foo". When it is set to "HAS_ATTRIBUTE:foo", the class
loading request is only sent to the members which have "foo" as a
<a href="#defining-member-attributes">member attribute</a>. Setting this to null allows
loading of classes from all members. See an example in the next section.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="example-for-filtering-members"><a class="anchor" href="#example-for-filtering-members"></a>Example for Filtering of Members</h4>
<div class="paragraph">
<p>As described above, the configuration element <code>provider-filter</code> is used to
limit members that can be used to load classes. The attribute required in the
<code>provider-filter</code> must be set as a member attribute on the members from which
the classes are to be loaded. See the following examples provided as
programmatic configurations.</p>
</div>
<div class="paragraph">
<p>The example configuration below allows the Hazelcast member to load classes
only from members with the <code>class-provider</code> attribute set. It prevents from
asking any other member to provide a locally unavailable class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config hazelcastConfig = new Config();
        UserCodeDeploymentConfig ucdConfig = hazelcastConfig.getUserCodeDeploymentConfig();
        ucdConfig.setProviderFilter("HAS_ATTRIBUTE:class-provider");

        HazelcastInstance instance = Hazelcast.newHazelcastInstance(hazelcastConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example configuration below sets the attribute <code>class-provider</code> for a
member. Therefore the above member will be able to load classes from this
member:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config hazelcastConfig = new Config();
        MemberAttributeConfig memberAttributes = hazelcastConfig.getMemberAttributeConfig();
        memberAttributes.setAttribute("class-provider", "true");

        HazelcastInstance instance = Hazelcast.newHazelcastInstance(hazelcastConfig);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client-user-code-deployment"><a class="anchor" href="#client-user-code-deployment"></a>Deploying User Code from Clients</h3>
<div class="paragraph">
<p>You can also deploy your code from the client side for the following
situations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You have objects that run on the cluster via the clients such as
<code>Runnable</code>, <code>Callable</code> and <code>EntryProcessor</code>.</p>
</li>
<li>
<p>You have new user domain objects which need to be deployed into the cluster.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When this feature is enabled on the client, the client will deploy the classes
to the members when connecting. This way, when a client adds a new class, the
members do not require a restart to include it in their classpath.</p>
</div>
<div class="paragraph">
<p>You can also use the client permission policy to specify which clients
are permitted to use User Code Deployment. See the <a href="#permissions">Permissions section</a>.</p>
</div>
<div class="paragraph">
<p>NOTE:</p>
</div>
<div class="sect3">
<h4 id="configuring-client-user-code-deployment"><a class="anchor" href="#configuring-client-user-code-deployment"></a>Configuring Client User Code Deployment</h4>
<div class="paragraph">
<p>Client User Code Deployment feature is not enabled by default. You can
configure this feature declaratively or programmatically.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using the user code deployment feature is a fit for your functional objects
like <code>Runnable</code>, <code>Callable</code> and <code>EntryProcessor</code>.
For the domain objects, we recommend you to use the
<a href="#accessing-domain-objects-without-domain-classes">generic object interface</a> (<code>GenericRecord</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Following are example configuration snippets:</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="paragraph">
<p>In your <code>hazelcast-client.xml/yaml</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast-client&gt;
    ...
    &lt;user-code-deployment enabled="true"&gt;
        &lt;jarPaths&gt;
            &lt;jarPath&gt;/User/example/example.jar&lt;/jarPath&gt;
            &lt;jarPath&gt;example.jar&lt;/jarPath&gt; &lt;!--from class path --&gt;
            &lt;jarPath&gt;https://com.example.com/example.jar&lt;/jarPath&gt;
            &lt;jarPath&gt;file://Users/example/example.jar&lt;/jarPath&gt;
        &lt;/jarPaths&gt;
        &lt;classNames&gt;
            &lt;!-- for classes available in client's class path --&gt;
            &lt;className&gt;example.ClassName&lt;/className&gt;
            &lt;className&gt;example.ClassName2&lt;/className&gt;
        &lt;/classNames&gt;
    &lt;/user-code-deployment&gt;
    ...
&lt;/hazelcast-client&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast-client:
  user-code-deployment
    enabled: true
    jarPaths:
      - /User/example/example.jar
      - example.jar
      - https://com.example.com/example.jar
      - file://Users/example/example.jar
    classNames:
      - example.ClassName
      - example.ClassName2</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        ClientConfig clientConfig = new ClientConfig();
        ClientUserCodeDeploymentConfig clientUserCodeDeploymentConfig = new ClientUserCodeDeploymentConfig();

        clientUserCodeDeploymentConfig.addJar("/User/example/example.jar");
        clientUserCodeDeploymentConfig.addJar("https://com.example.com/example.jar");
        clientUserCodeDeploymentConfig.addClass("example.ClassName");
        clientUserCodeDeploymentConfig.addClass("example.ClassName2");

        clientUserCodeDeploymentConfig.setEnabled(true);
        clientConfig.setUserCodeDeploymentConfig(clientUserCodeDeploymentConfig);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="client-user-code-deployment-note"><a class="anchor" href="#client-user-code-deployment-note"></a>Important to Know</h5>
<div class="paragraph">
<p>The members have to be configured in a specific way for the feature to work
correctly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>User Code Deployment must be enabled on the members. Otherwise, the classes
from the client will be ignored. Also blacklisted and non-whitelisted classes
will be ignored.</p>
</li>
<li>
<p>All members must be providers, <code>provider-mode</code> must be set to
<code>LOCAL_AND_CACHED_CLASSES</code> on all members.</p>
</li>
<li>
<p>No <code>provider-filter</code> must be configured.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The client uploads the classes only to one member. If the members don&#8217;t load
classes from each other, other members won&#8217;t see the class.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a programmatic configuration of the members that will work with client
user code deployment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        UserCodeDeploymentConfig ucdConfig = config.getUserCodeDeploymentConfig();
        ucdConfig.setEnabled(true);
        // following two configs are defaults, we show them for clarity
        ucdConfig.setProviderMode(ProviderMode.LOCAL_AND_CACHED_CLASSES);
        ucdConfig.setProviderFilter(null);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#member-user-code-deployment">Member User Code Deployment section</a>
for more information on enabling it on the member side and the configuration properties.</p>
</div>
<div class="paragraph">
<p>Classes deployed from clients are always cached on the members, no matter
whether <code>ETERNAL</code> or <code>OFF</code> is configured on the members.</p>
</div>
</div>
<div class="sect4">
<h5 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a>Performance Considerations</h5>
<div class="paragraph">
<p>The client always uploads all added classes and jars to one of the members,
whether it has them or not. So avoid adding large jar files for each connection
- if configured properly, the member will have the class the next time the
client connects.</p>
</div>
</div>
<div class="sect4">
<h5 id="_two_versions_of_a_class"><a class="anchor" href="#_two_versions_of_a_class"></a>Two Versions of a Class</h5>
<div class="paragraph">
<p>If the client uploads a class and the member already has that class, an
exception is thrown if the byte code is different. If byte code is same, it is
ignored. Therefore classes uploaded from the client can&#8217;t be updated with a new
version.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adding_user_library_to_classpath"><a class="anchor" href="#_adding_user_library_to_classpath"></a>Adding User Library to CLASSPATH</h4>
<div class="paragraph">
<p>When you want to use a Hazelcast feature in a non-Java client, you need to make
sure that the Hazelcast member recognizes it. For this, you can use the <code>/user-lib</code>
directory that comes with the Hazelcast package and deploy your own library to the member.
Let&#8217;s say you use Hazelcast Node.js client and want to use an entry processor.
This processor should be <code>IdentifiedDataSerializable</code> or <code>Portable</code> in the Node.js client.
You need to implement the Java equivalents of the processor and its factory on the member side,
and put these compiled class or JAR files into the <code>/user-lib</code> directory. Then you can run
the <code>start.sh</code> script which adds them to the classpath.</p>
</div>
<div class="paragraph">
<p>The following is an example code which can be the Java equivalent of
entry processor in the Node.js client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IdentifiedEntryProcessor implements EntryProcessor&lt;String, String, String&gt;, IdentifiedDataSerializable {
    static final int CLASS_ID = 1;
    private String value;
    public IdentifiedEntryProcessor() {
    }
    @Override
    public int getFactoryId() {
        return IdentifiedFactory.FACTORY_ID;
    }
    @Override
    public int getClassId() {
        return CLASS_ID;
    }
    @Override
    public void writeData(ObjectDataOutput out) throws IOException {
        out.writeUTF(value);
    }
    @Override
    public void readData(ObjectDataInput in) throws IOException {
        value = in.readUTF();
    }
    @Override
    public String process(Map.Entry&lt;String, String&gt; entry) {
        entry.setValue(value);
        return value;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can implement the above processor&#8217;s factory as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IdentifiedFactory implements DataSerializableFactory {
    public static final int FACTORY_ID = 5;
    @Override
    public IdentifiedDataSerializable create(int typeId) {
        if (typeId == IdentifiedEntryProcessor.CLASS_ID) {
            return new IdentifiedEntryProcessor();
        }
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following is the configuration for the above factory:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;serialization&gt;
        &lt;data-serializable-factories&gt;
            &lt;data-serializable-factory factory-id="5"&gt;
                IdentifiedFactory
            &lt;/data-serializable-factory&gt;
        &lt;/data-serializable-factories&gt;
    &lt;/serialization&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  serialization:
    data-serializable-factories:
      - factory-id: 5
        class-name: IdentifiedFactory</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can start your Hazelcast member by using the start scripts
(<code>start.sh</code> or <code>start.bat</code>) in the <code>/bin</code> directory. The start scripts
automatically adds your class and JAR files to the classpath.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="accessing-domain-objects-without-domain-classes"><a class="anchor" href="#accessing-domain-objects-without-domain-classes"></a>Accessing Domain Objects without Domain Classes - BETA</h3>
<div class="paragraph">
<p>Hazelcast offers a generic object interface (<code>GenericRecord</code>) that is returned to the user
when the domain class is missing on the classpath.
For example, if <code>PortableFactory</code> is not given in the serialization configuration for a
portable object, the user domain class cannot be created, and Hazelcast returns <code>GenericRecord</code> instead.
In the previous Hazelcast IMDG releases, we were throwing <code>HazelcastSerializationException("Could not create Portable for class-id: " + classId)</code>
for the same situation.</p>
</div>
<div class="paragraph">
<p><code>GenericRecord</code> is an immutable object. It allows you to read the field of objects via the related field names.
<code>GenericRecord</code> is applicable only to <code>Portable</code> objects.</p>
</div>
<div class="paragraph">
<p>You can use this feature when the cluster does not have the domain classes of the clients in a
client-server architecture. On remote calls like distributed executor service or entry processors,
you may need to access the domain object. In case the class of the domain object is not available on the cluster,
<code>GenericRecord</code> allows to access, read and write the objects
back without the class of the domain object on the classpath. Here is a read example with entry processor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    map.executeOnKey(key, (EntryProcessor&lt;Object, Object, Object&gt;) entry -&gt; {
             Object value = entry.getValue();
             GenericRecord genericRecord = (GenericRecord) value;

             int id = genericRecord.readInt("id");

             return null;
         });</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative approach introduced in the previous Hazelcast IMDG releases is the <a href="#member-user-code-deployment">User Code Deployment</a>
feature to deploy the classes from the client to the cluster.
However, it has a restriction: you can not upload
a new version of your class to the cluster if you use the portable versioning support.
Loading two different versions of the same class on the JVM is not a problem that we want to solve: using <code>GenericRecord</code>,
you can easily write different versions of your classes
from the clients and access them without using the User Code Deployment feature.</p>
</div>
<div class="paragraph">
<p>With the introduction of <code>GenericRecord</code>, User Code Deployment should be used only for functional objects like <code>Runnable</code>,
<code>Callable</code> and <code>EntryProcessor</code>.</p>
</div>
<div class="paragraph">
<p>You can also create a <code>GenericRecord</code> in portable format with <code>GenericRecord.Builder</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClassDefinition classDefinition = new ClassDefinitionBuilder(PORTABLE_FACTORY_ID, EMPLOYEE_CLASS_ID)
                        .addUTFField("name").addIntField("id").build();

GenericRecord namedRecord = GenericRecord.Builder.portable(classDefinition)
                .writeUTF("name", "foo")
                .writeInt("id", 123).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the class definitions are better to be created once and
used when creating different instances of the same type <code>GenericRecord</code>.</p>
</div>
<div class="paragraph">
<p>We have also added two convenience methods in <code>GenericRecord</code> for you to
avoid passing a class definition. For example, if you want to modify a value and
put it back using an entry processor, you don&#8217;t need to create a class definition.
Instead you can create a builder from <code>GenericRecord</code> which carries the same class definition as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">map.executeOnKey("key", (EntryProcessor&lt;Object, Object, Object&gt;) entry -&gt; {
            GenericRecord genericRecord = (GenericRecord) entry.getValue();
            GenericRecord modifiedGenericRecord = genericRecord.newBuilder()
                    .writeUTF("name","Kermit")
                    .writeLong("id", 4)
                    .writeInt("age",20)
                    .writeUTF("surname", "The Frog").build();
            entry.setValue(modifiedGenericRecord);
            return null;
        });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another convenience method is <code>cloneWithBuilder</code>. This is useful if you want to update only
a couple of fields from the original <code>genericRecord</code>. In that case, the new builder carries
both <code>classDefinition</code> and values from the original
<code>genericRecord</code>. Here is the same example where we just update the age:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">map.executeOnKey("key", (EntryProcessor&lt;Object, Object, Object&gt;) entry -&gt; {
            GenericRecord genericRecord = (GenericRecord) entry.getValue();
            GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder()
                    .writeInt("age",22).build();
            entry.setValue(modifiedGenericRecord);
            return null;
        });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another use case of this feature is on the client side (could also be a member):
<code>GenericRecord</code> allows to read from/write to a cluster without having the related classes on the classpath.
A client could work with the cluster without introducing the <code>PortableFactory</code> at the start.
In this case, the client works with <code>GenericRecord</code>s instead of domain classes.
An example code snippet on the client side with a map is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        GenericRecord record = (GenericRecord) map.get("key1");
        String name = record.readUTF("name");
        int id = record.readInt("id");

        GenericRecord newGenericRecord = genericRecord.cloneWithBuilder()
                .writeInt("age",22).build();

        map.put("key2", newGenericRecord);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="partition-group-configuration"><a class="anchor" href="#partition-group-configuration"></a>Partition Group Configuration</h3>
<div class="paragraph">
<p>Hazelcast distributes key objects into partitions using the consistent
hashing algorithm. Multiple replicas are created for each partition and
those partition replicas are distributed among Hazelcast members. An entry
is stored in the members that own replicas of the partition to which the entry&#8217;s
key is assigned. The total partition count is 271 by default; you can change it
with the configuration property <code>hazelcast.partition.count</code>. See the
<a href="#system-properties">System Properties appendix</a>.</p>
</div>
<div class="paragraph">
<p>Hazelcast member that owns the primary replica of a partition is called as
the partition owner. Other replicas are called backups. Based on the configuration,
a key object can be kept in multiple replicas of a partition. A member can hold at
most one replica of a partition (ownership or backup).</p>
</div>
<div class="paragraph">
<p>By default, Hazelcast distributes partition replicas randomly and equally among
the cluster members, assuming all members in the cluster are identical. But what
if some members share the same JVM or physical machine or chassis and you want
backups of these members to be assigned to members in another machine or chassis?
What if processing or memory capacities of some members are different and you
do not want an equal number of partitions to be assigned to all members?</p>
</div>
<div class="paragraph">
<p>To deal with such scenarios, you can group members in the same JVM (or physical machine)
or members located in the same chassis. Or you can group members to create identical
capacity. We call these groups <strong>partition groups</strong>. Partitions are assigned to those
partition groups instead of individual members. Backup replicas of a partition which is
owned by a partition group are located in other partition groups.</p>
</div>
<div class="sect3">
<h4 id="grouping-types"><a class="anchor" href="#grouping-types"></a>Grouping Types</h4>
<div class="paragraph">
<p>When you enable partition grouping, Hazelcast presents the following choices
for you to configure partition groups.</p>
</div>
<div class="sect4">
<h5 id="_host_aware"><a class="anchor" href="#_host_aware"></a>HOST_AWARE</h5>
<div class="paragraph">
<p>You can group members automatically using the IP addresses of members, so members
sharing the same network interface are grouped together. All members on the same
host (IP address or domain name) form a single partition group. This helps to avoid
data loss when a physical server crashes, because multiple replicas of the same
partition are not stored on the same host. But if there are multiple network
interfaces or domain names per physical machine, this assumption is invalid.</p>
</div>
<div class="paragraph">
<p>The following are declarative and programmatic configuration snippets that
show how to enable <code>HOST_AWARE</code> grouping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;partition-group enabled="true" group-type="HOST_AWARE" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.HOST_AWARE );</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_custom"><a class="anchor" href="#_custom"></a>CUSTOM</h5>
<div class="paragraph">
<p>You can do custom grouping using Hazelcast&#8217;s interface matching configuration.
This way, you can add different and multiple interfaces to a group. You can also
use wildcards in the interface addresses. For example, the users can create rack-aware
or data warehouse partition groups using custom partition grouping.</p>
</div>
<div class="paragraph">
<p>The following are declarative and programmatic configuration examples that show
how to enable and use <code>CUSTOM</code> grouping:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;partition-group enabled="true" group-type="CUSTOM"&gt;
        &lt;member-group&gt;
            &lt;interface&gt;10.10.0.*&lt;/interface&gt;
            &lt;interface&gt;10.10.3.*&lt;/interface&gt;
            &lt;interface&gt;10.10.5.*&lt;/interface&gt;
        &lt;/member-group&gt;
        &lt;member-group&gt;
            &lt;interface&gt;10.10.10.10-100&lt;/interface&gt;
            &lt;interface&gt;10.10.1.*&lt;/interface&gt;
            &lt;interface&gt;10.10.2.*&lt;/interface&gt;
        &lt;/member-group&gt;
    &lt;/partition-group&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  partition-group:
    enabled: true
    group-type: CUSTOM
    member-group:
      - - 10.10.0.*
        - 10.10.3.*
        - 10.10.5.*
      - - 10.10.10.10-100
        - 10.10.1.*
        - 10.10.2.*</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
        partitionGroupConfig.setEnabled( true )
                .setGroupType( PartitionGroupConfig.MemberGroupType.CUSTOM );

        MemberGroupConfig memberGroupConfig = new MemberGroupConfig();
        memberGroupConfig.addInterface( "10.10.0.*" )
                .addInterface( "10.10.3.*" ).addInterface("10.10.5.*" );

        MemberGroupConfig memberGroupConfig2 = new MemberGroupConfig();
        memberGroupConfig2.addInterface( "10.10.10.10-100" )
                .addInterface( "10.10.1.*").addInterface( "10.10.2.*" );

        partitionGroupConfig.addMemberGroupConfig( memberGroupConfig );
        partitionGroupConfig.addMemberGroupConfig( memberGroupConfig2 );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While your cluster was forming, if you configured your members to
discover each other by their IP addresses, you should use the IP addresses
for the <code>&lt;interface&gt;</code> element. If your members discovered each other by their
host names, you should use host names.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_per_member"><a class="anchor" href="#_per_member"></a>PER_MEMBER</h5>
<div class="paragraph">
<p>You can give every member its own group. Each member is a group of its own
and primary and backup partitions are distributed randomly (not on the same
physical member). This gives the least amount of protection and is the default
configuration for a Hazelcast cluster. This grouping type provides good redundancy
when Hazelcast members are on separate hosts. However, if multiple instances
run on the same host, this type is not a good option.</p>
</div>
<div class="paragraph">
<p>The following are declarative and programmatic configuration snippets that
show how to enable <code>PER_MEMBER</code> grouping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;partition-group enabled="true" group-type="PER_MEMBER" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.PER_MEMBER );</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_zone_aware"><a class="anchor" href="#_zone_aware"></a>ZONE_AWARE</h5>
<div class="paragraph">
<p>You can use ZONE_AWARE configuration with <a href="https://github.com/hazelcast/hazelcast-kubernetes" target="_blank" rel="noopener">Hazelcast Kubernetes</a>,
<a href="https://github.com/hazelcast/hazelcast-aws" target="_blank" rel="noopener">Hazelcast AWS</a>,
<a href="https://github.com/hazelcast/hazelcast-gcp" target="_blank" rel="noopener">Hazelcast GCP</a>,
<a href="https://github.com/hazelcast/hazelcast-jclouds" target="_blank" rel="noopener">Hazelcast jclouds</a> or
<a href="https://github.com/hazelcast/hazelcast-azure" target="_blank" rel="noopener">Hazelcast Azure</a> Discovery Service plugins.</p>
</div>
<div class="paragraph">
<p>As discovery services, these plugins put zone information to the Hazelcast
<a href="#defining-member-attributes">member attributes</a> map during the discovery process.
When ZONE_AWARE is configured as partition group type, Hazelcast creates the partition
groups with respect to member attributes map entries that include zone information.
That means backups are created in the other zones and each zone is accepted as one partition group.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the ZONE_AWARE partition grouping, a Hazelcast cluster spanning
multiple AZs should have an equal number of members in each AZ. Otherwise,
it results in uneven partition distribution among the members.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is the list of supported attributes which is set by the
Discovery Service plugins during a Hazelcast member start-up:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.partition.group.zone</code>: For the zones in the same area.</p>
</li>
<li>
<p><code>hazelcast.partition.group.rack</code>: For different racks in the same zone.</p>
</li>
<li>
<p><code>hazelcast.partition.group.host</code>: For a shared physical member if virtualization is used.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hazelcast jclouds plugin offers rack or host information in addition to
zone information based on the cloud provider. In such cases, Hazelcast looks for zone,
rack and host information in the given order and create partition groups with available information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following are declarative and programmatic configuration snippets
that show how to enable <code>ZONE_AWARE</code> grouping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;partition-group enabled="true" group-type="ZONE_AWARE" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled( true )
    .setGroupType( MemberGroupType.ZONE_AWARE );</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_spi"><a class="anchor" href="#_spi"></a>SPI</h5>
<div class="paragraph">
<p>You can provide your own partition group implementation using the SPI configuration.
To create your partition group implementation, you need to first extend the
<code>DiscoveryStrategy</code> class of the discovery service plugin, override the method
<code>public PartitionGroupStrategy getPartitionGroupStrategy()</code> and return the <code>PartitionGroupStrategy</code>
configuration in that overridden method.</p>
</div>
<div class="paragraph">
<p>The following code covers the implementation steps mentioned in the above paragraph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomDiscovery extends AbstractDiscoveryStrategy {

    public CustomDiscovery(ILogger logger, Map&lt;String, Comparable&gt; properties) {
        super(logger, properties);
    }

    @Override
    public Iterable&lt;DiscoveryNode&gt; discoverNodes() {
        Iterable&lt;DiscoveryNode&gt; iterable = //your implementation
        return iterable;
    }

    @Override
    public PartitionGroupStrategy getPartitionGroupStrategy() {
        return new CustomPartitionGroupStrategy();
    }

    private class CustomPartitionGroupStrategy implements PartitionGroupStrategy {
        @Override
        public Iterable&lt;MemberGroup&gt; getMemberGroups() {
            Iterable&lt;MemberGroup&gt; iterable = //your implementation
            return iterable;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="logging-configuration"><a class="anchor" href="#logging-configuration"></a>Logging Configuration</h3>
<div class="paragraph">
<p>Hazelcast has a flexible logging configuration and does not depend on
any logging framework except JDK logging. It has built-in adapters
for a number of logging frameworks and it also supports custom loggers
by providing logging interfaces.</p>
</div>
<div class="paragraph">
<p>To use the built-in adapters, set the <code>hazelcast.logging.type</code> property
to one of the predefined types below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>jdk</strong>: JDK logging (default)</p>
</li>
<li>
<p><strong>log4j</strong>: Log4j</p>
</li>
<li>
<p><strong>log4j2</strong>: Log4j2</p>
</li>
<li>
<p><strong>slf4j</strong>: Slf4j</p>
</li>
<li>
<p><strong>none</strong>: disable logging</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can set <code>hazelcast.logging.type</code> through declarative configuration,
programmatic configuration or JVM system property.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you choose to use <code>log4j</code>, <code>log4j2</code>, or <code>slf4j</code>, you should include
the proper dependencies in the classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.logging.type"&gt;log4j&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.logging.type: log4j</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config() ;
config.setProperty( "hazelcast.logging.type", "log4j" );</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>System Property</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>using the <code>java -Dhazelcast.logging.type=slf4j</code> JVM parameter</p>
</li>
<li>
<p>using <code>System.setProperty( "hazelcast.logging.type", "none" );</code> System class</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the provided logging mechanisms are not satisfactory, you can implement
your own using the custom logging feature. To use it, implement the
<code>com.hazelcast.logging.LoggerFactory</code> and <code>com.hazelcast.logging.ILogger</code>
interfaces and set the system property <code>hazelcast.logging.class</code> as your
custom <code>LoggerFactory</code> class name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.logging.class=foo.bar.MyLoggingFactory</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also listen to logging events generated by Hazelcast runtime
by registering <code>LogListener</code>s to <code>LoggingService</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">LogListener listener = new LogListener() {
  public void log( LogEvent logEvent ) {
    // do something
  }
};
HazelcastInstance instance = Hazelcast.newHazelcastInstance();
LoggingService loggingService = instance.getLoggingService();
loggingService.addLogListener( Level.INFO, listener );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Through the <code>LoggingService</code>, you can get the currently used
ILogger implementation and log your own messages too.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are not using command line for configuring logging, you should be careful
about Hazelcast classes. They may be defaulted to <code>jdk</code> logging before newly configured
logging is read. When logging mechanism is selected, it will not change.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Below are example configurations for Log4j2 and Log4j. Note that Hazelcast does not
recommend any specific logging library, these examples are provided only to demonstrate
how to configure the logging. You can use your custom logging as explained above.</p>
</div>
<div class="sect3">
<h4 id="_example_log4j2_configuration"><a class="anchor" href="#_example_log4j2_configuration"></a>Example Log4j2 Configuration</h4>
<div class="paragraph">
<p>Specify the logging type as Log4j2 and a separate logging configuration file as shown below.</p>
</div>
<div class="paragraph">
<p>Using JVM arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.logging.type=log4j2
-Dlog4j.configurationFile=/path/to/properties/log4j2.properties</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using declarative configuration (<code>hazelcast.xml/yaml</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.logging.type"&gt;log4j2&lt;/property&gt;
        &lt;property name="log4j2.configuration"&gt;/path/to/properties/log4j2.properties&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.logging.type: log4j2
    log4j2.configuration: /path/to/properties/log4j2.properties</code></pre>
</div>
</div>
<div class="paragraph">
<p>Following is an example <code>log4j2.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">rootLogger=file
rootLogger.level=info
property.filepath=/path/to/log/files
property.filename=hazelcast

appender.file.type=RollingFile
appender.file.name=RollingFile
appender.file.fileName=${filepath}/${filename}.log
appender.file.filePattern=${filepath}/${filename}-%d{yyyy-MM-dd}-%i.log.gz
appender.file.layout.type=PatternLayout
appender.file.layout.pattern = %d{yyyy-MM-dd HH:mm:ss} %-5p %c\{1}:%L - %m%n
appender.file.policies.type=Policies
appender.file.policies.time.type=TimeBasedTriggeringPolicy
appender.file.policies.time.interval=1
appender.file.policies.time.modulate=true
appender.file.policies.size.type=SizeBasedTriggeringPolicy
appender.file.policies.size.size=50MB
appender.file.strategy.type=DefaultRolloverStrategy
appender.file.strategy.max=100

rootLogger.appenderRefs=file
rootLogger.appenderRef.file.ref=RollingFile

#Hazelcast specific logs.

#log4j.logger.com.hazelcast=debug

#log4j.logger.com.hazelcast.cluster=debug
#log4j.logger.com.hazelcast.partition=debug
#log4j.logger.com.hazelcast.partition.InternalPartitionService=debug
#log4j.logger.com.hazelcast.nio=debug
#log4j.logger.com.hazelcast.hibernate=debug</code></pre>
</div>
</div>
<div class="paragraph">
<p>To enable the debug logs for all Hazelcast operations uncomment the below line
in the above configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>log4j.logger.com.hazelcast=debug</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not need detailed logs, the default settings are enough.
Using the Hazelcast specific lines in the above configuration file,
you can select to see specific logs (cluster, partition, hibernate, etc.) in desired levels.</p>
</div>
<div class="paragraph">
<p>You can also use the <code>hazelcast.logging.details.enabled</code> property to
specify whether the name, IP address and version of the cluster are included
in the logs. When there are lots of log lines, it may be hard to follow.
When set to <code>false</code>, those information will not appear.</p>
</div>
</div>
<div class="sect3">
<h4 id="_example_log4j_configuration"><a class="anchor" href="#_example_log4j_configuration"></a>Example Log4j Configuration</h4>
<div class="paragraph">
<p>Its configuration is similar to that of Log4j2. Below is the JVM argument way of
specifying the logging type and configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dhazelcast.logging.type=log4j
-Dlog4j.configuration=file:/path/to/properties/log4j.properties</code></pre>
</div>
</div>
<div class="paragraph">
<p>Following is an example <code>log4j.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">log4j.rootLogger=INFO,file

log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.File=/path/to/log/files/hazelcast.log
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %p [%c\{1}] - %m%n
log4j.appender.file.maxFileSize=50MB
log4j.appender.file.maxBackupIndex=100
log4j.appender.file.threshold=DEBUG

#log4j.logger.com.hazelcast=debug

#log4j.logger.com.hazelcast.cluster=debug
#log4j.logger.com.hazelcast.partition=debug
#log4j.logger.com.hazelcast.partition.InternalPartitionService=debug
#log4j.logger.com.hazelcast.nio=debug
#log4j.logger.com.hazelcast.hibernate=debug</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="other-network-configurations"><a class="anchor" href="#other-network-configurations"></a>Other Network Configurations</h3>
<div class="paragraph">
<p>All network related configurations are performed via the <code>network</code> element
in the Hazelcast XML configuration file or the class <code>NetworkConfig</code>
when using programmatic configuration. Following subsections describe the
available configurations that you can perform under the <code>network</code> element.</p>
</div>
<div class="sect3">
<h4 id="public-address"><a class="anchor" href="#public-address"></a>Public Address</h4>
<div class="paragraph">
<p><code>public-address</code> overrides the public address of a member. By default, a member
selects its socket address as its public address. But behind a network address translation (NAT),
two endpoints (members) may not be able to see/access each other.
If both members set their public addresses to their defined addresses on NAT,
then that way they can communicate with each other. In this case, their public addresses
are not an address of a local network interface but a virtual address defined by NAT.
It is optional to set and useful when you have a private cloud.
Note that, the value for this element should be given in the format <strong><code>host IP address:port number</code></strong>.
See the following examples.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;public-address&gt;11.22.33.44:5555&lt;/public-address&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    public-address: 11.22.33.44:5555</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.getNetworkConfig()
    .setPublicAddress( "11.22.33.44:5555" );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="port"><a class="anchor" href="#port"></a>Port</h4>
<div class="paragraph">
<p>You can specify the ports that Hazelcast uses to communicate between cluster members.
Its default value is <code>5701</code>. The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;port port-count="20" auto-increment="true"&gt;5701&lt;/port&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    port:
      auto-increment: true
      port-count: 20
      port: 5701</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.getNetworkConfig().setPort( 5701 )
    .setPortAutoIncrement( true ).setPortCount( 20 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>According to the above example, Hazelcast tries to find free ports between 5701 and 5720.</p>
</div>
<div class="paragraph">
<p><code>port</code> has the following attributes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>port-count</code>: By default, Hazelcast tries 100 ports to bind. Meaning that,
if you set the value of port as 5701, as members are joining to the cluster,
Hazelcast tries to find ports between 5701 and 5801. You can choose to change the
port count in the cases like having large instances on a single machine or
willing to have only a few ports to be assigned. The parameter <code>port-count</code>
is used for this purpose, whose default value is 100.</p>
</li>
<li>
<p><code>auto-increment</code>:  In some cases you may want to choose to use only one port.
In that case, you can disable the auto-increment feature of <code>port</code> by setting
<code>auto-increment</code> to <code>false</code>. The <code>port-count</code> attribute is not used when
auto-increment feature is disabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="outbound-ports"><a class="anchor" href="#outbound-ports"></a>Outbound Ports</h4>
<div class="paragraph">
<p>By default, Hazelcast lets the system pick up an ephemeral port during socket bind operation.
But security policies/firewalls may require you to restrict outbound ports to be
used by Hazelcast-enabled applications. To fulfill this requirement, you can configure
Hazelcast to use only defined outbound ports. The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;outbound-ports&gt;
            &lt;!-- ports between 33000 and 35000 --&gt;
            &lt;ports&gt;33000-35000&lt;/ports&gt;
            &lt;!-- comma separated ports --&gt;
            &lt;ports&gt;37000,37001,37002,37003&lt;/ports&gt;
            &lt;ports&gt;38000,38500-38600&lt;/ports&gt;
        &lt;/outbound-ports&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    outbound-ports:
      - 33000-35000
      - 37000,37001,37002,37003
      - 38000,38500-38600</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
NetworkConfig networkConfig = config.getNetworkConfig();
// ports between 35000 and 35100
networkConfig.addOutboundPortDefinition("35000-35100");
// comma separated ports
networkConfig.addOutboundPortDefinition("36001, 36002, 36003");
networkConfig.addOutboundPort(37000);
networkConfig.addOutboundPort(37001);
...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can use port ranges and/or comma separated ports.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As shown in the programmatic configuration, you use the method <code>addOutboundPort</code>
to add only one port. If you need to add a group of ports, then use the method <code>addOutboundPortDefinition</code>.</p>
</div>
<div class="paragraph">
<p>In the declarative configuration, the element <code>ports</code> can be used for both single and
multiple port definitions. When you set this element to  <code>0</code> or  <code>*</code>,
your operating system (not Hazelcast) selects a free port from the ephemeral range.</p>
</div>
</div>
<div class="sect3">
<h4 id="reuse-address"><a class="anchor" href="#reuse-address"></a>Reuse Address</h4>
<div class="paragraph">
<p>When you shutdown a cluster member, the server socket port goes into the
<code>TIME_WAIT</code> state for the next couple of minutes. If you start the member right after
shutting it down, you may not be able to bind it to the same port because it is in the
<code>TIME_WAIT</code> state. If you set the <code>reuse-address</code> element to <code>true</code>, the <code>TIME_WAIT</code> state
is ignored and you can bind the member to the same port again.</p>
</div>
<div class="paragraph">
<p>The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;reuse-address&gt;true&lt;/reuse-address&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    reuse-address: true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
NetworkConfig networkConfig = config.getNetworkConfig();

networkConfig.setReuseAddress( true );
...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="join"><a class="anchor" href="#join"></a>Join</h4>
<div class="paragraph">
<p>The <code>join</code> configuration element is used to discover Hazelcast members and enable them
to form a cluster. Hazelcast provides Auto Detection, Multicast, TCP/IP, AWS, Kubernetes, Azure, GCP, Eureka, and more.
These mechanisms are explained the <a href="#discovery-mechanisms">Discovery Mechanisms section</a>.
This section describes all the sub-elements and attributes of <code>join</code> element.
The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;join&gt;
            &lt;auto-detection enabled="true" /&gt;
            &lt;multicast enabled="false"&gt;
                &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;
                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
                &lt;multicast-time-to-live&gt;32&lt;/multicast-time-to-live&gt;
                &lt;multicast-timeout-seconds&gt;2&lt;/multicast-timeout-seconds&gt;
                &lt;trusted-interfaces&gt;
                    &lt;interface&gt;192.168.1.102&lt;/interface&gt;
                &lt;/trusted-interfaces&gt;
            &lt;/multicast&gt;
            &lt;tcp-ip enabled="false"&gt;
                &lt;required-member&gt;192.168.1.104&lt;/required-member&gt;
                &lt;member&gt;192.168.1.104&lt;/member&gt;
                &lt;members&gt;192.168.1.105,192.168.1.106&lt;/members&gt;
            &lt;/tcp-ip&gt;
            &lt;aws enabled="false"&gt;
                &lt;access-key&gt;my-access-key&lt;/access-key&gt;
                &lt;secret-key&gt;my-secret-key&lt;/secret-key&gt;
                &lt;region&gt;us-west-1&lt;/region&gt;
                &lt;host-header&gt;ec2.amazonaws.com&lt;/host-header&gt;
                &lt;security-group-name&gt;hazelcast-sg&lt;/security-group-name&gt;
                &lt;tag-key&gt;type&lt;/tag-key&gt;
                &lt;tag-value&gt;hz-members&lt;/tag-value&gt;
            &lt;/aws&gt;
            &lt;discovery-strategies&gt;
                &lt;discovery-strategy ... /&gt;
            &lt;/discovery-strategies&gt;
        &lt;/join&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    join:
      auto-detection:
        enabled: true
      multicast:
        enabled: false
        multicast-group: 224.2.2.3
        multicast-port: 54327
        multicast-time-to-live: 32
        multicast-timeout-seconds: 2
        trusted-interfaces:
          - 192.168.1.102
      tcp-ip:
        enabled: false
        required-member: 192.168.1.104
        member-list:
          - 192.168.1.104
          - 192.168.1.105,192.168.1.106
      aws:
        enabled: false
        access-key: my-access-key
        secret-key: my-secret-key
        region: us-west-1
        host-header: ec2.amazonaws.com
        security-group-name: hazelcast-sg
        tag-key: type
        tag-value: hz-nodes
      discovery-strategies:
        discovery-strategy:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
NetworkConfig network = config.getNetworkConfig();
JoinConfig join = network.getJoin();
join.getTcpIpConfig().addMember( "10.45.67.32" ).addMember( "10.45.67.100" )
            .setRequiredMember( "192.168.10.100" ).setEnabled( true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>join</code> element has the following sub-elements and attributes.</p>
</div>
<div class="sect4">
<h5 id="auto-detection-element"><a class="anchor" href="#auto-detection-element"></a>auto-detection element</h5>
<div class="paragraph">
<p>The <code>auto-detection</code> element includes the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Enables Hazelcast Auto Detection, <code>true</code> by default.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="multicast-element"><a class="anchor" href="#multicast-element"></a>multicast element</h5>
<div class="paragraph">
<p>The <code>multicast</code> element includes parameters to fine tune the multicast join mechanism.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether the multicast discovery is enabled or not, <code>true</code> or <code>false</code>.</p>
</li>
<li>
<p><code>multicast-group</code>: The multicast group IP address. Specify it when you want to create
clusters within the same network. Values can be between 224.0.0.0 and 239.255.255.255.
Its default value is 224.2.2.3.</p>
</li>
<li>
<p><code>multicast-port</code>: The multicast socket port that the Hazelcast member listens to and
sends discovery messages through. Its default value is 54327.</p>
</li>
<li>
<p><code>multicast-time-to-live</code>: Time-to-live value for multicast packets sent out to control
the scope of multicasts. See more information <a href="http://www.tldp.org/HOWTO/Multicast-HOWTO-2.html">here</a>.</p>
</li>
<li>
<p><code>multicast-timeout-seconds</code>: Only when the members are starting up, this timeout (in seconds)
specifies the period during which a member waits for a multicast response from another member.
For example, if you set it as 60 seconds, each member waits for 60 seconds until a leader
member is selected. Its default value is 2 seconds.</p>
</li>
<li>
<p><code>trusted-interfaces</code>: Includes IP addresses of trusted members. When a member wants to
join to the cluster, its join request is rejected if it is not a trusted member. You can
give an IP addresses range using the wildcard (*) on the last digit of IP address,
e.g., 192.168.1.* or 192.168.1.100-110.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Multicast mechanism is not recommended for production since UDP is often blocked
in production environments and other join mechanisms are more definite.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="tcp-ip-element"><a class="anchor" href="#tcp-ip-element"></a>tcp-ip element</h5>
<div class="paragraph">
<p>The <code>tcp-ip</code> element includes parameters to fine tune the TCP/IP join mechanism.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether the TCP/IP discovery is enabled or not.
Values can be <code>true</code> or <code>false</code>.</p>
</li>
<li>
<p><code>required-member</code>: IP address of the required member. Cluster is only
formed if the member with this IP address is found.</p>
</li>
<li>
<p><code>member</code>: IP address(es) of one or more well known members. Once members
are connected to these well known ones, all member addresses are communicated
with each other. You can also give comma separated IP addresses using the <code>members</code> element.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>tcp-ip</code> element also accepts the <code>interface</code> parameter. See the
<a href="#interfaces">Interfaces element description</a>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>connection-timeout-seconds</code>: Defines the connection timeout in seconds.
This is the maximum amount of time Hazelcast is going to try to connect to a well
known member before giving up. Setting it to a too low value could mean that a
member is not able to connect to a cluster. Setting it to a too high value means
that member startup could slow down because of longer timeouts, for example when
a well known member is not up. Increasing this value is recommended if you have many
IPs listed and the members cannot properly build up the cluster. Its default value is 5 seconds.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aws-element"><a class="anchor" href="#aws-element"></a>aws element</h5>
<div class="paragraph">
<p>The <code>aws</code> element includes parameters to allow the members to form a cluster
on the Amazon EC2 and ECS environments.</p>
</div>
<div class="paragraph">
<p>For details, please check the
<a href="https://github.com/hazelcast/hazelcast-aws">Hazelcast AWS Discovery plugin documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="azure-element"><a class="anchor" href="#azure-element"></a>azure element</h5>
<div class="paragraph">
<p>The <code>azure</code> element includes parameters to allow the members to form a cluster on the Azure VM machines.</p>
</div>
<div class="paragraph">
<p>For details, please check the
<a href="https://github.com/hazelcast/hazelcast-azure">Hazelcast Azure Discovery plugin documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="gcp-element"><a class="anchor" href="#gcp-element"></a>gcp element</h5>
<div class="paragraph">
<p>The <code>gcp</code> element includes parameters to allow the members to form a cluster on the GCP Compute VM instances.</p>
</div>
<div class="paragraph">
<p>For details, please check the
<a href="https://github.com/hazelcast/hazelcast-gcp">Hazelcast GCP Discovery plugin documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="kubernetes-element"><a class="anchor" href="#kubernetes-element"></a>kubernetes element</h5>
<div class="paragraph">
<p>The <code>kubernetes</code> element includes parameters to allow the members to form a cluster on the Kubernetes environment.</p>
</div>
<div class="paragraph">
<p>For details, please check the
<a href="https://github.com/hazelcast/hazelcast-kubernetes">Hazelcast Kubernetes Discovery plugin documentation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="discovery-strategies-element"><a class="anchor" href="#discovery-strategies-element"></a>discovery-strategies element</h5>
<div class="paragraph">
<p>The <code>discovery-strategies</code> element configures internal or external discovery
strategies based on the Hazelcast Discovery SPI. For further information, see
the <a href="#discovery-spi">Discovery SPI section</a> and the vendor documentation of
the used discovery strategy.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="interfaces"><a class="anchor" href="#interfaces"></a>Interfaces</h4>
<div class="paragraph">
<p>You can specify which network interfaces that Hazelcast should use.
Servers mostly have more than one network interface, so you may want to list
the valid IPs. <strong>Range characters <code>"*"</code> and <code>"-"</code></strong> can be used for simplicity.
For instance, 10.3.10.* refers to IPs between 10.3.10.0 and 10.3.10.255.
Interface 10.3.10.4-18 refers to IPs between 10.3.10.4 and 10.3.10.18
(4 and 18 included). If network interface configuration is enabled
(it is disabled by default) and if Hazelcast cannot find a matching interface,
then it prints a message on the console and does not start on that member.</p>
</div>
<div class="paragraph">
<p>The following are example configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;interfaces enabled="true"&gt;
            &lt;interface&gt;10.3.16.*&lt;/interface&gt;
            &lt;interface&gt;10.3.10.4-18&lt;/interface&gt;
            &lt;interface&gt;192.168.1.3&lt;/interface&gt;
        &lt;/interfaces&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    interfaces:
      enabled: true
      interfaces:
        - 10.3.16.*
        - 10.3.10.4-18
        - 192.168.1.3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
NetworkConfig network = config.getNetworkConfig();
InterfacesConfig interfaceConfig = network.getInterfaces();
interfaceConfig.setEnabled( true )
            .addInterface( "192.168.1.3" );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ipv6-support"><a class="anchor" href="#ipv6-support"></a>IPv6 Support</h4>
<div class="paragraph">
<p>Hazelcast supports IPv6 addresses seamlessly (This support is switched
off by default, see the note at the end of this section).</p>
</div>
<div class="paragraph">
<p>All you need is to define IPv6 addresses or interfaces in the network
configuration. The only current limitation is that you cannot define
wildcard IPv6 addresses in the TCP/IP join configuration (<code>tcp-ip</code> element).
<a href="#interfaces">Interfaces</a> configuration does not have this limitation,
you can configure wildcard IPv6 interfaces in the same way as IPv4 interfaces.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;port auto-increment="true"&gt;5701&lt;/port&gt;
        &lt;join&gt;
            &lt;multicast enabled="false"&gt;
                &lt;multicast-group&gt;FF02:0:0:0:0:0:0:1&lt;/multicast-group&gt;
                &lt;multicast-port&gt;54327&lt;/multicast-port&gt;
            &lt;/multicast&gt;
            &lt;tcp-ip enabled="true"&gt;
                &lt;member&gt;[fe80::223:6cff:fe93:7c7e]:5701&lt;/member&gt;
                &lt;interface&gt;192.168.1.0-7&lt;/interface&gt;
                &lt;interface&gt;192.168.1.*&lt;/interface&gt;
                &lt;interface&gt;fe80:0:0:0:45c5:47ee:fe15:493a&lt;/interface&gt;
            &lt;/tcp-ip&gt;
        &lt;/join&gt;
        &lt;interfaces enabled="true"&gt;
            &lt;interface&gt;10.3.16.*&lt;/interface&gt;
            &lt;interface&gt;10.3.10.4-18&lt;/interface&gt;
            &lt;interface&gt;fe80:0:0:0:45c5:47ee:fe15:*&lt;/interface&gt;
            &lt;interface&gt;fe80::223:6cff:fe93:0-5555&lt;/interface&gt;
        &lt;/interfaces&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    port:
      auto-increment: true
      port: 5701
    join:
      multicast:
        enabled: false
        multicast-group: FF02:0:0:0:0:0:0:1
        multicast-port: 54327
      tcp-ip:
        enabled: true
        member: [fe80::223:6cff:fe93:7c7e]:5701
        interface: 192.168.1.0-7
        interface: 192.168.1.*
        interface: fe80:0:0:0:45c5:47ee:fe15:493a
    interfaces:
      enabled: true
      interfaces:
        - 10.3.16.*
        - 10.3.10.4-18
        - fe80:0:0:0:45c5:47ee:fe15:*
        - fe80::223:6cff:fe93:0-5555</code></pre>
</div>
</div>
<div class="paragraph">
<p>JVM has two system properties for setting the preferred protocol stack
(IPv4 or IPv6) as well as the preferred address family types (inet4 or inet6).
On a dual stack machine, IPv6 stack is preferred by default, you can change this
through the <code>java.net.preferIPv4Stack=&lt;true|false&gt;</code> system property. When querying
name services, JVM prefers IPv4 addresses over IPv6 addresses and returns an IPv4
address if possible. You can change this through <code>java.net.preferIPv6Addresses=&lt;true|false&gt;</code>
system property.</p>
</div>
<div class="paragraph">
<p>See also additional <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/net/ipv6_guide/" target="_blank" rel="noopener">details on IPv6 support in Java</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
IPv6 support has been switched off by default, since some platforms have issues
using the IPv6 stack. Some other platforms such as Amazon AWS have no support at all.
To enable IPv6 support, just set configuration property <code>hazelcast.prefer.ipv4.stack</code>
to <strong>false</strong>. See the <a href="#system-properties">System Properties appendix</a> for details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="member-address-provides-spi"><a class="anchor" href="#member-address-provides-spi"></a>Member Address Provider SPI</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This SPI is not intended to provide addresses of other cluster members with
which the Hazelcast instance forms a cluster. To do that, see the
<a href="#other-network-configurations">previous sections</a> above.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, Hazelcast chooses the public and bind address. You can influence on the
choice by defining a <code>public-address</code> in the configuration or by using other
properties mentioned above. In some cases, though, these properties are not
enough and the default address picking strategy chooses wrong addresses.
This may be the case when deploying Hazelcast in some cloud environments,
such as AWS, when using Docker or when the instance is deployed behind a NAT
and the <code>public-address</code> property is not enough (see the <a href="#public-address">Public Address section</a>).</p>
</div>
<div class="paragraph">
<p>In these cases, it is possible to configure the bind and public address
in a more advanced way. You can provide an implementation of the
<code>com.hazelcast.spi.MemberAddressProvider</code> interface which provides
the bind and public address. The implementation may then choose these
addresses in any way - it may read from a system property or file or
even invoke a web service to retrieve the public and private address.</p>
</div>
<div class="paragraph">
<p>The details of the implementation depend heavily on the environment in which
Hazelcast is deployed. As such, we now demonstrate how to configure Hazelcast
to use a simplified custom member address provider SPI implementation.
An example implementation is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static final class SimpleMemberAddressProvider implements MemberAddressProvider {
    @Override
    public InetSocketAddress getBindAddress() {
        // determine the address using some configuration, calling an API, ...
        return new InetSocketAddress(hostname, port);
    }

    @Override
    public InetSocketAddress getPublicAddress() {
        // determine the address using some configuration, calling an API, ...
        return new InetSocketAddress(hostname, port);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if the bind address port is <code>0</code> then it uses a port as configured
in the Hazelcast network configuration (see the <a href="#port">Port section</a>).
If the public address port is set to <code>0</code> then it broadcasts the same port that
it is bound to. If you wish to bind to any local interface, you may return
<code>new InetSocketAddress((InetAddress) null, port)</code> from the <code>getBindAddress()</code> address.</p>
</div>
<div class="paragraph">
<p>The following configuration examples contain properties that are provided to the
constructor of the provider class. If you do not provide any properties, the class
may have either a no-arg constructor or a constructor accepting a single
<code>java.util.Properties</code> instance. On the other hand, if you do provide properties
in the configuration, the class must have a constructor accepting a single
<code>java.util.Properties</code> instance.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;network&gt;
        &lt;member-address-provider enabled="true"&gt;
            &lt;class-name&gt;SimpleMemberAddressProvider&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="prop1"&gt;prop1-value&lt;/property&gt;
                &lt;property name="prop2"&gt;prop2-value&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/member-address-provider&gt;
        &lt;!-- other network configurations --&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    member-address-provider:
      enabled: true
      class-name: SimpleMemberAddressProvider
      properties:
        prop1: prop1-value
        prop2: prop2-value
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
MemberAddressProviderConfig memberAddressProviderConfig = config.getNetworkConfig().getMemberAddressProviderConfig();
memberAddressProviderConfig
      .setEnabled(true)
      .setClassName(MemberAddressProviderWithStaticProperties.class.getName());
Properties properties = memberAddressProviderConfig.getProperties();
properties.setProperty("prop1", "prop1-value");
properties.setProperty("prop2", "prop2-value");

config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);

// perform other configuration

Hazelcast.newHazelcastInstance(config);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="failure-detector-configuration"><a class="anchor" href="#failure-detector-configuration"></a>Failure Detector Configuration</h3>
<div class="paragraph">
<p>A failure detector is responsible to determine if a member in the cluster is
unreachable or crashed. The most important problem in failure detection is to
distinguish whether a member is still alive but slow or has crashed. But according
to the famous <a href="http://dl.acm.org/citation.cfm?doid=3149.214121" target="_blank" rel="noopener">FLP result</a>,
it is impossible to distinguish a crashed member from a slow one in an asynchronous
system. A workaround to this limitation is to use unreliable failure detectors.
An unreliable failure detector allows a member to suspect that others have failed,
usually based on liveness criteria but it can make mistakes to a certain degree.</p>
</div>
<div class="paragraph">
<p>Hazelcast has the following built-in failure detectors: Deadline Failure Detector
and Phi Accrual Failure Detector.</p>
</div>
<div class="paragraph">
<p>There is also a Ping Failure Detector, that, if enabled, works in parallel with
the above ones, but identifies
the failures on OSI Layer 3 (Network Layer). This detector is by default disabled.</p>
</div>
<div class="paragraph">
<p>Note that, Hazelcast also offers failure detectors for its Java client.
See the <a href="#java-client-failure-detectors">Client Failure Detectors section</a> for more information.</p>
</div>
<div class="sect3">
<h4 id="_deadline_failure_detector"><a class="anchor" href="#_deadline_failure_detector"></a>Deadline Failure Detector</h4>
<div class="paragraph">
<p><em>Deadline Failure Detector</em> uses an absolute timeout for missing/lost
heartbeats. After timeout, a member is considered as crashed/unavailable
and marked as suspected.</p>
</div>
<div class="paragraph">
<p><em>Deadline Failure Detector</em> has the following configuration properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.heartbeat.interval.seconds</code>: This is the interval at which
member heartbeat messages are sent to each other.</p>
</li>
<li>
<p><code>hazelcast.max.no.heartbeat.seconds</code>: This is the timeout which defines
when a cluster member is suspected because it has not sent any heartbeats.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use <em>Deadline Failure Detector</em>, the configuration property
<code>hazelcast.heartbeat.failuredetector.type</code> should be set to <code>"deadline"</code>.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.heartbeat.failuredetector.type"&gt;deadline&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.interval.seconds"&gt;5&lt;/property&gt;
        &lt;property name="hazelcast.max.no.heartbeat.seconds"&gt;120&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.heartbeat.failuredetector.type: deadline
    hazelcast.heartbeat.interval.seconds: 5
    hazelcast.max.no.heartbeat.seconds: 120</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
config.setProperty("hazelcast.heartbeat.failuredetector.type", "deadline");
config.setProperty("hazelcast.heartbeat.interval.seconds", "5");
config.setProperty("hazelcast.max.no.heartbeat.seconds", "120");
[...]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<em>Deadline Failure Detector</em> is the default failure detector in Hazelcast.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="phi-accrual-failure-detector"><a class="anchor" href="#phi-accrual-failure-detector"></a>Phi Accrual Failure Detector</h4>
<div class="paragraph">
<p>This is the failure detector based on
<a href="https://www.computer.org/csdl/proceedings/srds/2004/2239/00/22390066-abs.html" target="_blank" rel="noopener">The Phi Accrual Failure Detector' by Hayashibara et al.</a></p>
</div>
<div class="paragraph">
<p>Phi Accrual Failure Detectorkeeps track of the intervals between heartbeats
in a sliding window of time andmeasures the mean and variance of these
samples and calculates a value of suspicion level (Phi). The value ofphi
increases when the period since the last heartbeat gets longer.If the network
becomes slow or unreliable, the resulting mean and variance increase, there needs
to be a longer period for which no heartbeat is received before the member is suspected.</p>
</div>
<div class="paragraph">
<p>The <code>hazelcast.heartbeat.interval.seconds</code>and <code>hazelcast.max.no.heartbeat.seconds</code>
propertiesstill can be used as period of heartbeat messages and deadline of
heartbeat messages. Since <em>Phi Accrual Failure Detector</em> is adaptive to network
conditions, a much lower <code>hazelcast.max.no.heartbeat.seconds</code> can be defined than
<em>Deadline Failure Detector</em>'s timeout.</p>
</div>
<div class="paragraph">
<p>In addition to the above two properties, <em>Phi Accrual Failure Detector</em> has the
following configuration properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.heartbeat.phiaccrual.failuredetector.threshold</code>: This is the phi
threshold for suspicion. After calculated phi exceeds this threshold, a member
is considered as unreachable and marked as suspected. A low threshold allows to
detect member crashes/failures faster but can generate more mistakes and cause
wrong member suspicions. A high threshold generates fewer mistakes but is slower
to detect actual crashes/failures.</p>
<div class="paragraph">
<p><code>phi = 1</code> means likeliness that we will make a mistake is about <code>10%</code>. The likeliness
is about <code>1%</code> with <code>phi = 2</code>, <code>0.1%</code> with <code>phi = 3</code> and so on. Default phi threshold is 10.</p>
</div>
</li>
<li>
<p><code>hazelcast.heartbeat.phiaccrual.failuredetector.sample.size</code>: Number of samples
to keep for history. Its default value is 200.</p>
</li>
<li>
<p><code>hazelcast.heartbeat.phiaccrual.failuredetector.min.std.dev.millis</code>: Minimum
standard deviation to use for the normal distribution used when calculating phi.
Too low standard deviation might result in too much sensitivity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use <em>Phi Accrual Failure Detector</em>, configuration property
<code>hazelcast.heartbeat.failuredetector.type</code> should be set to <code>"phi-accrual"</code>.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;properties&gt;
        &lt;property name="hazelcast.heartbeat.failuredetector.type"&gt;phi-accrual&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.interval.seconds"&gt;1&lt;/property&gt;
        &lt;property name="hazelcast.max.no.heartbeat.seconds"&gt;60&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.phiaccrual.failuredetector.threshold"&gt;10&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.phiaccrual.failuredetector.sample.size"&gt;200&lt;/property&gt;
        &lt;property name="hazelcast.heartbeat.phiaccrual.failuredetector.min.std.dev.millis"&gt;100&lt;/property&gt;
    &lt;/properties&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  properties:
    hazelcast.heartbeat.failuredetector.type: phi-accrual
    hazelcast.heartbeat.interval.seconds: 1
    hazelcast.max.no.heartbeat.seconds: 60
    hazelcast.heartbeat.phiaccrual.failuredetector.sample.size: 200
    hazelcast.heartbeat.phiaccrual.failuredetector.min.std.dev.millis: 100</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = ...;
config.setProperty("hazelcast.heartbeat.failuredetector.type", "phi-accrual");
config.setProperty("hazelcast.heartbeat.interval.seconds", "1");
config.setProperty("hazelcast.max.no.heartbeat.seconds", "60");
config.setProperty("hazelcast.heartbeat.phiaccrual.failuredetector.threshold", "10");
config.setProperty("hazelcast.heartbeat.phiaccrual.failuredetector.sample.size", "200");
config.setProperty("hazelcast.heartbeat.phiaccrual.failuredetector.min.std.dev.millis", "100");
[...]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ping-failure-detector"><a class="anchor" href="#ping-failure-detector"></a>Ping Failure Detector</h4>
<div class="paragraph">
<p>The Ping Failure Detector may be configured in addition to one of Deadline and
Phi Accrual Failure Detectors. It operates at Layer 3 of the OSI protocol and
provides much quicker and more deterministic detection of hardware and other
lower level events. This detector may be configured to perform an extra check
after a member is suspected by one of the other detectors, or it can work in
parallel, which is the default. This way hardware and network level issues are
detected more quickly.</p>
</div>
<div class="paragraph">
<p>This failure detector is based on <code>InetAddress.isReachable()</code>.
When the JVM process has enough permissions to create RAW sockets, the
implementation chooses to rely on ICMP Echo requests. This is preferred.</p>
</div>
<div class="paragraph">
<p>If there are not enough permissions, it can be configured to fallback on
attempting a TCP Echo on port 7. In the latter case, both a successful
connection or an explicit rejection is treated as "Host is Reachable".
Or, it can be forced to use only RAW sockets. This is not preferred as
each call creates a heavy weight socket and moreover the Echo service is
typically disabled.</p>
</div>
<div class="paragraph">
<p>For the Ping Failure Detector to rely <strong>only</strong> on ICMP Echo requests,
there are some criteria that need to be met.</p>
</div>
<div class="sect4">
<h5 id="requirements-and-linuxunix-configuration"><a class="anchor" href="#requirements-and-linuxunix-configuration"></a>Requirements and Linux/Unix Configuration</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Supported OS: as of Java 1.8 only Linux/Unix environments are supported</strong>.
This detector relies on ICMP, i.e., the protocol behind the <code>ping</code> command.
It tries to issue the ping attempts periodically, and their responses are used
to determine the reachability of the remote member. However, you cannot simply
create an ICMP Echo Request because these type of packets do not rely on any of
the preexisting transport protocols such as TCP. In order to create such a request,
you must have the privileges to create RAW sockets (see <a href="https://linux.die.net/man/7/raw" target="_blank" rel="noopener">https://linux.die.net/man/7/raw</a>).
Most operating systems allow this to the root users, however Unix based ones
are more flexible and allow the use of custom privileges per process
instead of requiring root access. Therefore, this detector is supported only on Linux.</p>
</li>
<li>
<p><strong>The Java executable must have the <code>cap_net_raw</code> capability.</strong> As described in
the above requirement, on Linux, you have the ability to define extra capabilities
to a single process, which would allow the process to interact with the RAW sockets.
This interaction is achieved via the capability <code>cap_net_raw</code>
(see <a href="https://linux.die.net/man/7/capabilities" target="_blank" rel="noopener">https://linux.die.net/man/7/capabilities</a>).
To enable this capability run the following command:</p>
<div class="paragraph">
<p><code>sudo setcap cap_net_raw=+ep &lt;JDK_HOME&gt;/jre/bin/java</code></p>
</div>
</li>
<li>
<p><strong>When running with custom capabilities, the dynamic linker on Linux rejects
loading the libs from untrusted paths.</strong> Since you have now <code>cap_net_raw</code> as a
custom capability for a process, it becomes suspicious to the dynamic linker
and throws an error: <code>java: error while loading shared libraries: libjli.so:
cannot open shared object file: No such file or directory</code></p>
<div class="ulist">
<ul>
<li>
<p>To overcome this rejection, the <code>&lt;JDK_HOME&gt;/jre/lib/amd64/jli/</code> path needs
to be added in the <code>ld.conf</code>. Run the following command to do this:
<code>echo "&lt;JDK_HOME&gt;/jre/lib/amd64/jli/" &gt;&gt; /etc/ld.so.conf.d/java.conf &amp;&amp; sudo ldconfig</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>ICMP Echo Requests must not be blocked by the receiving hosts.</strong>
<code>/proc/sys/net/ipv4/icmp_echo_ignore_all</code> set to <code>0</code>.
Run the following command:</p>
<div class="paragraph">
<p><code>echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If any of the above criteria isn&#8217;t met, then the <code>isReachable</code>
always falls back on TCP Echo attempts on port 7.</p>
</div>
<div class="paragraph">
<p>To be able to use the Ping Failure Detector, you can configure it
using the <code>icmp</code> element in your Hazelcast IMDG declarative configuration
file, e.g., <code>hazelcast.xml</code>. An example is shown below:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;network&gt;
    ...
        &lt;failure-detector&gt;
            &lt;icmp enabled="true"&gt;
                &lt;timeout-milliseconds&gt;1000&lt;/timeout-milliseconds&gt;
                &lt;fail-fast-on-startup&gt;true&lt;/fail-fast-on-startup&gt;
                &lt;interval-milliseconds&gt;1000&lt;/interval-milliseconds&gt;
                &lt;max-attempts&gt;3&lt;/max-attempts&gt;
                &lt;parallel-mode&gt;true&lt;/parallel-mode&gt;
                &lt;ttl&gt;0&lt;/ttl&gt;
            &lt;/icmp&gt;
        &lt;/failure-detector&gt;
    &lt;/network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  network:
    failure-detector:
      icmp:
        enabled: true
        timeout-milliseconds: 1000
        fail-fast-on-startup: true
        interval-milliseconds: 1000
        max-attempts: 3
        parallel-mode: true
        ttl: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the element and attribute descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>: Specifies whether the legacy ICMP detection mode is enabled; works
cooperatively with the existing failure detector and only kicks-in after
a pre-defined period has passed with no heartbeats from a member.
Its default value is <code>false</code>.</p>
</li>
<li>
<p><code>parallel-mode</code>: Specifies whether the parallel ping detector is enabled;
works separately from the other detectors. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>timeout-milliseconds</code>: Number of milliseconds until a ping attempt
is considered failed if there was no reply. Its default value is <code>1000</code> milliseconds.</p>
</li>
<li>
<p><code>max-attempts</code>: Maximum number of ping attempts before
the member/node gets suspected by the detector. Its default value is <code>2</code>.</p>
</li>
<li>
<p><code>interval-milliseconds</code>: Interval, in milliseconds, between each ping
attempt. 1000ms (1 sec) is also the minimum interval allowed.
Its default value is <code>1000</code> milliseconds.</p>
</li>
<li>
<p><code>ttl</code>: Maximum number of hops the packets should
go through. Its default value is <code>0</code>.</p>
</li>
<li>
<p><code>fail-fast-on-startup</code>: Specifies whether the cluster member fails to start
if it is unable to action an ICMP ping command when ICMP is enabled. Failure
is usually due to OS level restrictions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the above example configuration, the Ping detector attempts 3 pings, one every second and
waits up to 1 second for each to complete. If after 3 seconds, there was no successful
ping, the member gets suspected.</p>
</div>
<div class="paragraph">
<p>To enforce the <a href="#requirements-and-linuxunix-configuration">Requirements</a>, the property
<code>hazelcast.icmp.echo.fail.fast.on.startup</code> can also be set to <code>true</code>, in which case,
if any of the requirements isn&#8217;t met, Hazelcast fails to start.</p>
</div>
<div class="paragraph">
<p>Below is a summary table of all possible configuration combinations
of the ping failure detector.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Ping Failure Detector Possible Configuration Combinations</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 30%;">
<col style="width: 20%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ICMP</th>
<th class="tableblock halign-left valign-top">Parallel</th>
<th class="tableblock halign-left valign-top">Fail-Fast</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Linux</th>
<th class="tableblock halign-left valign-top">Windows</th>
<th class="tableblock halign-left valign-top">macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completely disabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Legacy ping mode. This works hand-to-hand with the OSI Layer 7 failure
detector (see. phi or deadline in the sections above). Ping in this mode
only kicks in after a period when there are no heartbeats received, in which
case the remote Hazelcast member is pinged up to a configurable count of attempts.
If all those attempts fail, the member gets suspected. You can configure this
attempt count using the <code>max-attempts</code> configuration element listed above.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parallel ping detector, works in parallel with the configured failure detector.
Checks periodically if members are live (OSI Layer 3) and suspects them immediately,
regardless of the other detectors.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  TCP Echo on port 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported  ICMP Echo if available - Falls back on TCP Echo on port 7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parallel ping detector, works in parallel with the configured failure detector.
Checks periodically if members are live (OSI Layer 3) and suspects them immediately,
regardless of the other detectors.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supported - Requires OS Configuration  Enforcing ICMP Echo if available -
No start up if not available</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not Supported</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not Supported - Requires root privileges</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_network_configuration"><a class="anchor" href="#_advanced_network_configuration"></a>Advanced Network Configuration</h3>
<div class="paragraph">
<p>With the default configuration, Hazelcast members use a single server socket for all kinds
of connections: cluster members, Hazelcast clients implementing the Open Binary Client
Protocol and HTTP protocol clients connect to a single server socket that handles all the protocols.</p>
</div>
<div class="paragraph">
<p>You can also configure the Hazelcast members with
separate server sockets using a different network configuration for different protocols.
This configuration scheme allows more flexibility when deploying Hazelcast as described
in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For security, it is possible to bind the member protocol server socket on a protected
internal network interface, while the client connections can be established on another
network interface accessible by the Hazelcast clients.</p>
</li>
<li>
<p>Different kinds of network connections can be established with different socket options.
For example varying send/receive window size to optimize the network usage, TLS for
connections over WAN while member-to-member connections may remain unencrypted, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the following example we introduce the advanced network configuration for a
member to listen for member-to-member connections on the default port <code>5701</code> while
listening for client connections on the port <code>9090</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        config.getAdvancedNetworkConfig().setEnabled(true);
        config.getAdvancedNetworkConfig().setClientEndpointConfig(
                new ServerSocketEndpointConfig().setPort(9090)
        );
        HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);
        System.out.println(instance.getCluster().getLocalMember().getAddressMap());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running this example prints something similar to the following output,
indicating that the member listens for the specified protocols on the respective configured ports:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{EndpointQualifier{type='CLIENT'}=[10.212.134.156]:9090, EndpointQualifier{type='MEMBER'}=[10.212.134.156]:5701}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network enabled="true"&gt;
        &lt;member-server-socket-endpoint-config&gt;
            &lt;port&gt;5701&lt;/port&gt;
        &lt;/member-server-socket-endpoint-config&gt;
        &lt;client-server-socket-endpoint-config&gt;
            &lt;port&gt;9090&lt;/port&gt;
        &lt;/client-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    enabled: true
    member-server-socket-endpoint-config:
      port:
        - 5701
    client-server-socket-endpoint-config:
      port:
        - 9090</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_cluster_members_for_advanced_network_configuration"><a class="anchor" href="#_setting_up_cluster_members_for_advanced_network_configuration"></a>Setting Up Cluster Members for Advanced Network Configuration</h4>
<div class="paragraph">
<p>Advanced network configuration and single-socket network configuration are
mutually exclusive: either an enabled <code>AdvancedNetworkConfig</code> or the <code>NetworkConfig</code>
object is used to configure a member&#8217;s networking, including the joiner, discovery,
failure detectors, etc. as described in the previous sections of this chapter.</p>
</div>
<div class="paragraph">
<p>You cannot define both elements in the declarative configuration, i.e., the <code>network</code>
and <code>advanced-network</code> elements cannot be configured at the same time. In the
programmatic configuration, an enabled <code>AdvancedNetworkConfig</code> takes precedence over
the <code>NetworkConfig</code>. <code>AdvancedNetworkConfig</code> is disabled by default, therefore the
unisocket member configuration under <code>NetworkConfig</code> is used in the default case.</p>
</div>
<div class="paragraph">
<p>When using the advanced network configuration, the following configurations are defined
member-wide:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Joiner and cluster discovery (Multicast, TCP/IP, AWS, Azure, GCP, Kubernetes, Eureka, etc.)</p>
</li>
<li>
<p><code>MemberAddressProvider</code> configuration</p>
</li>
<li>
<p>Failure detector configuration</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition to the above, the advanced network configuration allows the
configuration of multiple endpoints: each endpoint configuration applies for a
specific protocol, e.g., <code>MEMBER</code> and <code>CLIENT</code>. An additional optional identifier
can be configured to separate the configuration of multiple <code>WAN</code> protocol endpoints.</p>
</div>
<div class="paragraph">
<p>The supported protocols are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MEMBER</code>: A member server socket is required for Hazelcast to operate. The default
advanced network configuration defines a member endpoint configuration listening on
port 5701 (same as the single-socket Hazelcast member configuration).</p>
</li>
<li>
<p><code>CLIENT</code>: A single server socket handling the Hazelcast Open Binary Client Protocol
can be optionally configured. If no such endpoint is configured, then the clients will
not be able to connect to the Hazelcast member.</p>
</li>
<li>
<p><code>REST</code>: A REST server socket is optional.</p>
</li>
<li>
<p><code>MEMCACHE</code>: When accessing a Hazelcast cluster over the Memcache text protocol, an
endpoint listening to <code>MEMCACHE</code> protocol must be defined.</p>
</li>
<li>
<p><code>WAN</code>: Multiple WAN endpoint configurations can be defined to determine the network
settings of outgoing connections (from the members of a source cluster to the target
WAN cluster members) or to establish server sockets on which a target WAN member can
listen for the incoming connections from the source cluster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_server_socket_endpoint_configuration"><a class="anchor" href="#_server_socket_endpoint_configuration"></a>Server Socket Endpoint Configuration</h4>
<div class="paragraph">
<p>The server socket endpoint configuration is common for all protocols. The elements
comprising a server socket endpoint configuration are identical to their single-socket
network configuration counterparts.</p>
</div>
<div class="paragraph">
<p>The following declarative configuration example includes all the common server
socket endpoint elements:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
   ...
   &lt;advanced-network enabled="true"&gt;
       &lt;member-server-socket-endpoint-config&gt;
           &lt;port auto-increment="true" port-count="100"&gt;5701&lt;/port&gt;
           &lt;outbound-ports&gt;
               &lt;ports&gt;33000-35000&lt;/ports&gt;
               &lt;ports&gt;37000,37001,37002,37003&lt;/ports&gt;
               &lt;ports&gt;38000,38500-38600&lt;/ports&gt;
           &lt;/outbound-ports&gt;
           &lt;interfaces enabled="true"&gt;
               &lt;interface&gt;10.10.1.*&lt;/interface&gt;
           &lt;/interfaces&gt;
           &lt;ssl enabled="true"&gt;
               &lt;factory-class-name&gt;com.hazelcast.examples.MySSLContextFactory&lt;/factory-class-name&gt;
               &lt;properties&gt;
                   &lt;property name="foo"&gt;bar&lt;/property&gt;
               &lt;/properties&gt;
           &lt;/ssl&gt;
           &lt;symmetric-encryption&gt;
               &lt;algorithm&gt;ALGO&lt;/algorithm&gt;
               &lt;salt&gt;SALT&lt;/salt&gt;
               &lt;password&gt;PASS&lt;/password&gt;
               &lt;iteration-count&gt;10000&lt;/iteration-count&gt;
           &lt;/symmetric-encryption&gt;
           &lt;socket-interceptor enabled="true"&gt;
               &lt;class-name&gt;com.hazelcast.examples.MySocketInterceptor&lt;/class-name&gt;
               &lt;properties&gt;
                   &lt;property name="foo"&gt;bar&lt;/property&gt;
               &lt;/properties&gt;
           &lt;/socket-interceptor&gt;
           &lt;socket-options&gt;
               &lt;buffer-direct&gt;true&lt;/buffer-direct&gt;
               &lt;tcp-no-delay&gt;true&lt;/tcp-no-delay&gt;
               &lt;keep-alive&gt;true&lt;/keep-alive&gt;
               &lt;connect-timeout-seconds&gt;64&lt;/connect-timeout-seconds&gt;
               &lt;send-buffer-size-kb&gt;25&lt;/send-buffer-size-kb&gt;
               &lt;receive-buffer-size-kb&gt;33&lt;/receive-buffer-size-kb&gt;
               &lt;linger-seconds&gt;99&lt;/linger-seconds&gt;
           &lt;/socket-options&gt;
           &lt;public-address&gt;dummy&lt;/public-address&gt;
           &lt;reuse-address&gt;true&lt;/reuse-address&gt;
        &lt;/member-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network
    enabled: true
    member-server-socket-endpoint-config:
    port:
      auto-increment: true
      port-count: 100
      port: 5701
    outbound-ports:
      - 33000-35000
      - 37000,37001,37002,37003
      - 38000,38500-38600
    interfaces:
      enabled: true
      interfaces:
        - 10.10.1.*
    ssl:
      enabled: true
      factory-class-name: com.hazelcast.examples.MySSLContextFactory
      properties:
        foo: bar
    symmetric-encryption:
      algorithm: ALGO
      salt: SALT
      password: PASS
      iteration-count: 10000
    socket-interceptor:
      enabled: true
      class-name: com.hazelcast.examples.MySocketInterceptor
      properties:
        foo: bar
    socket-options:
      buffer-direct: true
      tcp-no-delay: true
      keep-alive: true
      connect-timeout-seconds: 64
      send-buffer-size-kb: 25
      receive-buffer-size-kb: 33
      linger-seconds: 99
    public-address: dummy
    reuse-address: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using the declarative configuration, specific element names introduce the
server socket endpoint configuration for each protocol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>member-server-socket-endpoint-config</code> for <code>MEMBER</code> protocol</p>
</li>
<li>
<p><code>client-server-socket-endpoint-config</code> for <code>CLIENT</code> protocol</p>
</li>
<li>
<p><code>rest-server-socket-endpoint-config</code> for <code>REST</code> endpoint</p>
</li>
<li>
<p><code>memcache-server-socket-endpoint-config</code> for <code>MEMCACHE</code> endpoint</p>
</li>
<li>
<p><code>wan-server-socket-endpoint-config</code> for <code>WAN</code> endpoints</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using the programmatic configuration, corresponding methods set the
respective server socket endpoint configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getAdvancedNetworkConfig().setMemberEndpointConfig(
                new ServerSocketEndpointConfig()
                    .setPort(5701)
                    .setPortAutoIncrement(false)
                    .setSSLConfig(new SSLConfig())
                    .setReuseAddress(true)
                    .setSocketTcpNoDelay(true)
        );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_rest_server_socket_endpoint_configuration"><a class="anchor" href="#_setting_up_rest_server_socket_endpoint_configuration"></a>Setting Up REST Server Socket Endpoint Configuration</h4>
<div class="paragraph">
<p>In addition to the common server socket configuration described above, the REST
endpoint configuration includes certain additional elements which are used to
enable/disable the REST functionality groups.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getAdvancedNetworkConfig().setRestEndpointConfig(
                new RestServerEndpointConfig()
                    .setPort(8080)
                    .setPortAutoIncrement(false)
                    .enableGroups(WAN, CLUSTER_READ, HEALTH_CHECK)
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network enabled="true"&gt;
        &lt;rest-server-socket-endpoint-config&gt;
            &lt;port auto-increment="false"&gt;8080&lt;/port&gt;
            &lt;endpoint-groups&gt;
                &lt;endpoint-group name="WAN" enabled="true"/&gt;
                &lt;endpoint-group name="CLUSTER_READ" enabled="true"/&gt;
                &lt;endpoint-group name="HEALTH_CHECK" enabled="true"/&gt;
            &lt;/endpoint-groups&gt;
        &lt;/rest-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    enabled: true
    rest-server-socket-endpoint-config:
      port:
        auto-increment: false
        port: 8080
      endpoint-groups:
        WAN:
          enabled: true
        CLUSTER_READ:
          enabled: true
        HEALTH_CHECK:
          enabled: true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_wan_endpoints_configuration"><a class="anchor" href="#_setting_up_wan_endpoints_configuration"></a>Setting Up WAN Endpoints Configuration</h4>
<div class="paragraph">
<p>Multiple WAN endpoint configurations can be defined to configure the outgoing
connections and server sockets, depending on the role of the member in the WAN
replication. The configuration examples are provided in the following sections for
both active and passive side of the WAN replication.</p>
</div>
<div class="sect4">
<h5 id="_configuring_the_wan_active_side"><a class="anchor" href="#_configuring_the_wan_active_side"></a>Configuring the WAN Active Side</h5>
<div class="paragraph">
<p>The members on the active cluster initiate connections to the target cluster members,
so there is no need to create a server socket. A plain <code>EndpointConfig</code> is created that
supplies the configuration for the client side of connections that the active members
will create:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getAdvancedNetworkConfig().addWanEndpointConfig(
                new EndpointConfig().setName("tokyo")
                        .setSSLConfig(new SSLConfig()
                                            .setEnabled(true)
                                            .setFactoryClassName("com.hazelcast.examples.MySSLContextFactory")
                                            .setProperty("foo", "bar"))
        );
        WanReplicationConfig wanReplicationConfig = new WanReplicationConfig();
        WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        			.setEndpoint("tokyo")
        			.setTargetEndpoints("tokyo.hazelcast.com:8765");
        wanReplicationConfig.addBatchReplicationPublisherConfig(publisherConfig);
        config.addWanReplicationConfig(wanReplicationConfig);

        config.getMapConfig("customers").setWanReplicationRef(
                new WanReplicationRef("replicate-to-tokyo", "com.company.MergePolicy", emptyList(), false)
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network enabled="true"&gt;
        &lt;wan-endpoint-config name="tokyo"&gt;
            &lt;ssl enabled="true"&gt;
                &lt;factory-class-name&gt;com.hazelcast.examples.MySSLContextFactory&lt;/factory-class-name&gt;
                &lt;properties&gt;
                    &lt;property name="endpoints"&gt;tokyo.example.com:11010&lt;/property&gt;
                &lt;/properties&gt;
            &lt;/ssl&gt;
        &lt;/wan-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
    &lt;wan-replication name="replicate-to-tokyo"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;clusterB&lt;/cluster-name&gt;
            &lt;target-endpoints&gt;...&lt;/target-endpoints&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
    &lt;map name="customer"&gt;
        &lt;wan-replication-ref name="replicate-to-tokyo"&gt;
            &lt;merge-policy&gt;...&lt;/merge-policy&gt;
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    enabled: true
    wan-endpoint-config:
      endpoint-tokyo:
        ssl:
          enabled: true
          factory-class-name: com.hazelcast.examples.MySSLContextFactory
          properties:
            endpoints: tokyo.example.com:11010
    wan-replication:
      replicate-to-tokyo:
        batch-publisher:
          cluster-name: clusterB&lt;
          target-endpoints: ...
    map:
      customer:
        wan-replication-ref:
          replicate-to-tokyo:
            merge-policy-class-name: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wan-endpoint-config</code> element contains the same sub-elements as the
<code>member-server-socket-endpoint-config</code> element described above except <code>port</code>,
<code>public-address</code> and <code>reuse-address</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_the_wan_passive_side"><a class="anchor" href="#_configuring_the_wan_passive_side"></a>Configuring the WAN Passive Side</h5>
<div class="paragraph">
<p>On the passive cluster, a server socket is configured on the members to listen
for the incoming WAN connections, matching the network configuration (SSL configuration,
etc.) configured on the active side of the WAN replication.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        config.getAdvancedNetworkConfig().addWanEndpointConfig(
                new ServerSocketEndpointConfig()
                        .setName("tokyo")
                        .setPort(11010)
                        .setPortAutoIncrement(false)
                        .setSSLConfig(new SSLConfig()
                                .setEnabled(true)
                                .setFactoryClassName("com.hazelcast.examples.MySSLContextFactory")
                                .setProperty("foo", "bar")
                        ));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;advanced-network enabled="true"&gt;
        &lt;wan-server-socket-endpoint-config name="tokyo"&gt;
            &lt;port auto-increment="false"&gt;11010&lt;/port&gt;
            &lt;ssl enabled="true"&gt;
                &lt;factory-class-name&gt;com.hazelcast.examples.MySSLContextFactory&lt;/factory-class-name&gt;
                &lt;properties&gt;
                    &lt;property name="foo"&gt;bar&lt;/property&gt;
                &lt;/properties&gt;
            &lt;/ssl&gt;
        &lt;/wan-server-socket-endpoint-config&gt;
    &lt;/advanced-network&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  advanced-network:
    enabled: true
    wan-server-socket-endpoint-config:
      tokyo:
        port:
          auto-increment: false
          port: 11010
        ssl:
          enabled: true
          factory-class-name: com.hazelcast.examples.MySSLContextFactory
        properties:
          foo: bar</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_advanced_network_configuration_faq"><a class="anchor" href="#_advanced_network_configuration_faq"></a>Advanced Network Configuration FAQ</h4>
<div class="qlist qanda">
<ol>
<li>
<p><em>Can I multiplex protocols on a single advanced network endpoint? For example, can I use a single server socket to listen for <code>MEMBER</code> and <code>CLIENT</code> protocols?</em></p>
<p>No, each endpoint configuration that defines a server socket must bind to a different socket address.</p>
</li>
<li>
<p><em>Can I mix unisocket and advanced network members in the same cluster?</em></p>
<p>No, the results will be undefined.</p>
</li>
<li>
<p><em>Can I configure multiple server socket endpoints for the same protocol?</em></p>
<p>You can only configure multiple server socket endpoints for <code>WAN</code> protocol. For other protocols (<code>MEMBER</code>, <code>CLIENT</code>, <code>REST</code>, <code>MEMCACHE</code>), a single server socket can be configured.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<link rel="shortcut icon" href="http://hazelcast.com/images/favicon.png">
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/vendor/search.js" id="search-script" data-base-path="../../.." data-page-path="/hazelcast/4.1/deploy/setting_up_clusters.html"></script>
<script async src="../../../_/../search-index.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
