<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hazelcast Hazelcast Documentation</title>
    <link rel="canonical" href="https://JakeSCahill.github.io/hazelcast/4.1/deploy/network_partitioning.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-M267KFN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-M267KFN')</script>
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://JakeSCahill.github.io">Hazelcast Documentation</a>
        <div class="navbar-item">
          <input id="search-input" type="text" placeholder="Search docs">
        </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Hazelcast IMDG</a>
            <a class="navbar-item" href="#">Hazelcast Jet</a>
            <a class="navbar-item" href="#">Hazelcast Cloud</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Use cases</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Demos</a>
            <a class="navbar-item" href="#">GitHub</a>
            <a class="navbar-item" href="#">Community</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="hazelcast" data-version="4.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../hazelcast_overview.html">Hazelcast IMDG</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hazelcast_overview.html">Overview</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../get-started/getting_started.html">Get Started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started/glossary.html">Glossary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../develop/hazelcast_clients.html">Develop Solutions</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/jcache.html">JCache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/performance.html">Performance</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/serialization.html">Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/striim_cdc.html">Striim Hot Cache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/transactions.html">Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_query.html">Distributed Query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_sql.html">Distributed SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_events.html">Distributed Events</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_computing.html">Distributed Computing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="installing_upgrading.html">Deploy Clusters</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="starting_members_clients.html">Starting Members and Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="setting_up_clusters.html">Setting Up Clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="management.html">Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="simulator.html">Hazelcast Simulator</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="wan.html">WAN Replication</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="network_partitioning.html">Network Partitioning</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../migrate/migration_guides.html">Migrate</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../troubleshoot/common_exception_types.html">Troubleshooting</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../reference/faq.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/dds.html">Distributed data structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/system_properties.html">System properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/understanding_configuration.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/phone_homes.html">Phone homes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/hazelcast_plugins.html">Plugins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute/extending_hazelcast.html">Contribute</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/licenses.html">Licenses</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/revision_history.html">Documentation changes</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Hazelcast IMDG</span>
    <span class="version">4.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Hazelcast IMDG</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../hazelcast_overview.html">4.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Home</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../home/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../home/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../hazelcast_overview.html">Hazelcast IMDG</a></li>
    <li><a href="installing_upgrading.html">Deploy Clusters</a></li>
    <li><a href="network_partitioning.html">Network Partitioning</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a class="git" href="file:///C:/Users/Jake%20Cahill/Documents/code-playground/docs/hazelcast-docs/modules/deploy/pages/network_partitioning.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<div class="sect1">
<h2 id="_network_partitioning"><a class="anchor" href="#_network_partitioning"></a>Network Partitioning</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_split_brain_syndrome"><a class="anchor" href="#_split_brain_syndrome"></a>Split-Brain Syndrome</h3>
<div class="paragraph">
<p>In general, network partitioning is a network failure that causes
the members to split into multiple groups such that
a member in a group cannot communicate with members in other groups.
In a partition scenario, all sides of the original cluster operate independently
assuming members in other sides are failed. Network partitioning is also called as <em>Split-Brain Syndrome</em>.</p>
</div>
<div class="paragraph">
<p>Even though this communication failure is called as <em>network partitioning</em>,
in practice a process or an entire OS that&#8217;s suspending/pausing very long can cause
communication interruptions. If these interruptions take long enough time to
assume that the other side is crashed, the cluster splits into
multiple partitions and they start operating independently.
That&#8217;s why any communication failure/interruption long enough can be
classified as network partitioning.</p>
</div>
<div class="paragraph">
<p>Moreover, communication failures don&#8217;t have to be symmetrical.
A network failure can interrupt only one side of the channel or
a suspended process/member may not even observe the rest as crashed.
That kind of network partitioning can be called as <em>partial network partitioning</em>.
See <a href="#partial-network-partitions">Partial Network Partitions section</a> for more info.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dealing_with_network_partitions"><a class="anchor" href="#_dealing_with_network_partitions"></a>Dealing with Network Partitions</h3>
<div class="paragraph">
<p>Hazelcast handles network partitions using the following solutions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Split-brain protection: Split-brain protection could be used when
consistency is the major concern on a network partitioning.
It requires a minimum cluster size to keep a particular data structure available.
When cluster size is below the defined split-brain protection size,
then subsequent operations are rejected with a <code>SplitBrainProtectionException</code>.
See the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</li>
<li>
<p>Split-brain recovery (merge policies): Split-brain recovery is to
make data structures available and operational on both sides of a network partition,
and merge their data once the network partitioning problem is resolved.
See the <a href="#split-brain-recovery">Split-Brain Recovery section</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Split-brain recovery is also supported for
the data structures whose in-memory format is <code>NATIVE</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_split_brain_protection"><a class="anchor" href="#_split_brain_protection"></a>Split-Brain Protection</h3>
<div class="paragraph">
<p>Split-brain protection mechanism provided in Hazelcast protects
your cluster in case the number of cluster members drops below the specified one.
How to respond to a split-brain scenario depends on whether consistency of
data or availability of your application is of primary concern.
In either case, because a split-brain scenario is caused by
a network failure, you must initiate an effort to identify and
correct the network failure. Your cluster cannot be brought back to
steady state operation until the underlying network failure is fixed.
If consistency is your primary concern, you can use Hazelcast&#8217;s split-brain
protection feature.</p>
</div>
<div class="paragraph">
<p>This feature enables you to specify
the minimum cluster size required for operations to occur.
This is achieved by defining and configuring a <code>minimum-cluster-size</code> for the cluster.
If the cluster size is below this minimum value, the operations are rejected and
the rejected operations return a <code>SplitBrainProtectionException</code> to their callers.
Additionally, it is possible to configure this size with a user-defined
<code>SplitBrainProtectionFunction</code> which is consulted to determine there is no split-brain on
each cluster membership change.</p>
</div>
<div class="paragraph">
<p>Your application continues its operations on the remaining operating cluster.
Any application instances connected to the cluster with sizes below the minimum threshold
defined by the split-brain protection configuration receive exceptions which, depending on the programming and
monitoring setup, should generate alerts. The key point is that rather than
applications continuing in error with stale data, they are prevented from doing so.</p>
</div>
<div class="paragraph">
<p>Split-brain protection is supported for the following Hazelcast data structures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IMap (for Hazelcast 3.5 and higher versions)</p>
</li>
<li>
<p>Transactional Map (for Hazelcast 3.5 and higher versions)</p>
</li>
<li>
<p>ICache (for Hazelcast 3.5 and higher versions)</p>
</li>
<li>
<p>ILock (for Hazelcast 3.8 and higher versions)</p>
</li>
<li>
<p>IQueue (for Hazelcast 3.8 and higher versions)</p>
</li>
<li>
<p>IExecutorService, DurableExecutorService, IScheduledExecutorService,
MultiMap, ISet, IList, Ringbuffer, Replicated Map, Cardinality Estimator,
IAtomicLong, IAtomicReference, ISemaphore, ICountdownLatch
(for Hazelcast 3.10 and higher versions)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each data structure to be protected should have the configuration added to
it as explained in the <a href="#configuring-split-brain-protection">Configuring Split-Brain Protection section</a>.</p>
</div>
<div class="sect3">
<h4 id="_time_window_for_split_brain_protection"><a class="anchor" href="#_time_window_for_split_brain_protection"></a>Time Window for Split-Brain Protection</h4>
<div class="paragraph">
<p>Cluster membership is established and maintained by heartbeats.
A network partitioning presents some members as being unreachable.
While configurable, it is normally seconds or tens of seconds before
the cluster is adjusted to exclude unreachable members.
The cluster size is based on the currently understood number of members.</p>
</div>
<div class="paragraph">
<p>For this reason, there will be a time window between
the network partitioning and the application of split-brain protection.
Length of this window depends on the failure detector.
Given guarantee is, every member eventually detects
the failed members and rejects the operation on the data structure which
requires the split-brain protection.</p>
</div>
<div class="paragraph">
<p>Split-brain protection can be
configured with out-of-the-box <code>SplitBrainProtectionFunction</code>s which
determine whether there is a split-brain situation independent of the
cluster membership manager. These functions take advantage of the heartbeat
and other failure-detector information configured on
the Hazelcast members.</p>
</div>
<div class="paragraph">
<p>For more information, see the <a href="#consistency-and-replication-model">Consistency and Replication Model chapter</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_split_brain_protection"><a class="anchor" href="#_configuring_split_brain_protection"></a>Configuring Split-Brain Protection</h4>
<div class="paragraph">
<p>You can set up the split-brain protection configuration using either
declarative or programmatic mechanism.</p>
</div>
<div class="paragraph">
<p>Assume that you have a 7-member Hazelcast Cluster and you want to
set the minimum number of four members for the cluster to continue operating.
In this case, if a split-brain happens, the sub-clusters of sizes 1, 2 and 3 are
prevented from being used. Only the sub-cluster of four members is allowed to be used.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is preferable to have an odd-sized initial cluster size to prevent
a single network partitioning (split-brain) from creating two equal sized clusters.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_member_count_split_brain_protection"><a class="anchor" href="#_member_count_split_brain_protection"></a>Member Count Split-Brain Protection</h5>
<div class="paragraph">
<p>This type of split-brain protection function determines the presence of split-brain protection based on
the count of members in the cluster, as observed by the local member&#8217;s cluster
membership manager and is available since Hazelcast 3.5.
The following are map configurations for the example 7-member cluster scenario described above:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection name="splitBrainProtectionRuleWithFourMembers" enabled="true"&gt;
        &lt;minimum-cluster-size&gt;4&lt;/minimum-cluster-size&gt;
    &lt;/split-brain-protection&gt;
    &lt;map name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitBrainProtectionRuleWithFourMembers&lt;/split-brain-protection-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    splitBrainProtectionRuleWithFourMembers:
      enabled: true
      minimum-cluster-size: 4
  map:
    default:
      split-brain-protection-ref: splitBrainProtectionRuleWithFourMembers</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SplitBrainProtectionConfig splitBrainProtectionConfig = new SplitBrainProtectionConfig();
splitBrainProtectionConfig.setName("splitBrainProtectionRuleWithFourMembers")
 .setEnabled(true)
 .setMinimumClusterSize(4);

MapConfig mapConfig = new MapConfig();
mapConfig.setSplitBrainProtectionName("splitBrainProtectionRuleWithFourMembers");

Config config = new Config();
config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
config.addMapConfig(mapConfig);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_probabilistic_split_brain_protection_function"><a class="anchor" href="#_probabilistic_split_brain_protection_function"></a>Probabilistic Split-Brain Protection Function</h5>
<div class="paragraph">
<p>The probabilistic split-brain protection function uses a private instance of
<a href="#phi-accrual-failure-detector">Phi Accrual Cluster Failure Detector</a> which is
updated with member heartbeats and its parameters can be fine-tuned to
determine the count of live members in the cluster, independently of
the cluster&#8217;s membership manager.</p>
</div>
<div class="paragraph">
<p>This function has the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>acceptable-heartbeat-pause-millis</code>: Duration in milliseconds corresponding to
the number of potentially lost/delayed heartbeats that are accepted before
considering it to be an anomaly. This margin is important to be able to
survive sudden, occasional, pauses in heartbeat arrivals, due to
for example garbage collection or network drops.
The value must be in the [heartbeat interval , maximum no heartbeat interval] range,
otherwise Hazelcast does not start. Its default value is <code>60000</code> milliseconds.</p>
</li>
<li>
<p><code>suspicion-threshold</code>: Threshold for suspicion (Ï†) level.
A low threshold is prone to generate many wrong suspicions but
ensures a quick detection in the event of a real crash.
Conversely, a high threshold generates fewer mistakes but
needs more time to detect actual crashes. Its default value is <code>10</code>.</p>
</li>
<li>
<p><code>max-sample-size</code>: Number of samples to use for
calculation of mean and standard deviation of inter-arrival times.
Its default value is <code>200</code>.</p>
</li>
<li>
<p><code>heartbeat-interval-millis</code>: Bootstrap the stats with heartbeats that
corresponds to this duration in milliseconds, with a rather
high standard deviation (since environment is unknown in the beginning).
Its default value is <code>5000</code> milliseconds.</p>
</li>
<li>
<p><code>min-std-deviation-millis</code>: Minimum standard deviation (in milliseconds) to use for
the normal distribution used when calculating phi. Too low standard deviation might
result in too much sensitivity for sudden, but normal, deviations in heartbeat
inter arrival times. Its default value is <code>100</code> milliseconds.</p>
</li>
</ul>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection enabled="true" name="probabilistic-split-brain-protection"&gt;
        &lt;minimum-cluster-size&gt;3&lt;/minimum-cluster-size&gt;
        &lt;protect-on&gt;READ_WRITE&lt;/protect-on&gt;
        &lt;probabilistic-split-brain-protection acceptable-heartbeat-pause-millis="5000"
                max-sample-size="500" suspicion-threshold="10" /&gt;
    &lt;/split-brain-protection&gt;
    &lt;set name="split-brain-protected-set"&gt;
        &lt;split-brain-protection-ref&gt;probabilistic-split-brain-protection&lt;/split-brain-protection-ref&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    probabilistic-split-brain-protection:
      enabled: true
      minimum-cluster-size: 3
      protect-on: READ_WRITE
      probabilistic-split-brain-protection:
        acceptable-heartbeat-pause-millis: 5000
        max-sample-size: 500
        suspicion-threshold: 10
  set:
    split-brain-protected-set:
      split-brain-protection-ref: probabilistic-split-brain-protection</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SplitBrainProtectionConfig splitBrainProtectionConfig =
        SplitBrainProtectionConfig.newProbabilisticSplitBrainProtectionConfigBuilder("probabilist-splitBrainProtection", 3)
                .withAcceptableHeartbeatPauseMillis(5000)
                .withMaxSampleSize(500)
                .withSuspicionThreshold(10)
                .build();
splitBrainProtectionConfig.setProtectOn(SplitBrainProtectionOn.READ_WRITE);
SetConfig setConfig = new SetConfig("split-brain-protected-set");
setConfig.setSplitBrainProtectionName("probabilist-splitBrainProtection");
Config config = new Config();
config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
config.addSetConfig(setConfig);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_recently_active_split_brain_protection_function"><a class="anchor" href="#_recently_active_split_brain_protection_function"></a>Recently-Active Split-Brain Protection Function</h5>
<div class="paragraph">
<p>This function can be used to implement
a more conservative split-brain protection by requiring that
a heartbeat has been received from each member within a configurable
time window since now.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection enabled="true" name="recently-active-split-brain-protection"&gt;
        &lt;minimum-cluster-size&gt;4&lt;/minimum-cluster-size&gt;
        &lt;protect-on&gt;READ_WRITE&lt;/protect-on&gt;
        &lt;recently-active-split-brain-protection heartbeat-tolerance-millis="60000" /&gt;
    &lt;/split-brain-protection&gt;
    &lt;set name="split-brain-protected-set"&gt;
        &lt;split-brain-protection-ref&gt;recently-active-split-brain-protection&lt;/split-brain-protection-ref&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    recently-active-split-brain-protection:
      enabled: true
      minimum-cluster-size: 4
      protect-on: READ_WRITE
      recently-active-split-brain-protection:
        heartbeat-tolerance-millis: 60000
  set:
    split-brain-protected-set:
      split-brain-protection-ref: recently-active-split-brain-protection</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SplitBrainProtectionConfig splitBrainProtectionConfig =
        SplitBrainProtectionConfig.newRecentlyActiveSplitBrainProtectionConfigBuilder("recently-active-splitBrainProtection", 4, 60000)
                .build();
splitBrainProtectionConfig.setProtectOn(SplitBrainProtectionOn.READ_WRITE);
SetConfig setConfig = new SetConfig("split-brain-protected-set");
setConfig.setSplitBrainProtectionName("recently-active-splitBrainProtection");
Config config = new Config();
config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
config.addSetConfig(setConfig);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_split_brain_protection_configuration_reference"><a class="anchor" href="#_split_brain_protection_configuration_reference"></a>Split-Brain Protection Configuration Reference</h5>
<div class="paragraph">
<p>The split-brain protection configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>minimum-cluster-size</code>: Minimum number of members required in a cluster for
the cluster to remain in an operational state. If the number of
members is below the defined minimum at any time, the operations are
rejected and the rejected operations return a <code>SplitBrainProtectionException</code> to their callers.</p>
</li>
<li>
<p><code>protect-on</code>: Type of the cluster split-brain protection. Available values are READ, WRITE and READ_WRITE.</p>
</li>
<li>
<p><code>split-brain-protection-function-class-name</code>: Class name of a <code>SplitBrainProtectionFunction</code> implementation,
allows to configure split-brain protection with a custom split-brain protection function.
It cannot be used in conjunction with <code>probabilistic-split-brain-protection</code> or <code>recently-active-split-brain-protection</code>.</p>
</li>
<li>
<p><code>split-brain-protection-listeners</code>: Declaration of split-brain protection listeners which are
notified on split-brain protection status changes.</p>
</li>
<li>
<p><code>probabilistic-split-brain-protection</code>: Configures the split-brain protection with a probabilistic
protection function. It cannot be used in conjunction with <code>split-brain-protection-function-class-name</code> or
<code>recently-active-split-brain-protection</code>.</p>
</li>
<li>
<p><code>recently-active-split-brain-protection</code>: Configures the split-brain protection with a recently-active
protection function. It cannot be used in conjunction with <code>split-brain-protection-function-class-name</code>
or <code>probabilistic-split-brain-protection</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example configuration with custom SplitBrainProtectionFunction implementation</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package my.domain;

public class CustomSplitBrainProtectionFunction implements SplitBrainProtectionFunction {
        @Override
        public boolean apply(Collection&lt;Member&gt; members) {
            // implement split-brain detection logic here
        }
    }</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection enabled="true" name="member-count-split-brain-protection"&gt;
        &lt;protect-on&gt;READ_WRITE&lt;/protect-on&gt;
        &lt;minimum-cluster-size&gt;3&lt;/minimum-cluster-size&gt;
        &lt;split-brain-protection-function-class-name&gt;my.domain.CustomSplitBrainProtectionFunction&lt;/split-brain-protection-function-class-name&gt;
    &lt;/split-brain-protection&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    member-count-split-brain-protection:
      enabled: true
      protect-on: READ_WRITE
      minimum-cluster-size: 3
      split-brain-protection-function-class-name: my.domain.CustomSplitBrainProtectionFunction</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_split_brain_protection_listeners"><a class="anchor" href="#_configuring_split_brain_protection_listeners"></a>Configuring Split-Brain Protection Listeners</h4>
<div class="paragraph">
<p>You can register listeners to be notified about the split-brain protection results.
Split-brain protection listeners are local to the member where they are registered,
so they receive only events that occurred on that local member.</p>
</div>
<div class="paragraph">
<p>These listeners can be configured via declarative or programmatic configuration.
The following examples are such configurations.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;split-brain-protection name="splitBrainProtectionRuleWithFourMembers" enabled="true"&gt;
        &lt;minimum-cluster-size&gt;4&lt;/minimum-cluster-size&gt;
        &lt;split-brain-protection-listeners&gt;
            &lt;split-brain-protection-listener&gt;
               com.company.splitbrainprotection.FourMemberSplitBrainProtectionListener
            &lt;/split-brain-protection-listener&gt;
        &lt;/split-brain-protection-listeners&gt;
    &lt;/split-brain-protection&gt;
    &lt;map name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitBrainProtectionRuleWithFourMembers&lt;/split-brain-protection-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  split-brain-protection:
    splitBrainProtectionRuleWithFourMembers:
      enabled: true
      minimum-cluster-size: 4
      split-brain-protection-listener: com.company.splitbrainprotection.FourMemberSplitBrainProtectionListener
  map:
    default:
      split-brain-protection-ref: splitBrainProtectionRuleWithFourMembers</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SplitBrainProtectionListenerConfig listenerConfig = new SplitBrainProtectionListenerConfig();
// You can either directly set SplitBrainProtection listener implementation of your own
listenerConfig.setImplementation(new SplitBrainProtectionListener() {
    @Override
    public void onChange(SplitBrainProtectionEvent splitBrainProtectionEvent) {
        if (splitBrainProtectionEvent.isPresent()) {
            // handle SplitBrainProtection presence
        } else {
            // handle SplitBrainProtection absence
        }
    }
});
// Or you can give the name of the class that implements SplitBrainProtectionListener interface.
listenerConfig.setClassName("com.company.splitBrainProtection.ThreeMemberSplitBrainProtectionListener");

SplitBrainProtectionConfig splitBrainProtectionConfig = new SplitBrainProtectionConfig();
splitBrainProtectionConfig.setName("splitBrainProtectionRuleWithFourMembers")
					    .setEnabled(true)
					    .setMinimumClusterSize(4)
					    .addListenerConfig(listenerConfig);


MapConfig mapConfig = new MapConfig();
mapConfig.setSplitBrainProtectionName("splitBrainProtectionRuleWithFourMembers");

Config config = new Config();
config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
config.addMapConfig(mapConfig);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_querying_split_brain_protection_results"><a class="anchor" href="#_querying_split_brain_protection_results"></a>Querying Split-Brain Protection Results</h4>
<div class="paragraph">
<p>Split-brain protection service gives you the ability to
query split-brain protection results over the <code>SplitBrainProtection</code> instances.
These instances let you query the result of a particular split-brain protection.</p>
</div>
<div class="paragraph">
<p>The following is a <code>SplitBrainProtection</code> interface that you can interact with.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * {@link SplitBrainProtection} provides access to the current status of a split-brain protection.
 */
public interface SplitBrainProtection {
    /**
     * Returns true if the minimum cluster size is satisfied, otherwise false.
     *
     * @return boolean whether the minimum cluster size property is satisfied
     */
    boolean hasMinimumSize();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can retrieve the <code>SplitBrainProtection</code> instance as in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        String splitBrainProtectionName = "at-least-one-storage-member";
        SplitBrainProtectionConfig splitBrainProtectionConfig = new SplitBrainProtectionConfig();
        splitBrainProtectionConfig.setName(splitBrainProtectionName);
        splitBrainProtectionConfig.setEnabled(true);

        MapConfig mapConfig = new MapConfig();
        mapConfig.setSplitBrainProtectionName(splitBrainProtectionName);

        Config config = new Config();
        config.addSplitBrainProtectionConfig(splitBrainProtectionConfig);
        config.addMapConfig(mapConfig);

        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config);
        SplitBrainProtectionService splitBrainProtectionService = hazelcastInstance.getSplitBrainProtectionService();
        SplitBrainProtection splitBrainProtection = splitBrainProtectionService.getSplitBrainProtection(splitBrainProtectionName);

        boolean splitBrainProtectionPresence = splitBrainProtection.hasMinimumSize();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_split_brain_recovery"><a class="anchor" href="#_split_brain_recovery"></a>Split-Brain Recovery</h3>
<div class="paragraph">
<p>Hazelcast deploys a background task that periodically searches for split clusters.
When a split is detected, the side that will initiate the merge process is decided.
This decision is based on the cluster size; the smaller cluster, by
member count, merges into the bigger one. If they have an equal number of members,
then a hashing algorithm determines the merging cluster. When deciding the merging side,
both sides ensure that there&#8217;s no intersection in their member lists.</p>
</div>
<div class="paragraph">
<p>After the merging side is decided, the oldest cluster member of
the merging side initiates the cluster merge process by sending
merge instructions to the members in its cluster.</p>
</div>
<div class="paragraph">
<p>While recovering from partitioning, Hazelcast uses merge policies for
supported data structures to resolve data conflicts between split clusters.
A merge policy is a callback function to resolve conflicts between
the existing and merging data. Hazelcast provides an interface to be
implemented and also a selection of out-of-the-box policies.
Data structures without split-brain recovery support discarding the data from merging side.</p>
</div>
<div class="paragraph">
<p>Each member of the merging cluster:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>closes all of its network connections (detach from its cluster)</p>
</li>
<li>
<p>takes a snapshot of local data structures which support split-brain recovery</p>
</li>
<li>
<p>discards all data structure data</p>
</li>
<li>
<p>joins to the new cluster as lite member</p>
</li>
<li>
<p>sends merge operations to the new cluster from local snapshots.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see the <a href="#consistency-and-replication-model">Consistency and Replication Model chapter</a>.</p>
</div>
<div class="sect3">
<h4 id="_merge_policies"><a class="anchor" href="#_merge_policies"></a>Merge Policies</h4>
<div class="paragraph">
<p>Since Hazelcast 3.10 all merge policies implement
the unified interface <code>com.hazelcast.spi.SplitBrainMergePolicy</code>.
We provide the following out-of-the-box implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DiscardMergePolicy</code>: The entry from the smaller cluster is discarded.</p>
</li>
<li>
<p><code>ExpirationTimeMergePolicy</code>: The entry with the higher expiration time wins.</p>
</li>
<li>
<p><code>HigherHitsMergePolicy</code>: The entry with the higher number of hits wins.</p>
</li>
<li>
<p><code>HyperLogLogMergePolicy</code>: Specialized merge policy for the <code>CardinalityEstimator</code>,
which uses the default merge algorithm from HyperLogLog research, keeping
the maximum register value of the two given instances.</p>
</li>
<li>
<p><code>LatestAccessMergePolicy</code>: The entry with the latest access wins.</p>
</li>
<li>
<p><code>LatestUpdateMergePolicy</code>: The entry with the latest update wins.</p>
</li>
<li>
<p><code>PassThroughMergePolicy</code>: the entry from the smaller cluster wins.</p>
</li>
<li>
<p><code>PutIfAbsentMergePolicy</code>: The entry from the smaller cluster wins if
it doesn&#8217;t exist in the cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally you can develop a custom merge policy by implementing
the <code>SplitBrainMergePolicy</code> interface, as explained in the
<a href="#custom-merge-policies">Custom Merge Policies section</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_supported_data_structures"><a class="anchor" href="#_supported_data_structures"></a>Supported Data Structures</h4>
<div class="paragraph">
<p>The following data structures support split-brain recovery:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IMap</code> (including High-Density Memory Store backed IMap)</p>
</li>
<li>
<p><code>ICache</code> (including High-Density Memory Store backed IMap)</p>
</li>
<li>
<p><code>ReplicatedMap</code></p>
</li>
<li>
<p><code>MultiMap</code></p>
</li>
<li>
<p><code>IAtomicLong</code></p>
</li>
<li>
<p><code>IAtomicReference</code></p>
</li>
<li>
<p><code>IQueue</code></p>
</li>
<li>
<p><code>IList</code></p>
</li>
<li>
<p><code>ISet</code></p>
</li>
<li>
<p><code>RingBuffer</code></p>
</li>
<li>
<p><code>CardinalityEstimator</code></p>
</li>
<li>
<p><code>ScheduledExecutorService</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The statistic based out-of-the-box merge policies are only supported by
<code>IMap</code>, <code>ICache</code>, <code>ReplicatedMap</code> and <code>MultiMap</code>.
The <code>HyperLogLogMergePolicy</code> is supported by the <code>CardinalityEstimator</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Except the <code>CardinalityEstimator</code> data structure,
the default merge policy for all the Hazelcast data structures that
support split-brain recovery (listed above) is <code>PutIfAbsentMergePolicy</code>.
For the <code>CardinalityEstimator</code> data structure,
the default merge policy is <code>HyperLogLogMergePolicy</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See also the <a href="#merge-types">Merge Types section</a> for a complete overview of
supported merge types of each data structure. There is a config validation which
checks these constraints to provide fail-fast behavior for invalid configurations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the other data structures, e.g., <code>ISemaphore</code>, <code>ICountdownLatch</code> and <code>ILock</code>,
the instance from the smaller cluster is discarded during the split-brain recovery.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_merge_policies"><a class="anchor" href="#_configuring_merge_policies"></a>Configuring Merge Policies</h4>
<div class="paragraph">
<p>The merge policies are configured via a <code>MergePolicyConfig</code>, which can be set for
all supported data structures. The only exception is <code>ICache</code>, which just accepts
the merge policy classname (due to compatibility reasons with older Hazelcast clients).
For <code>ICache</code>, all other configurable merge parameters are the default values from <code>MergePolicyConfig</code>.</p>
</div>
<div class="paragraph">
<p>For custom merge policies you should set the full class name of your implementation as
the <code>merge-policy</code> configuration. For the out-of-the-box merge policies the simple classname is enough.</p>
</div>
<div class="sect4">
<h5 id="_declarative_configuration"><a class="anchor" href="#_declarative_configuration"></a>Declarative Configuration</h5>
<div class="paragraph">
<p>Here are examples how merge policies can be specified for various data structures:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;merge-policy batch-size="100"&gt;LatestUpdateMergePolicy&lt;/merge-policy&gt;
    &lt;/map&gt;

    &lt;replicatedmap name="default"&gt;
        &lt;merge-policy batch-size="100"&gt;org.example.merge.MyMergePolicy&lt;/merge-policy&gt;
    &lt;/replicatedmap&gt;

    &lt;multimap name="default"&gt;
        &lt;merge-policy batch-size="50"&gt;HigherHitsMergePolicy&lt;/merge-policy&gt;
    &lt;/multimap&gt;

    &lt;list name="default"&gt;
        &lt;merge-policy batch-size="500"&gt;org.example.merge.MyMergePolicy&lt;/merge-policy&gt;
    &lt;/list&gt;

    &lt;atomic-long name="default"&gt;
        &lt;merge-policy&gt;PutIfAbsentMergePolicy&lt;/merge-policy&gt;
    &lt;/atomic-long&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      merge-policy:
        batch-size: 100
        class-name: LatestUpdateMergePolicy
  replicatedmap:
    default:
      merge-policy:
        batch-size: 100
        class-name: org.example.merge.MyMergePolicy
  multimap:
    default:
      merge-policy:
        batch-size: 50
        class-name: HigherHitsMergePolicy
  list:
    default:
      merge-policy:
        batch-size: 500
        class-name: org.example.merge.MyMergePolicy
  atomic-long:
    default:
      merge-policy:
        class-name: PutIfAbsentMergePolicy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how merge policies are specified for <code>ICache</code> (it is the same configuration tag,
but lacks the support for additional attributes like <code>batch-size</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cache name="default"&gt;
        &lt;merge-policy&gt;org.example.merge.MyMergePolicy&lt;/merge-policy&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cache:
    default:
      merge-policy:
        class-name: org.example.merge.MyMergePolicy</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_programmatic_configuration"><a class="anchor" href="#_programmatic_configuration"></a>Programmatic Configuration</h5>
<div class="paragraph">
<p>Here are examples how merge policies can be specified for various data structures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        MergePolicyConfig mergePolicyConfig = new MergePolicyConfig()
                .setPolicy("org.example.merge.MyMergePolicy")
                .setBatchSize(100);

        MapConfig mapConfig = new MapConfig("default")
                .setMergePolicyConfig(mergePolicyConfig);

        ListConfig listConfig = new ListConfig("default")
                .setMergePolicyConfig(mergePolicyConfig);

        Config config = new Config()
                .addMapConfig(mapConfig)
                .addListConfig(listConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how merge policies are specified for <code>ICache</code> (you can only set the merge policy classname):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CacheConfig mapConfig = new CacheConfig()
  .setName("default")
  .setMergePolicy("org.example.merge.MyMergePolicy");

Config config = new Config()
  .addMapConfig(mapConfig);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_merge_policies"><a class="anchor" href="#_custom_merge_policies"></a>Custom Merge Policies</h4>
<div class="paragraph">
<p>To implement a custom merge policy you have to implement <code>com.hazelcast.spi.SplitBrainMergePolicy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SplitBrainMergePolicy&lt;V, T extends MergingValue&lt;V&gt;, R&gt;
    extends DataSerializable {

  R merge(T mergingValue, T existingValue);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MergingValue</code> is an interface which describes a merge type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please have in mind that <code>existingValue</code> can be <code>null</code>.
This happens when a data structure or key-based entry was just created in the smaller cluster.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_merge_types"><a class="anchor" href="#_merge_types"></a>Merge Types</h5>
<div class="paragraph">
<p>A merge type defines an attribute which is required by a merge policy and provided by a data structure.</p>
</div>
<div class="paragraph">
<p><code>MergingValue</code> is the main merge type, which is required by all merge policies and provided by
all data structures. It contains the value of the merged data in raw (in-memory storage) and
deserialized format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MergingValue&lt;V&gt; extends MergingView {

  V getValue();

  Object getRawValue();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MergingValue</code> extends <code>MergingView</code>, which is a marker interface extended by all provided merge types.</p>
</div>
<div class="paragraph">
<p>The most common extension of <code>MergingValue</code> is <code>MergingEntry</code>, which additionally provides the key in
raw (in-memory storage) and deserialized format (used by all key-based data structures like
<code>IMap</code> or <code>ICache</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MergingEntry&lt;K, V&gt; extends MergingValue&lt;V&gt; {

  K getKey();

  Object getRawKey();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition we have a bunch of specialized merge types, e.g., for provided statistics.
An example is <code>MergingHits</code>, which provides the hit counter of the merge data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MergingHits extends MergingView {

  long getHits();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>com.hazelcast.spi.merge.SplitBrainMergeTypes</code> contains composed interfaces,
which show the provided merge types and required merge policy return type for each data structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ReplicatedMapMergeTypes&lt;K, V&gt; extends MergingEntry&lt;K, V&gt;,
    MergingCreationTime, MergingHits, MergingLastAccessTime, MergingLastUpdateTime,
    MergingTTL {
}

public interface QueueMergeTypes&lt;V&gt; extends MergingValue&lt;Collection&lt;V&gt;&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ReplicatedMap</code> provides key/value merge data, with the creation time, access hits,
last access time, last update time and TTL. The return type of the merge policy is <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>The <code>IQueue</code> just provides a collection of values. The return type is also a <code>Collection&lt;Object&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The following is the full list of merge types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MergingValue</code>: Represents the value of the merged data.</p>
</li>
<li>
<p><code>MergingEntry</code>: Represents the key and value of the merged data.</p>
</li>
<li>
<p><code>MergingCreationTime</code>: Represents the creation time of the merging process.</p>
</li>
<li>
<p><code>MergingHits</code>: Represents the access hits of the merged data.</p>
</li>
<li>
<p><code>MergingLastAccessTime</code>: Represents the last time when the merged data is accessed.</p>
</li>
<li>
<p><code>MergingLastUpdateTime</code>: Represents the last time when the merged data is updated.</p>
</li>
<li>
<p><code>MergingTTL</code>: Represents the time-to-live value of the merged data.</p>
</li>
<li>
<p><code>MergingMaxIdle</code>: Represents the maximum idle timeout value of the merged data.</p>
</li>
<li>
<p><code>MergingCost</code>: Represents the memory costs for the merging process after a split-brain.</p>
</li>
<li>
<p><code>MergingVersion</code>: Represents the version of the merged data.</p>
</li>
<li>
<p><code>MergingExpirationTime</code>: Represents the expiration time of the merged data.</p>
</li>
<li>
<p><code>MergingLastStoredTime</code>: Represents the last stored time of the merged data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the following table shows the merge types provided by each data structure:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Merge Types</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Data Structure</th>
<th class="tableblock halign-left valign-top">Merge Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IMap</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
<li>
<p><code>MergingCreationTime</code></p>
</li>
<li>
<p><code>MergingHits</code></p>
</li>
<li>
<p><code>MergingLastAccessTime</code></p>
</li>
<li>
<p><code>MergingLastUpdateTime</code></p>
</li>
<li>
<p><code>MergingTTL</code></p>
</li>
<li>
<p><code>MergingMaxIdle</code></p>
</li>
<li>
<p><code>MergingCosts</code></p>
</li>
<li>
<p><code>MergingVersion</code></p>
</li>
<li>
<p><code>MergingExpirationTime</code></p>
</li>
<li>
<p><code>MergingLastStoredTime</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ICache</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
<li>
<p><code>MergingCreationTime</code></p>
</li>
<li>
<p><code>MergingHits</code></p>
</li>
<li>
<p><code>MergingLastAccessTime</code></p>
</li>
<li>
<p><code>MergingLastUpdateTime</code></p>
</li>
<li>
<p><code>MergingTTL</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReplicatedMap</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
<li>
<p><code>MergingCreationTime</code></p>
</li>
<li>
<p><code>MergingHits</code></p>
</li>
<li>
<p><code>MergingLastAccessTime</code></p>
</li>
<li>
<p><code>MergingLastUpdateTime</code></p>
</li>
<li>
<p><code>MergingTTL</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MultiMap</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
<li>
<p><code>MergingCreationTime</code></p>
</li>
<li>
<p><code>MergingHits</code></p>
</li>
<li>
<p><code>MergingLastAccessTime</code></p>
</li>
<li>
<p><code>MergingLastUpdateTime</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IQueue</code>, <code>ISet</code>, <code>IList</code>, <code>Ringbuffer</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingValue</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IAtomicLong</code>, <code>IAtomicReference</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingValue</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CardinalityEstimator</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ScheduledExecutorService</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>MergingEntry</code></p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following sections show various examples on how to implement
merge type interfaces for all data structures, specific merge types or a specific data structure.</p>
</div>
</div>
<div class="sect4">
<h5 id="_accessing_deserialized_values"><a class="anchor" href="#_accessing_deserialized_values"></a>Accessing Deserialized Values</h5>
<div class="paragraph">
<p><code>MergingValue.getRawValue()</code> and <code>MergingEntry.getRawKey()</code> always return
the data in the in-memory format of the data structure.
For some data structure like <code>IMap</code> this depends on your configuration.
Other data structure like <code>ISet</code> or <code>IList</code> always use the <code>BINARY</code> in-memory format.</p>
</div>
<div class="paragraph">
<p>If you need the deserialized key or value, you have to call <code>MergingValue.getValue()</code> or
<code>MergingEntry.getKey()</code>.
The deserialization is done lazily on that method call, since it&#8217;s quite expensive and
should be avoided if the result is not needed.
This also requires the deserialized classes to be on the classpath of the server.
Otherwise a <code>ClassNotFoundException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>This is an example which checks if the (deserialized) value of
the <code>mergingValue</code> or <code>existingValue</code> is an <code>Integer</code>.
If so it is merged, otherwise <code>null</code> is returned (which  removes the entry):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MergeIntegerValuesMergePolicy&lt;V&gt; implements SplitBrainMergePolicy&lt;V, MergingValue&lt;V&gt;, Object&gt; {

    @Override
    public Object merge(MergingValue&lt;V&gt; mergingValue, MergingValue&lt;V&gt; existingValue) {
        Object mergingUserValue = mergingValue.getValue();
        Object existingUserValue = existingValue == null ? null : existingValue.getValue();
        System.out.println("========================== Merging..."
                + "\n    mergingValue: " + mergingUserValue
                + "\n    existingValue: " + existingUserValue
                + "\n    mergingValue class: " + mergingUserValue.getClass().getName()
                + "\n    existingValue class: " + (existingUserValue == null ? "null" : existingUserValue.getClass().getName())
        );
        if (mergingUserValue instanceof Integer) {
            return mergingValue.getRawValue();
        }
        return null;
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For data structures like <code>ISet</code> or <code>ICollection</code> you need a merge policy, which supports collections:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MergeCollectionOfIntegerValuesMergePolicy
        implements SplitBrainMergePolicy&lt;Collection&lt;Object&gt;, MergingValue&lt;Collection&lt;Object&gt;&gt;, Collection&lt;Object&gt;&gt; {

    @Override
    public Collection&lt;Object&gt; merge(MergingValue&lt;Collection&lt;Object&gt;&gt; mergingValue,
                                    MergingValue&lt;Collection&lt;Object&gt;&gt; existingValue) {
        Collection&lt;Object&gt; result = new ArrayList&lt;&gt;();
        for (Object value : mergingValue.getValue()) {
            if (value instanceof Integer) {
                result.add(value);
            }
        }
        if (existingValue != null) {
            for (Object value : existingValue.getValue()) {
                if (value instanceof Integer) {
                    result.add(value);
                }
            }
        }
        return result;
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also combine both merge policies to support single values and collections.
This merge policy is a bit more complex and less type safe, but can be configured on all data structures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MergeIntegerValuesMergePolicy2&lt;V, T extends MergingValue&lt;V&gt;&gt; implements SplitBrainMergePolicy&lt;V, T, Object&gt; {

    @Override
    public Object merge(T mergingValue, T existingValue) {
        if (mergingValue.getValue() instanceof Integer) {
            return mergingValue.getRawValue();
        }
        if (existingValue != null &amp;&amp; existingValue.getValue() instanceof Integer) {
            return existingValue.getRawValue();
        }
        if (mergingValue.getRawValue() instanceof Collection) {
            Collection&lt;Object&gt; result = new ArrayList&lt;&gt;();
            addIntegersToCollection(mergingValue, result);
            if (result.isEmpty() &amp;&amp; existingValue != null) {
                addIntegersToCollection(existingValue, result);
            }
            return result;
        }
        return null;
    }

    private void addIntegersToCollection(T mergingValue, Collection&lt;Object&gt; result) {
        for (Object value : (Collection&lt;Object&gt;) mergingValue.getValue()) {
            if (value instanceof Integer) {
                result.add(value);
            }
        }
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please have in mind that <code>existingValue</code> can be <code>null</code>, so a <code>null</code> check is
mandatory before calling <code>existingValue.getValue()</code> or <code>existingValue.getRawValue()</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you return <code>null</code> on a collection based data structure, the whole data structure will be removed.
An empty collection works in the same way, so you don&#8217;t have to check <code>Collection.isEmpty()</code> in your merge policy.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_accessing_hazelcast_usercontext"><a class="anchor" href="#_accessing_hazelcast_usercontext"></a>Accessing Hazelcast UserContext</h5>
<div class="paragraph">
<p>If you need access to external references in your merge policy,
you can use the Hazelcast <code>UserContext</code> to get them injected.
An example would be a database connection to check which value is stored in your database.
To achieve this your merge policy needs to implement <code>HazelcastInstanceAware</code> and
call <code>HazelcastInstance.getUserContext()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserContextMergePolicy&lt;V&gt; implements SplitBrainMergePolicy&lt;V, MergingValue&lt;V&gt;, Object&gt;, HazelcastInstanceAware {

    public static final String TRUTH_PROVIDER_ID = "truthProvider";

    private transient TruthProvider truthProvider;

    @Override
    public Object merge(MergingValue&lt;V&gt; mergingValue, MergingValue&lt;V&gt; existingValue) {
        Object mergingUserValue = mergingValue.getValue();
        Object existingUserValue = existingValue == null ? null : existingValue.getValue();
        boolean isMergeable = truthProvider.isMergeable(mergingUserValue, existingUserValue);
        System.out.println("========================== Merging..."
                        + "\n    mergingValue: " + mergingUserValue
                        + "\n    existingValue: " + existingUserValue
                        + "\n    isMergeable(): " + isMergeable
        );
        if (isMergeable) {
            return mergingValue.getRawValue();
        }
        return null;
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }

    @Override
    public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {
        ConcurrentMap&lt;String, Object&gt; userContext = hazelcastInstance.getUserContext();
        truthProvider = (TruthProvider) userContext.get(TRUTH_PROVIDER_ID);
    }

    public interface TruthProvider {

        boolean isMergeable(Object mergingValue, Object existingValue);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>UserContext</code> can be setup like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MergePolicyConfig mergePolicyConfig = new MergePolicyConfig()
  .setPolicy(UserContextMergePolicy.class.getName());

MapConfig mapConfig = new MapConfig("default")
  .setMergePolicyConfig(mergePolicyConfig);

ConcurrentMap&lt;String, Object&gt; userContext = new ConcurrentHashMap&lt;String, Object&gt;();
userContext.put(TruthProvider.TRUTH_PROVIDER_ID, new ExampleTruthProvider());

Config config = new Config()
  .addMapConfig(mapConfig)
  .setUserContext(userContext);

Hazelcast.newHazelcastInstance(config);</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The merge operations are executed on the partition threads.
Database accesses are slow compared to in-memory operations.
The <code>SplitBrainMergePolicy.merge()</code> method is called for every key-value pair or
every collection from your smaller cluster, which has a merge policy defined.
So there can be millions of database accesses due to a merge policy, which implements this.
Be aware that this can block your cluster for a long time or overload your database due to the high amount of queries.</p>
</div>
<div class="paragraph">
<p>Also the <code>com.hazelcast.core.LifeCycleEvent.MERGED</code> is thrown
after a timeout (we don&#8217;t wait forever for merge operations to continue).
At the moment this timeout is 500 milliseconds per merged item or entry, but at least 5 seconds.
If your database is slow, you might get the <code>LifeCycleEvent</code> while there are still merge operations in progress.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_merge_policies_with_multiple_merge_types"><a class="anchor" href="#_merge_policies_with_multiple_merge_types"></a>Merge Policies With Multiple Merge Types</h5>
<div class="paragraph">
<p>You can also write a merge policy, which requires multiple merge types.
This merge policy is supported by all data structures, which provide <code>MergingHits</code> and <code>MergingCreationTime</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ComposedHitsAndCreationTimeMergePolicy&lt;V, T extends MergingValue&lt;V&gt; &amp; MergingHits &amp; MergingCreationTime&gt;
        implements SplitBrainMergePolicy&lt;V, T, Object&gt; {

    @Override
    public Object merge(T mergingValue, T existingValue) {
        if (existingValue == null) {
            return mergingValue.getValue();
        }
        System.out.println("========================== Merging value " + mergingValue.getValue() + "..."
                + "\n    mergingValue creation time: " + mergingValue.getCreationTime()
                + "\n    existingValue creation time: " + existingValue.getCreationTime()
                + "\n    mergingValue hits: " + mergingValue.getHits()
                + "\n    existingValue hits: " + existingValue.getHits()
        );

        if (mergingValue.getCreationTime() &lt; existingValue.getCreationTime()
                &amp;&amp; mergingValue.getHits() &gt; existingValue.getHits()) {
            return mergingValue.getRawValue();
        }
        return existingValue.getRawValue();
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you configure this merge policy on a data structures, which does not provide these merge types,
you get an <code>InvalidConfigurationException</code> with a message like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>The merge policy org.example.merge.ComposedHitsAndCreationTimeMergePolicy
can just be configured on data structures which provide the merging type
com.hazelcast.spi.merge.MergingHits.
See SplitBrainMergingTypes for supported merging types.</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_merge_policies_for_specific_data_structures"><a class="anchor" href="#_merge_policies_for_specific_data_structures"></a>Merge Policies For Specific Data Structures</h5>
<div class="paragraph">
<p>It&#8217;s also possible to restrict a merge policy to a specific data structure.
This merge policy, for example, only works on <code>IMap</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MapEntryCostsMergePolicy implements SplitBrainMergePolicy&lt;Object, MapMergeTypes&lt;Object, Object&gt;, Object&gt; {

    @Override
    public Object merge(MapMergeTypes mergingValue, MapMergeTypes existingValue) {
        if (existingValue == null) {
            return mergingValue.getValue();
        }
        System.out.println("========================== Merging key " + mergingValue.getKey() + "..."
                + "\n    mergingValue costs: " + mergingValue.getCost()
                + "\n    existingValue costs: " + existingValue.getCost()
        );

        if (mergingValue.getCost() &gt; existingValue.getCost()) {
            return mergingValue.getRawValue();
        }
        return existingValue.getRawValue();
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you configure it on other data structures, you get an <code>InvalidConfigurationException</code> with a message like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>The merge policy org.example.merge.MapEntryCostsMergePolicy
can just be configured on data structures which provide the merging type
com.hazelcast.spi.merge.SplitBrainMergeTypes$MapMergeTypes.
See SplitBrainMergingTypes for supported merging types.</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is another example for a merge policy, which only works on
the <code>IAtomicReference</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AtomicReferenceMergeIntegerValuesMergePolicy
        implements SplitBrainMergePolicy&lt;Object, AtomicReferenceMergeTypes, Object&gt; {

    @Override
    public Object merge(AtomicReferenceMergeTypes mergingValue, AtomicReferenceMergeTypes existingValue) {
        Object mergingUserValue = mergingValue.getValue();
        Object existingUserValue = existingValue == null ? null : existingValue.getValue();
        System.out.println("========================== Merging..."
                + "\n    mergingValue: " + mergingUserValue
                + "\n    existingValue: " + existingUserValue
                + "\n    mergingValue class: " + mergingUserValue.getClass().getName()
                + "\n    existingValue class: " + (existingUserValue == null ? "null" : existingUserValue.getClass().getName())
        );
        if (mergingUserValue instanceof Integer) {
            return mergingValue.getRawValue();
        }
        return null;
    }

    @Override
    public void writeData(ObjectDataOutput out) {
    }

    @Override
    public void readData(ObjectDataInput in) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although every data structure supports <code>MergingValue</code>, which is
the only merge type of <code>AtomicReferenceMergeTypes</code>, this merge policy is restricted to <code>IAtomicReference</code> data structures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>The merge policy org.example.merge.AtomicReferenceMergeIntegerValuesMergePolicy
can just be configured on data structures which provide the merging type
com.hazelcast.spi.merge.SplitBrainMergeTypes$AtomicReferenceMergeTypes.
See SplitBrainMergingTypes for supported merging types.</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_best_practices"><a class="anchor" href="#_best_practices"></a>Best Practices</h5>
<div class="paragraph">
<p>Here are some best practices when implementing your own merge policy</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Only call <code>MergingValue.getValue()</code> and <code>MergingEntry.getKey()</code> when you really need
the deserialized value to save costs (CPU and memory) and avoid <code>ClassNotFoundException</code>.</p>
</li>
<li>
<p>If you want to return one of the given values (merging or existing),
it&#8217;s best to return <code>mergingValue.getRawValue()</code> or <code>existingValue.getRawValue()</code>,
since they are already in the correct in-memory format of the data structure.
If you return a deserialized value, it might need to be serialized again, which are avoidable costs.</p>
</li>
<li>
<p>Be careful with slow operations in the merge policy (like database accesses),
since they block your partition threads. Also the <code>LifeCycleEvent.MERGED</code> or
<code>LifeCycleEvent.MERGE_FAILED</code> may be thrown too early, if the merge operations take too long to finish.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_partial_network_partitions"><a class="anchor" href="#_partial_network_partitions"></a>Partial Network Partitions</h3>
<div class="paragraph">
<p>In some cases, detecting and handling network partitions are not very straightforward.
Because these kind of network partitions don&#8217;t cause a clearly separated, distinct groups.
But they create overlapping partitioned groups or worse, asymmetric communication failures
between members. This can be called as partial network partitioning.</p>
</div>
<div class="paragraph">
<p>Assume <code>[N1, N2, N3, N4]</code> is a cluster with four members. This is how a healthy cluster looks,
each member has a connection to other members:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/HealthyCluster.png" alt="Healthy Cluster"></span></p>
</div>
<div class="paragraph">
<p>Assuming that <code>N2</code> becomes partitioned away from rest of the cluster when it disconnects from
the other members, two separate groups are formed: <code>[N1, N3, N4]</code> and <code>[N2]</code>.
This is called a full network partition:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/FullNetworkPartition.png" alt="Full Network Partition"></span></p>
</div>
<div class="paragraph">
<p>But when <code>N2</code> cannot communicate only one or two of the rest, then there won&#8217;t be a clear
separation of partitioned groups. For instance when <code>N2</code> becomes disconnected from both
<code>N3</code> and <code>N4</code>, two overlapping healthy groups are formed: <code>[N1, N2]</code> and <code>[N1, N3, N4]</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/PartialNetworkPartition1.png" alt="Partial Network Partition"></span></p>
</div>
<div class="paragraph">
<p>Or, when <code>N2</code> is disconnected only from <code>N1</code>, again two overlapping healthy groups are
formed, but this time with equal size: <code>[N1, N3, N4]</code> and <code>[N2, N3, N4]</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/PartialNetworkPartition1.png" alt="Partial Network Partition"></span></p>
</div>
<div class="paragraph">
<p>Last two figures above are samples of the partial network partitioning. Our solution to
this problem is to figure out the largest set of fully-connected members and artificially separate
these members from the rest. This way we will have a completely separated set of members without
any intersection. This is the same problem with the <a href="https://en.wikipedia.org/wiki/Clique_problem" target="_blank" rel="noopener">maximum clique problem</a>
in graph theory. Hence we are using an implementation of the
<a href="https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm" target="_blank" rel="noopener">Bronâ€“Kerbosch algorithm</a>
to find the maximum clique.</p>
</div>
<div class="paragraph">
<p>Normally each Hazelcast member tracks the liveliness of other members using local failure detectors.
But they don&#8217;t share their failure detection knowledge with other cluster members. In order to
execute the Bronâ€“Kerbosch algorithm and figure out the largest set of fully-connected members,
we need to gather those local failure detection data from all members. When partial network
partitioning resolution mechanism is enabled, all members send their local failure detections
(suspicions about other members) inside the usual heartbeat message.
(See the <a href="#failure-detector-configuration">Failure Detector Configuration section</a>
for more info about failure detectors.) The master (oldest) member in the cluster gathers all this
information and executes the maximum clique algorithm and then decides the smallest set of Hazelcast members,
if any, to kick from the cluster so that the remaining members are fully-connected to each other again.
In a healthy cluster this set is empty.</p>
</div>
<div class="paragraph">
<p>This process has two properties to configure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.partial.member.disconnection.resolution.heartbeat.count</code>:  When the master receives
a heartbeat problem report from another member, it first waits for a number of heartbeat rounds
to allow other members to report their problems if there is any. After that, it takes all reports
received so far and checks if it can update the cluster member in a way that the minimum number of
members will be kicked from the cluster and there won&#8217;t be any heartbeat problem between the remaining members.</p>
<div class="paragraph">
<p>If this configuration option is set to <code>0</code>, this functionality is disabled. It is recommended to be
set to at least <code>3</code> or <code>5</code> so that the master will wait long enough to collect heartbeat problem reports.
Otherwise, the master member can make sub-optimal decisions. Default value is <code>0</code>.</p>
</div>
</li>
<li>
<p><code>hazelcast.partial.member.disconnection.resolution.algorithm.timeout.seconds</code>: The partial member
disconnection resolution mechanism uses a graph algorithm that finds a maximum clique in non-polynomial time.
Since it could take a lot of time to find a maximum clique in a large graph, i.e, in a large cluster with
lots of random network disconnections, we use a timeout mechanism to stop execution of the algorithm.
Default value is <code>5</code> seconds.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Partial network partition resolution mechanism is not enabled by default.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<link rel="shortcut icon" href="http://hazelcast.com/images/favicon.png">
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/vendor/search.js" id="search-script" data-base-path="../../.." data-page-path="/hazelcast/4.1/deploy/network_partitioning.html"></script>
<script async src="../../../_/../search-index.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
